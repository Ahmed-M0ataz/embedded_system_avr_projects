
free_rtos_lab3.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003de2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000c  00800060  00003de2  00003e76  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002bb  0080006c  0080006c  00003e82  2**0
                  ALLOC
  3 .stab         00006930  00000000  00000000  00003e84  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003e63  00000000  00000000  0000a7b4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 61 08 	jmp	0x10c2	; 0x10c2 <__vector_1>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 b9 0b 	jmp	0x1772	; 0x1772 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 ee       	ldi	r30, 0xE2	; 226
      68:	fd e3       	ldi	r31, 0x3D	; 61
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	ac 36       	cpi	r26, 0x6C	; 108
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	13 e0       	ldi	r17, 0x03	; 3
      78:	ac e6       	ldi	r26, 0x6C	; 108
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a7 32       	cpi	r26, 0x27	; 39
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 ae 08 	call	0x115c	; 0x115c <main>
      8a:	0c 94 ef 1e 	jmp	0x3dde	; 0x3dde <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DIO_SET_PIN_VALUE>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	00 d0       	rcall	.+0      	; 0x98 <DIO_SET_PIN_VALUE+0x6>
      98:	00 d0       	rcall	.+0      	; 0x9a <DIO_SET_PIN_VALUE+0x8>
      9a:	00 d0       	rcall	.+0      	; 0x9c <DIO_SET_PIN_VALUE+0xa>
      9c:	cd b7       	in	r28, 0x3d	; 61
      9e:	de b7       	in	r29, 0x3e	; 62
      a0:	8a 83       	std	Y+2, r24	; 0x02
      a2:	6b 83       	std	Y+3, r22	; 0x03
      a4:	4c 83       	std	Y+4, r20	; 0x04
      a6:	19 82       	std	Y+1, r1	; 0x01
      a8:	8a 81       	ldd	r24, Y+2	; 0x02
      aa:	84 30       	cpi	r24, 0x04	; 4
      ac:	18 f0       	brcs	.+6      	; 0xb4 <DIO_SET_PIN_VALUE+0x22>
      ae:	81 e0       	ldi	r24, 0x01	; 1
      b0:	89 83       	std	Y+1, r24	; 0x01
      b2:	e0 c0       	rjmp	.+448    	; 0x274 <DIO_SET_PIN_VALUE+0x1e2>
      b4:	8b 81       	ldd	r24, Y+3	; 0x03
      b6:	88 30       	cpi	r24, 0x08	; 8
      b8:	18 f0       	brcs	.+6      	; 0xc0 <DIO_SET_PIN_VALUE+0x2e>
      ba:	82 e0       	ldi	r24, 0x02	; 2
      bc:	89 83       	std	Y+1, r24	; 0x01
      be:	da c0       	rjmp	.+436    	; 0x274 <DIO_SET_PIN_VALUE+0x1e2>
      c0:	8c 81       	ldd	r24, Y+4	; 0x04
      c2:	88 23       	and	r24, r24
      c4:	31 f0       	breq	.+12     	; 0xd2 <DIO_SET_PIN_VALUE+0x40>
      c6:	8c 81       	ldd	r24, Y+4	; 0x04
      c8:	81 30       	cpi	r24, 0x01	; 1
      ca:	19 f0       	breq	.+6      	; 0xd2 <DIO_SET_PIN_VALUE+0x40>
      cc:	83 e0       	ldi	r24, 0x03	; 3
      ce:	89 83       	std	Y+1, r24	; 0x01
      d0:	d1 c0       	rjmp	.+418    	; 0x274 <DIO_SET_PIN_VALUE+0x1e2>
      d2:	8a 81       	ldd	r24, Y+2	; 0x02
      d4:	28 2f       	mov	r18, r24
      d6:	30 e0       	ldi	r19, 0x00	; 0
      d8:	3e 83       	std	Y+6, r19	; 0x06
      da:	2d 83       	std	Y+5, r18	; 0x05
      dc:	8d 81       	ldd	r24, Y+5	; 0x05
      de:	9e 81       	ldd	r25, Y+6	; 0x06
      e0:	81 30       	cpi	r24, 0x01	; 1
      e2:	91 05       	cpc	r25, r1
      e4:	09 f4       	brne	.+2      	; 0xe8 <DIO_SET_PIN_VALUE+0x56>
      e6:	43 c0       	rjmp	.+134    	; 0x16e <DIO_SET_PIN_VALUE+0xdc>
      e8:	2d 81       	ldd	r18, Y+5	; 0x05
      ea:	3e 81       	ldd	r19, Y+6	; 0x06
      ec:	22 30       	cpi	r18, 0x02	; 2
      ee:	31 05       	cpc	r19, r1
      f0:	2c f4       	brge	.+10     	; 0xfc <DIO_SET_PIN_VALUE+0x6a>
      f2:	8d 81       	ldd	r24, Y+5	; 0x05
      f4:	9e 81       	ldd	r25, Y+6	; 0x06
      f6:	00 97       	sbiw	r24, 0x00	; 0
      f8:	71 f0       	breq	.+28     	; 0x116 <DIO_SET_PIN_VALUE+0x84>
      fa:	bc c0       	rjmp	.+376    	; 0x274 <DIO_SET_PIN_VALUE+0x1e2>
      fc:	2d 81       	ldd	r18, Y+5	; 0x05
      fe:	3e 81       	ldd	r19, Y+6	; 0x06
     100:	22 30       	cpi	r18, 0x02	; 2
     102:	31 05       	cpc	r19, r1
     104:	09 f4       	brne	.+2      	; 0x108 <DIO_SET_PIN_VALUE+0x76>
     106:	5f c0       	rjmp	.+190    	; 0x1c6 <DIO_SET_PIN_VALUE+0x134>
     108:	8d 81       	ldd	r24, Y+5	; 0x05
     10a:	9e 81       	ldd	r25, Y+6	; 0x06
     10c:	83 30       	cpi	r24, 0x03	; 3
     10e:	91 05       	cpc	r25, r1
     110:	09 f4       	brne	.+2      	; 0x114 <DIO_SET_PIN_VALUE+0x82>
     112:	85 c0       	rjmp	.+266    	; 0x21e <DIO_SET_PIN_VALUE+0x18c>
     114:	af c0       	rjmp	.+350    	; 0x274 <DIO_SET_PIN_VALUE+0x1e2>
     116:	8c 81       	ldd	r24, Y+4	; 0x04
     118:	81 30       	cpi	r24, 0x01	; 1
     11a:	a1 f4       	brne	.+40     	; 0x144 <DIO_SET_PIN_VALUE+0xb2>
     11c:	ab e3       	ldi	r26, 0x3B	; 59
     11e:	b0 e0       	ldi	r27, 0x00	; 0
     120:	eb e3       	ldi	r30, 0x3B	; 59
     122:	f0 e0       	ldi	r31, 0x00	; 0
     124:	80 81       	ld	r24, Z
     126:	48 2f       	mov	r20, r24
     128:	8b 81       	ldd	r24, Y+3	; 0x03
     12a:	28 2f       	mov	r18, r24
     12c:	30 e0       	ldi	r19, 0x00	; 0
     12e:	81 e0       	ldi	r24, 0x01	; 1
     130:	90 e0       	ldi	r25, 0x00	; 0
     132:	02 2e       	mov	r0, r18
     134:	02 c0       	rjmp	.+4      	; 0x13a <DIO_SET_PIN_VALUE+0xa8>
     136:	88 0f       	add	r24, r24
     138:	99 1f       	adc	r25, r25
     13a:	0a 94       	dec	r0
     13c:	e2 f7       	brpl	.-8      	; 0x136 <DIO_SET_PIN_VALUE+0xa4>
     13e:	84 2b       	or	r24, r20
     140:	8c 93       	st	X, r24
     142:	98 c0       	rjmp	.+304    	; 0x274 <DIO_SET_PIN_VALUE+0x1e2>
     144:	ab e3       	ldi	r26, 0x3B	; 59
     146:	b0 e0       	ldi	r27, 0x00	; 0
     148:	eb e3       	ldi	r30, 0x3B	; 59
     14a:	f0 e0       	ldi	r31, 0x00	; 0
     14c:	80 81       	ld	r24, Z
     14e:	48 2f       	mov	r20, r24
     150:	8b 81       	ldd	r24, Y+3	; 0x03
     152:	28 2f       	mov	r18, r24
     154:	30 e0       	ldi	r19, 0x00	; 0
     156:	81 e0       	ldi	r24, 0x01	; 1
     158:	90 e0       	ldi	r25, 0x00	; 0
     15a:	02 2e       	mov	r0, r18
     15c:	02 c0       	rjmp	.+4      	; 0x162 <DIO_SET_PIN_VALUE+0xd0>
     15e:	88 0f       	add	r24, r24
     160:	99 1f       	adc	r25, r25
     162:	0a 94       	dec	r0
     164:	e2 f7       	brpl	.-8      	; 0x15e <DIO_SET_PIN_VALUE+0xcc>
     166:	80 95       	com	r24
     168:	84 23       	and	r24, r20
     16a:	8c 93       	st	X, r24
     16c:	83 c0       	rjmp	.+262    	; 0x274 <DIO_SET_PIN_VALUE+0x1e2>
     16e:	8c 81       	ldd	r24, Y+4	; 0x04
     170:	81 30       	cpi	r24, 0x01	; 1
     172:	a1 f4       	brne	.+40     	; 0x19c <DIO_SET_PIN_VALUE+0x10a>
     174:	a8 e3       	ldi	r26, 0x38	; 56
     176:	b0 e0       	ldi	r27, 0x00	; 0
     178:	e8 e3       	ldi	r30, 0x38	; 56
     17a:	f0 e0       	ldi	r31, 0x00	; 0
     17c:	80 81       	ld	r24, Z
     17e:	48 2f       	mov	r20, r24
     180:	8b 81       	ldd	r24, Y+3	; 0x03
     182:	28 2f       	mov	r18, r24
     184:	30 e0       	ldi	r19, 0x00	; 0
     186:	81 e0       	ldi	r24, 0x01	; 1
     188:	90 e0       	ldi	r25, 0x00	; 0
     18a:	02 2e       	mov	r0, r18
     18c:	02 c0       	rjmp	.+4      	; 0x192 <DIO_SET_PIN_VALUE+0x100>
     18e:	88 0f       	add	r24, r24
     190:	99 1f       	adc	r25, r25
     192:	0a 94       	dec	r0
     194:	e2 f7       	brpl	.-8      	; 0x18e <DIO_SET_PIN_VALUE+0xfc>
     196:	84 2b       	or	r24, r20
     198:	8c 93       	st	X, r24
     19a:	6c c0       	rjmp	.+216    	; 0x274 <DIO_SET_PIN_VALUE+0x1e2>
     19c:	a8 e3       	ldi	r26, 0x38	; 56
     19e:	b0 e0       	ldi	r27, 0x00	; 0
     1a0:	e8 e3       	ldi	r30, 0x38	; 56
     1a2:	f0 e0       	ldi	r31, 0x00	; 0
     1a4:	80 81       	ld	r24, Z
     1a6:	48 2f       	mov	r20, r24
     1a8:	8b 81       	ldd	r24, Y+3	; 0x03
     1aa:	28 2f       	mov	r18, r24
     1ac:	30 e0       	ldi	r19, 0x00	; 0
     1ae:	81 e0       	ldi	r24, 0x01	; 1
     1b0:	90 e0       	ldi	r25, 0x00	; 0
     1b2:	02 2e       	mov	r0, r18
     1b4:	02 c0       	rjmp	.+4      	; 0x1ba <DIO_SET_PIN_VALUE+0x128>
     1b6:	88 0f       	add	r24, r24
     1b8:	99 1f       	adc	r25, r25
     1ba:	0a 94       	dec	r0
     1bc:	e2 f7       	brpl	.-8      	; 0x1b6 <DIO_SET_PIN_VALUE+0x124>
     1be:	80 95       	com	r24
     1c0:	84 23       	and	r24, r20
     1c2:	8c 93       	st	X, r24
     1c4:	57 c0       	rjmp	.+174    	; 0x274 <DIO_SET_PIN_VALUE+0x1e2>
     1c6:	8c 81       	ldd	r24, Y+4	; 0x04
     1c8:	81 30       	cpi	r24, 0x01	; 1
     1ca:	a1 f4       	brne	.+40     	; 0x1f4 <DIO_SET_PIN_VALUE+0x162>
     1cc:	a5 e3       	ldi	r26, 0x35	; 53
     1ce:	b0 e0       	ldi	r27, 0x00	; 0
     1d0:	e5 e3       	ldi	r30, 0x35	; 53
     1d2:	f0 e0       	ldi	r31, 0x00	; 0
     1d4:	80 81       	ld	r24, Z
     1d6:	48 2f       	mov	r20, r24
     1d8:	8b 81       	ldd	r24, Y+3	; 0x03
     1da:	28 2f       	mov	r18, r24
     1dc:	30 e0       	ldi	r19, 0x00	; 0
     1de:	81 e0       	ldi	r24, 0x01	; 1
     1e0:	90 e0       	ldi	r25, 0x00	; 0
     1e2:	02 2e       	mov	r0, r18
     1e4:	02 c0       	rjmp	.+4      	; 0x1ea <DIO_SET_PIN_VALUE+0x158>
     1e6:	88 0f       	add	r24, r24
     1e8:	99 1f       	adc	r25, r25
     1ea:	0a 94       	dec	r0
     1ec:	e2 f7       	brpl	.-8      	; 0x1e6 <DIO_SET_PIN_VALUE+0x154>
     1ee:	84 2b       	or	r24, r20
     1f0:	8c 93       	st	X, r24
     1f2:	40 c0       	rjmp	.+128    	; 0x274 <DIO_SET_PIN_VALUE+0x1e2>
     1f4:	a5 e3       	ldi	r26, 0x35	; 53
     1f6:	b0 e0       	ldi	r27, 0x00	; 0
     1f8:	e5 e3       	ldi	r30, 0x35	; 53
     1fa:	f0 e0       	ldi	r31, 0x00	; 0
     1fc:	80 81       	ld	r24, Z
     1fe:	48 2f       	mov	r20, r24
     200:	8b 81       	ldd	r24, Y+3	; 0x03
     202:	28 2f       	mov	r18, r24
     204:	30 e0       	ldi	r19, 0x00	; 0
     206:	81 e0       	ldi	r24, 0x01	; 1
     208:	90 e0       	ldi	r25, 0x00	; 0
     20a:	02 2e       	mov	r0, r18
     20c:	02 c0       	rjmp	.+4      	; 0x212 <DIO_SET_PIN_VALUE+0x180>
     20e:	88 0f       	add	r24, r24
     210:	99 1f       	adc	r25, r25
     212:	0a 94       	dec	r0
     214:	e2 f7       	brpl	.-8      	; 0x20e <DIO_SET_PIN_VALUE+0x17c>
     216:	80 95       	com	r24
     218:	84 23       	and	r24, r20
     21a:	8c 93       	st	X, r24
     21c:	2b c0       	rjmp	.+86     	; 0x274 <DIO_SET_PIN_VALUE+0x1e2>
     21e:	8c 81       	ldd	r24, Y+4	; 0x04
     220:	81 30       	cpi	r24, 0x01	; 1
     222:	a1 f4       	brne	.+40     	; 0x24c <DIO_SET_PIN_VALUE+0x1ba>
     224:	a2 e3       	ldi	r26, 0x32	; 50
     226:	b0 e0       	ldi	r27, 0x00	; 0
     228:	e2 e3       	ldi	r30, 0x32	; 50
     22a:	f0 e0       	ldi	r31, 0x00	; 0
     22c:	80 81       	ld	r24, Z
     22e:	48 2f       	mov	r20, r24
     230:	8b 81       	ldd	r24, Y+3	; 0x03
     232:	28 2f       	mov	r18, r24
     234:	30 e0       	ldi	r19, 0x00	; 0
     236:	81 e0       	ldi	r24, 0x01	; 1
     238:	90 e0       	ldi	r25, 0x00	; 0
     23a:	02 2e       	mov	r0, r18
     23c:	02 c0       	rjmp	.+4      	; 0x242 <DIO_SET_PIN_VALUE+0x1b0>
     23e:	88 0f       	add	r24, r24
     240:	99 1f       	adc	r25, r25
     242:	0a 94       	dec	r0
     244:	e2 f7       	brpl	.-8      	; 0x23e <DIO_SET_PIN_VALUE+0x1ac>
     246:	84 2b       	or	r24, r20
     248:	8c 93       	st	X, r24
     24a:	14 c0       	rjmp	.+40     	; 0x274 <DIO_SET_PIN_VALUE+0x1e2>
     24c:	a2 e3       	ldi	r26, 0x32	; 50
     24e:	b0 e0       	ldi	r27, 0x00	; 0
     250:	e2 e3       	ldi	r30, 0x32	; 50
     252:	f0 e0       	ldi	r31, 0x00	; 0
     254:	80 81       	ld	r24, Z
     256:	48 2f       	mov	r20, r24
     258:	8b 81       	ldd	r24, Y+3	; 0x03
     25a:	28 2f       	mov	r18, r24
     25c:	30 e0       	ldi	r19, 0x00	; 0
     25e:	81 e0       	ldi	r24, 0x01	; 1
     260:	90 e0       	ldi	r25, 0x00	; 0
     262:	02 2e       	mov	r0, r18
     264:	02 c0       	rjmp	.+4      	; 0x26a <DIO_SET_PIN_VALUE+0x1d8>
     266:	88 0f       	add	r24, r24
     268:	99 1f       	adc	r25, r25
     26a:	0a 94       	dec	r0
     26c:	e2 f7       	brpl	.-8      	; 0x266 <DIO_SET_PIN_VALUE+0x1d4>
     26e:	80 95       	com	r24
     270:	84 23       	and	r24, r20
     272:	8c 93       	st	X, r24
     274:	89 81       	ldd	r24, Y+1	; 0x01
     276:	26 96       	adiw	r28, 0x06	; 6
     278:	0f b6       	in	r0, 0x3f	; 63
     27a:	f8 94       	cli
     27c:	de bf       	out	0x3e, r29	; 62
     27e:	0f be       	out	0x3f, r0	; 63
     280:	cd bf       	out	0x3d, r28	; 61
     282:	cf 91       	pop	r28
     284:	df 91       	pop	r29
     286:	08 95       	ret

00000288 <DIO_SET_PIN_DIRECTION>:

//FUNCTION FOR DIRECTION (REG DDR) FOR 1 PIN **************


u8 DIO_SET_PIN_DIRECTION(u8 PORT_NB,u8 PIN_NB,u8 PIN_DIRECTION)//RIGESTER PORT PIN PIN....
{u8 ERROR_STATE=0;
     288:	df 93       	push	r29
     28a:	cf 93       	push	r28
     28c:	00 d0       	rcall	.+0      	; 0x28e <DIO_SET_PIN_DIRECTION+0x6>
     28e:	00 d0       	rcall	.+0      	; 0x290 <DIO_SET_PIN_DIRECTION+0x8>
     290:	00 d0       	rcall	.+0      	; 0x292 <DIO_SET_PIN_DIRECTION+0xa>
     292:	cd b7       	in	r28, 0x3d	; 61
     294:	de b7       	in	r29, 0x3e	; 62
     296:	8a 83       	std	Y+2, r24	; 0x02
     298:	6b 83       	std	Y+3, r22	; 0x03
     29a:	4c 83       	std	Y+4, r20	; 0x04
     29c:	19 82       	std	Y+1, r1	; 0x01
	if (PORT_NB>=DIO_MAX_PORT_NB)
     29e:	8a 81       	ldd	r24, Y+2	; 0x02
     2a0:	84 30       	cpi	r24, 0x04	; 4
     2a2:	18 f0       	brcs	.+6      	; 0x2aa <DIO_SET_PIN_DIRECTION+0x22>
	{
		ERROR_STATE=1;//PORT ERROR
     2a4:	81 e0       	ldi	r24, 0x01	; 1
     2a6:	89 83       	std	Y+1, r24	; 0x01
     2a8:	e0 c0       	rjmp	.+448    	; 0x46a <DIO_SET_PIN_DIRECTION+0x1e2>

	}else if (PIN_NB >= DIO_MAX_PIN_NB)
     2aa:	8b 81       	ldd	r24, Y+3	; 0x03
     2ac:	88 30       	cpi	r24, 0x08	; 8
     2ae:	18 f0       	brcs	.+6      	; 0x2b6 <DIO_SET_PIN_DIRECTION+0x2e>

	{
		ERROR_STATE=2;//PIN ERROR
     2b0:	82 e0       	ldi	r24, 0x02	; 2
     2b2:	89 83       	std	Y+1, r24	; 0x01
     2b4:	da c0       	rjmp	.+436    	; 0x46a <DIO_SET_PIN_DIRECTION+0x1e2>

	}else if((PIN_DIRECTION !=DIO_INPUT)&&(PIN_DIRECTION!=DIO_OUTPUT))
     2b6:	8c 81       	ldd	r24, Y+4	; 0x04
     2b8:	88 23       	and	r24, r24
     2ba:	31 f0       	breq	.+12     	; 0x2c8 <DIO_SET_PIN_DIRECTION+0x40>
     2bc:	8c 81       	ldd	r24, Y+4	; 0x04
     2be:	81 30       	cpi	r24, 0x01	; 1
     2c0:	19 f0       	breq	.+6      	; 0x2c8 <DIO_SET_PIN_DIRECTION+0x40>
	{

		ERROR_STATE=3;//VALUE ERROR
     2c2:	83 e0       	ldi	r24, 0x03	; 3
     2c4:	89 83       	std	Y+1, r24	; 0x01
     2c6:	d1 c0       	rjmp	.+418    	; 0x46a <DIO_SET_PIN_DIRECTION+0x1e2>
	}
	else
	{

		switch (PORT_NB)
     2c8:	8a 81       	ldd	r24, Y+2	; 0x02
     2ca:	28 2f       	mov	r18, r24
     2cc:	30 e0       	ldi	r19, 0x00	; 0
     2ce:	3e 83       	std	Y+6, r19	; 0x06
     2d0:	2d 83       	std	Y+5, r18	; 0x05
     2d2:	8d 81       	ldd	r24, Y+5	; 0x05
     2d4:	9e 81       	ldd	r25, Y+6	; 0x06
     2d6:	81 30       	cpi	r24, 0x01	; 1
     2d8:	91 05       	cpc	r25, r1
     2da:	09 f4       	brne	.+2      	; 0x2de <DIO_SET_PIN_DIRECTION+0x56>
     2dc:	43 c0       	rjmp	.+134    	; 0x364 <DIO_SET_PIN_DIRECTION+0xdc>
     2de:	2d 81       	ldd	r18, Y+5	; 0x05
     2e0:	3e 81       	ldd	r19, Y+6	; 0x06
     2e2:	22 30       	cpi	r18, 0x02	; 2
     2e4:	31 05       	cpc	r19, r1
     2e6:	2c f4       	brge	.+10     	; 0x2f2 <DIO_SET_PIN_DIRECTION+0x6a>
     2e8:	8d 81       	ldd	r24, Y+5	; 0x05
     2ea:	9e 81       	ldd	r25, Y+6	; 0x06
     2ec:	00 97       	sbiw	r24, 0x00	; 0
     2ee:	71 f0       	breq	.+28     	; 0x30c <DIO_SET_PIN_DIRECTION+0x84>
     2f0:	bc c0       	rjmp	.+376    	; 0x46a <DIO_SET_PIN_DIRECTION+0x1e2>
     2f2:	2d 81       	ldd	r18, Y+5	; 0x05
     2f4:	3e 81       	ldd	r19, Y+6	; 0x06
     2f6:	22 30       	cpi	r18, 0x02	; 2
     2f8:	31 05       	cpc	r19, r1
     2fa:	09 f4       	brne	.+2      	; 0x2fe <DIO_SET_PIN_DIRECTION+0x76>
     2fc:	5f c0       	rjmp	.+190    	; 0x3bc <DIO_SET_PIN_DIRECTION+0x134>
     2fe:	8d 81       	ldd	r24, Y+5	; 0x05
     300:	9e 81       	ldd	r25, Y+6	; 0x06
     302:	83 30       	cpi	r24, 0x03	; 3
     304:	91 05       	cpc	r25, r1
     306:	09 f4       	brne	.+2      	; 0x30a <DIO_SET_PIN_DIRECTION+0x82>
     308:	85 c0       	rjmp	.+266    	; 0x414 <DIO_SET_PIN_DIRECTION+0x18c>
     30a:	af c0       	rjmp	.+350    	; 0x46a <DIO_SET_PIN_DIRECTION+0x1e2>
		{
		case GROUP_A:
					assign_bit(DIO_U8_DDRA,PIN_NB,PIN_DIRECTION);
     30c:	8c 81       	ldd	r24, Y+4	; 0x04
     30e:	81 30       	cpi	r24, 0x01	; 1
     310:	a1 f4       	brne	.+40     	; 0x33a <DIO_SET_PIN_DIRECTION+0xb2>
     312:	aa e3       	ldi	r26, 0x3A	; 58
     314:	b0 e0       	ldi	r27, 0x00	; 0
     316:	ea e3       	ldi	r30, 0x3A	; 58
     318:	f0 e0       	ldi	r31, 0x00	; 0
     31a:	80 81       	ld	r24, Z
     31c:	48 2f       	mov	r20, r24
     31e:	8b 81       	ldd	r24, Y+3	; 0x03
     320:	28 2f       	mov	r18, r24
     322:	30 e0       	ldi	r19, 0x00	; 0
     324:	81 e0       	ldi	r24, 0x01	; 1
     326:	90 e0       	ldi	r25, 0x00	; 0
     328:	02 2e       	mov	r0, r18
     32a:	02 c0       	rjmp	.+4      	; 0x330 <DIO_SET_PIN_DIRECTION+0xa8>
     32c:	88 0f       	add	r24, r24
     32e:	99 1f       	adc	r25, r25
     330:	0a 94       	dec	r0
     332:	e2 f7       	brpl	.-8      	; 0x32c <DIO_SET_PIN_DIRECTION+0xa4>
     334:	84 2b       	or	r24, r20
     336:	8c 93       	st	X, r24
     338:	98 c0       	rjmp	.+304    	; 0x46a <DIO_SET_PIN_DIRECTION+0x1e2>
     33a:	aa e3       	ldi	r26, 0x3A	; 58
     33c:	b0 e0       	ldi	r27, 0x00	; 0
     33e:	ea e3       	ldi	r30, 0x3A	; 58
     340:	f0 e0       	ldi	r31, 0x00	; 0
     342:	80 81       	ld	r24, Z
     344:	48 2f       	mov	r20, r24
     346:	8b 81       	ldd	r24, Y+3	; 0x03
     348:	28 2f       	mov	r18, r24
     34a:	30 e0       	ldi	r19, 0x00	; 0
     34c:	81 e0       	ldi	r24, 0x01	; 1
     34e:	90 e0       	ldi	r25, 0x00	; 0
     350:	02 2e       	mov	r0, r18
     352:	02 c0       	rjmp	.+4      	; 0x358 <DIO_SET_PIN_DIRECTION+0xd0>
     354:	88 0f       	add	r24, r24
     356:	99 1f       	adc	r25, r25
     358:	0a 94       	dec	r0
     35a:	e2 f7       	brpl	.-8      	; 0x354 <DIO_SET_PIN_DIRECTION+0xcc>
     35c:	80 95       	com	r24
     35e:	84 23       	and	r24, r20
     360:	8c 93       	st	X, r24
     362:	83 c0       	rjmp	.+262    	; 0x46a <DIO_SET_PIN_DIRECTION+0x1e2>
			break;
		case GROUP_B:
					assign_bit(DIO_U8_DDRB,PIN_NB,PIN_DIRECTION);
     364:	8c 81       	ldd	r24, Y+4	; 0x04
     366:	81 30       	cpi	r24, 0x01	; 1
     368:	a1 f4       	brne	.+40     	; 0x392 <DIO_SET_PIN_DIRECTION+0x10a>
     36a:	a7 e3       	ldi	r26, 0x37	; 55
     36c:	b0 e0       	ldi	r27, 0x00	; 0
     36e:	e7 e3       	ldi	r30, 0x37	; 55
     370:	f0 e0       	ldi	r31, 0x00	; 0
     372:	80 81       	ld	r24, Z
     374:	48 2f       	mov	r20, r24
     376:	8b 81       	ldd	r24, Y+3	; 0x03
     378:	28 2f       	mov	r18, r24
     37a:	30 e0       	ldi	r19, 0x00	; 0
     37c:	81 e0       	ldi	r24, 0x01	; 1
     37e:	90 e0       	ldi	r25, 0x00	; 0
     380:	02 2e       	mov	r0, r18
     382:	02 c0       	rjmp	.+4      	; 0x388 <DIO_SET_PIN_DIRECTION+0x100>
     384:	88 0f       	add	r24, r24
     386:	99 1f       	adc	r25, r25
     388:	0a 94       	dec	r0
     38a:	e2 f7       	brpl	.-8      	; 0x384 <DIO_SET_PIN_DIRECTION+0xfc>
     38c:	84 2b       	or	r24, r20
     38e:	8c 93       	st	X, r24
     390:	6c c0       	rjmp	.+216    	; 0x46a <DIO_SET_PIN_DIRECTION+0x1e2>
     392:	a7 e3       	ldi	r26, 0x37	; 55
     394:	b0 e0       	ldi	r27, 0x00	; 0
     396:	e7 e3       	ldi	r30, 0x37	; 55
     398:	f0 e0       	ldi	r31, 0x00	; 0
     39a:	80 81       	ld	r24, Z
     39c:	48 2f       	mov	r20, r24
     39e:	8b 81       	ldd	r24, Y+3	; 0x03
     3a0:	28 2f       	mov	r18, r24
     3a2:	30 e0       	ldi	r19, 0x00	; 0
     3a4:	81 e0       	ldi	r24, 0x01	; 1
     3a6:	90 e0       	ldi	r25, 0x00	; 0
     3a8:	02 2e       	mov	r0, r18
     3aa:	02 c0       	rjmp	.+4      	; 0x3b0 <DIO_SET_PIN_DIRECTION+0x128>
     3ac:	88 0f       	add	r24, r24
     3ae:	99 1f       	adc	r25, r25
     3b0:	0a 94       	dec	r0
     3b2:	e2 f7       	brpl	.-8      	; 0x3ac <DIO_SET_PIN_DIRECTION+0x124>
     3b4:	80 95       	com	r24
     3b6:	84 23       	and	r24, r20
     3b8:	8c 93       	st	X, r24
     3ba:	57 c0       	rjmp	.+174    	; 0x46a <DIO_SET_PIN_DIRECTION+0x1e2>
			break;
		case GROUP_C:
					assign_bit(DIO_U8_DDRC,PIN_NB,PIN_DIRECTION);
     3bc:	8c 81       	ldd	r24, Y+4	; 0x04
     3be:	81 30       	cpi	r24, 0x01	; 1
     3c0:	a1 f4       	brne	.+40     	; 0x3ea <DIO_SET_PIN_DIRECTION+0x162>
     3c2:	a4 e3       	ldi	r26, 0x34	; 52
     3c4:	b0 e0       	ldi	r27, 0x00	; 0
     3c6:	e4 e3       	ldi	r30, 0x34	; 52
     3c8:	f0 e0       	ldi	r31, 0x00	; 0
     3ca:	80 81       	ld	r24, Z
     3cc:	48 2f       	mov	r20, r24
     3ce:	8b 81       	ldd	r24, Y+3	; 0x03
     3d0:	28 2f       	mov	r18, r24
     3d2:	30 e0       	ldi	r19, 0x00	; 0
     3d4:	81 e0       	ldi	r24, 0x01	; 1
     3d6:	90 e0       	ldi	r25, 0x00	; 0
     3d8:	02 2e       	mov	r0, r18
     3da:	02 c0       	rjmp	.+4      	; 0x3e0 <DIO_SET_PIN_DIRECTION+0x158>
     3dc:	88 0f       	add	r24, r24
     3de:	99 1f       	adc	r25, r25
     3e0:	0a 94       	dec	r0
     3e2:	e2 f7       	brpl	.-8      	; 0x3dc <DIO_SET_PIN_DIRECTION+0x154>
     3e4:	84 2b       	or	r24, r20
     3e6:	8c 93       	st	X, r24
     3e8:	40 c0       	rjmp	.+128    	; 0x46a <DIO_SET_PIN_DIRECTION+0x1e2>
     3ea:	a4 e3       	ldi	r26, 0x34	; 52
     3ec:	b0 e0       	ldi	r27, 0x00	; 0
     3ee:	e4 e3       	ldi	r30, 0x34	; 52
     3f0:	f0 e0       	ldi	r31, 0x00	; 0
     3f2:	80 81       	ld	r24, Z
     3f4:	48 2f       	mov	r20, r24
     3f6:	8b 81       	ldd	r24, Y+3	; 0x03
     3f8:	28 2f       	mov	r18, r24
     3fa:	30 e0       	ldi	r19, 0x00	; 0
     3fc:	81 e0       	ldi	r24, 0x01	; 1
     3fe:	90 e0       	ldi	r25, 0x00	; 0
     400:	02 2e       	mov	r0, r18
     402:	02 c0       	rjmp	.+4      	; 0x408 <DIO_SET_PIN_DIRECTION+0x180>
     404:	88 0f       	add	r24, r24
     406:	99 1f       	adc	r25, r25
     408:	0a 94       	dec	r0
     40a:	e2 f7       	brpl	.-8      	; 0x404 <DIO_SET_PIN_DIRECTION+0x17c>
     40c:	80 95       	com	r24
     40e:	84 23       	and	r24, r20
     410:	8c 93       	st	X, r24
     412:	2b c0       	rjmp	.+86     	; 0x46a <DIO_SET_PIN_DIRECTION+0x1e2>
			break;
		case GROUP_D:
					assign_bit(DIO_U8_DDRD,PIN_NB,PIN_DIRECTION);
     414:	8c 81       	ldd	r24, Y+4	; 0x04
     416:	81 30       	cpi	r24, 0x01	; 1
     418:	a1 f4       	brne	.+40     	; 0x442 <DIO_SET_PIN_DIRECTION+0x1ba>
     41a:	a1 e3       	ldi	r26, 0x31	; 49
     41c:	b0 e0       	ldi	r27, 0x00	; 0
     41e:	e1 e3       	ldi	r30, 0x31	; 49
     420:	f0 e0       	ldi	r31, 0x00	; 0
     422:	80 81       	ld	r24, Z
     424:	48 2f       	mov	r20, r24
     426:	8b 81       	ldd	r24, Y+3	; 0x03
     428:	28 2f       	mov	r18, r24
     42a:	30 e0       	ldi	r19, 0x00	; 0
     42c:	81 e0       	ldi	r24, 0x01	; 1
     42e:	90 e0       	ldi	r25, 0x00	; 0
     430:	02 2e       	mov	r0, r18
     432:	02 c0       	rjmp	.+4      	; 0x438 <DIO_SET_PIN_DIRECTION+0x1b0>
     434:	88 0f       	add	r24, r24
     436:	99 1f       	adc	r25, r25
     438:	0a 94       	dec	r0
     43a:	e2 f7       	brpl	.-8      	; 0x434 <DIO_SET_PIN_DIRECTION+0x1ac>
     43c:	84 2b       	or	r24, r20
     43e:	8c 93       	st	X, r24
     440:	14 c0       	rjmp	.+40     	; 0x46a <DIO_SET_PIN_DIRECTION+0x1e2>
     442:	a1 e3       	ldi	r26, 0x31	; 49
     444:	b0 e0       	ldi	r27, 0x00	; 0
     446:	e1 e3       	ldi	r30, 0x31	; 49
     448:	f0 e0       	ldi	r31, 0x00	; 0
     44a:	80 81       	ld	r24, Z
     44c:	48 2f       	mov	r20, r24
     44e:	8b 81       	ldd	r24, Y+3	; 0x03
     450:	28 2f       	mov	r18, r24
     452:	30 e0       	ldi	r19, 0x00	; 0
     454:	81 e0       	ldi	r24, 0x01	; 1
     456:	90 e0       	ldi	r25, 0x00	; 0
     458:	02 2e       	mov	r0, r18
     45a:	02 c0       	rjmp	.+4      	; 0x460 <DIO_SET_PIN_DIRECTION+0x1d8>
     45c:	88 0f       	add	r24, r24
     45e:	99 1f       	adc	r25, r25
     460:	0a 94       	dec	r0
     462:	e2 f7       	brpl	.-8      	; 0x45c <DIO_SET_PIN_DIRECTION+0x1d4>
     464:	80 95       	com	r24
     466:	84 23       	and	r24, r20
     468:	8c 93       	st	X, r24

	}



return ERROR_STATE;
     46a:	89 81       	ldd	r24, Y+1	; 0x01
}
     46c:	26 96       	adiw	r28, 0x06	; 6
     46e:	0f b6       	in	r0, 0x3f	; 63
     470:	f8 94       	cli
     472:	de bf       	out	0x3e, r29	; 62
     474:	0f be       	out	0x3f, r0	; 63
     476:	cd bf       	out	0x3d, r28	; 61
     478:	cf 91       	pop	r28
     47a:	df 91       	pop	r29
     47c:	08 95       	ret

0000047e <DIO_GET_PIN_VALUE>:

//FUNCTION FOR GET VALUE (REG PIN) FOR 1 PIN **************


u8 DIO_GET_PIN_VALUE(u8 PORT_NB,u8 PIN_NB,u8 *PIN_VALUE)//RIGESTER PORT PIN PIN....
{u8 ERROR_STATE=0;
     47e:	df 93       	push	r29
     480:	cf 93       	push	r28
     482:	cd b7       	in	r28, 0x3d	; 61
     484:	de b7       	in	r29, 0x3e	; 62
     486:	27 97       	sbiw	r28, 0x07	; 7
     488:	0f b6       	in	r0, 0x3f	; 63
     48a:	f8 94       	cli
     48c:	de bf       	out	0x3e, r29	; 62
     48e:	0f be       	out	0x3f, r0	; 63
     490:	cd bf       	out	0x3d, r28	; 61
     492:	8a 83       	std	Y+2, r24	; 0x02
     494:	6b 83       	std	Y+3, r22	; 0x03
     496:	5d 83       	std	Y+5, r21	; 0x05
     498:	4c 83       	std	Y+4, r20	; 0x04
     49a:	19 82       	std	Y+1, r1	; 0x01
	if (PORT_NB>=DIO_MAX_PORT_NB)
     49c:	8a 81       	ldd	r24, Y+2	; 0x02
     49e:	84 30       	cpi	r24, 0x04	; 4
     4a0:	18 f0       	brcs	.+6      	; 0x4a8 <DIO_GET_PIN_VALUE+0x2a>
	{
		ERROR_STATE=1;//PORT ERROR
     4a2:	81 e0       	ldi	r24, 0x01	; 1
     4a4:	89 83       	std	Y+1, r24	; 0x01
     4a6:	76 c0       	rjmp	.+236    	; 0x594 <DIO_GET_PIN_VALUE+0x116>

	}else if (PIN_NB >= DIO_MAX_PIN_NB)
     4a8:	8b 81       	ldd	r24, Y+3	; 0x03
     4aa:	88 30       	cpi	r24, 0x08	; 8
     4ac:	18 f0       	brcs	.+6      	; 0x4b4 <DIO_GET_PIN_VALUE+0x36>

	{
		ERROR_STATE=2;//PIN ERROR
     4ae:	82 e0       	ldi	r24, 0x02	; 2
     4b0:	89 83       	std	Y+1, r24	; 0x01
     4b2:	70 c0       	rjmp	.+224    	; 0x594 <DIO_GET_PIN_VALUE+0x116>

	}
	else
	{

		switch (PORT_NB)
     4b4:	8a 81       	ldd	r24, Y+2	; 0x02
     4b6:	28 2f       	mov	r18, r24
     4b8:	30 e0       	ldi	r19, 0x00	; 0
     4ba:	3f 83       	std	Y+7, r19	; 0x07
     4bc:	2e 83       	std	Y+6, r18	; 0x06
     4be:	4e 81       	ldd	r20, Y+6	; 0x06
     4c0:	5f 81       	ldd	r21, Y+7	; 0x07
     4c2:	41 30       	cpi	r20, 0x01	; 1
     4c4:	51 05       	cpc	r21, r1
     4c6:	59 f1       	breq	.+86     	; 0x51e <DIO_GET_PIN_VALUE+0xa0>
     4c8:	8e 81       	ldd	r24, Y+6	; 0x06
     4ca:	9f 81       	ldd	r25, Y+7	; 0x07
     4cc:	82 30       	cpi	r24, 0x02	; 2
     4ce:	91 05       	cpc	r25, r1
     4d0:	34 f4       	brge	.+12     	; 0x4de <DIO_GET_PIN_VALUE+0x60>
     4d2:	2e 81       	ldd	r18, Y+6	; 0x06
     4d4:	3f 81       	ldd	r19, Y+7	; 0x07
     4d6:	21 15       	cp	r18, r1
     4d8:	31 05       	cpc	r19, r1
     4da:	69 f0       	breq	.+26     	; 0x4f6 <DIO_GET_PIN_VALUE+0x78>
     4dc:	5b c0       	rjmp	.+182    	; 0x594 <DIO_GET_PIN_VALUE+0x116>
     4de:	4e 81       	ldd	r20, Y+6	; 0x06
     4e0:	5f 81       	ldd	r21, Y+7	; 0x07
     4e2:	42 30       	cpi	r20, 0x02	; 2
     4e4:	51 05       	cpc	r21, r1
     4e6:	79 f1       	breq	.+94     	; 0x546 <DIO_GET_PIN_VALUE+0xc8>
     4e8:	8e 81       	ldd	r24, Y+6	; 0x06
     4ea:	9f 81       	ldd	r25, Y+7	; 0x07
     4ec:	83 30       	cpi	r24, 0x03	; 3
     4ee:	91 05       	cpc	r25, r1
     4f0:	09 f4       	brne	.+2      	; 0x4f4 <DIO_GET_PIN_VALUE+0x76>
     4f2:	3d c0       	rjmp	.+122    	; 0x56e <DIO_GET_PIN_VALUE+0xf0>
     4f4:	4f c0       	rjmp	.+158    	; 0x594 <DIO_GET_PIN_VALUE+0x116>
		{
		case GROUP_A:
			*PIN_VALUE = get_bit(DIO_U8_PINA,PIN_NB);
     4f6:	e9 e3       	ldi	r30, 0x39	; 57
     4f8:	f0 e0       	ldi	r31, 0x00	; 0
     4fa:	80 81       	ld	r24, Z
     4fc:	28 2f       	mov	r18, r24
     4fe:	30 e0       	ldi	r19, 0x00	; 0
     500:	8b 81       	ldd	r24, Y+3	; 0x03
     502:	88 2f       	mov	r24, r24
     504:	90 e0       	ldi	r25, 0x00	; 0
     506:	a9 01       	movw	r20, r18
     508:	02 c0       	rjmp	.+4      	; 0x50e <DIO_GET_PIN_VALUE+0x90>
     50a:	55 95       	asr	r21
     50c:	47 95       	ror	r20
     50e:	8a 95       	dec	r24
     510:	e2 f7       	brpl	.-8      	; 0x50a <DIO_GET_PIN_VALUE+0x8c>
     512:	ca 01       	movw	r24, r20
     514:	81 70       	andi	r24, 0x01	; 1
     516:	ec 81       	ldd	r30, Y+4	; 0x04
     518:	fd 81       	ldd	r31, Y+5	; 0x05
     51a:	80 83       	st	Z, r24
     51c:	3b c0       	rjmp	.+118    	; 0x594 <DIO_GET_PIN_VALUE+0x116>
			break;
		case GROUP_B:
			*PIN_VALUE = get_bit(DIO_U8_PINB,PIN_NB);
     51e:	e6 e3       	ldi	r30, 0x36	; 54
     520:	f0 e0       	ldi	r31, 0x00	; 0
     522:	80 81       	ld	r24, Z
     524:	28 2f       	mov	r18, r24
     526:	30 e0       	ldi	r19, 0x00	; 0
     528:	8b 81       	ldd	r24, Y+3	; 0x03
     52a:	88 2f       	mov	r24, r24
     52c:	90 e0       	ldi	r25, 0x00	; 0
     52e:	a9 01       	movw	r20, r18
     530:	02 c0       	rjmp	.+4      	; 0x536 <DIO_GET_PIN_VALUE+0xb8>
     532:	55 95       	asr	r21
     534:	47 95       	ror	r20
     536:	8a 95       	dec	r24
     538:	e2 f7       	brpl	.-8      	; 0x532 <DIO_GET_PIN_VALUE+0xb4>
     53a:	ca 01       	movw	r24, r20
     53c:	81 70       	andi	r24, 0x01	; 1
     53e:	ec 81       	ldd	r30, Y+4	; 0x04
     540:	fd 81       	ldd	r31, Y+5	; 0x05
     542:	80 83       	st	Z, r24
     544:	27 c0       	rjmp	.+78     	; 0x594 <DIO_GET_PIN_VALUE+0x116>
			break;
		case GROUP_C:
			*PIN_VALUE = get_bit(DIO_U8_PINC,PIN_NB);
     546:	e3 e3       	ldi	r30, 0x33	; 51
     548:	f0 e0       	ldi	r31, 0x00	; 0
     54a:	80 81       	ld	r24, Z
     54c:	28 2f       	mov	r18, r24
     54e:	30 e0       	ldi	r19, 0x00	; 0
     550:	8b 81       	ldd	r24, Y+3	; 0x03
     552:	88 2f       	mov	r24, r24
     554:	90 e0       	ldi	r25, 0x00	; 0
     556:	a9 01       	movw	r20, r18
     558:	02 c0       	rjmp	.+4      	; 0x55e <DIO_GET_PIN_VALUE+0xe0>
     55a:	55 95       	asr	r21
     55c:	47 95       	ror	r20
     55e:	8a 95       	dec	r24
     560:	e2 f7       	brpl	.-8      	; 0x55a <DIO_GET_PIN_VALUE+0xdc>
     562:	ca 01       	movw	r24, r20
     564:	81 70       	andi	r24, 0x01	; 1
     566:	ec 81       	ldd	r30, Y+4	; 0x04
     568:	fd 81       	ldd	r31, Y+5	; 0x05
     56a:	80 83       	st	Z, r24
     56c:	13 c0       	rjmp	.+38     	; 0x594 <DIO_GET_PIN_VALUE+0x116>
			break;
		case GROUP_D:
			*PIN_VALUE = get_bit(DIO_U8_PIND,PIN_NB);
     56e:	e0 e3       	ldi	r30, 0x30	; 48
     570:	f0 e0       	ldi	r31, 0x00	; 0
     572:	80 81       	ld	r24, Z
     574:	28 2f       	mov	r18, r24
     576:	30 e0       	ldi	r19, 0x00	; 0
     578:	8b 81       	ldd	r24, Y+3	; 0x03
     57a:	88 2f       	mov	r24, r24
     57c:	90 e0       	ldi	r25, 0x00	; 0
     57e:	a9 01       	movw	r20, r18
     580:	02 c0       	rjmp	.+4      	; 0x586 <DIO_GET_PIN_VALUE+0x108>
     582:	55 95       	asr	r21
     584:	47 95       	ror	r20
     586:	8a 95       	dec	r24
     588:	e2 f7       	brpl	.-8      	; 0x582 <DIO_GET_PIN_VALUE+0x104>
     58a:	ca 01       	movw	r24, r20
     58c:	81 70       	andi	r24, 0x01	; 1
     58e:	ec 81       	ldd	r30, Y+4	; 0x04
     590:	fd 81       	ldd	r31, Y+5	; 0x05
     592:	80 83       	st	Z, r24

	}



return ERROR_STATE;
     594:	89 81       	ldd	r24, Y+1	; 0x01
}
     596:	27 96       	adiw	r28, 0x07	; 7
     598:	0f b6       	in	r0, 0x3f	; 63
     59a:	f8 94       	cli
     59c:	de bf       	out	0x3e, r29	; 62
     59e:	0f be       	out	0x3f, r0	; 63
     5a0:	cd bf       	out	0x3d, r28	; 61
     5a2:	cf 91       	pop	r28
     5a4:	df 91       	pop	r29
     5a6:	08 95       	ret

000005a8 <DIO_SET_PORT_VALUE>:

//FUNCTION FOR OUTPUT VALUE (REG PORT) FOR 8 PIN **************


u8 DIO_SET_PORT_VALUE(u8 PORT_NB,u8 PORT_VALUE)//RIGESTER PORT (PORT PORT....
{u8 ERROR_STATE=0;
     5a8:	df 93       	push	r29
     5aa:	cf 93       	push	r28
     5ac:	00 d0       	rcall	.+0      	; 0x5ae <DIO_SET_PORT_VALUE+0x6>
     5ae:	00 d0       	rcall	.+0      	; 0x5b0 <DIO_SET_PORT_VALUE+0x8>
     5b0:	0f 92       	push	r0
     5b2:	cd b7       	in	r28, 0x3d	; 61
     5b4:	de b7       	in	r29, 0x3e	; 62
     5b6:	8a 83       	std	Y+2, r24	; 0x02
     5b8:	6b 83       	std	Y+3, r22	; 0x03
     5ba:	19 82       	std	Y+1, r1	; 0x01
	if (PORT_NB>=DIO_MAX_PORT_NB)
     5bc:	8a 81       	ldd	r24, Y+2	; 0x02
     5be:	84 30       	cpi	r24, 0x04	; 4
     5c0:	18 f0       	brcs	.+6      	; 0x5c8 <DIO_SET_PORT_VALUE+0x20>
	{
		ERROR_STATE=1;//PORT ERROR
     5c2:	81 e0       	ldi	r24, 0x01	; 1
     5c4:	89 83       	std	Y+1, r24	; 0x01
     5c6:	32 c0       	rjmp	.+100    	; 0x62c <DIO_SET_PORT_VALUE+0x84>

	}
	else
	{

		switch (PORT_NB)
     5c8:	8a 81       	ldd	r24, Y+2	; 0x02
     5ca:	28 2f       	mov	r18, r24
     5cc:	30 e0       	ldi	r19, 0x00	; 0
     5ce:	3d 83       	std	Y+5, r19	; 0x05
     5d0:	2c 83       	std	Y+4, r18	; 0x04
     5d2:	8c 81       	ldd	r24, Y+4	; 0x04
     5d4:	9d 81       	ldd	r25, Y+5	; 0x05
     5d6:	81 30       	cpi	r24, 0x01	; 1
     5d8:	91 05       	cpc	r25, r1
     5da:	d1 f0       	breq	.+52     	; 0x610 <DIO_SET_PORT_VALUE+0x68>
     5dc:	2c 81       	ldd	r18, Y+4	; 0x04
     5de:	3d 81       	ldd	r19, Y+5	; 0x05
     5e0:	22 30       	cpi	r18, 0x02	; 2
     5e2:	31 05       	cpc	r19, r1
     5e4:	2c f4       	brge	.+10     	; 0x5f0 <DIO_SET_PORT_VALUE+0x48>
     5e6:	8c 81       	ldd	r24, Y+4	; 0x04
     5e8:	9d 81       	ldd	r25, Y+5	; 0x05
     5ea:	00 97       	sbiw	r24, 0x00	; 0
     5ec:	61 f0       	breq	.+24     	; 0x606 <DIO_SET_PORT_VALUE+0x5e>
     5ee:	1e c0       	rjmp	.+60     	; 0x62c <DIO_SET_PORT_VALUE+0x84>
     5f0:	2c 81       	ldd	r18, Y+4	; 0x04
     5f2:	3d 81       	ldd	r19, Y+5	; 0x05
     5f4:	22 30       	cpi	r18, 0x02	; 2
     5f6:	31 05       	cpc	r19, r1
     5f8:	81 f0       	breq	.+32     	; 0x61a <DIO_SET_PORT_VALUE+0x72>
     5fa:	8c 81       	ldd	r24, Y+4	; 0x04
     5fc:	9d 81       	ldd	r25, Y+5	; 0x05
     5fe:	83 30       	cpi	r24, 0x03	; 3
     600:	91 05       	cpc	r25, r1
     602:	81 f0       	breq	.+32     	; 0x624 <DIO_SET_PORT_VALUE+0x7c>
     604:	13 c0       	rjmp	.+38     	; 0x62c <DIO_SET_PORT_VALUE+0x84>
		{
		case GROUP_A:
			DIO_U8_PORTA=PORT_VALUE;
     606:	eb e3       	ldi	r30, 0x3B	; 59
     608:	f0 e0       	ldi	r31, 0x00	; 0
     60a:	8b 81       	ldd	r24, Y+3	; 0x03
     60c:	80 83       	st	Z, r24
     60e:	0e c0       	rjmp	.+28     	; 0x62c <DIO_SET_PORT_VALUE+0x84>
			break;
		case GROUP_B:
			DIO_U8_PORTB=PORT_VALUE;
     610:	e8 e3       	ldi	r30, 0x38	; 56
     612:	f0 e0       	ldi	r31, 0x00	; 0
     614:	8b 81       	ldd	r24, Y+3	; 0x03
     616:	80 83       	st	Z, r24
     618:	09 c0       	rjmp	.+18     	; 0x62c <DIO_SET_PORT_VALUE+0x84>
			break;
		case GROUP_C:
			DIO_U8_PORTC=PORT_VALUE;
     61a:	e5 e3       	ldi	r30, 0x35	; 53
     61c:	f0 e0       	ldi	r31, 0x00	; 0
     61e:	8b 81       	ldd	r24, Y+3	; 0x03
     620:	80 83       	st	Z, r24
     622:	04 c0       	rjmp	.+8      	; 0x62c <DIO_SET_PORT_VALUE+0x84>
			break;
		case GROUP_D:
			DIO_U8_PORTD=PORT_VALUE;
     624:	e2 e3       	ldi	r30, 0x32	; 50
     626:	f0 e0       	ldi	r31, 0x00	; 0
     628:	8b 81       	ldd	r24, Y+3	; 0x03
     62a:	80 83       	st	Z, r24

	}



return ERROR_STATE;
     62c:	89 81       	ldd	r24, Y+1	; 0x01
}
     62e:	0f 90       	pop	r0
     630:	0f 90       	pop	r0
     632:	0f 90       	pop	r0
     634:	0f 90       	pop	r0
     636:	0f 90       	pop	r0
     638:	cf 91       	pop	r28
     63a:	df 91       	pop	r29
     63c:	08 95       	ret

0000063e <DIO_SET_PORT_DIRECTION>:

//FUNCTION FOR DIRECTION (REG DDR) FOR 8 PIN **************


u8 DIO_SET_PORT_DIRECTION(u8 PORT_NB,u8 PORT_DIRECTION)//RIGESTER PORT (PORT PORT....
{u8 ERROR_STATE=0;
     63e:	df 93       	push	r29
     640:	cf 93       	push	r28
     642:	00 d0       	rcall	.+0      	; 0x644 <DIO_SET_PORT_DIRECTION+0x6>
     644:	00 d0       	rcall	.+0      	; 0x646 <DIO_SET_PORT_DIRECTION+0x8>
     646:	0f 92       	push	r0
     648:	cd b7       	in	r28, 0x3d	; 61
     64a:	de b7       	in	r29, 0x3e	; 62
     64c:	8a 83       	std	Y+2, r24	; 0x02
     64e:	6b 83       	std	Y+3, r22	; 0x03
     650:	19 82       	std	Y+1, r1	; 0x01
	if (PORT_NB>=DIO_MAX_PORT_NB)
     652:	8a 81       	ldd	r24, Y+2	; 0x02
     654:	84 30       	cpi	r24, 0x04	; 4
     656:	18 f0       	brcs	.+6      	; 0x65e <DIO_SET_PORT_DIRECTION+0x20>
	{
		ERROR_STATE=1;//PORT ERROR
     658:	81 e0       	ldi	r24, 0x01	; 1
     65a:	89 83       	std	Y+1, r24	; 0x01
     65c:	32 c0       	rjmp	.+100    	; 0x6c2 <DIO_SET_PORT_DIRECTION+0x84>

	}
	else
	{

		switch (PORT_NB)
     65e:	8a 81       	ldd	r24, Y+2	; 0x02
     660:	28 2f       	mov	r18, r24
     662:	30 e0       	ldi	r19, 0x00	; 0
     664:	3d 83       	std	Y+5, r19	; 0x05
     666:	2c 83       	std	Y+4, r18	; 0x04
     668:	8c 81       	ldd	r24, Y+4	; 0x04
     66a:	9d 81       	ldd	r25, Y+5	; 0x05
     66c:	81 30       	cpi	r24, 0x01	; 1
     66e:	91 05       	cpc	r25, r1
     670:	d1 f0       	breq	.+52     	; 0x6a6 <DIO_SET_PORT_DIRECTION+0x68>
     672:	2c 81       	ldd	r18, Y+4	; 0x04
     674:	3d 81       	ldd	r19, Y+5	; 0x05
     676:	22 30       	cpi	r18, 0x02	; 2
     678:	31 05       	cpc	r19, r1
     67a:	2c f4       	brge	.+10     	; 0x686 <DIO_SET_PORT_DIRECTION+0x48>
     67c:	8c 81       	ldd	r24, Y+4	; 0x04
     67e:	9d 81       	ldd	r25, Y+5	; 0x05
     680:	00 97       	sbiw	r24, 0x00	; 0
     682:	61 f0       	breq	.+24     	; 0x69c <DIO_SET_PORT_DIRECTION+0x5e>
     684:	1e c0       	rjmp	.+60     	; 0x6c2 <DIO_SET_PORT_DIRECTION+0x84>
     686:	2c 81       	ldd	r18, Y+4	; 0x04
     688:	3d 81       	ldd	r19, Y+5	; 0x05
     68a:	22 30       	cpi	r18, 0x02	; 2
     68c:	31 05       	cpc	r19, r1
     68e:	81 f0       	breq	.+32     	; 0x6b0 <DIO_SET_PORT_DIRECTION+0x72>
     690:	8c 81       	ldd	r24, Y+4	; 0x04
     692:	9d 81       	ldd	r25, Y+5	; 0x05
     694:	83 30       	cpi	r24, 0x03	; 3
     696:	91 05       	cpc	r25, r1
     698:	81 f0       	breq	.+32     	; 0x6ba <DIO_SET_PORT_DIRECTION+0x7c>
     69a:	13 c0       	rjmp	.+38     	; 0x6c2 <DIO_SET_PORT_DIRECTION+0x84>
		{
		case GROUP_A:
			DIO_U8_DDRA=PORT_DIRECTION;
     69c:	ea e3       	ldi	r30, 0x3A	; 58
     69e:	f0 e0       	ldi	r31, 0x00	; 0
     6a0:	8b 81       	ldd	r24, Y+3	; 0x03
     6a2:	80 83       	st	Z, r24
     6a4:	0e c0       	rjmp	.+28     	; 0x6c2 <DIO_SET_PORT_DIRECTION+0x84>
			break;
		case GROUP_B:
			DIO_U8_DDRB=PORT_DIRECTION;
     6a6:	e7 e3       	ldi	r30, 0x37	; 55
     6a8:	f0 e0       	ldi	r31, 0x00	; 0
     6aa:	8b 81       	ldd	r24, Y+3	; 0x03
     6ac:	80 83       	st	Z, r24
     6ae:	09 c0       	rjmp	.+18     	; 0x6c2 <DIO_SET_PORT_DIRECTION+0x84>
			break;
		case GROUP_C:
			DIO_U8_DDRC=PORT_DIRECTION;
     6b0:	e4 e3       	ldi	r30, 0x34	; 52
     6b2:	f0 e0       	ldi	r31, 0x00	; 0
     6b4:	8b 81       	ldd	r24, Y+3	; 0x03
     6b6:	80 83       	st	Z, r24
     6b8:	04 c0       	rjmp	.+8      	; 0x6c2 <DIO_SET_PORT_DIRECTION+0x84>
			break;
		case GROUP_D:
			DIO_U8_DDRD=PORT_DIRECTION;
     6ba:	e1 e3       	ldi	r30, 0x31	; 49
     6bc:	f0 e0       	ldi	r31, 0x00	; 0
     6be:	8b 81       	ldd	r24, Y+3	; 0x03
     6c0:	80 83       	st	Z, r24

	}



return ERROR_STATE;
     6c2:	89 81       	ldd	r24, Y+1	; 0x01
}
     6c4:	0f 90       	pop	r0
     6c6:	0f 90       	pop	r0
     6c8:	0f 90       	pop	r0
     6ca:	0f 90       	pop	r0
     6cc:	0f 90       	pop	r0
     6ce:	cf 91       	pop	r28
     6d0:	df 91       	pop	r29
     6d2:	08 95       	ret

000006d4 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
     6d4:	df 93       	push	r29
     6d6:	cf 93       	push	r28
     6d8:	00 d0       	rcall	.+0      	; 0x6da <xEventGroupCreate+0x6>
     6da:	cd b7       	in	r28, 0x3d	; 61
     6dc:	de b7       	in	r29, 0x3e	; 62
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
     6de:	8b e0       	ldi	r24, 0x0B	; 11
     6e0:	90 e0       	ldi	r25, 0x00	; 0
     6e2:	0e 94 af 06 	call	0xd5e	; 0xd5e <pvPortMalloc>
     6e6:	9a 83       	std	Y+2, r25	; 0x02
     6e8:	89 83       	std	Y+1, r24	; 0x01

		if( pxEventBits != NULL )
     6ea:	89 81       	ldd	r24, Y+1	; 0x01
     6ec:	9a 81       	ldd	r25, Y+2	; 0x02
     6ee:	00 97       	sbiw	r24, 0x00	; 0
     6f0:	49 f0       	breq	.+18     	; 0x704 <xEventGroupCreate+0x30>
		{
			pxEventBits->uxEventBits = 0;
     6f2:	e9 81       	ldd	r30, Y+1	; 0x01
     6f4:	fa 81       	ldd	r31, Y+2	; 0x02
     6f6:	11 82       	std	Z+1, r1	; 0x01
     6f8:	10 82       	st	Z, r1
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     6fa:	89 81       	ldd	r24, Y+1	; 0x01
     6fc:	9a 81       	ldd	r25, Y+2	; 0x02
     6fe:	02 96       	adiw	r24, 0x02	; 2
     700:	0e 94 2b 07 	call	0xe56	; 0xe56 <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
     704:	89 81       	ldd	r24, Y+1	; 0x01
     706:	9a 81       	ldd	r25, Y+2	; 0x02
	}
     708:	0f 90       	pop	r0
     70a:	0f 90       	pop	r0
     70c:	cf 91       	pop	r28
     70e:	df 91       	pop	r29
     710:	08 95       	ret

00000712 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
     712:	df 93       	push	r29
     714:	cf 93       	push	r28
     716:	cd b7       	in	r28, 0x3d	; 61
     718:	de b7       	in	r29, 0x3e	; 62
     71a:	60 97       	sbiw	r28, 0x10	; 16
     71c:	0f b6       	in	r0, 0x3f	; 63
     71e:	f8 94       	cli
     720:	de bf       	out	0x3e, r29	; 62
     722:	0f be       	out	0x3f, r0	; 63
     724:	cd bf       	out	0x3d, r28	; 61
     726:	9a 87       	std	Y+10, r25	; 0x0a
     728:	89 87       	std	Y+9, r24	; 0x09
     72a:	7c 87       	std	Y+12, r23	; 0x0c
     72c:	6b 87       	std	Y+11, r22	; 0x0b
     72e:	5e 87       	std	Y+14, r21	; 0x0e
     730:	4d 87       	std	Y+13, r20	; 0x0d
     732:	38 8b       	std	Y+16, r19	; 0x10
     734:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
     736:	89 85       	ldd	r24, Y+9	; 0x09
     738:	9a 85       	ldd	r25, Y+10	; 0x0a
     73a:	9c 83       	std	Y+4, r25	; 0x04
     73c:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     73e:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     740:	0e 94 ee 15 	call	0x2bdc	; 0x2bdc <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     744:	eb 81       	ldd	r30, Y+3	; 0x03
     746:	fc 81       	ldd	r31, Y+4	; 0x04
     748:	80 81       	ld	r24, Z
     74a:	91 81       	ldd	r25, Z+1	; 0x01
     74c:	98 87       	std	Y+8, r25	; 0x08
     74e:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     750:	89 85       	ldd	r24, Y+9	; 0x09
     752:	9a 85       	ldd	r25, Y+10	; 0x0a
     754:	2b 85       	ldd	r18, Y+11	; 0x0b
     756:	3c 85       	ldd	r19, Y+12	; 0x0c
     758:	b9 01       	movw	r22, r18
     75a:	0e 94 60 05 	call	0xac0	; 0xac0 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     75e:	2f 81       	ldd	r18, Y+7	; 0x07
     760:	38 85       	ldd	r19, Y+8	; 0x08
     762:	8b 85       	ldd	r24, Y+11	; 0x0b
     764:	9c 85       	ldd	r25, Y+12	; 0x0c
     766:	28 2b       	or	r18, r24
     768:	39 2b       	or	r19, r25
     76a:	8d 85       	ldd	r24, Y+13	; 0x0d
     76c:	9e 85       	ldd	r25, Y+14	; 0x0e
     76e:	28 23       	and	r18, r24
     770:	39 23       	and	r19, r25
     772:	8d 85       	ldd	r24, Y+13	; 0x0d
     774:	9e 85       	ldd	r25, Y+14	; 0x0e
     776:	28 17       	cp	r18, r24
     778:	39 07       	cpc	r19, r25
     77a:	c9 f4       	brne	.+50     	; 0x7ae <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
     77c:	2f 81       	ldd	r18, Y+7	; 0x07
     77e:	38 85       	ldd	r19, Y+8	; 0x08
     780:	8b 85       	ldd	r24, Y+11	; 0x0b
     782:	9c 85       	ldd	r25, Y+12	; 0x0c
     784:	82 2b       	or	r24, r18
     786:	93 2b       	or	r25, r19
     788:	9e 83       	std	Y+6, r25	; 0x06
     78a:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     78c:	eb 81       	ldd	r30, Y+3	; 0x03
     78e:	fc 81       	ldd	r31, Y+4	; 0x04
     790:	20 81       	ld	r18, Z
     792:	31 81       	ldd	r19, Z+1	; 0x01
     794:	8d 85       	ldd	r24, Y+13	; 0x0d
     796:	9e 85       	ldd	r25, Y+14	; 0x0e
     798:	80 95       	com	r24
     79a:	90 95       	com	r25
     79c:	82 23       	and	r24, r18
     79e:	93 23       	and	r25, r19
     7a0:	eb 81       	ldd	r30, Y+3	; 0x03
     7a2:	fc 81       	ldd	r31, Y+4	; 0x04
     7a4:	91 83       	std	Z+1, r25	; 0x01
     7a6:	80 83       	st	Z, r24

			xTicksToWait = 0;
     7a8:	18 8a       	std	Y+16, r1	; 0x10
     7aa:	1f 86       	std	Y+15, r1	; 0x0f
     7ac:	1e c0       	rjmp	.+60     	; 0x7ea <xEventGroupSync+0xd8>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     7ae:	8f 85       	ldd	r24, Y+15	; 0x0f
     7b0:	98 89       	ldd	r25, Y+16	; 0x10
     7b2:	00 97       	sbiw	r24, 0x00	; 0
     7b4:	91 f0       	breq	.+36     	; 0x7da <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     7b6:	8b 81       	ldd	r24, Y+3	; 0x03
     7b8:	9c 81       	ldd	r25, Y+4	; 0x04
     7ba:	bc 01       	movw	r22, r24
     7bc:	6e 5f       	subi	r22, 0xFE	; 254
     7be:	7f 4f       	sbci	r23, 0xFF	; 255
     7c0:	8d 85       	ldd	r24, Y+13	; 0x0d
     7c2:	9e 85       	ldd	r25, Y+14	; 0x0e
     7c4:	9c 01       	movw	r18, r24
     7c6:	35 60       	ori	r19, 0x05	; 5
     7c8:	4f 85       	ldd	r20, Y+15	; 0x0f
     7ca:	58 89       	ldd	r21, Y+16	; 0x10
     7cc:	cb 01       	movw	r24, r22
     7ce:	b9 01       	movw	r22, r18
     7d0:	0e 94 5e 18 	call	0x30bc	; 0x30bc <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
     7d4:	1e 82       	std	Y+6, r1	; 0x06
     7d6:	1d 82       	std	Y+5, r1	; 0x05
     7d8:	08 c0       	rjmp	.+16     	; 0x7ea <xEventGroupSync+0xd8>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     7da:	eb 81       	ldd	r30, Y+3	; 0x03
     7dc:	fc 81       	ldd	r31, Y+4	; 0x04
     7de:	80 81       	ld	r24, Z
     7e0:	91 81       	ldd	r25, Z+1	; 0x01
     7e2:	9e 83       	std	Y+6, r25	; 0x06
     7e4:	8d 83       	std	Y+5, r24	; 0x05
				xTimeoutOccurred = pdTRUE;
     7e6:	81 e0       	ldi	r24, 0x01	; 1
     7e8:	89 83       	std	Y+1, r24	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     7ea:	0e 94 fa 15 	call	0x2bf4	; 0x2bf4 <xTaskResumeAll>
     7ee:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
     7f0:	8f 85       	ldd	r24, Y+15	; 0x0f
     7f2:	98 89       	ldd	r25, Y+16	; 0x10
     7f4:	00 97       	sbiw	r24, 0x00	; 0
     7f6:	09 f4       	brne	.+2      	; 0x7fa <xEventGroupSync+0xe8>
     7f8:	3a c0       	rjmp	.+116    	; 0x86e <__stack+0xf>
	{
		if( xAlreadyYielded == pdFALSE )
     7fa:	8a 81       	ldd	r24, Y+2	; 0x02
     7fc:	88 23       	and	r24, r24
     7fe:	11 f4       	brne	.+4      	; 0x804 <xEventGroupSync+0xf2>
		{
			portYIELD_WITHIN_API();
     800:	0e 94 a7 0a 	call	0x154e	; 0x154e <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     804:	0e 94 b1 1a 	call	0x3562	; 0x3562 <uxTaskResetEventItemValue>
     808:	9e 83       	std	Y+6, r25	; 0x06
     80a:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     80c:	8d 81       	ldd	r24, Y+5	; 0x05
     80e:	9e 81       	ldd	r25, Y+6	; 0x06
     810:	80 70       	andi	r24, 0x00	; 0
     812:	92 70       	andi	r25, 0x02	; 2
     814:	00 97       	sbiw	r24, 0x00	; 0
     816:	31 f5       	brne	.+76     	; 0x864 <__stack+0x5>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     818:	0f b6       	in	r0, 0x3f	; 63
     81a:	f8 94       	cli
     81c:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     81e:	eb 81       	ldd	r30, Y+3	; 0x03
     820:	fc 81       	ldd	r31, Y+4	; 0x04
     822:	80 81       	ld	r24, Z
     824:	91 81       	ldd	r25, Z+1	; 0x01
     826:	9e 83       	std	Y+6, r25	; 0x06
     828:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     82a:	2d 81       	ldd	r18, Y+5	; 0x05
     82c:	3e 81       	ldd	r19, Y+6	; 0x06
     82e:	8d 85       	ldd	r24, Y+13	; 0x0d
     830:	9e 85       	ldd	r25, Y+14	; 0x0e
     832:	28 23       	and	r18, r24
     834:	39 23       	and	r19, r25
     836:	8d 85       	ldd	r24, Y+13	; 0x0d
     838:	9e 85       	ldd	r25, Y+14	; 0x0e
     83a:	28 17       	cp	r18, r24
     83c:	39 07       	cpc	r19, r25
     83e:	71 f4       	brne	.+28     	; 0x85c <xEventGroupSync+0x14a>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     840:	eb 81       	ldd	r30, Y+3	; 0x03
     842:	fc 81       	ldd	r31, Y+4	; 0x04
     844:	20 81       	ld	r18, Z
     846:	31 81       	ldd	r19, Z+1	; 0x01
     848:	8d 85       	ldd	r24, Y+13	; 0x0d
     84a:	9e 85       	ldd	r25, Y+14	; 0x0e
     84c:	80 95       	com	r24
     84e:	90 95       	com	r25
     850:	82 23       	and	r24, r18
     852:	93 23       	and	r25, r19
     854:	eb 81       	ldd	r30, Y+3	; 0x03
     856:	fc 81       	ldd	r31, Y+4	; 0x04
     858:	91 83       	std	Z+1, r25	; 0x01
     85a:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     85c:	0f 90       	pop	r0
     85e:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
     860:	81 e0       	ldi	r24, 0x01	; 1
     862:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     864:	8d 81       	ldd	r24, Y+5	; 0x05
     866:	9e 81       	ldd	r25, Y+6	; 0x06
     868:	90 70       	andi	r25, 0x00	; 0
     86a:	9e 83       	std	Y+6, r25	; 0x06
     86c:	8d 83       	std	Y+5, r24	; 0x05
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     86e:	8d 81       	ldd	r24, Y+5	; 0x05
     870:	9e 81       	ldd	r25, Y+6	; 0x06
}
     872:	60 96       	adiw	r28, 0x10	; 16
     874:	0f b6       	in	r0, 0x3f	; 63
     876:	f8 94       	cli
     878:	de bf       	out	0x3e, r29	; 62
     87a:	0f be       	out	0x3f, r0	; 63
     87c:	cd bf       	out	0x3d, r28	; 61
     87e:	cf 91       	pop	r28
     880:	df 91       	pop	r29
     882:	08 95       	ret

00000884 <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
     884:	0f 93       	push	r16
     886:	1f 93       	push	r17
     888:	df 93       	push	r29
     88a:	cf 93       	push	r28
     88c:	cd b7       	in	r28, 0x3d	; 61
     88e:	de b7       	in	r29, 0x3e	; 62
     890:	63 97       	sbiw	r28, 0x13	; 19
     892:	0f b6       	in	r0, 0x3f	; 63
     894:	f8 94       	cli
     896:	de bf       	out	0x3e, r29	; 62
     898:	0f be       	out	0x3f, r0	; 63
     89a:	cd bf       	out	0x3d, r28	; 61
     89c:	9d 87       	std	Y+13, r25	; 0x0d
     89e:	8c 87       	std	Y+12, r24	; 0x0c
     8a0:	7f 87       	std	Y+15, r23	; 0x0f
     8a2:	6e 87       	std	Y+14, r22	; 0x0e
     8a4:	48 8b       	std	Y+16, r20	; 0x10
     8a6:	29 8b       	std	Y+17, r18	; 0x11
     8a8:	1b 8b       	std	Y+19, r17	; 0x13
     8aa:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
     8ac:	8c 85       	ldd	r24, Y+12	; 0x0c
     8ae:	9d 85       	ldd	r25, Y+13	; 0x0d
     8b0:	9b 87       	std	Y+11, r25	; 0x0b
     8b2:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
     8b4:	1f 82       	std	Y+7, r1	; 0x07
     8b6:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     8b8:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     8ba:	0e 94 ee 15 	call	0x2bdc	; 0x2bdc <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     8be:	ea 85       	ldd	r30, Y+10	; 0x0a
     8c0:	fb 85       	ldd	r31, Y+11	; 0x0b
     8c2:	80 81       	ld	r24, Z
     8c4:	91 81       	ldd	r25, Z+1	; 0x01
     8c6:	9a 83       	std	Y+2, r25	; 0x02
     8c8:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     8ca:	89 81       	ldd	r24, Y+1	; 0x01
     8cc:	9a 81       	ldd	r25, Y+2	; 0x02
     8ce:	2e 85       	ldd	r18, Y+14	; 0x0e
     8d0:	3f 85       	ldd	r19, Y+15	; 0x0f
     8d2:	b9 01       	movw	r22, r18
     8d4:	49 89       	ldd	r20, Y+17	; 0x11
     8d6:	0e 94 7d 06 	call	0xcfa	; 0xcfa <prvTestWaitCondition>
     8da:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
     8dc:	8d 81       	ldd	r24, Y+5	; 0x05
     8de:	88 23       	and	r24, r24
     8e0:	c1 f0       	breq	.+48     	; 0x912 <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
     8e2:	89 81       	ldd	r24, Y+1	; 0x01
     8e4:	9a 81       	ldd	r25, Y+2	; 0x02
     8e6:	99 87       	std	Y+9, r25	; 0x09
     8e8:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
     8ea:	1b 8a       	std	Y+19, r1	; 0x13
     8ec:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     8ee:	88 89       	ldd	r24, Y+16	; 0x10
     8f0:	88 23       	and	r24, r24
     8f2:	e9 f1       	breq	.+122    	; 0x96e <xEventGroupWaitBits+0xea>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     8f4:	ea 85       	ldd	r30, Y+10	; 0x0a
     8f6:	fb 85       	ldd	r31, Y+11	; 0x0b
     8f8:	20 81       	ld	r18, Z
     8fa:	31 81       	ldd	r19, Z+1	; 0x01
     8fc:	8e 85       	ldd	r24, Y+14	; 0x0e
     8fe:	9f 85       	ldd	r25, Y+15	; 0x0f
     900:	80 95       	com	r24
     902:	90 95       	com	r25
     904:	82 23       	and	r24, r18
     906:	93 23       	and	r25, r19
     908:	ea 85       	ldd	r30, Y+10	; 0x0a
     90a:	fb 85       	ldd	r31, Y+11	; 0x0b
     90c:	91 83       	std	Z+1, r25	; 0x01
     90e:	80 83       	st	Z, r24
     910:	2e c0       	rjmp	.+92     	; 0x96e <xEventGroupWaitBits+0xea>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     912:	8a 89       	ldd	r24, Y+18	; 0x12
     914:	9b 89       	ldd	r25, Y+19	; 0x13
     916:	00 97       	sbiw	r24, 0x00	; 0
     918:	39 f4       	brne	.+14     	; 0x928 <xEventGroupWaitBits+0xa4>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
     91a:	89 81       	ldd	r24, Y+1	; 0x01
     91c:	9a 81       	ldd	r25, Y+2	; 0x02
     91e:	99 87       	std	Y+9, r25	; 0x09
     920:	88 87       	std	Y+8, r24	; 0x08
			xTimeoutOccurred = pdTRUE;
     922:	81 e0       	ldi	r24, 0x01	; 1
     924:	8b 83       	std	Y+3, r24	; 0x03
     926:	23 c0       	rjmp	.+70     	; 0x96e <xEventGroupWaitBits+0xea>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     928:	88 89       	ldd	r24, Y+16	; 0x10
     92a:	88 23       	and	r24, r24
     92c:	29 f0       	breq	.+10     	; 0x938 <xEventGroupWaitBits+0xb4>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     92e:	8e 81       	ldd	r24, Y+6	; 0x06
     930:	9f 81       	ldd	r25, Y+7	; 0x07
     932:	91 60       	ori	r25, 0x01	; 1
     934:	9f 83       	std	Y+7, r25	; 0x07
     936:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     938:	89 89       	ldd	r24, Y+17	; 0x11
     93a:	88 23       	and	r24, r24
     93c:	29 f0       	breq	.+10     	; 0x948 <xEventGroupWaitBits+0xc4>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     93e:	8e 81       	ldd	r24, Y+6	; 0x06
     940:	9f 81       	ldd	r25, Y+7	; 0x07
     942:	94 60       	ori	r25, 0x04	; 4
     944:	9f 83       	std	Y+7, r25	; 0x07
     946:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     948:	8a 85       	ldd	r24, Y+10	; 0x0a
     94a:	9b 85       	ldd	r25, Y+11	; 0x0b
     94c:	bc 01       	movw	r22, r24
     94e:	6e 5f       	subi	r22, 0xFE	; 254
     950:	7f 4f       	sbci	r23, 0xFF	; 255
     952:	2e 85       	ldd	r18, Y+14	; 0x0e
     954:	3f 85       	ldd	r19, Y+15	; 0x0f
     956:	8e 81       	ldd	r24, Y+6	; 0x06
     958:	9f 81       	ldd	r25, Y+7	; 0x07
     95a:	28 2b       	or	r18, r24
     95c:	39 2b       	or	r19, r25
     95e:	4a 89       	ldd	r20, Y+18	; 0x12
     960:	5b 89       	ldd	r21, Y+19	; 0x13
     962:	cb 01       	movw	r24, r22
     964:	b9 01       	movw	r22, r18
     966:	0e 94 5e 18 	call	0x30bc	; 0x30bc <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
     96a:	19 86       	std	Y+9, r1	; 0x09
     96c:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     96e:	0e 94 fa 15 	call	0x2bf4	; 0x2bf4 <xTaskResumeAll>
     972:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
     974:	8a 89       	ldd	r24, Y+18	; 0x12
     976:	9b 89       	ldd	r25, Y+19	; 0x13
     978:	00 97       	sbiw	r24, 0x00	; 0
     97a:	09 f4       	brne	.+2      	; 0x97e <xEventGroupWaitBits+0xfa>
     97c:	3c c0       	rjmp	.+120    	; 0x9f6 <xEventGroupWaitBits+0x172>
	{
		if( xAlreadyYielded == pdFALSE )
     97e:	8c 81       	ldd	r24, Y+4	; 0x04
     980:	88 23       	and	r24, r24
     982:	11 f4       	brne	.+4      	; 0x988 <xEventGroupWaitBits+0x104>
		{
			portYIELD_WITHIN_API();
     984:	0e 94 a7 0a 	call	0x154e	; 0x154e <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     988:	0e 94 b1 1a 	call	0x3562	; 0x3562 <uxTaskResetEventItemValue>
     98c:	99 87       	std	Y+9, r25	; 0x09
     98e:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     990:	88 85       	ldd	r24, Y+8	; 0x08
     992:	99 85       	ldd	r25, Y+9	; 0x09
     994:	80 70       	andi	r24, 0x00	; 0
     996:	92 70       	andi	r25, 0x02	; 2
     998:	00 97       	sbiw	r24, 0x00	; 0
     99a:	41 f5       	brne	.+80     	; 0x9ec <xEventGroupWaitBits+0x168>
		{
			taskENTER_CRITICAL();
     99c:	0f b6       	in	r0, 0x3f	; 63
     99e:	f8 94       	cli
     9a0:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     9a2:	ea 85       	ldd	r30, Y+10	; 0x0a
     9a4:	fb 85       	ldd	r31, Y+11	; 0x0b
     9a6:	80 81       	ld	r24, Z
     9a8:	91 81       	ldd	r25, Z+1	; 0x01
     9aa:	99 87       	std	Y+9, r25	; 0x09
     9ac:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     9ae:	88 85       	ldd	r24, Y+8	; 0x08
     9b0:	99 85       	ldd	r25, Y+9	; 0x09
     9b2:	2e 85       	ldd	r18, Y+14	; 0x0e
     9b4:	3f 85       	ldd	r19, Y+15	; 0x0f
     9b6:	b9 01       	movw	r22, r18
     9b8:	49 89       	ldd	r20, Y+17	; 0x11
     9ba:	0e 94 7d 06 	call	0xcfa	; 0xcfa <prvTestWaitCondition>
     9be:	88 23       	and	r24, r24
     9c0:	89 f0       	breq	.+34     	; 0x9e4 <xEventGroupWaitBits+0x160>
				{
					if( xClearOnExit != pdFALSE )
     9c2:	88 89       	ldd	r24, Y+16	; 0x10
     9c4:	88 23       	and	r24, r24
     9c6:	71 f0       	breq	.+28     	; 0x9e4 <xEventGroupWaitBits+0x160>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     9c8:	ea 85       	ldd	r30, Y+10	; 0x0a
     9ca:	fb 85       	ldd	r31, Y+11	; 0x0b
     9cc:	20 81       	ld	r18, Z
     9ce:	31 81       	ldd	r19, Z+1	; 0x01
     9d0:	8e 85       	ldd	r24, Y+14	; 0x0e
     9d2:	9f 85       	ldd	r25, Y+15	; 0x0f
     9d4:	80 95       	com	r24
     9d6:	90 95       	com	r25
     9d8:	82 23       	and	r24, r18
     9da:	93 23       	and	r25, r19
     9dc:	ea 85       	ldd	r30, Y+10	; 0x0a
     9de:	fb 85       	ldd	r31, Y+11	; 0x0b
     9e0:	91 83       	std	Z+1, r25	; 0x01
     9e2:	80 83       	st	Z, r24
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
     9e4:	81 e0       	ldi	r24, 0x01	; 1
     9e6:	8b 83       	std	Y+3, r24	; 0x03
			}
			taskEXIT_CRITICAL();
     9e8:	0f 90       	pop	r0
     9ea:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     9ec:	88 85       	ldd	r24, Y+8	; 0x08
     9ee:	99 85       	ldd	r25, Y+9	; 0x09
     9f0:	90 70       	andi	r25, 0x00	; 0
     9f2:	99 87       	std	Y+9, r25	; 0x09
     9f4:	88 87       	std	Y+8, r24	; 0x08
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     9f6:	88 85       	ldd	r24, Y+8	; 0x08
     9f8:	99 85       	ldd	r25, Y+9	; 0x09
}
     9fa:	63 96       	adiw	r28, 0x13	; 19
     9fc:	0f b6       	in	r0, 0x3f	; 63
     9fe:	f8 94       	cli
     a00:	de bf       	out	0x3e, r29	; 62
     a02:	0f be       	out	0x3f, r0	; 63
     a04:	cd bf       	out	0x3d, r28	; 61
     a06:	cf 91       	pop	r28
     a08:	df 91       	pop	r29
     a0a:	1f 91       	pop	r17
     a0c:	0f 91       	pop	r16
     a0e:	08 95       	ret

00000a10 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
     a10:	df 93       	push	r29
     a12:	cf 93       	push	r28
     a14:	cd b7       	in	r28, 0x3d	; 61
     a16:	de b7       	in	r29, 0x3e	; 62
     a18:	28 97       	sbiw	r28, 0x08	; 8
     a1a:	0f b6       	in	r0, 0x3f	; 63
     a1c:	f8 94       	cli
     a1e:	de bf       	out	0x3e, r29	; 62
     a20:	0f be       	out	0x3f, r0	; 63
     a22:	cd bf       	out	0x3d, r28	; 61
     a24:	9e 83       	std	Y+6, r25	; 0x06
     a26:	8d 83       	std	Y+5, r24	; 0x05
     a28:	78 87       	std	Y+8, r23	; 0x08
     a2a:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
     a2c:	8d 81       	ldd	r24, Y+5	; 0x05
     a2e:	9e 81       	ldd	r25, Y+6	; 0x06
     a30:	9c 83       	std	Y+4, r25	; 0x04
     a32:	8b 83       	std	Y+3, r24	; 0x03
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
     a34:	0f b6       	in	r0, 0x3f	; 63
     a36:	f8 94       	cli
     a38:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
     a3a:	eb 81       	ldd	r30, Y+3	; 0x03
     a3c:	fc 81       	ldd	r31, Y+4	; 0x04
     a3e:	80 81       	ld	r24, Z
     a40:	91 81       	ldd	r25, Z+1	; 0x01
     a42:	9a 83       	std	Y+2, r25	; 0x02
     a44:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     a46:	eb 81       	ldd	r30, Y+3	; 0x03
     a48:	fc 81       	ldd	r31, Y+4	; 0x04
     a4a:	20 81       	ld	r18, Z
     a4c:	31 81       	ldd	r19, Z+1	; 0x01
     a4e:	8f 81       	ldd	r24, Y+7	; 0x07
     a50:	98 85       	ldd	r25, Y+8	; 0x08
     a52:	80 95       	com	r24
     a54:	90 95       	com	r25
     a56:	82 23       	and	r24, r18
     a58:	93 23       	and	r25, r19
     a5a:	eb 81       	ldd	r30, Y+3	; 0x03
     a5c:	fc 81       	ldd	r31, Y+4	; 0x04
     a5e:	91 83       	std	Z+1, r25	; 0x01
     a60:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
     a62:	0f 90       	pop	r0
     a64:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
     a66:	89 81       	ldd	r24, Y+1	; 0x01
     a68:	9a 81       	ldd	r25, Y+2	; 0x02
}
     a6a:	28 96       	adiw	r28, 0x08	; 8
     a6c:	0f b6       	in	r0, 0x3f	; 63
     a6e:	f8 94       	cli
     a70:	de bf       	out	0x3e, r29	; 62
     a72:	0f be       	out	0x3f, r0	; 63
     a74:	cd bf       	out	0x3d, r28	; 61
     a76:	cf 91       	pop	r28
     a78:	df 91       	pop	r29
     a7a:	08 95       	ret

00000a7c <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
     a7c:	df 93       	push	r29
     a7e:	cf 93       	push	r28
     a80:	cd b7       	in	r28, 0x3d	; 61
     a82:	de b7       	in	r29, 0x3e	; 62
     a84:	27 97       	sbiw	r28, 0x07	; 7
     a86:	0f b6       	in	r0, 0x3f	; 63
     a88:	f8 94       	cli
     a8a:	de bf       	out	0x3e, r29	; 62
     a8c:	0f be       	out	0x3f, r0	; 63
     a8e:	cd bf       	out	0x3d, r28	; 61
     a90:	9f 83       	std	Y+7, r25	; 0x07
     a92:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
     a94:	8e 81       	ldd	r24, Y+6	; 0x06
     a96:	9f 81       	ldd	r25, Y+7	; 0x07
     a98:	9c 83       	std	Y+4, r25	; 0x04
     a9a:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     a9c:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
     a9e:	eb 81       	ldd	r30, Y+3	; 0x03
     aa0:	fc 81       	ldd	r31, Y+4	; 0x04
     aa2:	80 81       	ld	r24, Z
     aa4:	91 81       	ldd	r25, Z+1	; 0x01
     aa6:	9a 83       	std	Y+2, r25	; 0x02
     aa8:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
     aaa:	89 81       	ldd	r24, Y+1	; 0x01
     aac:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
     aae:	27 96       	adiw	r28, 0x07	; 7
     ab0:	0f b6       	in	r0, 0x3f	; 63
     ab2:	f8 94       	cli
     ab4:	de bf       	out	0x3e, r29	; 62
     ab6:	0f be       	out	0x3f, r0	; 63
     ab8:	cd bf       	out	0x3d, r28	; 61
     aba:	cf 91       	pop	r28
     abc:	df 91       	pop	r29
     abe:	08 95       	ret

00000ac0 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     ac0:	df 93       	push	r29
     ac2:	cf 93       	push	r28
     ac4:	cd b7       	in	r28, 0x3d	; 61
     ac6:	de b7       	in	r29, 0x3e	; 62
     ac8:	65 97       	sbiw	r28, 0x15	; 21
     aca:	0f b6       	in	r0, 0x3f	; 63
     acc:	f8 94       	cli
     ace:	de bf       	out	0x3e, r29	; 62
     ad0:	0f be       	out	0x3f, r0	; 63
     ad2:	cd bf       	out	0x3d, r28	; 61
     ad4:	9b 8b       	std	Y+19, r25	; 0x13
     ad6:	8a 8b       	std	Y+18, r24	; 0x12
     ad8:	7d 8b       	std	Y+21, r23	; 0x15
     ada:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     adc:	19 86       	std	Y+9, r1	; 0x09
     ade:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = xEventGroup;
     ae0:	8a 89       	ldd	r24, Y+18	; 0x12
     ae2:	9b 89       	ldd	r25, Y+19	; 0x13
     ae4:	9b 83       	std	Y+3, r25	; 0x03
     ae6:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
     ae8:	19 82       	std	Y+1, r1	; 0x01
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
     aea:	8a 81       	ldd	r24, Y+2	; 0x02
     aec:	9b 81       	ldd	r25, Y+3	; 0x03
     aee:	02 96       	adiw	r24, 0x02	; 2
     af0:	9b 87       	std	Y+11, r25	; 0x0b
     af2:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     af4:	8a 85       	ldd	r24, Y+10	; 0x0a
     af6:	9b 85       	ldd	r25, Y+11	; 0x0b
     af8:	03 96       	adiw	r24, 0x03	; 3
     afa:	9d 87       	std	Y+13, r25	; 0x0d
     afc:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
     afe:	0e 94 ee 15 	call	0x2bdc	; 0x2bdc <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     b02:	ea 85       	ldd	r30, Y+10	; 0x0a
     b04:	fb 85       	ldd	r31, Y+11	; 0x0b
     b06:	85 81       	ldd	r24, Z+5	; 0x05
     b08:	96 81       	ldd	r25, Z+6	; 0x06
     b0a:	99 8b       	std	Y+17, r25	; 0x11
     b0c:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     b0e:	ea 81       	ldd	r30, Y+2	; 0x02
     b10:	fb 81       	ldd	r31, Y+3	; 0x03
     b12:	20 81       	ld	r18, Z
     b14:	31 81       	ldd	r19, Z+1	; 0x01
     b16:	8c 89       	ldd	r24, Y+20	; 0x14
     b18:	9d 89       	ldd	r25, Y+21	; 0x15
     b1a:	82 2b       	or	r24, r18
     b1c:	93 2b       	or	r25, r19
     b1e:	ea 81       	ldd	r30, Y+2	; 0x02
     b20:	fb 81       	ldd	r31, Y+3	; 0x03
     b22:	91 83       	std	Z+1, r25	; 0x01
     b24:	80 83       	st	Z, r24
     b26:	59 c0       	rjmp	.+178    	; 0xbda <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
     b28:	e8 89       	ldd	r30, Y+16	; 0x10
     b2a:	f9 89       	ldd	r31, Y+17	; 0x11
     b2c:	82 81       	ldd	r24, Z+2	; 0x02
     b2e:	93 81       	ldd	r25, Z+3	; 0x03
     b30:	9f 87       	std	Y+15, r25	; 0x0f
     b32:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     b34:	e8 89       	ldd	r30, Y+16	; 0x10
     b36:	f9 89       	ldd	r31, Y+17	; 0x11
     b38:	80 81       	ld	r24, Z
     b3a:	91 81       	ldd	r25, Z+1	; 0x01
     b3c:	9f 83       	std	Y+7, r25	; 0x07
     b3e:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
     b40:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
     b42:	8e 81       	ldd	r24, Y+6	; 0x06
     b44:	9f 81       	ldd	r25, Y+7	; 0x07
     b46:	80 70       	andi	r24, 0x00	; 0
     b48:	9d 83       	std	Y+5, r25	; 0x05
     b4a:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     b4c:	8e 81       	ldd	r24, Y+6	; 0x06
     b4e:	9f 81       	ldd	r25, Y+7	; 0x07
     b50:	90 70       	andi	r25, 0x00	; 0
     b52:	9f 83       	std	Y+7, r25	; 0x07
     b54:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     b56:	8c 81       	ldd	r24, Y+4	; 0x04
     b58:	9d 81       	ldd	r25, Y+5	; 0x05
     b5a:	80 70       	andi	r24, 0x00	; 0
     b5c:	94 70       	andi	r25, 0x04	; 4
     b5e:	00 97       	sbiw	r24, 0x00	; 0
     b60:	69 f4       	brne	.+26     	; 0xb7c <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     b62:	ea 81       	ldd	r30, Y+2	; 0x02
     b64:	fb 81       	ldd	r31, Y+3	; 0x03
     b66:	20 81       	ld	r18, Z
     b68:	31 81       	ldd	r19, Z+1	; 0x01
     b6a:	8e 81       	ldd	r24, Y+6	; 0x06
     b6c:	9f 81       	ldd	r25, Y+7	; 0x07
     b6e:	82 23       	and	r24, r18
     b70:	93 23       	and	r25, r19
     b72:	00 97       	sbiw	r24, 0x00	; 0
     b74:	91 f0       	breq	.+36     	; 0xb9a <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
     b76:	81 e0       	ldi	r24, 0x01	; 1
     b78:	89 83       	std	Y+1, r24	; 0x01
     b7a:	0f c0       	rjmp	.+30     	; 0xb9a <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     b7c:	ea 81       	ldd	r30, Y+2	; 0x02
     b7e:	fb 81       	ldd	r31, Y+3	; 0x03
     b80:	20 81       	ld	r18, Z
     b82:	31 81       	ldd	r19, Z+1	; 0x01
     b84:	8e 81       	ldd	r24, Y+6	; 0x06
     b86:	9f 81       	ldd	r25, Y+7	; 0x07
     b88:	28 23       	and	r18, r24
     b8a:	39 23       	and	r19, r25
     b8c:	8e 81       	ldd	r24, Y+6	; 0x06
     b8e:	9f 81       	ldd	r25, Y+7	; 0x07
     b90:	28 17       	cp	r18, r24
     b92:	39 07       	cpc	r19, r25
     b94:	11 f4       	brne	.+4      	; 0xb9a <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
     b96:	81 e0       	ldi	r24, 0x01	; 1
     b98:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     b9a:	89 81       	ldd	r24, Y+1	; 0x01
     b9c:	88 23       	and	r24, r24
     b9e:	c9 f0       	breq	.+50     	; 0xbd2 <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     ba0:	8c 81       	ldd	r24, Y+4	; 0x04
     ba2:	9d 81       	ldd	r25, Y+5	; 0x05
     ba4:	80 70       	andi	r24, 0x00	; 0
     ba6:	91 70       	andi	r25, 0x01	; 1
     ba8:	00 97       	sbiw	r24, 0x00	; 0
     baa:	41 f0       	breq	.+16     	; 0xbbc <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     bac:	88 85       	ldd	r24, Y+8	; 0x08
     bae:	99 85       	ldd	r25, Y+9	; 0x09
     bb0:	2e 81       	ldd	r18, Y+6	; 0x06
     bb2:	3f 81       	ldd	r19, Y+7	; 0x07
     bb4:	82 2b       	or	r24, r18
     bb6:	93 2b       	or	r25, r19
     bb8:	99 87       	std	Y+9, r25	; 0x09
     bba:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     bbc:	ea 81       	ldd	r30, Y+2	; 0x02
     bbe:	fb 81       	ldd	r31, Y+3	; 0x03
     bc0:	80 81       	ld	r24, Z
     bc2:	91 81       	ldd	r25, Z+1	; 0x01
     bc4:	9c 01       	movw	r18, r24
     bc6:	32 60       	ori	r19, 0x02	; 2
     bc8:	88 89       	ldd	r24, Y+16	; 0x10
     bca:	99 89       	ldd	r25, Y+17	; 0x11
     bcc:	b9 01       	movw	r22, r18
     bce:	0e 94 f9 18 	call	0x31f2	; 0x31f2 <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
     bd2:	8e 85       	ldd	r24, Y+14	; 0x0e
     bd4:	9f 85       	ldd	r25, Y+15	; 0x0f
     bd6:	99 8b       	std	Y+17, r25	; 0x11
     bd8:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     bda:	28 89       	ldd	r18, Y+16	; 0x10
     bdc:	39 89       	ldd	r19, Y+17	; 0x11
     bde:	8c 85       	ldd	r24, Y+12	; 0x0c
     be0:	9d 85       	ldd	r25, Y+13	; 0x0d
     be2:	28 17       	cp	r18, r24
     be4:	39 07       	cpc	r19, r25
     be6:	09 f0       	breq	.+2      	; 0xbea <xEventGroupSetBits+0x12a>
     be8:	9f cf       	rjmp	.-194    	; 0xb28 <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     bea:	ea 81       	ldd	r30, Y+2	; 0x02
     bec:	fb 81       	ldd	r31, Y+3	; 0x03
     bee:	20 81       	ld	r18, Z
     bf0:	31 81       	ldd	r19, Z+1	; 0x01
     bf2:	88 85       	ldd	r24, Y+8	; 0x08
     bf4:	99 85       	ldd	r25, Y+9	; 0x09
     bf6:	80 95       	com	r24
     bf8:	90 95       	com	r25
     bfa:	82 23       	and	r24, r18
     bfc:	93 23       	and	r25, r19
     bfe:	ea 81       	ldd	r30, Y+2	; 0x02
     c00:	fb 81       	ldd	r31, Y+3	; 0x03
     c02:	91 83       	std	Z+1, r25	; 0x01
     c04:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
     c06:	0e 94 fa 15 	call	0x2bf4	; 0x2bf4 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
     c0a:	ea 81       	ldd	r30, Y+2	; 0x02
     c0c:	fb 81       	ldd	r31, Y+3	; 0x03
     c0e:	80 81       	ld	r24, Z
     c10:	91 81       	ldd	r25, Z+1	; 0x01
}
     c12:	65 96       	adiw	r28, 0x15	; 21
     c14:	0f b6       	in	r0, 0x3f	; 63
     c16:	f8 94       	cli
     c18:	de bf       	out	0x3e, r29	; 62
     c1a:	0f be       	out	0x3f, r0	; 63
     c1c:	cd bf       	out	0x3d, r28	; 61
     c1e:	cf 91       	pop	r28
     c20:	df 91       	pop	r29
     c22:	08 95       	ret

00000c24 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
     c24:	df 93       	push	r29
     c26:	cf 93       	push	r28
     c28:	00 d0       	rcall	.+0      	; 0xc2a <vEventGroupDelete+0x6>
     c2a:	00 d0       	rcall	.+0      	; 0xc2c <vEventGroupDelete+0x8>
     c2c:	00 d0       	rcall	.+0      	; 0xc2e <vEventGroupDelete+0xa>
     c2e:	cd b7       	in	r28, 0x3d	; 61
     c30:	de b7       	in	r29, 0x3e	; 62
     c32:	9e 83       	std	Y+6, r25	; 0x06
     c34:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
     c36:	8d 81       	ldd	r24, Y+5	; 0x05
     c38:	9e 81       	ldd	r25, Y+6	; 0x06
     c3a:	9c 83       	std	Y+4, r25	; 0x04
     c3c:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
     c3e:	8b 81       	ldd	r24, Y+3	; 0x03
     c40:	9c 81       	ldd	r25, Y+4	; 0x04
     c42:	02 96       	adiw	r24, 0x02	; 2
     c44:	9a 83       	std	Y+2, r25	; 0x02
     c46:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
     c48:	0e 94 ee 15 	call	0x2bdc	; 0x2bdc <vTaskSuspendAll>
     c4c:	08 c0       	rjmp	.+16     	; 0xc5e <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
     c4e:	e9 81       	ldd	r30, Y+1	; 0x01
     c50:	fa 81       	ldd	r31, Y+2	; 0x02
     c52:	85 81       	ldd	r24, Z+5	; 0x05
     c54:	96 81       	ldd	r25, Z+6	; 0x06
     c56:	60 e0       	ldi	r22, 0x00	; 0
     c58:	72 e0       	ldi	r23, 0x02	; 2
     c5a:	0e 94 f9 18 	call	0x31f2	; 0x31f2 <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     c5e:	e9 81       	ldd	r30, Y+1	; 0x01
     c60:	fa 81       	ldd	r31, Y+2	; 0x02
     c62:	80 81       	ld	r24, Z
     c64:	88 23       	and	r24, r24
     c66:	99 f7       	brne	.-26     	; 0xc4e <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
     c68:	8b 81       	ldd	r24, Y+3	; 0x03
     c6a:	9c 81       	ldd	r25, Y+4	; 0x04
     c6c:	0e 94 05 07 	call	0xe0a	; 0xe0a <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
     c70:	0e 94 fa 15 	call	0x2bf4	; 0x2bf4 <xTaskResumeAll>
}
     c74:	26 96       	adiw	r28, 0x06	; 6
     c76:	0f b6       	in	r0, 0x3f	; 63
     c78:	f8 94       	cli
     c7a:	de bf       	out	0x3e, r29	; 62
     c7c:	0f be       	out	0x3f, r0	; 63
     c7e:	cd bf       	out	0x3d, r28	; 61
     c80:	cf 91       	pop	r28
     c82:	df 91       	pop	r29
     c84:	08 95       	ret

00000c86 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
     c86:	df 93       	push	r29
     c88:	cf 93       	push	r28
     c8a:	00 d0       	rcall	.+0      	; 0xc8c <vEventGroupSetBitsCallback+0x6>
     c8c:	00 d0       	rcall	.+0      	; 0xc8e <vEventGroupSetBitsCallback+0x8>
     c8e:	00 d0       	rcall	.+0      	; 0xc90 <vEventGroupSetBitsCallback+0xa>
     c90:	cd b7       	in	r28, 0x3d	; 61
     c92:	de b7       	in	r29, 0x3e	; 62
     c94:	9a 83       	std	Y+2, r25	; 0x02
     c96:	89 83       	std	Y+1, r24	; 0x01
     c98:	4b 83       	std	Y+3, r20	; 0x03
     c9a:	5c 83       	std	Y+4, r21	; 0x04
     c9c:	6d 83       	std	Y+5, r22	; 0x05
     c9e:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     ca0:	89 81       	ldd	r24, Y+1	; 0x01
     ca2:	9a 81       	ldd	r25, Y+2	; 0x02
     ca4:	2b 81       	ldd	r18, Y+3	; 0x03
     ca6:	3c 81       	ldd	r19, Y+4	; 0x04
     ca8:	b9 01       	movw	r22, r18
     caa:	0e 94 60 05 	call	0xac0	; 0xac0 <xEventGroupSetBits>
}
     cae:	26 96       	adiw	r28, 0x06	; 6
     cb0:	0f b6       	in	r0, 0x3f	; 63
     cb2:	f8 94       	cli
     cb4:	de bf       	out	0x3e, r29	; 62
     cb6:	0f be       	out	0x3f, r0	; 63
     cb8:	cd bf       	out	0x3d, r28	; 61
     cba:	cf 91       	pop	r28
     cbc:	df 91       	pop	r29
     cbe:	08 95       	ret

00000cc0 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
     cc0:	df 93       	push	r29
     cc2:	cf 93       	push	r28
     cc4:	00 d0       	rcall	.+0      	; 0xcc6 <vEventGroupClearBitsCallback+0x6>
     cc6:	00 d0       	rcall	.+0      	; 0xcc8 <vEventGroupClearBitsCallback+0x8>
     cc8:	00 d0       	rcall	.+0      	; 0xcca <vEventGroupClearBitsCallback+0xa>
     cca:	cd b7       	in	r28, 0x3d	; 61
     ccc:	de b7       	in	r29, 0x3e	; 62
     cce:	9a 83       	std	Y+2, r25	; 0x02
     cd0:	89 83       	std	Y+1, r24	; 0x01
     cd2:	4b 83       	std	Y+3, r20	; 0x03
     cd4:	5c 83       	std	Y+4, r21	; 0x04
     cd6:	6d 83       	std	Y+5, r22	; 0x05
     cd8:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     cda:	89 81       	ldd	r24, Y+1	; 0x01
     cdc:	9a 81       	ldd	r25, Y+2	; 0x02
     cde:	2b 81       	ldd	r18, Y+3	; 0x03
     ce0:	3c 81       	ldd	r19, Y+4	; 0x04
     ce2:	b9 01       	movw	r22, r18
     ce4:	0e 94 08 05 	call	0xa10	; 0xa10 <xEventGroupClearBits>
}
     ce8:	26 96       	adiw	r28, 0x06	; 6
     cea:	0f b6       	in	r0, 0x3f	; 63
     cec:	f8 94       	cli
     cee:	de bf       	out	0x3e, r29	; 62
     cf0:	0f be       	out	0x3f, r0	; 63
     cf2:	cd bf       	out	0x3d, r28	; 61
     cf4:	cf 91       	pop	r28
     cf6:	df 91       	pop	r29
     cf8:	08 95       	ret

00000cfa <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
     cfa:	df 93       	push	r29
     cfc:	cf 93       	push	r28
     cfe:	00 d0       	rcall	.+0      	; 0xd00 <prvTestWaitCondition+0x6>
     d00:	00 d0       	rcall	.+0      	; 0xd02 <prvTestWaitCondition+0x8>
     d02:	00 d0       	rcall	.+0      	; 0xd04 <prvTestWaitCondition+0xa>
     d04:	cd b7       	in	r28, 0x3d	; 61
     d06:	de b7       	in	r29, 0x3e	; 62
     d08:	9b 83       	std	Y+3, r25	; 0x03
     d0a:	8a 83       	std	Y+2, r24	; 0x02
     d0c:	7d 83       	std	Y+5, r23	; 0x05
     d0e:	6c 83       	std	Y+4, r22	; 0x04
     d10:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
     d12:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
     d14:	8e 81       	ldd	r24, Y+6	; 0x06
     d16:	88 23       	and	r24, r24
     d18:	59 f4       	brne	.+22     	; 0xd30 <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
     d1a:	8a 81       	ldd	r24, Y+2	; 0x02
     d1c:	9b 81       	ldd	r25, Y+3	; 0x03
     d1e:	2c 81       	ldd	r18, Y+4	; 0x04
     d20:	3d 81       	ldd	r19, Y+5	; 0x05
     d22:	82 23       	and	r24, r18
     d24:	93 23       	and	r25, r19
     d26:	00 97       	sbiw	r24, 0x00	; 0
     d28:	81 f0       	breq	.+32     	; 0xd4a <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
     d2a:	81 e0       	ldi	r24, 0x01	; 1
     d2c:	89 83       	std	Y+1, r24	; 0x01
     d2e:	0d c0       	rjmp	.+26     	; 0xd4a <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     d30:	2a 81       	ldd	r18, Y+2	; 0x02
     d32:	3b 81       	ldd	r19, Y+3	; 0x03
     d34:	8c 81       	ldd	r24, Y+4	; 0x04
     d36:	9d 81       	ldd	r25, Y+5	; 0x05
     d38:	28 23       	and	r18, r24
     d3a:	39 23       	and	r19, r25
     d3c:	8c 81       	ldd	r24, Y+4	; 0x04
     d3e:	9d 81       	ldd	r25, Y+5	; 0x05
     d40:	28 17       	cp	r18, r24
     d42:	39 07       	cpc	r19, r25
     d44:	11 f4       	brne	.+4      	; 0xd4a <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
     d46:	81 e0       	ldi	r24, 0x01	; 1
     d48:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
     d4a:	89 81       	ldd	r24, Y+1	; 0x01
}
     d4c:	26 96       	adiw	r28, 0x06	; 6
     d4e:	0f b6       	in	r0, 0x3f	; 63
     d50:	f8 94       	cli
     d52:	de bf       	out	0x3e, r29	; 62
     d54:	0f be       	out	0x3f, r0	; 63
     d56:	cd bf       	out	0x3d, r28	; 61
     d58:	cf 91       	pop	r28
     d5a:	df 91       	pop	r29
     d5c:	08 95       	ret

00000d5e <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     d5e:	df 93       	push	r29
     d60:	cf 93       	push	r28
     d62:	00 d0       	rcall	.+0      	; 0xd64 <pvPortMalloc+0x6>
     d64:	00 d0       	rcall	.+0      	; 0xd66 <pvPortMalloc+0x8>
     d66:	cd b7       	in	r28, 0x3d	; 61
     d68:	de b7       	in	r29, 0x3e	; 62
     d6a:	9c 83       	std	Y+4, r25	; 0x04
     d6c:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
     d6e:	1a 82       	std	Y+2, r1	; 0x02
     d70:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     d72:	0e 94 ee 15 	call	0x2bdc	; 0x2bdc <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     d76:	80 91 6e 00 	lds	r24, 0x006E
     d7a:	90 91 6f 00 	lds	r25, 0x006F
     d7e:	00 97       	sbiw	r24, 0x00	; 0
     d80:	31 f4       	brne	.+12     	; 0xd8e <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     d82:	81 e7       	ldi	r24, 0x71	; 113
     d84:	90 e0       	ldi	r25, 0x00	; 0
     d86:	90 93 6f 00 	sts	0x006F, r25
     d8a:	80 93 6e 00 	sts	0x006E, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     d8e:	80 91 6c 00 	lds	r24, 0x006C
     d92:	90 91 6d 00 	lds	r25, 0x006D
     d96:	2b 81       	ldd	r18, Y+3	; 0x03
     d98:	3c 81       	ldd	r19, Y+4	; 0x04
     d9a:	82 0f       	add	r24, r18
     d9c:	93 1f       	adc	r25, r19
     d9e:	22 e0       	ldi	r18, 0x02	; 2
     da0:	87 35       	cpi	r24, 0x57	; 87
     da2:	92 07       	cpc	r25, r18
     da4:	38 f5       	brcc	.+78     	; 0xdf4 <pvPortMalloc+0x96>
     da6:	20 91 6c 00 	lds	r18, 0x006C
     daa:	30 91 6d 00 	lds	r19, 0x006D
     dae:	8b 81       	ldd	r24, Y+3	; 0x03
     db0:	9c 81       	ldd	r25, Y+4	; 0x04
     db2:	28 0f       	add	r18, r24
     db4:	39 1f       	adc	r19, r25
     db6:	80 91 6c 00 	lds	r24, 0x006C
     dba:	90 91 6d 00 	lds	r25, 0x006D
     dbe:	82 17       	cp	r24, r18
     dc0:	93 07       	cpc	r25, r19
     dc2:	c0 f4       	brcc	.+48     	; 0xdf4 <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     dc4:	20 91 6e 00 	lds	r18, 0x006E
     dc8:	30 91 6f 00 	lds	r19, 0x006F
     dcc:	80 91 6c 00 	lds	r24, 0x006C
     dd0:	90 91 6d 00 	lds	r25, 0x006D
     dd4:	82 0f       	add	r24, r18
     dd6:	93 1f       	adc	r25, r19
     dd8:	9a 83       	std	Y+2, r25	; 0x02
     dda:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
     ddc:	20 91 6c 00 	lds	r18, 0x006C
     de0:	30 91 6d 00 	lds	r19, 0x006D
     de4:	8b 81       	ldd	r24, Y+3	; 0x03
     de6:	9c 81       	ldd	r25, Y+4	; 0x04
     de8:	82 0f       	add	r24, r18
     dea:	93 1f       	adc	r25, r19
     dec:	90 93 6d 00 	sts	0x006D, r25
     df0:	80 93 6c 00 	sts	0x006C, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     df4:	0e 94 fa 15 	call	0x2bf4	; 0x2bf4 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
     df8:	89 81       	ldd	r24, Y+1	; 0x01
     dfa:	9a 81       	ldd	r25, Y+2	; 0x02
}
     dfc:	0f 90       	pop	r0
     dfe:	0f 90       	pop	r0
     e00:	0f 90       	pop	r0
     e02:	0f 90       	pop	r0
     e04:	cf 91       	pop	r28
     e06:	df 91       	pop	r29
     e08:	08 95       	ret

00000e0a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     e0a:	df 93       	push	r29
     e0c:	cf 93       	push	r28
     e0e:	00 d0       	rcall	.+0      	; 0xe10 <vPortFree+0x6>
     e10:	cd b7       	in	r28, 0x3d	; 61
     e12:	de b7       	in	r29, 0x3e	; 62
     e14:	9a 83       	std	Y+2, r25	; 0x02
     e16:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
     e18:	0f 90       	pop	r0
     e1a:	0f 90       	pop	r0
     e1c:	cf 91       	pop	r28
     e1e:	df 91       	pop	r29
     e20:	08 95       	ret

00000e22 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     e22:	df 93       	push	r29
     e24:	cf 93       	push	r28
     e26:	cd b7       	in	r28, 0x3d	; 61
     e28:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     e2a:	10 92 6d 00 	sts	0x006D, r1
     e2e:	10 92 6c 00 	sts	0x006C, r1
}
     e32:	cf 91       	pop	r28
     e34:	df 91       	pop	r29
     e36:	08 95       	ret

00000e38 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     e38:	df 93       	push	r29
     e3a:	cf 93       	push	r28
     e3c:	cd b7       	in	r28, 0x3d	; 61
     e3e:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     e40:	20 91 6c 00 	lds	r18, 0x006C
     e44:	30 91 6d 00 	lds	r19, 0x006D
     e48:	87 e5       	ldi	r24, 0x57	; 87
     e4a:	92 e0       	ldi	r25, 0x02	; 2
     e4c:	82 1b       	sub	r24, r18
     e4e:	93 0b       	sbc	r25, r19
}
     e50:	cf 91       	pop	r28
     e52:	df 91       	pop	r29
     e54:	08 95       	ret

00000e56 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     e56:	df 93       	push	r29
     e58:	cf 93       	push	r28
     e5a:	00 d0       	rcall	.+0      	; 0xe5c <vListInitialise+0x6>
     e5c:	cd b7       	in	r28, 0x3d	; 61
     e5e:	de b7       	in	r29, 0x3e	; 62
     e60:	9a 83       	std	Y+2, r25	; 0x02
     e62:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     e64:	89 81       	ldd	r24, Y+1	; 0x01
     e66:	9a 81       	ldd	r25, Y+2	; 0x02
     e68:	03 96       	adiw	r24, 0x03	; 3
     e6a:	e9 81       	ldd	r30, Y+1	; 0x01
     e6c:	fa 81       	ldd	r31, Y+2	; 0x02
     e6e:	92 83       	std	Z+2, r25	; 0x02
     e70:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     e72:	e9 81       	ldd	r30, Y+1	; 0x01
     e74:	fa 81       	ldd	r31, Y+2	; 0x02
     e76:	8f ef       	ldi	r24, 0xFF	; 255
     e78:	9f ef       	ldi	r25, 0xFF	; 255
     e7a:	94 83       	std	Z+4, r25	; 0x04
     e7c:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     e7e:	89 81       	ldd	r24, Y+1	; 0x01
     e80:	9a 81       	ldd	r25, Y+2	; 0x02
     e82:	03 96       	adiw	r24, 0x03	; 3
     e84:	e9 81       	ldd	r30, Y+1	; 0x01
     e86:	fa 81       	ldd	r31, Y+2	; 0x02
     e88:	96 83       	std	Z+6, r25	; 0x06
     e8a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     e8c:	89 81       	ldd	r24, Y+1	; 0x01
     e8e:	9a 81       	ldd	r25, Y+2	; 0x02
     e90:	03 96       	adiw	r24, 0x03	; 3
     e92:	e9 81       	ldd	r30, Y+1	; 0x01
     e94:	fa 81       	ldd	r31, Y+2	; 0x02
     e96:	90 87       	std	Z+8, r25	; 0x08
     e98:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     e9a:	e9 81       	ldd	r30, Y+1	; 0x01
     e9c:	fa 81       	ldd	r31, Y+2	; 0x02
     e9e:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     ea0:	0f 90       	pop	r0
     ea2:	0f 90       	pop	r0
     ea4:	cf 91       	pop	r28
     ea6:	df 91       	pop	r29
     ea8:	08 95       	ret

00000eaa <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
     eaa:	df 93       	push	r29
     eac:	cf 93       	push	r28
     eae:	00 d0       	rcall	.+0      	; 0xeb0 <vListInitialiseItem+0x6>
     eb0:	cd b7       	in	r28, 0x3d	; 61
     eb2:	de b7       	in	r29, 0x3e	; 62
     eb4:	9a 83       	std	Y+2, r25	; 0x02
     eb6:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
     eb8:	e9 81       	ldd	r30, Y+1	; 0x01
     eba:	fa 81       	ldd	r31, Y+2	; 0x02
     ebc:	11 86       	std	Z+9, r1	; 0x09
     ebe:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     ec0:	0f 90       	pop	r0
     ec2:	0f 90       	pop	r0
     ec4:	cf 91       	pop	r28
     ec6:	df 91       	pop	r29
     ec8:	08 95       	ret

00000eca <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     eca:	df 93       	push	r29
     ecc:	cf 93       	push	r28
     ece:	00 d0       	rcall	.+0      	; 0xed0 <vListInsertEnd+0x6>
     ed0:	00 d0       	rcall	.+0      	; 0xed2 <vListInsertEnd+0x8>
     ed2:	00 d0       	rcall	.+0      	; 0xed4 <vListInsertEnd+0xa>
     ed4:	cd b7       	in	r28, 0x3d	; 61
     ed6:	de b7       	in	r29, 0x3e	; 62
     ed8:	9c 83       	std	Y+4, r25	; 0x04
     eda:	8b 83       	std	Y+3, r24	; 0x03
     edc:	7e 83       	std	Y+6, r23	; 0x06
     ede:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
     ee0:	eb 81       	ldd	r30, Y+3	; 0x03
     ee2:	fc 81       	ldd	r31, Y+4	; 0x04
     ee4:	81 81       	ldd	r24, Z+1	; 0x01
     ee6:	92 81       	ldd	r25, Z+2	; 0x02
     ee8:	9a 83       	std	Y+2, r25	; 0x02
     eea:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     eec:	ed 81       	ldd	r30, Y+5	; 0x05
     eee:	fe 81       	ldd	r31, Y+6	; 0x06
     ef0:	89 81       	ldd	r24, Y+1	; 0x01
     ef2:	9a 81       	ldd	r25, Y+2	; 0x02
     ef4:	93 83       	std	Z+3, r25	; 0x03
     ef6:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     ef8:	e9 81       	ldd	r30, Y+1	; 0x01
     efa:	fa 81       	ldd	r31, Y+2	; 0x02
     efc:	84 81       	ldd	r24, Z+4	; 0x04
     efe:	95 81       	ldd	r25, Z+5	; 0x05
     f00:	ed 81       	ldd	r30, Y+5	; 0x05
     f02:	fe 81       	ldd	r31, Y+6	; 0x06
     f04:	95 83       	std	Z+5, r25	; 0x05
     f06:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     f08:	e9 81       	ldd	r30, Y+1	; 0x01
     f0a:	fa 81       	ldd	r31, Y+2	; 0x02
     f0c:	04 80       	ldd	r0, Z+4	; 0x04
     f0e:	f5 81       	ldd	r31, Z+5	; 0x05
     f10:	e0 2d       	mov	r30, r0
     f12:	8d 81       	ldd	r24, Y+5	; 0x05
     f14:	9e 81       	ldd	r25, Y+6	; 0x06
     f16:	93 83       	std	Z+3, r25	; 0x03
     f18:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
     f1a:	e9 81       	ldd	r30, Y+1	; 0x01
     f1c:	fa 81       	ldd	r31, Y+2	; 0x02
     f1e:	8d 81       	ldd	r24, Y+5	; 0x05
     f20:	9e 81       	ldd	r25, Y+6	; 0x06
     f22:	95 83       	std	Z+5, r25	; 0x05
     f24:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
     f26:	ed 81       	ldd	r30, Y+5	; 0x05
     f28:	fe 81       	ldd	r31, Y+6	; 0x06
     f2a:	8b 81       	ldd	r24, Y+3	; 0x03
     f2c:	9c 81       	ldd	r25, Y+4	; 0x04
     f2e:	91 87       	std	Z+9, r25	; 0x09
     f30:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     f32:	eb 81       	ldd	r30, Y+3	; 0x03
     f34:	fc 81       	ldd	r31, Y+4	; 0x04
     f36:	80 81       	ld	r24, Z
     f38:	8f 5f       	subi	r24, 0xFF	; 255
     f3a:	eb 81       	ldd	r30, Y+3	; 0x03
     f3c:	fc 81       	ldd	r31, Y+4	; 0x04
     f3e:	80 83       	st	Z, r24
}
     f40:	26 96       	adiw	r28, 0x06	; 6
     f42:	0f b6       	in	r0, 0x3f	; 63
     f44:	f8 94       	cli
     f46:	de bf       	out	0x3e, r29	; 62
     f48:	0f be       	out	0x3f, r0	; 63
     f4a:	cd bf       	out	0x3d, r28	; 61
     f4c:	cf 91       	pop	r28
     f4e:	df 91       	pop	r29
     f50:	08 95       	ret

00000f52 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     f52:	df 93       	push	r29
     f54:	cf 93       	push	r28
     f56:	cd b7       	in	r28, 0x3d	; 61
     f58:	de b7       	in	r29, 0x3e	; 62
     f5a:	28 97       	sbiw	r28, 0x08	; 8
     f5c:	0f b6       	in	r0, 0x3f	; 63
     f5e:	f8 94       	cli
     f60:	de bf       	out	0x3e, r29	; 62
     f62:	0f be       	out	0x3f, r0	; 63
     f64:	cd bf       	out	0x3d, r28	; 61
     f66:	9e 83       	std	Y+6, r25	; 0x06
     f68:	8d 83       	std	Y+5, r24	; 0x05
     f6a:	78 87       	std	Y+8, r23	; 0x08
     f6c:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     f6e:	ef 81       	ldd	r30, Y+7	; 0x07
     f70:	f8 85       	ldd	r31, Y+8	; 0x08
     f72:	80 81       	ld	r24, Z
     f74:	91 81       	ldd	r25, Z+1	; 0x01
     f76:	9a 83       	std	Y+2, r25	; 0x02
     f78:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     f7a:	89 81       	ldd	r24, Y+1	; 0x01
     f7c:	9a 81       	ldd	r25, Y+2	; 0x02
     f7e:	2f ef       	ldi	r18, 0xFF	; 255
     f80:	8f 3f       	cpi	r24, 0xFF	; 255
     f82:	92 07       	cpc	r25, r18
     f84:	39 f4       	brne	.+14     	; 0xf94 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     f86:	ed 81       	ldd	r30, Y+5	; 0x05
     f88:	fe 81       	ldd	r31, Y+6	; 0x06
     f8a:	87 81       	ldd	r24, Z+7	; 0x07
     f8c:	90 85       	ldd	r25, Z+8	; 0x08
     f8e:	9c 83       	std	Y+4, r25	; 0x04
     f90:	8b 83       	std	Y+3, r24	; 0x03
     f92:	18 c0       	rjmp	.+48     	; 0xfc4 <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     f94:	8d 81       	ldd	r24, Y+5	; 0x05
     f96:	9e 81       	ldd	r25, Y+6	; 0x06
     f98:	03 96       	adiw	r24, 0x03	; 3
     f9a:	9c 83       	std	Y+4, r25	; 0x04
     f9c:	8b 83       	std	Y+3, r24	; 0x03
     f9e:	06 c0       	rjmp	.+12     	; 0xfac <vListInsert+0x5a>
     fa0:	eb 81       	ldd	r30, Y+3	; 0x03
     fa2:	fc 81       	ldd	r31, Y+4	; 0x04
     fa4:	82 81       	ldd	r24, Z+2	; 0x02
     fa6:	93 81       	ldd	r25, Z+3	; 0x03
     fa8:	9c 83       	std	Y+4, r25	; 0x04
     faa:	8b 83       	std	Y+3, r24	; 0x03
     fac:	eb 81       	ldd	r30, Y+3	; 0x03
     fae:	fc 81       	ldd	r31, Y+4	; 0x04
     fb0:	02 80       	ldd	r0, Z+2	; 0x02
     fb2:	f3 81       	ldd	r31, Z+3	; 0x03
     fb4:	e0 2d       	mov	r30, r0
     fb6:	20 81       	ld	r18, Z
     fb8:	31 81       	ldd	r19, Z+1	; 0x01
     fba:	89 81       	ldd	r24, Y+1	; 0x01
     fbc:	9a 81       	ldd	r25, Y+2	; 0x02
     fbe:	82 17       	cp	r24, r18
     fc0:	93 07       	cpc	r25, r19
     fc2:	70 f7       	brcc	.-36     	; 0xfa0 <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     fc4:	eb 81       	ldd	r30, Y+3	; 0x03
     fc6:	fc 81       	ldd	r31, Y+4	; 0x04
     fc8:	82 81       	ldd	r24, Z+2	; 0x02
     fca:	93 81       	ldd	r25, Z+3	; 0x03
     fcc:	ef 81       	ldd	r30, Y+7	; 0x07
     fce:	f8 85       	ldd	r31, Y+8	; 0x08
     fd0:	93 83       	std	Z+3, r25	; 0x03
     fd2:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     fd4:	ef 81       	ldd	r30, Y+7	; 0x07
     fd6:	f8 85       	ldd	r31, Y+8	; 0x08
     fd8:	02 80       	ldd	r0, Z+2	; 0x02
     fda:	f3 81       	ldd	r31, Z+3	; 0x03
     fdc:	e0 2d       	mov	r30, r0
     fde:	8f 81       	ldd	r24, Y+7	; 0x07
     fe0:	98 85       	ldd	r25, Y+8	; 0x08
     fe2:	95 83       	std	Z+5, r25	; 0x05
     fe4:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     fe6:	ef 81       	ldd	r30, Y+7	; 0x07
     fe8:	f8 85       	ldd	r31, Y+8	; 0x08
     fea:	8b 81       	ldd	r24, Y+3	; 0x03
     fec:	9c 81       	ldd	r25, Y+4	; 0x04
     fee:	95 83       	std	Z+5, r25	; 0x05
     ff0:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
     ff2:	eb 81       	ldd	r30, Y+3	; 0x03
     ff4:	fc 81       	ldd	r31, Y+4	; 0x04
     ff6:	8f 81       	ldd	r24, Y+7	; 0x07
     ff8:	98 85       	ldd	r25, Y+8	; 0x08
     ffa:	93 83       	std	Z+3, r25	; 0x03
     ffc:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
     ffe:	ef 81       	ldd	r30, Y+7	; 0x07
    1000:	f8 85       	ldd	r31, Y+8	; 0x08
    1002:	8d 81       	ldd	r24, Y+5	; 0x05
    1004:	9e 81       	ldd	r25, Y+6	; 0x06
    1006:	91 87       	std	Z+9, r25	; 0x09
    1008:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    100a:	ed 81       	ldd	r30, Y+5	; 0x05
    100c:	fe 81       	ldd	r31, Y+6	; 0x06
    100e:	80 81       	ld	r24, Z
    1010:	8f 5f       	subi	r24, 0xFF	; 255
    1012:	ed 81       	ldd	r30, Y+5	; 0x05
    1014:	fe 81       	ldd	r31, Y+6	; 0x06
    1016:	80 83       	st	Z, r24
}
    1018:	28 96       	adiw	r28, 0x08	; 8
    101a:	0f b6       	in	r0, 0x3f	; 63
    101c:	f8 94       	cli
    101e:	de bf       	out	0x3e, r29	; 62
    1020:	0f be       	out	0x3f, r0	; 63
    1022:	cd bf       	out	0x3d, r28	; 61
    1024:	cf 91       	pop	r28
    1026:	df 91       	pop	r29
    1028:	08 95       	ret

0000102a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    102a:	df 93       	push	r29
    102c:	cf 93       	push	r28
    102e:	00 d0       	rcall	.+0      	; 0x1030 <uxListRemove+0x6>
    1030:	00 d0       	rcall	.+0      	; 0x1032 <uxListRemove+0x8>
    1032:	cd b7       	in	r28, 0x3d	; 61
    1034:	de b7       	in	r29, 0x3e	; 62
    1036:	9c 83       	std	Y+4, r25	; 0x04
    1038:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    103a:	eb 81       	ldd	r30, Y+3	; 0x03
    103c:	fc 81       	ldd	r31, Y+4	; 0x04
    103e:	80 85       	ldd	r24, Z+8	; 0x08
    1040:	91 85       	ldd	r25, Z+9	; 0x09
    1042:	9a 83       	std	Y+2, r25	; 0x02
    1044:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1046:	eb 81       	ldd	r30, Y+3	; 0x03
    1048:	fc 81       	ldd	r31, Y+4	; 0x04
    104a:	a2 81       	ldd	r26, Z+2	; 0x02
    104c:	b3 81       	ldd	r27, Z+3	; 0x03
    104e:	eb 81       	ldd	r30, Y+3	; 0x03
    1050:	fc 81       	ldd	r31, Y+4	; 0x04
    1052:	84 81       	ldd	r24, Z+4	; 0x04
    1054:	95 81       	ldd	r25, Z+5	; 0x05
    1056:	15 96       	adiw	r26, 0x05	; 5
    1058:	9c 93       	st	X, r25
    105a:	8e 93       	st	-X, r24
    105c:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    105e:	eb 81       	ldd	r30, Y+3	; 0x03
    1060:	fc 81       	ldd	r31, Y+4	; 0x04
    1062:	a4 81       	ldd	r26, Z+4	; 0x04
    1064:	b5 81       	ldd	r27, Z+5	; 0x05
    1066:	eb 81       	ldd	r30, Y+3	; 0x03
    1068:	fc 81       	ldd	r31, Y+4	; 0x04
    106a:	82 81       	ldd	r24, Z+2	; 0x02
    106c:	93 81       	ldd	r25, Z+3	; 0x03
    106e:	13 96       	adiw	r26, 0x03	; 3
    1070:	9c 93       	st	X, r25
    1072:	8e 93       	st	-X, r24
    1074:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1076:	e9 81       	ldd	r30, Y+1	; 0x01
    1078:	fa 81       	ldd	r31, Y+2	; 0x02
    107a:	21 81       	ldd	r18, Z+1	; 0x01
    107c:	32 81       	ldd	r19, Z+2	; 0x02
    107e:	8b 81       	ldd	r24, Y+3	; 0x03
    1080:	9c 81       	ldd	r25, Y+4	; 0x04
    1082:	28 17       	cp	r18, r24
    1084:	39 07       	cpc	r19, r25
    1086:	41 f4       	brne	.+16     	; 0x1098 <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1088:	eb 81       	ldd	r30, Y+3	; 0x03
    108a:	fc 81       	ldd	r31, Y+4	; 0x04
    108c:	84 81       	ldd	r24, Z+4	; 0x04
    108e:	95 81       	ldd	r25, Z+5	; 0x05
    1090:	e9 81       	ldd	r30, Y+1	; 0x01
    1092:	fa 81       	ldd	r31, Y+2	; 0x02
    1094:	92 83       	std	Z+2, r25	; 0x02
    1096:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    1098:	eb 81       	ldd	r30, Y+3	; 0x03
    109a:	fc 81       	ldd	r31, Y+4	; 0x04
    109c:	11 86       	std	Z+9, r1	; 0x09
    109e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    10a0:	e9 81       	ldd	r30, Y+1	; 0x01
    10a2:	fa 81       	ldd	r31, Y+2	; 0x02
    10a4:	80 81       	ld	r24, Z
    10a6:	81 50       	subi	r24, 0x01	; 1
    10a8:	e9 81       	ldd	r30, Y+1	; 0x01
    10aa:	fa 81       	ldd	r31, Y+2	; 0x02
    10ac:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    10ae:	e9 81       	ldd	r30, Y+1	; 0x01
    10b0:	fa 81       	ldd	r31, Y+2	; 0x02
    10b2:	80 81       	ld	r24, Z
}
    10b4:	0f 90       	pop	r0
    10b6:	0f 90       	pop	r0
    10b8:	0f 90       	pop	r0
    10ba:	0f 90       	pop	r0
    10bc:	cf 91       	pop	r28
    10be:	df 91       	pop	r29
    10c0:	08 95       	ret

000010c2 <__vector_1>:
SemaphoreHandle_t xSemaphore;


void __vector_1(void) __attribute__((signal));
void __vector_1(void)
{
    10c2:	1f 92       	push	r1
    10c4:	0f 92       	push	r0
    10c6:	0f b6       	in	r0, 0x3f	; 63
    10c8:	0f 92       	push	r0
    10ca:	11 24       	eor	r1, r1
    10cc:	2f 93       	push	r18
    10ce:	3f 93       	push	r19
    10d0:	4f 93       	push	r20
    10d2:	5f 93       	push	r21
    10d4:	6f 93       	push	r22
    10d6:	7f 93       	push	r23
    10d8:	8f 93       	push	r24
    10da:	9f 93       	push	r25
    10dc:	af 93       	push	r26
    10de:	bf 93       	push	r27
    10e0:	ef 93       	push	r30
    10e2:	ff 93       	push	r31
    10e4:	df 93       	push	r29
    10e6:	cf 93       	push	r28
    10e8:	cd b7       	in	r28, 0x3d	; 61
    10ea:	de b7       	in	r29, 0x3e	; 62
	xSemaphoreGiveFromISR(xSemaphore,NULL);
    10ec:	80 91 25 03 	lds	r24, 0x0325
    10f0:	90 91 26 03 	lds	r25, 0x0326
    10f4:	60 e0       	ldi	r22, 0x00	; 0
    10f6:	70 e0       	ldi	r23, 0x00	; 0
    10f8:	0e 94 f2 0d 	call	0x1be4	; 0x1be4 <xQueueGiveFromISR>
}
    10fc:	cf 91       	pop	r28
    10fe:	df 91       	pop	r29
    1100:	ff 91       	pop	r31
    1102:	ef 91       	pop	r30
    1104:	bf 91       	pop	r27
    1106:	af 91       	pop	r26
    1108:	9f 91       	pop	r25
    110a:	8f 91       	pop	r24
    110c:	7f 91       	pop	r23
    110e:	6f 91       	pop	r22
    1110:	5f 91       	pop	r21
    1112:	4f 91       	pop	r20
    1114:	3f 91       	pop	r19
    1116:	2f 91       	pop	r18
    1118:	0f 90       	pop	r0
    111a:	0f be       	out	0x3f, r0	; 63
    111c:	0f 90       	pop	r0
    111e:	1f 90       	pop	r1
    1120:	18 95       	reti

00001122 <LED_2>:
// @ xSemaphoreTake()
// Setting xTicksToWait to portMAX_DELAY will cause the task to wait indefinitely
// (without timing out) provided INCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h.

void LED_2(void * pvParameters)
{
    1122:	df 93       	push	r29
    1124:	cf 93       	push	r28
    1126:	00 d0       	rcall	.+0      	; 0x1128 <LED_2+0x6>
    1128:	cd b7       	in	r28, 0x3d	; 61
    112a:	de b7       	in	r29, 0x3e	; 62
    112c:	9a 83       	std	Y+2, r25	; 0x02
    112e:	89 83       	std	Y+1, r24	; 0x01

	while(1)
	{
		if(xSemaphoreTake(xSemaphore,10))
    1130:	80 91 25 03 	lds	r24, 0x0325
    1134:	90 91 26 03 	lds	r25, 0x0326
    1138:	6a e0       	ldi	r22, 0x0A	; 10
    113a:	70 e0       	ldi	r23, 0x00	; 0
    113c:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <xQueueSemaphoreTake>
    1140:	88 23       	and	r24, r24
    1142:	31 f0       	breq	.+12     	; 0x1150 <LED_2+0x2e>
		{
	DIO_SET_PIN_VALUE(GROUP_C,PIN1,DIO_LOW);
    1144:	82 e0       	ldi	r24, 0x02	; 2
    1146:	61 e0       	ldi	r22, 0x01	; 1
    1148:	40 e0       	ldi	r20, 0x00	; 0
    114a:	0e 94 49 00 	call	0x92	; 0x92 <DIO_SET_PIN_VALUE>
    114e:	f0 cf       	rjmp	.-32     	; 0x1130 <LED_2+0xe>
		//	LCD_u8Write("Button is pressed ",0,0);
		}else
		{	DIO_SET_PIN_VALUE(GROUP_C,PIN1,DIO_HIGH);
    1150:	82 e0       	ldi	r24, 0x02	; 2
    1152:	61 e0       	ldi	r22, 0x01	; 1
    1154:	41 e0       	ldi	r20, 0x01	; 1
    1156:	0e 94 49 00 	call	0x92	; 0x92 <DIO_SET_PIN_VALUE>
    115a:	ea cf       	rjmp	.-44     	; 0x1130 <LED_2+0xe>

0000115c <main>:
		}
	}
}

void main(void)
{
    115c:	ef 92       	push	r14
    115e:	ff 92       	push	r15
    1160:	0f 93       	push	r16
    1162:	df 93       	push	r29
    1164:	cf 93       	push	r28
    1166:	cd b7       	in	r28, 0x3d	; 61
    1168:	de b7       	in	r29, 0x3e	; 62
	// LED Pins
	DIO_SET_PIN_DIRECTION(GROUP_C,PIN1,DIO_HIGH);
    116a:	82 e0       	ldi	r24, 0x02	; 2
    116c:	61 e0       	ldi	r22, 0x01	; 1
    116e:	41 e0       	ldi	r20, 0x01	; 1
    1170:	0e 94 44 01 	call	0x288	; 0x288 <DIO_SET_PIN_DIRECTION>
	DIO_SET_PIN_DIRECTION(GROUP_D,PIN2,DIO_INPUT);
    1174:	83 e0       	ldi	r24, 0x03	; 3
    1176:	62 e0       	ldi	r22, 0x02	; 2
    1178:	40 e0       	ldi	r20, 0x00	; 0
    117a:	0e 94 44 01 	call	0x288	; 0x288 <DIO_SET_PIN_DIRECTION>
	DIO_SET_PIN_VALUE(GROUP_D,PIN2,DIO_HIGH);
    117e:	83 e0       	ldi	r24, 0x03	; 3
    1180:	62 e0       	ldi	r22, 0x02	; 2
    1182:	41 e0       	ldi	r20, 0x01	; 1
    1184:	0e 94 49 00 	call	0x92	; 0x92 <DIO_SET_PIN_VALUE>
	// EXTI 0 Pin : Pin D2 -> I/P
	// Connect it to internal pull up resistor
	

	// EXTI 0 configurations
	MCUCR = 0b00000000;		// The falling edge of INT0 generates an interrupt request
    1188:	e5 e5       	ldi	r30, 0x55	; 85
    118a:	f0 e0       	ldi	r31, 0x00	; 0
    118c:	10 82       	st	Z, r1
	SREG  = 0b10000000;		// Global Interrupt Enable
    118e:	ef e5       	ldi	r30, 0x5F	; 95
    1190:	f0 e0       	ldi	r31, 0x00	; 0
    1192:	80 e8       	ldi	r24, 0x80	; 128
    1194:	80 83       	st	Z, r24
	GICR  = 0b01000000;		// External Interrupt Request 0 Enable
    1196:	eb e5       	ldi	r30, 0x5B	; 91
    1198:	f0 e0       	ldi	r31, 0x00	; 0
    119a:	80 e4       	ldi	r24, 0x40	; 64
    119c:	80 83       	st	Z, r24


//	LCD_void_Initialize();
//semaphore  take decrement , give increment

	xSemaphore = xSemaphoreCreateCounting(1,0);//1 max task  , 0 intiol task (if give make increment , take decrement
    119e:	81 e0       	ldi	r24, 0x01	; 1
    11a0:	60 e0       	ldi	r22, 0x00	; 0
    11a2:	0e 94 ce 0c 	call	0x199c	; 0x199c <xQueueCreateCountingSemaphore>
    11a6:	90 93 26 03 	sts	0x0326, r25
    11aa:	80 93 25 03 	sts	0x0325, r24

	xTaskCreate(LED_2,"Task_2",150,NULL,1,NULL);
    11ae:	81 e9       	ldi	r24, 0x91	; 145
    11b0:	98 e0       	ldi	r25, 0x08	; 8
    11b2:	20 e6       	ldi	r18, 0x60	; 96
    11b4:	30 e0       	ldi	r19, 0x00	; 0
    11b6:	b9 01       	movw	r22, r18
    11b8:	46 e9       	ldi	r20, 0x96	; 150
    11ba:	50 e0       	ldi	r21, 0x00	; 0
    11bc:	20 e0       	ldi	r18, 0x00	; 0
    11be:	30 e0       	ldi	r19, 0x00	; 0
    11c0:	01 e0       	ldi	r16, 0x01	; 1
    11c2:	ee 24       	eor	r14, r14
    11c4:	ff 24       	eor	r15, r15
    11c6:	0e 94 fe 12 	call	0x25fc	; 0x25fc <xTaskCreate>


	vTaskStartScheduler();
    11ca:	0e 94 b0 15 	call	0x2b60	; 0x2b60 <vTaskStartScheduler>
    11ce:	ff cf       	rjmp	.-2      	; 0x11ce <main+0x72>

000011d0 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    11d0:	df 93       	push	r29
    11d2:	cf 93       	push	r28
    11d4:	cd b7       	in	r28, 0x3d	; 61
    11d6:	de b7       	in	r29, 0x3e	; 62
    11d8:	28 97       	sbiw	r28, 0x08	; 8
    11da:	0f b6       	in	r0, 0x3f	; 63
    11dc:	f8 94       	cli
    11de:	de bf       	out	0x3e, r29	; 62
    11e0:	0f be       	out	0x3f, r0	; 63
    11e2:	cd bf       	out	0x3d, r28	; 61
    11e4:	9c 83       	std	Y+4, r25	; 0x04
    11e6:	8b 83       	std	Y+3, r24	; 0x03
    11e8:	7e 83       	std	Y+6, r23	; 0x06
    11ea:	6d 83       	std	Y+5, r22	; 0x05
    11ec:	58 87       	std	Y+8, r21	; 0x08
    11ee:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    11f0:	eb 81       	ldd	r30, Y+3	; 0x03
    11f2:	fc 81       	ldd	r31, Y+4	; 0x04
    11f4:	81 e1       	ldi	r24, 0x11	; 17
    11f6:	80 83       	st	Z, r24
	pxTopOfStack--;
    11f8:	8b 81       	ldd	r24, Y+3	; 0x03
    11fa:	9c 81       	ldd	r25, Y+4	; 0x04
    11fc:	01 97       	sbiw	r24, 0x01	; 1
    11fe:	9c 83       	std	Y+4, r25	; 0x04
    1200:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    1202:	eb 81       	ldd	r30, Y+3	; 0x03
    1204:	fc 81       	ldd	r31, Y+4	; 0x04
    1206:	82 e2       	ldi	r24, 0x22	; 34
    1208:	80 83       	st	Z, r24
	pxTopOfStack--;
    120a:	8b 81       	ldd	r24, Y+3	; 0x03
    120c:	9c 81       	ldd	r25, Y+4	; 0x04
    120e:	01 97       	sbiw	r24, 0x01	; 1
    1210:	9c 83       	std	Y+4, r25	; 0x04
    1212:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    1214:	eb 81       	ldd	r30, Y+3	; 0x03
    1216:	fc 81       	ldd	r31, Y+4	; 0x04
    1218:	83 e3       	ldi	r24, 0x33	; 51
    121a:	80 83       	st	Z, r24
	pxTopOfStack--;
    121c:	8b 81       	ldd	r24, Y+3	; 0x03
    121e:	9c 81       	ldd	r25, Y+4	; 0x04
    1220:	01 97       	sbiw	r24, 0x01	; 1
    1222:	9c 83       	std	Y+4, r25	; 0x04
    1224:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    1226:	8d 81       	ldd	r24, Y+5	; 0x05
    1228:	9e 81       	ldd	r25, Y+6	; 0x06
    122a:	9a 83       	std	Y+2, r25	; 0x02
    122c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    122e:	89 81       	ldd	r24, Y+1	; 0x01
    1230:	eb 81       	ldd	r30, Y+3	; 0x03
    1232:	fc 81       	ldd	r31, Y+4	; 0x04
    1234:	80 83       	st	Z, r24
	pxTopOfStack--;
    1236:	8b 81       	ldd	r24, Y+3	; 0x03
    1238:	9c 81       	ldd	r25, Y+4	; 0x04
    123a:	01 97       	sbiw	r24, 0x01	; 1
    123c:	9c 83       	std	Y+4, r25	; 0x04
    123e:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1240:	89 81       	ldd	r24, Y+1	; 0x01
    1242:	9a 81       	ldd	r25, Y+2	; 0x02
    1244:	89 2f       	mov	r24, r25
    1246:	99 27       	eor	r25, r25
    1248:	9a 83       	std	Y+2, r25	; 0x02
    124a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    124c:	89 81       	ldd	r24, Y+1	; 0x01
    124e:	eb 81       	ldd	r30, Y+3	; 0x03
    1250:	fc 81       	ldd	r31, Y+4	; 0x04
    1252:	80 83       	st	Z, r24
	pxTopOfStack--;
    1254:	8b 81       	ldd	r24, Y+3	; 0x03
    1256:	9c 81       	ldd	r25, Y+4	; 0x04
    1258:	01 97       	sbiw	r24, 0x01	; 1
    125a:	9c 83       	std	Y+4, r25	; 0x04
    125c:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    125e:	eb 81       	ldd	r30, Y+3	; 0x03
    1260:	fc 81       	ldd	r31, Y+4	; 0x04
    1262:	10 82       	st	Z, r1
	pxTopOfStack--;
    1264:	8b 81       	ldd	r24, Y+3	; 0x03
    1266:	9c 81       	ldd	r25, Y+4	; 0x04
    1268:	01 97       	sbiw	r24, 0x01	; 1
    126a:	9c 83       	std	Y+4, r25	; 0x04
    126c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    126e:	eb 81       	ldd	r30, Y+3	; 0x03
    1270:	fc 81       	ldd	r31, Y+4	; 0x04
    1272:	80 e8       	ldi	r24, 0x80	; 128
    1274:	80 83       	st	Z, r24
	pxTopOfStack--;
    1276:	8b 81       	ldd	r24, Y+3	; 0x03
    1278:	9c 81       	ldd	r25, Y+4	; 0x04
    127a:	01 97       	sbiw	r24, 0x01	; 1
    127c:	9c 83       	std	Y+4, r25	; 0x04
    127e:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    1280:	eb 81       	ldd	r30, Y+3	; 0x03
    1282:	fc 81       	ldd	r31, Y+4	; 0x04
    1284:	10 82       	st	Z, r1
	pxTopOfStack--;
    1286:	8b 81       	ldd	r24, Y+3	; 0x03
    1288:	9c 81       	ldd	r25, Y+4	; 0x04
    128a:	01 97       	sbiw	r24, 0x01	; 1
    128c:	9c 83       	std	Y+4, r25	; 0x04
    128e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    1290:	eb 81       	ldd	r30, Y+3	; 0x03
    1292:	fc 81       	ldd	r31, Y+4	; 0x04
    1294:	82 e0       	ldi	r24, 0x02	; 2
    1296:	80 83       	st	Z, r24
	pxTopOfStack--;
    1298:	8b 81       	ldd	r24, Y+3	; 0x03
    129a:	9c 81       	ldd	r25, Y+4	; 0x04
    129c:	01 97       	sbiw	r24, 0x01	; 1
    129e:	9c 83       	std	Y+4, r25	; 0x04
    12a0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    12a2:	eb 81       	ldd	r30, Y+3	; 0x03
    12a4:	fc 81       	ldd	r31, Y+4	; 0x04
    12a6:	83 e0       	ldi	r24, 0x03	; 3
    12a8:	80 83       	st	Z, r24
	pxTopOfStack--;
    12aa:	8b 81       	ldd	r24, Y+3	; 0x03
    12ac:	9c 81       	ldd	r25, Y+4	; 0x04
    12ae:	01 97       	sbiw	r24, 0x01	; 1
    12b0:	9c 83       	std	Y+4, r25	; 0x04
    12b2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    12b4:	eb 81       	ldd	r30, Y+3	; 0x03
    12b6:	fc 81       	ldd	r31, Y+4	; 0x04
    12b8:	84 e0       	ldi	r24, 0x04	; 4
    12ba:	80 83       	st	Z, r24
	pxTopOfStack--;
    12bc:	8b 81       	ldd	r24, Y+3	; 0x03
    12be:	9c 81       	ldd	r25, Y+4	; 0x04
    12c0:	01 97       	sbiw	r24, 0x01	; 1
    12c2:	9c 83       	std	Y+4, r25	; 0x04
    12c4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    12c6:	eb 81       	ldd	r30, Y+3	; 0x03
    12c8:	fc 81       	ldd	r31, Y+4	; 0x04
    12ca:	85 e0       	ldi	r24, 0x05	; 5
    12cc:	80 83       	st	Z, r24
	pxTopOfStack--;
    12ce:	8b 81       	ldd	r24, Y+3	; 0x03
    12d0:	9c 81       	ldd	r25, Y+4	; 0x04
    12d2:	01 97       	sbiw	r24, 0x01	; 1
    12d4:	9c 83       	std	Y+4, r25	; 0x04
    12d6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    12d8:	eb 81       	ldd	r30, Y+3	; 0x03
    12da:	fc 81       	ldd	r31, Y+4	; 0x04
    12dc:	86 e0       	ldi	r24, 0x06	; 6
    12de:	80 83       	st	Z, r24
	pxTopOfStack--;
    12e0:	8b 81       	ldd	r24, Y+3	; 0x03
    12e2:	9c 81       	ldd	r25, Y+4	; 0x04
    12e4:	01 97       	sbiw	r24, 0x01	; 1
    12e6:	9c 83       	std	Y+4, r25	; 0x04
    12e8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    12ea:	eb 81       	ldd	r30, Y+3	; 0x03
    12ec:	fc 81       	ldd	r31, Y+4	; 0x04
    12ee:	87 e0       	ldi	r24, 0x07	; 7
    12f0:	80 83       	st	Z, r24
	pxTopOfStack--;
    12f2:	8b 81       	ldd	r24, Y+3	; 0x03
    12f4:	9c 81       	ldd	r25, Y+4	; 0x04
    12f6:	01 97       	sbiw	r24, 0x01	; 1
    12f8:	9c 83       	std	Y+4, r25	; 0x04
    12fa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    12fc:	eb 81       	ldd	r30, Y+3	; 0x03
    12fe:	fc 81       	ldd	r31, Y+4	; 0x04
    1300:	88 e0       	ldi	r24, 0x08	; 8
    1302:	80 83       	st	Z, r24
	pxTopOfStack--;
    1304:	8b 81       	ldd	r24, Y+3	; 0x03
    1306:	9c 81       	ldd	r25, Y+4	; 0x04
    1308:	01 97       	sbiw	r24, 0x01	; 1
    130a:	9c 83       	std	Y+4, r25	; 0x04
    130c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    130e:	eb 81       	ldd	r30, Y+3	; 0x03
    1310:	fc 81       	ldd	r31, Y+4	; 0x04
    1312:	89 e0       	ldi	r24, 0x09	; 9
    1314:	80 83       	st	Z, r24
	pxTopOfStack--;
    1316:	8b 81       	ldd	r24, Y+3	; 0x03
    1318:	9c 81       	ldd	r25, Y+4	; 0x04
    131a:	01 97       	sbiw	r24, 0x01	; 1
    131c:	9c 83       	std	Y+4, r25	; 0x04
    131e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    1320:	eb 81       	ldd	r30, Y+3	; 0x03
    1322:	fc 81       	ldd	r31, Y+4	; 0x04
    1324:	80 e1       	ldi	r24, 0x10	; 16
    1326:	80 83       	st	Z, r24
	pxTopOfStack--;
    1328:	8b 81       	ldd	r24, Y+3	; 0x03
    132a:	9c 81       	ldd	r25, Y+4	; 0x04
    132c:	01 97       	sbiw	r24, 0x01	; 1
    132e:	9c 83       	std	Y+4, r25	; 0x04
    1330:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    1332:	eb 81       	ldd	r30, Y+3	; 0x03
    1334:	fc 81       	ldd	r31, Y+4	; 0x04
    1336:	81 e1       	ldi	r24, 0x11	; 17
    1338:	80 83       	st	Z, r24
	pxTopOfStack--;
    133a:	8b 81       	ldd	r24, Y+3	; 0x03
    133c:	9c 81       	ldd	r25, Y+4	; 0x04
    133e:	01 97       	sbiw	r24, 0x01	; 1
    1340:	9c 83       	std	Y+4, r25	; 0x04
    1342:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    1344:	eb 81       	ldd	r30, Y+3	; 0x03
    1346:	fc 81       	ldd	r31, Y+4	; 0x04
    1348:	82 e1       	ldi	r24, 0x12	; 18
    134a:	80 83       	st	Z, r24
	pxTopOfStack--;
    134c:	8b 81       	ldd	r24, Y+3	; 0x03
    134e:	9c 81       	ldd	r25, Y+4	; 0x04
    1350:	01 97       	sbiw	r24, 0x01	; 1
    1352:	9c 83       	std	Y+4, r25	; 0x04
    1354:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    1356:	eb 81       	ldd	r30, Y+3	; 0x03
    1358:	fc 81       	ldd	r31, Y+4	; 0x04
    135a:	83 e1       	ldi	r24, 0x13	; 19
    135c:	80 83       	st	Z, r24
	pxTopOfStack--;
    135e:	8b 81       	ldd	r24, Y+3	; 0x03
    1360:	9c 81       	ldd	r25, Y+4	; 0x04
    1362:	01 97       	sbiw	r24, 0x01	; 1
    1364:	9c 83       	std	Y+4, r25	; 0x04
    1366:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    1368:	eb 81       	ldd	r30, Y+3	; 0x03
    136a:	fc 81       	ldd	r31, Y+4	; 0x04
    136c:	84 e1       	ldi	r24, 0x14	; 20
    136e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1370:	8b 81       	ldd	r24, Y+3	; 0x03
    1372:	9c 81       	ldd	r25, Y+4	; 0x04
    1374:	01 97       	sbiw	r24, 0x01	; 1
    1376:	9c 83       	std	Y+4, r25	; 0x04
    1378:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    137a:	eb 81       	ldd	r30, Y+3	; 0x03
    137c:	fc 81       	ldd	r31, Y+4	; 0x04
    137e:	85 e1       	ldi	r24, 0x15	; 21
    1380:	80 83       	st	Z, r24
	pxTopOfStack--;
    1382:	8b 81       	ldd	r24, Y+3	; 0x03
    1384:	9c 81       	ldd	r25, Y+4	; 0x04
    1386:	01 97       	sbiw	r24, 0x01	; 1
    1388:	9c 83       	std	Y+4, r25	; 0x04
    138a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    138c:	eb 81       	ldd	r30, Y+3	; 0x03
    138e:	fc 81       	ldd	r31, Y+4	; 0x04
    1390:	86 e1       	ldi	r24, 0x16	; 22
    1392:	80 83       	st	Z, r24
	pxTopOfStack--;
    1394:	8b 81       	ldd	r24, Y+3	; 0x03
    1396:	9c 81       	ldd	r25, Y+4	; 0x04
    1398:	01 97       	sbiw	r24, 0x01	; 1
    139a:	9c 83       	std	Y+4, r25	; 0x04
    139c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    139e:	eb 81       	ldd	r30, Y+3	; 0x03
    13a0:	fc 81       	ldd	r31, Y+4	; 0x04
    13a2:	87 e1       	ldi	r24, 0x17	; 23
    13a4:	80 83       	st	Z, r24
	pxTopOfStack--;
    13a6:	8b 81       	ldd	r24, Y+3	; 0x03
    13a8:	9c 81       	ldd	r25, Y+4	; 0x04
    13aa:	01 97       	sbiw	r24, 0x01	; 1
    13ac:	9c 83       	std	Y+4, r25	; 0x04
    13ae:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    13b0:	eb 81       	ldd	r30, Y+3	; 0x03
    13b2:	fc 81       	ldd	r31, Y+4	; 0x04
    13b4:	88 e1       	ldi	r24, 0x18	; 24
    13b6:	80 83       	st	Z, r24
	pxTopOfStack--;
    13b8:	8b 81       	ldd	r24, Y+3	; 0x03
    13ba:	9c 81       	ldd	r25, Y+4	; 0x04
    13bc:	01 97       	sbiw	r24, 0x01	; 1
    13be:	9c 83       	std	Y+4, r25	; 0x04
    13c0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    13c2:	eb 81       	ldd	r30, Y+3	; 0x03
    13c4:	fc 81       	ldd	r31, Y+4	; 0x04
    13c6:	89 e1       	ldi	r24, 0x19	; 25
    13c8:	80 83       	st	Z, r24
	pxTopOfStack--;
    13ca:	8b 81       	ldd	r24, Y+3	; 0x03
    13cc:	9c 81       	ldd	r25, Y+4	; 0x04
    13ce:	01 97       	sbiw	r24, 0x01	; 1
    13d0:	9c 83       	std	Y+4, r25	; 0x04
    13d2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    13d4:	eb 81       	ldd	r30, Y+3	; 0x03
    13d6:	fc 81       	ldd	r31, Y+4	; 0x04
    13d8:	80 e2       	ldi	r24, 0x20	; 32
    13da:	80 83       	st	Z, r24
	pxTopOfStack--;
    13dc:	8b 81       	ldd	r24, Y+3	; 0x03
    13de:	9c 81       	ldd	r25, Y+4	; 0x04
    13e0:	01 97       	sbiw	r24, 0x01	; 1
    13e2:	9c 83       	std	Y+4, r25	; 0x04
    13e4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    13e6:	eb 81       	ldd	r30, Y+3	; 0x03
    13e8:	fc 81       	ldd	r31, Y+4	; 0x04
    13ea:	81 e2       	ldi	r24, 0x21	; 33
    13ec:	80 83       	st	Z, r24
	pxTopOfStack--;
    13ee:	8b 81       	ldd	r24, Y+3	; 0x03
    13f0:	9c 81       	ldd	r25, Y+4	; 0x04
    13f2:	01 97       	sbiw	r24, 0x01	; 1
    13f4:	9c 83       	std	Y+4, r25	; 0x04
    13f6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    13f8:	eb 81       	ldd	r30, Y+3	; 0x03
    13fa:	fc 81       	ldd	r31, Y+4	; 0x04
    13fc:	82 e2       	ldi	r24, 0x22	; 34
    13fe:	80 83       	st	Z, r24
	pxTopOfStack--;
    1400:	8b 81       	ldd	r24, Y+3	; 0x03
    1402:	9c 81       	ldd	r25, Y+4	; 0x04
    1404:	01 97       	sbiw	r24, 0x01	; 1
    1406:	9c 83       	std	Y+4, r25	; 0x04
    1408:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    140a:	eb 81       	ldd	r30, Y+3	; 0x03
    140c:	fc 81       	ldd	r31, Y+4	; 0x04
    140e:	83 e2       	ldi	r24, 0x23	; 35
    1410:	80 83       	st	Z, r24
	pxTopOfStack--;
    1412:	8b 81       	ldd	r24, Y+3	; 0x03
    1414:	9c 81       	ldd	r25, Y+4	; 0x04
    1416:	01 97       	sbiw	r24, 0x01	; 1
    1418:	9c 83       	std	Y+4, r25	; 0x04
    141a:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    141c:	8f 81       	ldd	r24, Y+7	; 0x07
    141e:	98 85       	ldd	r25, Y+8	; 0x08
    1420:	9a 83       	std	Y+2, r25	; 0x02
    1422:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1424:	89 81       	ldd	r24, Y+1	; 0x01
    1426:	eb 81       	ldd	r30, Y+3	; 0x03
    1428:	fc 81       	ldd	r31, Y+4	; 0x04
    142a:	80 83       	st	Z, r24
	pxTopOfStack--;
    142c:	8b 81       	ldd	r24, Y+3	; 0x03
    142e:	9c 81       	ldd	r25, Y+4	; 0x04
    1430:	01 97       	sbiw	r24, 0x01	; 1
    1432:	9c 83       	std	Y+4, r25	; 0x04
    1434:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1436:	89 81       	ldd	r24, Y+1	; 0x01
    1438:	9a 81       	ldd	r25, Y+2	; 0x02
    143a:	89 2f       	mov	r24, r25
    143c:	99 27       	eor	r25, r25
    143e:	9a 83       	std	Y+2, r25	; 0x02
    1440:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1442:	89 81       	ldd	r24, Y+1	; 0x01
    1444:	eb 81       	ldd	r30, Y+3	; 0x03
    1446:	fc 81       	ldd	r31, Y+4	; 0x04
    1448:	80 83       	st	Z, r24
	pxTopOfStack--;
    144a:	8b 81       	ldd	r24, Y+3	; 0x03
    144c:	9c 81       	ldd	r25, Y+4	; 0x04
    144e:	01 97       	sbiw	r24, 0x01	; 1
    1450:	9c 83       	std	Y+4, r25	; 0x04
    1452:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    1454:	eb 81       	ldd	r30, Y+3	; 0x03
    1456:	fc 81       	ldd	r31, Y+4	; 0x04
    1458:	86 e2       	ldi	r24, 0x26	; 38
    145a:	80 83       	st	Z, r24
	pxTopOfStack--;
    145c:	8b 81       	ldd	r24, Y+3	; 0x03
    145e:	9c 81       	ldd	r25, Y+4	; 0x04
    1460:	01 97       	sbiw	r24, 0x01	; 1
    1462:	9c 83       	std	Y+4, r25	; 0x04
    1464:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    1466:	eb 81       	ldd	r30, Y+3	; 0x03
    1468:	fc 81       	ldd	r31, Y+4	; 0x04
    146a:	87 e2       	ldi	r24, 0x27	; 39
    146c:	80 83       	st	Z, r24
	pxTopOfStack--;
    146e:	8b 81       	ldd	r24, Y+3	; 0x03
    1470:	9c 81       	ldd	r25, Y+4	; 0x04
    1472:	01 97       	sbiw	r24, 0x01	; 1
    1474:	9c 83       	std	Y+4, r25	; 0x04
    1476:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    1478:	eb 81       	ldd	r30, Y+3	; 0x03
    147a:	fc 81       	ldd	r31, Y+4	; 0x04
    147c:	88 e2       	ldi	r24, 0x28	; 40
    147e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1480:	8b 81       	ldd	r24, Y+3	; 0x03
    1482:	9c 81       	ldd	r25, Y+4	; 0x04
    1484:	01 97       	sbiw	r24, 0x01	; 1
    1486:	9c 83       	std	Y+4, r25	; 0x04
    1488:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    148a:	eb 81       	ldd	r30, Y+3	; 0x03
    148c:	fc 81       	ldd	r31, Y+4	; 0x04
    148e:	89 e2       	ldi	r24, 0x29	; 41
    1490:	80 83       	st	Z, r24
	pxTopOfStack--;
    1492:	8b 81       	ldd	r24, Y+3	; 0x03
    1494:	9c 81       	ldd	r25, Y+4	; 0x04
    1496:	01 97       	sbiw	r24, 0x01	; 1
    1498:	9c 83       	std	Y+4, r25	; 0x04
    149a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    149c:	eb 81       	ldd	r30, Y+3	; 0x03
    149e:	fc 81       	ldd	r31, Y+4	; 0x04
    14a0:	80 e3       	ldi	r24, 0x30	; 48
    14a2:	80 83       	st	Z, r24
	pxTopOfStack--;
    14a4:	8b 81       	ldd	r24, Y+3	; 0x03
    14a6:	9c 81       	ldd	r25, Y+4	; 0x04
    14a8:	01 97       	sbiw	r24, 0x01	; 1
    14aa:	9c 83       	std	Y+4, r25	; 0x04
    14ac:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    14ae:	eb 81       	ldd	r30, Y+3	; 0x03
    14b0:	fc 81       	ldd	r31, Y+4	; 0x04
    14b2:	81 e3       	ldi	r24, 0x31	; 49
    14b4:	80 83       	st	Z, r24
	pxTopOfStack--;
    14b6:	8b 81       	ldd	r24, Y+3	; 0x03
    14b8:	9c 81       	ldd	r25, Y+4	; 0x04
    14ba:	01 97       	sbiw	r24, 0x01	; 1
    14bc:	9c 83       	std	Y+4, r25	; 0x04
    14be:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    14c0:	8b 81       	ldd	r24, Y+3	; 0x03
    14c2:	9c 81       	ldd	r25, Y+4	; 0x04
}
    14c4:	28 96       	adiw	r28, 0x08	; 8
    14c6:	0f b6       	in	r0, 0x3f	; 63
    14c8:	f8 94       	cli
    14ca:	de bf       	out	0x3e, r29	; 62
    14cc:	0f be       	out	0x3f, r0	; 63
    14ce:	cd bf       	out	0x3d, r28	; 61
    14d0:	cf 91       	pop	r28
    14d2:	df 91       	pop	r29
    14d4:	08 95       	ret

000014d6 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    14d6:	df 93       	push	r29
    14d8:	cf 93       	push	r28
    14da:	cd b7       	in	r28, 0x3d	; 61
    14dc:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    14de:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    14e2:	a0 91 c8 02 	lds	r26, 0x02C8
    14e6:	b0 91 c9 02 	lds	r27, 0x02C9
    14ea:	cd 91       	ld	r28, X+
    14ec:	cd bf       	out	0x3d, r28	; 61
    14ee:	dd 91       	ld	r29, X+
    14f0:	de bf       	out	0x3e, r29	; 62
    14f2:	ff 91       	pop	r31
    14f4:	ef 91       	pop	r30
    14f6:	df 91       	pop	r29
    14f8:	cf 91       	pop	r28
    14fa:	bf 91       	pop	r27
    14fc:	af 91       	pop	r26
    14fe:	9f 91       	pop	r25
    1500:	8f 91       	pop	r24
    1502:	7f 91       	pop	r23
    1504:	6f 91       	pop	r22
    1506:	5f 91       	pop	r21
    1508:	4f 91       	pop	r20
    150a:	3f 91       	pop	r19
    150c:	2f 91       	pop	r18
    150e:	1f 91       	pop	r17
    1510:	0f 91       	pop	r16
    1512:	ff 90       	pop	r15
    1514:	ef 90       	pop	r14
    1516:	df 90       	pop	r13
    1518:	cf 90       	pop	r12
    151a:	bf 90       	pop	r11
    151c:	af 90       	pop	r10
    151e:	9f 90       	pop	r9
    1520:	8f 90       	pop	r8
    1522:	7f 90       	pop	r7
    1524:	6f 90       	pop	r6
    1526:	5f 90       	pop	r5
    1528:	4f 90       	pop	r4
    152a:	3f 90       	pop	r3
    152c:	2f 90       	pop	r2
    152e:	1f 90       	pop	r1
    1530:	0f 90       	pop	r0
    1532:	0f be       	out	0x3f, r0	; 63
    1534:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1536:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    1538:	81 e0       	ldi	r24, 0x01	; 1
}
    153a:	cf 91       	pop	r28
    153c:	df 91       	pop	r29
    153e:	08 95       	ret

00001540 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1540:	df 93       	push	r29
    1542:	cf 93       	push	r28
    1544:	cd b7       	in	r28, 0x3d	; 61
    1546:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1548:	cf 91       	pop	r28
    154a:	df 91       	pop	r29
    154c:	08 95       	ret

0000154e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    154e:	0f 92       	push	r0
    1550:	0f b6       	in	r0, 0x3f	; 63
    1552:	f8 94       	cli
    1554:	0f 92       	push	r0
    1556:	1f 92       	push	r1
    1558:	11 24       	eor	r1, r1
    155a:	2f 92       	push	r2
    155c:	3f 92       	push	r3
    155e:	4f 92       	push	r4
    1560:	5f 92       	push	r5
    1562:	6f 92       	push	r6
    1564:	7f 92       	push	r7
    1566:	8f 92       	push	r8
    1568:	9f 92       	push	r9
    156a:	af 92       	push	r10
    156c:	bf 92       	push	r11
    156e:	cf 92       	push	r12
    1570:	df 92       	push	r13
    1572:	ef 92       	push	r14
    1574:	ff 92       	push	r15
    1576:	0f 93       	push	r16
    1578:	1f 93       	push	r17
    157a:	2f 93       	push	r18
    157c:	3f 93       	push	r19
    157e:	4f 93       	push	r20
    1580:	5f 93       	push	r21
    1582:	6f 93       	push	r22
    1584:	7f 93       	push	r23
    1586:	8f 93       	push	r24
    1588:	9f 93       	push	r25
    158a:	af 93       	push	r26
    158c:	bf 93       	push	r27
    158e:	cf 93       	push	r28
    1590:	df 93       	push	r29
    1592:	ef 93       	push	r30
    1594:	ff 93       	push	r31
    1596:	a0 91 c8 02 	lds	r26, 0x02C8
    159a:	b0 91 c9 02 	lds	r27, 0x02C9
    159e:	0d b6       	in	r0, 0x3d	; 61
    15a0:	0d 92       	st	X+, r0
    15a2:	0e b6       	in	r0, 0x3e	; 62
    15a4:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    15a6:	0e 94 cf 17 	call	0x2f9e	; 0x2f9e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    15aa:	a0 91 c8 02 	lds	r26, 0x02C8
    15ae:	b0 91 c9 02 	lds	r27, 0x02C9
    15b2:	cd 91       	ld	r28, X+
    15b4:	cd bf       	out	0x3d, r28	; 61
    15b6:	dd 91       	ld	r29, X+
    15b8:	de bf       	out	0x3e, r29	; 62
    15ba:	ff 91       	pop	r31
    15bc:	ef 91       	pop	r30
    15be:	df 91       	pop	r29
    15c0:	cf 91       	pop	r28
    15c2:	bf 91       	pop	r27
    15c4:	af 91       	pop	r26
    15c6:	9f 91       	pop	r25
    15c8:	8f 91       	pop	r24
    15ca:	7f 91       	pop	r23
    15cc:	6f 91       	pop	r22
    15ce:	5f 91       	pop	r21
    15d0:	4f 91       	pop	r20
    15d2:	3f 91       	pop	r19
    15d4:	2f 91       	pop	r18
    15d6:	1f 91       	pop	r17
    15d8:	0f 91       	pop	r16
    15da:	ff 90       	pop	r15
    15dc:	ef 90       	pop	r14
    15de:	df 90       	pop	r13
    15e0:	cf 90       	pop	r12
    15e2:	bf 90       	pop	r11
    15e4:	af 90       	pop	r10
    15e6:	9f 90       	pop	r9
    15e8:	8f 90       	pop	r8
    15ea:	7f 90       	pop	r7
    15ec:	6f 90       	pop	r6
    15ee:	5f 90       	pop	r5
    15f0:	4f 90       	pop	r4
    15f2:	3f 90       	pop	r3
    15f4:	2f 90       	pop	r2
    15f6:	1f 90       	pop	r1
    15f8:	0f 90       	pop	r0
    15fa:	0f be       	out	0x3f, r0	; 63
    15fc:	0f 90       	pop	r0

	asm volatile ( "ret" );
    15fe:	08 95       	ret

00001600 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1600:	0f 92       	push	r0
    1602:	0f b6       	in	r0, 0x3f	; 63
    1604:	f8 94       	cli
    1606:	0f 92       	push	r0
    1608:	1f 92       	push	r1
    160a:	11 24       	eor	r1, r1
    160c:	2f 92       	push	r2
    160e:	3f 92       	push	r3
    1610:	4f 92       	push	r4
    1612:	5f 92       	push	r5
    1614:	6f 92       	push	r6
    1616:	7f 92       	push	r7
    1618:	8f 92       	push	r8
    161a:	9f 92       	push	r9
    161c:	af 92       	push	r10
    161e:	bf 92       	push	r11
    1620:	cf 92       	push	r12
    1622:	df 92       	push	r13
    1624:	ef 92       	push	r14
    1626:	ff 92       	push	r15
    1628:	0f 93       	push	r16
    162a:	1f 93       	push	r17
    162c:	2f 93       	push	r18
    162e:	3f 93       	push	r19
    1630:	4f 93       	push	r20
    1632:	5f 93       	push	r21
    1634:	6f 93       	push	r22
    1636:	7f 93       	push	r23
    1638:	8f 93       	push	r24
    163a:	9f 93       	push	r25
    163c:	af 93       	push	r26
    163e:	bf 93       	push	r27
    1640:	cf 93       	push	r28
    1642:	df 93       	push	r29
    1644:	ef 93       	push	r30
    1646:	ff 93       	push	r31
    1648:	a0 91 c8 02 	lds	r26, 0x02C8
    164c:	b0 91 c9 02 	lds	r27, 0x02C9
    1650:	0d b6       	in	r0, 0x3d	; 61
    1652:	0d 92       	st	X+, r0
    1654:	0e b6       	in	r0, 0x3e	; 62
    1656:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1658:	0e 94 ea 16 	call	0x2dd4	; 0x2dd4 <xTaskIncrementTick>
    165c:	88 23       	and	r24, r24
    165e:	11 f0       	breq	.+4      	; 0x1664 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    1660:	0e 94 cf 17 	call	0x2f9e	; 0x2f9e <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1664:	a0 91 c8 02 	lds	r26, 0x02C8
    1668:	b0 91 c9 02 	lds	r27, 0x02C9
    166c:	cd 91       	ld	r28, X+
    166e:	cd bf       	out	0x3d, r28	; 61
    1670:	dd 91       	ld	r29, X+
    1672:	de bf       	out	0x3e, r29	; 62
    1674:	ff 91       	pop	r31
    1676:	ef 91       	pop	r30
    1678:	df 91       	pop	r29
    167a:	cf 91       	pop	r28
    167c:	bf 91       	pop	r27
    167e:	af 91       	pop	r26
    1680:	9f 91       	pop	r25
    1682:	8f 91       	pop	r24
    1684:	7f 91       	pop	r23
    1686:	6f 91       	pop	r22
    1688:	5f 91       	pop	r21
    168a:	4f 91       	pop	r20
    168c:	3f 91       	pop	r19
    168e:	2f 91       	pop	r18
    1690:	1f 91       	pop	r17
    1692:	0f 91       	pop	r16
    1694:	ff 90       	pop	r15
    1696:	ef 90       	pop	r14
    1698:	df 90       	pop	r13
    169a:	cf 90       	pop	r12
    169c:	bf 90       	pop	r11
    169e:	af 90       	pop	r10
    16a0:	9f 90       	pop	r9
    16a2:	8f 90       	pop	r8
    16a4:	7f 90       	pop	r7
    16a6:	6f 90       	pop	r6
    16a8:	5f 90       	pop	r5
    16aa:	4f 90       	pop	r4
    16ac:	3f 90       	pop	r3
    16ae:	2f 90       	pop	r2
    16b0:	1f 90       	pop	r1
    16b2:	0f 90       	pop	r0
    16b4:	0f be       	out	0x3f, r0	; 63
    16b6:	0f 90       	pop	r0

	asm volatile ( "ret" );
    16b8:	08 95       	ret

000016ba <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    16ba:	df 93       	push	r29
    16bc:	cf 93       	push	r28
    16be:	00 d0       	rcall	.+0      	; 0x16c0 <prvSetupTimerInterrupt+0x6>
    16c0:	00 d0       	rcall	.+0      	; 0x16c2 <prvSetupTimerInterrupt+0x8>
    16c2:	00 d0       	rcall	.+0      	; 0x16c4 <prvSetupTimerInterrupt+0xa>
    16c4:	cd b7       	in	r28, 0x3d	; 61
    16c6:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    16c8:	80 e4       	ldi	r24, 0x40	; 64
    16ca:	9f e1       	ldi	r25, 0x1F	; 31
    16cc:	a0 e0       	ldi	r26, 0x00	; 0
    16ce:	b0 e0       	ldi	r27, 0x00	; 0
    16d0:	8b 83       	std	Y+3, r24	; 0x03
    16d2:	9c 83       	std	Y+4, r25	; 0x04
    16d4:	ad 83       	std	Y+5, r26	; 0x05
    16d6:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    16d8:	8b 81       	ldd	r24, Y+3	; 0x03
    16da:	9c 81       	ldd	r25, Y+4	; 0x04
    16dc:	ad 81       	ldd	r26, Y+5	; 0x05
    16de:	be 81       	ldd	r27, Y+6	; 0x06
    16e0:	68 94       	set
    16e2:	15 f8       	bld	r1, 5
    16e4:	b6 95       	lsr	r27
    16e6:	a7 95       	ror	r26
    16e8:	97 95       	ror	r25
    16ea:	87 95       	ror	r24
    16ec:	16 94       	lsr	r1
    16ee:	d1 f7       	brne	.-12     	; 0x16e4 <prvSetupTimerInterrupt+0x2a>
    16f0:	8b 83       	std	Y+3, r24	; 0x03
    16f2:	9c 83       	std	Y+4, r25	; 0x04
    16f4:	ad 83       	std	Y+5, r26	; 0x05
    16f6:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    16f8:	8b 81       	ldd	r24, Y+3	; 0x03
    16fa:	9c 81       	ldd	r25, Y+4	; 0x04
    16fc:	ad 81       	ldd	r26, Y+5	; 0x05
    16fe:	be 81       	ldd	r27, Y+6	; 0x06
    1700:	01 97       	sbiw	r24, 0x01	; 1
    1702:	a1 09       	sbc	r26, r1
    1704:	b1 09       	sbc	r27, r1
    1706:	8b 83       	std	Y+3, r24	; 0x03
    1708:	9c 83       	std	Y+4, r25	; 0x04
    170a:	ad 83       	std	Y+5, r26	; 0x05
    170c:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    170e:	8b 81       	ldd	r24, Y+3	; 0x03
    1710:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    1712:	8b 81       	ldd	r24, Y+3	; 0x03
    1714:	9c 81       	ldd	r25, Y+4	; 0x04
    1716:	ad 81       	ldd	r26, Y+5	; 0x05
    1718:	be 81       	ldd	r27, Y+6	; 0x06
    171a:	89 2f       	mov	r24, r25
    171c:	9a 2f       	mov	r25, r26
    171e:	ab 2f       	mov	r26, r27
    1720:	bb 27       	eor	r27, r27
    1722:	8b 83       	std	Y+3, r24	; 0x03
    1724:	9c 83       	std	Y+4, r25	; 0x04
    1726:	ad 83       	std	Y+5, r26	; 0x05
    1728:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    172a:	8b 81       	ldd	r24, Y+3	; 0x03
    172c:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    172e:	eb e4       	ldi	r30, 0x4B	; 75
    1730:	f0 e0       	ldi	r31, 0x00	; 0
    1732:	8a 81       	ldd	r24, Y+2	; 0x02
    1734:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    1736:	ea e4       	ldi	r30, 0x4A	; 74
    1738:	f0 e0       	ldi	r31, 0x00	; 0
    173a:	89 81       	ldd	r24, Y+1	; 0x01
    173c:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    173e:	8b e0       	ldi	r24, 0x0B	; 11
    1740:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    1742:	ee e4       	ldi	r30, 0x4E	; 78
    1744:	f0 e0       	ldi	r31, 0x00	; 0
    1746:	89 81       	ldd	r24, Y+1	; 0x01
    1748:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    174a:	e9 e5       	ldi	r30, 0x59	; 89
    174c:	f0 e0       	ldi	r31, 0x00	; 0
    174e:	80 81       	ld	r24, Z
    1750:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1752:	89 81       	ldd	r24, Y+1	; 0x01
    1754:	80 61       	ori	r24, 0x10	; 16
    1756:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    1758:	e9 e5       	ldi	r30, 0x59	; 89
    175a:	f0 e0       	ldi	r31, 0x00	; 0
    175c:	89 81       	ldd	r24, Y+1	; 0x01
    175e:	80 83       	st	Z, r24
}
    1760:	26 96       	adiw	r28, 0x06	; 6
    1762:	0f b6       	in	r0, 0x3f	; 63
    1764:	f8 94       	cli
    1766:	de bf       	out	0x3e, r29	; 62
    1768:	0f be       	out	0x3f, r0	; 63
    176a:	cd bf       	out	0x3d, r28	; 61
    176c:	cf 91       	pop	r28
    176e:	df 91       	pop	r29
    1770:	08 95       	ret

00001772 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    1772:	0e 94 00 0b 	call	0x1600	; 0x1600 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1776:	18 95       	reti

00001778 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1778:	df 93       	push	r29
    177a:	cf 93       	push	r28
    177c:	00 d0       	rcall	.+0      	; 0x177e <xQueueGenericReset+0x6>
    177e:	00 d0       	rcall	.+0      	; 0x1780 <xQueueGenericReset+0x8>
    1780:	0f 92       	push	r0
    1782:	cd b7       	in	r28, 0x3d	; 61
    1784:	de b7       	in	r29, 0x3e	; 62
    1786:	9c 83       	std	Y+4, r25	; 0x04
    1788:	8b 83       	std	Y+3, r24	; 0x03
    178a:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    178c:	8b 81       	ldd	r24, Y+3	; 0x03
    178e:	9c 81       	ldd	r25, Y+4	; 0x04
    1790:	9a 83       	std	Y+2, r25	; 0x02
    1792:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1794:	0f b6       	in	r0, 0x3f	; 63
    1796:	f8 94       	cli
    1798:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    179a:	e9 81       	ldd	r30, Y+1	; 0x01
    179c:	fa 81       	ldd	r31, Y+2	; 0x02
    179e:	40 81       	ld	r20, Z
    17a0:	51 81       	ldd	r21, Z+1	; 0x01
    17a2:	e9 81       	ldd	r30, Y+1	; 0x01
    17a4:	fa 81       	ldd	r31, Y+2	; 0x02
    17a6:	83 8d       	ldd	r24, Z+27	; 0x1b
    17a8:	28 2f       	mov	r18, r24
    17aa:	30 e0       	ldi	r19, 0x00	; 0
    17ac:	e9 81       	ldd	r30, Y+1	; 0x01
    17ae:	fa 81       	ldd	r31, Y+2	; 0x02
    17b0:	84 8d       	ldd	r24, Z+28	; 0x1c
    17b2:	88 2f       	mov	r24, r24
    17b4:	90 e0       	ldi	r25, 0x00	; 0
    17b6:	bc 01       	movw	r22, r24
    17b8:	26 9f       	mul	r18, r22
    17ba:	c0 01       	movw	r24, r0
    17bc:	27 9f       	mul	r18, r23
    17be:	90 0d       	add	r25, r0
    17c0:	36 9f       	mul	r19, r22
    17c2:	90 0d       	add	r25, r0
    17c4:	11 24       	eor	r1, r1
    17c6:	84 0f       	add	r24, r20
    17c8:	95 1f       	adc	r25, r21
    17ca:	e9 81       	ldd	r30, Y+1	; 0x01
    17cc:	fa 81       	ldd	r31, Y+2	; 0x02
    17ce:	95 83       	std	Z+5, r25	; 0x05
    17d0:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    17d2:	e9 81       	ldd	r30, Y+1	; 0x01
    17d4:	fa 81       	ldd	r31, Y+2	; 0x02
    17d6:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    17d8:	e9 81       	ldd	r30, Y+1	; 0x01
    17da:	fa 81       	ldd	r31, Y+2	; 0x02
    17dc:	80 81       	ld	r24, Z
    17de:	91 81       	ldd	r25, Z+1	; 0x01
    17e0:	e9 81       	ldd	r30, Y+1	; 0x01
    17e2:	fa 81       	ldd	r31, Y+2	; 0x02
    17e4:	93 83       	std	Z+3, r25	; 0x03
    17e6:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    17e8:	e9 81       	ldd	r30, Y+1	; 0x01
    17ea:	fa 81       	ldd	r31, Y+2	; 0x02
    17ec:	40 81       	ld	r20, Z
    17ee:	51 81       	ldd	r21, Z+1	; 0x01
    17f0:	e9 81       	ldd	r30, Y+1	; 0x01
    17f2:	fa 81       	ldd	r31, Y+2	; 0x02
    17f4:	83 8d       	ldd	r24, Z+27	; 0x1b
    17f6:	88 2f       	mov	r24, r24
    17f8:	90 e0       	ldi	r25, 0x00	; 0
    17fa:	9c 01       	movw	r18, r24
    17fc:	21 50       	subi	r18, 0x01	; 1
    17fe:	30 40       	sbci	r19, 0x00	; 0
    1800:	e9 81       	ldd	r30, Y+1	; 0x01
    1802:	fa 81       	ldd	r31, Y+2	; 0x02
    1804:	84 8d       	ldd	r24, Z+28	; 0x1c
    1806:	88 2f       	mov	r24, r24
    1808:	90 e0       	ldi	r25, 0x00	; 0
    180a:	bc 01       	movw	r22, r24
    180c:	26 9f       	mul	r18, r22
    180e:	c0 01       	movw	r24, r0
    1810:	27 9f       	mul	r18, r23
    1812:	90 0d       	add	r25, r0
    1814:	36 9f       	mul	r19, r22
    1816:	90 0d       	add	r25, r0
    1818:	11 24       	eor	r1, r1
    181a:	84 0f       	add	r24, r20
    181c:	95 1f       	adc	r25, r21
    181e:	e9 81       	ldd	r30, Y+1	; 0x01
    1820:	fa 81       	ldd	r31, Y+2	; 0x02
    1822:	97 83       	std	Z+7, r25	; 0x07
    1824:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    1826:	e9 81       	ldd	r30, Y+1	; 0x01
    1828:	fa 81       	ldd	r31, Y+2	; 0x02
    182a:	8f ef       	ldi	r24, 0xFF	; 255
    182c:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    182e:	e9 81       	ldd	r30, Y+1	; 0x01
    1830:	fa 81       	ldd	r31, Y+2	; 0x02
    1832:	8f ef       	ldi	r24, 0xFF	; 255
    1834:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1836:	8d 81       	ldd	r24, Y+5	; 0x05
    1838:	88 23       	and	r24, r24
    183a:	79 f4       	brne	.+30     	; 0x185a <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    183c:	e9 81       	ldd	r30, Y+1	; 0x01
    183e:	fa 81       	ldd	r31, Y+2	; 0x02
    1840:	80 85       	ldd	r24, Z+8	; 0x08
    1842:	88 23       	and	r24, r24
    1844:	a1 f0       	breq	.+40     	; 0x186e <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1846:	89 81       	ldd	r24, Y+1	; 0x01
    1848:	9a 81       	ldd	r25, Y+2	; 0x02
    184a:	08 96       	adiw	r24, 0x08	; 8
    184c:	0e 94 8e 18 	call	0x311c	; 0x311c <xTaskRemoveFromEventList>
    1850:	88 23       	and	r24, r24
    1852:	69 f0       	breq	.+26     	; 0x186e <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1854:	0e 94 a7 0a 	call	0x154e	; 0x154e <vPortYield>
    1858:	0a c0       	rjmp	.+20     	; 0x186e <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    185a:	89 81       	ldd	r24, Y+1	; 0x01
    185c:	9a 81       	ldd	r25, Y+2	; 0x02
    185e:	08 96       	adiw	r24, 0x08	; 8
    1860:	0e 94 2b 07 	call	0xe56	; 0xe56 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1864:	89 81       	ldd	r24, Y+1	; 0x01
    1866:	9a 81       	ldd	r25, Y+2	; 0x02
    1868:	41 96       	adiw	r24, 0x11	; 17
    186a:	0e 94 2b 07 	call	0xe56	; 0xe56 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    186e:	0f 90       	pop	r0
    1870:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    1872:	81 e0       	ldi	r24, 0x01	; 1
}
    1874:	0f 90       	pop	r0
    1876:	0f 90       	pop	r0
    1878:	0f 90       	pop	r0
    187a:	0f 90       	pop	r0
    187c:	0f 90       	pop	r0
    187e:	cf 91       	pop	r28
    1880:	df 91       	pop	r29
    1882:	08 95       	ret

00001884 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    1884:	0f 93       	push	r16
    1886:	1f 93       	push	r17
    1888:	df 93       	push	r29
    188a:	cf 93       	push	r28
    188c:	cd b7       	in	r28, 0x3d	; 61
    188e:	de b7       	in	r29, 0x3e	; 62
    1890:	29 97       	sbiw	r28, 0x09	; 9
    1892:	0f b6       	in	r0, 0x3f	; 63
    1894:	f8 94       	cli
    1896:	de bf       	out	0x3e, r29	; 62
    1898:	0f be       	out	0x3f, r0	; 63
    189a:	cd bf       	out	0x3d, r28	; 61
    189c:	8f 83       	std	Y+7, r24	; 0x07
    189e:	68 87       	std	Y+8, r22	; 0x08
    18a0:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    18a2:	88 85       	ldd	r24, Y+8	; 0x08
    18a4:	88 23       	and	r24, r24
    18a6:	19 f4       	brne	.+6      	; 0x18ae <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    18a8:	1c 82       	std	Y+4, r1	; 0x04
    18aa:	1b 82       	std	Y+3, r1	; 0x03
    18ac:	10 c0       	rjmp	.+32     	; 0x18ce <xQueueGenericCreate+0x4a>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    18ae:	8f 81       	ldd	r24, Y+7	; 0x07
    18b0:	28 2f       	mov	r18, r24
    18b2:	30 e0       	ldi	r19, 0x00	; 0
    18b4:	88 85       	ldd	r24, Y+8	; 0x08
    18b6:	88 2f       	mov	r24, r24
    18b8:	90 e0       	ldi	r25, 0x00	; 0
    18ba:	ac 01       	movw	r20, r24
    18bc:	24 9f       	mul	r18, r20
    18be:	c0 01       	movw	r24, r0
    18c0:	25 9f       	mul	r18, r21
    18c2:	90 0d       	add	r25, r0
    18c4:	34 9f       	mul	r19, r20
    18c6:	90 0d       	add	r25, r0
    18c8:	11 24       	eor	r1, r1
    18ca:	9c 83       	std	Y+4, r25	; 0x04
    18cc:	8b 83       	std	Y+3, r24	; 0x03
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    18ce:	8b 81       	ldd	r24, Y+3	; 0x03
    18d0:	9c 81       	ldd	r25, Y+4	; 0x04
    18d2:	4f 96       	adiw	r24, 0x1f	; 31
    18d4:	0e 94 af 06 	call	0xd5e	; 0xd5e <pvPortMalloc>
    18d8:	9e 83       	std	Y+6, r25	; 0x06
    18da:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    18dc:	8d 81       	ldd	r24, Y+5	; 0x05
    18de:	9e 81       	ldd	r25, Y+6	; 0x06
    18e0:	00 97       	sbiw	r24, 0x00	; 0
    18e2:	a1 f0       	breq	.+40     	; 0x190c <xQueueGenericCreate+0x88>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    18e4:	8d 81       	ldd	r24, Y+5	; 0x05
    18e6:	9e 81       	ldd	r25, Y+6	; 0x06
    18e8:	9a 83       	std	Y+2, r25	; 0x02
    18ea:	89 83       	std	Y+1, r24	; 0x01
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    18ec:	89 81       	ldd	r24, Y+1	; 0x01
    18ee:	9a 81       	ldd	r25, Y+2	; 0x02
    18f0:	4f 96       	adiw	r24, 0x1f	; 31
    18f2:	9a 83       	std	Y+2, r25	; 0x02
    18f4:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    18f6:	29 81       	ldd	r18, Y+1	; 0x01
    18f8:	3a 81       	ldd	r19, Y+2	; 0x02
    18fa:	ed 81       	ldd	r30, Y+5	; 0x05
    18fc:	fe 81       	ldd	r31, Y+6	; 0x06
    18fe:	8f 81       	ldd	r24, Y+7	; 0x07
    1900:	68 85       	ldd	r22, Y+8	; 0x08
    1902:	a9 01       	movw	r20, r18
    1904:	29 85       	ldd	r18, Y+9	; 0x09
    1906:	8f 01       	movw	r16, r30
    1908:	0e 94 93 0c 	call	0x1926	; 0x1926 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    190c:	8d 81       	ldd	r24, Y+5	; 0x05
    190e:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    1910:	29 96       	adiw	r28, 0x09	; 9
    1912:	0f b6       	in	r0, 0x3f	; 63
    1914:	f8 94       	cli
    1916:	de bf       	out	0x3e, r29	; 62
    1918:	0f be       	out	0x3f, r0	; 63
    191a:	cd bf       	out	0x3d, r28	; 61
    191c:	cf 91       	pop	r28
    191e:	df 91       	pop	r29
    1920:	1f 91       	pop	r17
    1922:	0f 91       	pop	r16
    1924:	08 95       	ret

00001926 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    1926:	0f 93       	push	r16
    1928:	1f 93       	push	r17
    192a:	df 93       	push	r29
    192c:	cf 93       	push	r28
    192e:	cd b7       	in	r28, 0x3d	; 61
    1930:	de b7       	in	r29, 0x3e	; 62
    1932:	27 97       	sbiw	r28, 0x07	; 7
    1934:	0f b6       	in	r0, 0x3f	; 63
    1936:	f8 94       	cli
    1938:	de bf       	out	0x3e, r29	; 62
    193a:	0f be       	out	0x3f, r0	; 63
    193c:	cd bf       	out	0x3d, r28	; 61
    193e:	89 83       	std	Y+1, r24	; 0x01
    1940:	6a 83       	std	Y+2, r22	; 0x02
    1942:	5c 83       	std	Y+4, r21	; 0x04
    1944:	4b 83       	std	Y+3, r20	; 0x03
    1946:	2d 83       	std	Y+5, r18	; 0x05
    1948:	1f 83       	std	Y+7, r17	; 0x07
    194a:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    194c:	8a 81       	ldd	r24, Y+2	; 0x02
    194e:	88 23       	and	r24, r24
    1950:	39 f4       	brne	.+14     	; 0x1960 <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1952:	8e 81       	ldd	r24, Y+6	; 0x06
    1954:	9f 81       	ldd	r25, Y+7	; 0x07
    1956:	ee 81       	ldd	r30, Y+6	; 0x06
    1958:	ff 81       	ldd	r31, Y+7	; 0x07
    195a:	91 83       	std	Z+1, r25	; 0x01
    195c:	80 83       	st	Z, r24
    195e:	06 c0       	rjmp	.+12     	; 0x196c <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1960:	8b 81       	ldd	r24, Y+3	; 0x03
    1962:	9c 81       	ldd	r25, Y+4	; 0x04
    1964:	ee 81       	ldd	r30, Y+6	; 0x06
    1966:	ff 81       	ldd	r31, Y+7	; 0x07
    1968:	91 83       	std	Z+1, r25	; 0x01
    196a:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    196c:	ee 81       	ldd	r30, Y+6	; 0x06
    196e:	ff 81       	ldd	r31, Y+7	; 0x07
    1970:	89 81       	ldd	r24, Y+1	; 0x01
    1972:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    1974:	ee 81       	ldd	r30, Y+6	; 0x06
    1976:	ff 81       	ldd	r31, Y+7	; 0x07
    1978:	8a 81       	ldd	r24, Y+2	; 0x02
    197a:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    197c:	8e 81       	ldd	r24, Y+6	; 0x06
    197e:	9f 81       	ldd	r25, Y+7	; 0x07
    1980:	61 e0       	ldi	r22, 0x01	; 1
    1982:	0e 94 bc 0b 	call	0x1778	; 0x1778 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    1986:	27 96       	adiw	r28, 0x07	; 7
    1988:	0f b6       	in	r0, 0x3f	; 63
    198a:	f8 94       	cli
    198c:	de bf       	out	0x3e, r29	; 62
    198e:	0f be       	out	0x3f, r0	; 63
    1990:	cd bf       	out	0x3d, r28	; 61
    1992:	cf 91       	pop	r28
    1994:	df 91       	pop	r29
    1996:	1f 91       	pop	r17
    1998:	0f 91       	pop	r16
    199a:	08 95       	ret

0000199c <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
    199c:	df 93       	push	r29
    199e:	cf 93       	push	r28
    19a0:	00 d0       	rcall	.+0      	; 0x19a2 <xQueueCreateCountingSemaphore+0x6>
    19a2:	00 d0       	rcall	.+0      	; 0x19a4 <xQueueCreateCountingSemaphore+0x8>
    19a4:	cd b7       	in	r28, 0x3d	; 61
    19a6:	de b7       	in	r29, 0x3e	; 62
    19a8:	8b 83       	std	Y+3, r24	; 0x03
    19aa:	6c 83       	std	Y+4, r22	; 0x04
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
		configASSERT( uxInitialCount <= uxMaxCount );

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
    19ac:	8b 81       	ldd	r24, Y+3	; 0x03
    19ae:	60 e0       	ldi	r22, 0x00	; 0
    19b0:	42 e0       	ldi	r20, 0x02	; 2
    19b2:	0e 94 42 0c 	call	0x1884	; 0x1884 <xQueueGenericCreate>
    19b6:	9a 83       	std	Y+2, r25	; 0x02
    19b8:	89 83       	std	Y+1, r24	; 0x01

		if( xHandle != NULL )
    19ba:	89 81       	ldd	r24, Y+1	; 0x01
    19bc:	9a 81       	ldd	r25, Y+2	; 0x02
    19be:	00 97       	sbiw	r24, 0x00	; 0
    19c0:	21 f0       	breq	.+8      	; 0x19ca <xQueueCreateCountingSemaphore+0x2e>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
    19c2:	e9 81       	ldd	r30, Y+1	; 0x01
    19c4:	fa 81       	ldd	r31, Y+2	; 0x02
    19c6:	8c 81       	ldd	r24, Y+4	; 0x04
    19c8:	82 8f       	std	Z+26, r24	; 0x1a
		else
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		return xHandle;
    19ca:	89 81       	ldd	r24, Y+1	; 0x01
    19cc:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    19ce:	0f 90       	pop	r0
    19d0:	0f 90       	pop	r0
    19d2:	0f 90       	pop	r0
    19d4:	0f 90       	pop	r0
    19d6:	cf 91       	pop	r28
    19d8:	df 91       	pop	r29
    19da:	08 95       	ret

000019dc <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    19dc:	df 93       	push	r29
    19de:	cf 93       	push	r28
    19e0:	cd b7       	in	r28, 0x3d	; 61
    19e2:	de b7       	in	r29, 0x3e	; 62
    19e4:	2f 97       	sbiw	r28, 0x0f	; 15
    19e6:	0f b6       	in	r0, 0x3f	; 63
    19e8:	f8 94       	cli
    19ea:	de bf       	out	0x3e, r29	; 62
    19ec:	0f be       	out	0x3f, r0	; 63
    19ee:	cd bf       	out	0x3d, r28	; 61
    19f0:	99 87       	std	Y+9, r25	; 0x09
    19f2:	88 87       	std	Y+8, r24	; 0x08
    19f4:	7b 87       	std	Y+11, r23	; 0x0b
    19f6:	6a 87       	std	Y+10, r22	; 0x0a
    19f8:	5d 87       	std	Y+13, r21	; 0x0d
    19fa:	4c 87       	std	Y+12, r20	; 0x0c
    19fc:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    19fe:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    1a00:	88 85       	ldd	r24, Y+8	; 0x08
    1a02:	99 85       	ldd	r25, Y+9	; 0x09
    1a04:	9a 83       	std	Y+2, r25	; 0x02
    1a06:	89 83       	std	Y+1, r24	; 0x01
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1a08:	0f b6       	in	r0, 0x3f	; 63
    1a0a:	f8 94       	cli
    1a0c:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1a0e:	e9 81       	ldd	r30, Y+1	; 0x01
    1a10:	fa 81       	ldd	r31, Y+2	; 0x02
    1a12:	92 8d       	ldd	r25, Z+26	; 0x1a
    1a14:	e9 81       	ldd	r30, Y+1	; 0x01
    1a16:	fa 81       	ldd	r31, Y+2	; 0x02
    1a18:	83 8d       	ldd	r24, Z+27	; 0x1b
    1a1a:	98 17       	cp	r25, r24
    1a1c:	18 f0       	brcs	.+6      	; 0x1a24 <xQueueGenericSend+0x48>
    1a1e:	8e 85       	ldd	r24, Y+14	; 0x0e
    1a20:	82 30       	cpi	r24, 0x02	; 2
    1a22:	11 f5       	brne	.+68     	; 0x1a68 <xQueueGenericSend+0x8c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1a24:	89 81       	ldd	r24, Y+1	; 0x01
    1a26:	9a 81       	ldd	r25, Y+2	; 0x02
    1a28:	2a 85       	ldd	r18, Y+10	; 0x0a
    1a2a:	3b 85       	ldd	r19, Y+11	; 0x0b
    1a2c:	b9 01       	movw	r22, r18
    1a2e:	4e 85       	ldd	r20, Y+14	; 0x0e
    1a30:	0e 94 40 11 	call	0x2280	; 0x2280 <prvCopyDataToQueue>
    1a34:	8b 83       	std	Y+3, r24	; 0x03

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a36:	e9 81       	ldd	r30, Y+1	; 0x01
    1a38:	fa 81       	ldd	r31, Y+2	; 0x02
    1a3a:	81 89       	ldd	r24, Z+17	; 0x11
    1a3c:	88 23       	and	r24, r24
    1a3e:	51 f0       	breq	.+20     	; 0x1a54 <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a40:	89 81       	ldd	r24, Y+1	; 0x01
    1a42:	9a 81       	ldd	r25, Y+2	; 0x02
    1a44:	41 96       	adiw	r24, 0x11	; 17
    1a46:	0e 94 8e 18 	call	0x311c	; 0x311c <xTaskRemoveFromEventList>
    1a4a:	88 23       	and	r24, r24
    1a4c:	41 f0       	breq	.+16     	; 0x1a5e <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1a4e:	0e 94 a7 0a 	call	0x154e	; 0x154e <vPortYield>
    1a52:	05 c0       	rjmp	.+10     	; 0x1a5e <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1a54:	8b 81       	ldd	r24, Y+3	; 0x03
    1a56:	88 23       	and	r24, r24
    1a58:	11 f0       	breq	.+4      	; 0x1a5e <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1a5a:	0e 94 a7 0a 	call	0x154e	; 0x154e <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1a5e:	0f 90       	pop	r0
    1a60:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1a62:	81 e0       	ldi	r24, 0x01	; 1
    1a64:	8f 87       	std	Y+15, r24	; 0x0f
    1a66:	5c c0       	rjmp	.+184    	; 0x1b20 <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1a68:	8c 85       	ldd	r24, Y+12	; 0x0c
    1a6a:	9d 85       	ldd	r25, Y+13	; 0x0d
    1a6c:	00 97       	sbiw	r24, 0x00	; 0
    1a6e:	21 f4       	brne	.+8      	; 0x1a78 <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1a70:	0f 90       	pop	r0
    1a72:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1a74:	1f 86       	std	Y+15, r1	; 0x0f
    1a76:	54 c0       	rjmp	.+168    	; 0x1b20 <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1a78:	8c 81       	ldd	r24, Y+4	; 0x04
    1a7a:	88 23       	and	r24, r24
    1a7c:	31 f4       	brne	.+12     	; 0x1a8a <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1a7e:	ce 01       	movw	r24, r28
    1a80:	05 96       	adiw	r24, 0x05	; 5
    1a82:	0e 94 74 19 	call	0x32e8	; 0x32e8 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1a86:	81 e0       	ldi	r24, 0x01	; 1
    1a88:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1a8a:	0f 90       	pop	r0
    1a8c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1a8e:	0e 94 ee 15 	call	0x2bdc	; 0x2bdc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1a92:	0f b6       	in	r0, 0x3f	; 63
    1a94:	f8 94       	cli
    1a96:	0f 92       	push	r0
    1a98:	e9 81       	ldd	r30, Y+1	; 0x01
    1a9a:	fa 81       	ldd	r31, Y+2	; 0x02
    1a9c:	85 8d       	ldd	r24, Z+29	; 0x1d
    1a9e:	8f 3f       	cpi	r24, 0xFF	; 255
    1aa0:	19 f4       	brne	.+6      	; 0x1aa8 <xQueueGenericSend+0xcc>
    1aa2:	e9 81       	ldd	r30, Y+1	; 0x01
    1aa4:	fa 81       	ldd	r31, Y+2	; 0x02
    1aa6:	15 8e       	std	Z+29, r1	; 0x1d
    1aa8:	e9 81       	ldd	r30, Y+1	; 0x01
    1aaa:	fa 81       	ldd	r31, Y+2	; 0x02
    1aac:	86 8d       	ldd	r24, Z+30	; 0x1e
    1aae:	8f 3f       	cpi	r24, 0xFF	; 255
    1ab0:	19 f4       	brne	.+6      	; 0x1ab8 <xQueueGenericSend+0xdc>
    1ab2:	e9 81       	ldd	r30, Y+1	; 0x01
    1ab4:	fa 81       	ldd	r31, Y+2	; 0x02
    1ab6:	16 8e       	std	Z+30, r1	; 0x1e
    1ab8:	0f 90       	pop	r0
    1aba:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1abc:	ce 01       	movw	r24, r28
    1abe:	05 96       	adiw	r24, 0x05	; 5
    1ac0:	9e 01       	movw	r18, r28
    1ac2:	24 5f       	subi	r18, 0xF4	; 244
    1ac4:	3f 4f       	sbci	r19, 0xFF	; 255
    1ac6:	b9 01       	movw	r22, r18
    1ac8:	0e 94 8d 19 	call	0x331a	; 0x331a <xTaskCheckForTimeOut>
    1acc:	88 23       	and	r24, r24
    1ace:	09 f5       	brne	.+66     	; 0x1b12 <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1ad0:	89 81       	ldd	r24, Y+1	; 0x01
    1ad2:	9a 81       	ldd	r25, Y+2	; 0x02
    1ad4:	0e 94 bc 12 	call	0x2578	; 0x2578 <prvIsQueueFull>
    1ad8:	88 23       	and	r24, r24
    1ada:	a1 f0       	breq	.+40     	; 0x1b04 <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1adc:	89 81       	ldd	r24, Y+1	; 0x01
    1ade:	9a 81       	ldd	r25, Y+2	; 0x02
    1ae0:	08 96       	adiw	r24, 0x08	; 8
    1ae2:	2c 85       	ldd	r18, Y+12	; 0x0c
    1ae4:	3d 85       	ldd	r19, Y+13	; 0x0d
    1ae6:	b9 01       	movw	r22, r18
    1ae8:	0e 94 3c 18 	call	0x3078	; 0x3078 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1aec:	89 81       	ldd	r24, Y+1	; 0x01
    1aee:	9a 81       	ldd	r25, Y+2	; 0x02
    1af0:	0e 94 2d 12 	call	0x245a	; 0x245a <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1af4:	0e 94 fa 15 	call	0x2bf4	; 0x2bf4 <xTaskResumeAll>
    1af8:	88 23       	and	r24, r24
    1afa:	09 f0       	breq	.+2      	; 0x1afe <xQueueGenericSend+0x122>
    1afc:	85 cf       	rjmp	.-246    	; 0x1a08 <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    1afe:	0e 94 a7 0a 	call	0x154e	; 0x154e <vPortYield>
    1b02:	82 cf       	rjmp	.-252    	; 0x1a08 <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1b04:	89 81       	ldd	r24, Y+1	; 0x01
    1b06:	9a 81       	ldd	r25, Y+2	; 0x02
    1b08:	0e 94 2d 12 	call	0x245a	; 0x245a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1b0c:	0e 94 fa 15 	call	0x2bf4	; 0x2bf4 <xTaskResumeAll>
    1b10:	7b cf       	rjmp	.-266    	; 0x1a08 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1b12:	89 81       	ldd	r24, Y+1	; 0x01
    1b14:	9a 81       	ldd	r25, Y+2	; 0x02
    1b16:	0e 94 2d 12 	call	0x245a	; 0x245a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1b1a:	0e 94 fa 15 	call	0x2bf4	; 0x2bf4 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1b1e:	1f 86       	std	Y+15, r1	; 0x0f
    1b20:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	} /*lint -restore */
}
    1b22:	2f 96       	adiw	r28, 0x0f	; 15
    1b24:	0f b6       	in	r0, 0x3f	; 63
    1b26:	f8 94       	cli
    1b28:	de bf       	out	0x3e, r29	; 62
    1b2a:	0f be       	out	0x3f, r0	; 63
    1b2c:	cd bf       	out	0x3d, r28	; 61
    1b2e:	cf 91       	pop	r28
    1b30:	df 91       	pop	r29
    1b32:	08 95       	ret

00001b34 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1b34:	df 93       	push	r29
    1b36:	cf 93       	push	r28
    1b38:	cd b7       	in	r28, 0x3d	; 61
    1b3a:	de b7       	in	r29, 0x3e	; 62
    1b3c:	2c 97       	sbiw	r28, 0x0c	; 12
    1b3e:	0f b6       	in	r0, 0x3f	; 63
    1b40:	f8 94       	cli
    1b42:	de bf       	out	0x3e, r29	; 62
    1b44:	0f be       	out	0x3f, r0	; 63
    1b46:	cd bf       	out	0x3d, r28	; 61
    1b48:	9f 83       	std	Y+7, r25	; 0x07
    1b4a:	8e 83       	std	Y+6, r24	; 0x06
    1b4c:	79 87       	std	Y+9, r23	; 0x09
    1b4e:	68 87       	std	Y+8, r22	; 0x08
    1b50:	5b 87       	std	Y+11, r21	; 0x0b
    1b52:	4a 87       	std	Y+10, r20	; 0x0a
    1b54:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    1b56:	8e 81       	ldd	r24, Y+6	; 0x06
    1b58:	9f 81       	ldd	r25, Y+7	; 0x07
    1b5a:	9b 83       	std	Y+3, r25	; 0x03
    1b5c:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1b5e:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1b60:	ea 81       	ldd	r30, Y+2	; 0x02
    1b62:	fb 81       	ldd	r31, Y+3	; 0x03
    1b64:	92 8d       	ldd	r25, Z+26	; 0x1a
    1b66:	ea 81       	ldd	r30, Y+2	; 0x02
    1b68:	fb 81       	ldd	r31, Y+3	; 0x03
    1b6a:	83 8d       	ldd	r24, Z+27	; 0x1b
    1b6c:	98 17       	cp	r25, r24
    1b6e:	18 f0       	brcs	.+6      	; 0x1b76 <xQueueGenericSendFromISR+0x42>
    1b70:	8c 85       	ldd	r24, Y+12	; 0x0c
    1b72:	82 30       	cpi	r24, 0x02	; 2
    1b74:	61 f5       	brne	.+88     	; 0x1bce <xQueueGenericSendFromISR+0x9a>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1b76:	ea 81       	ldd	r30, Y+2	; 0x02
    1b78:	fb 81       	ldd	r31, Y+3	; 0x03
    1b7a:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b7c:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1b7e:	8a 81       	ldd	r24, Y+2	; 0x02
    1b80:	9b 81       	ldd	r25, Y+3	; 0x03
    1b82:	28 85       	ldd	r18, Y+8	; 0x08
    1b84:	39 85       	ldd	r19, Y+9	; 0x09
    1b86:	b9 01       	movw	r22, r18
    1b88:	4c 85       	ldd	r20, Y+12	; 0x0c
    1b8a:	0e 94 40 11 	call	0x2280	; 0x2280 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1b8e:	89 81       	ldd	r24, Y+1	; 0x01
    1b90:	8f 3f       	cpi	r24, 0xFF	; 255
    1b92:	a9 f4       	brne	.+42     	; 0x1bbe <xQueueGenericSendFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b94:	ea 81       	ldd	r30, Y+2	; 0x02
    1b96:	fb 81       	ldd	r31, Y+3	; 0x03
    1b98:	81 89       	ldd	r24, Z+17	; 0x11
    1b9a:	88 23       	and	r24, r24
    1b9c:	a9 f0       	breq	.+42     	; 0x1bc8 <xQueueGenericSendFromISR+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b9e:	8a 81       	ldd	r24, Y+2	; 0x02
    1ba0:	9b 81       	ldd	r25, Y+3	; 0x03
    1ba2:	41 96       	adiw	r24, 0x11	; 17
    1ba4:	0e 94 8e 18 	call	0x311c	; 0x311c <xTaskRemoveFromEventList>
    1ba8:	88 23       	and	r24, r24
    1baa:	71 f0       	breq	.+28     	; 0x1bc8 <xQueueGenericSendFromISR+0x94>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1bac:	8a 85       	ldd	r24, Y+10	; 0x0a
    1bae:	9b 85       	ldd	r25, Y+11	; 0x0b
    1bb0:	00 97       	sbiw	r24, 0x00	; 0
    1bb2:	51 f0       	breq	.+20     	; 0x1bc8 <xQueueGenericSendFromISR+0x94>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1bb4:	ea 85       	ldd	r30, Y+10	; 0x0a
    1bb6:	fb 85       	ldd	r31, Y+11	; 0x0b
    1bb8:	81 e0       	ldi	r24, 0x01	; 1
    1bba:	80 83       	st	Z, r24
    1bbc:	05 c0       	rjmp	.+10     	; 0x1bc8 <xQueueGenericSendFromISR+0x94>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1bbe:	89 81       	ldd	r24, Y+1	; 0x01
    1bc0:	8f 5f       	subi	r24, 0xFF	; 255
    1bc2:	ea 81       	ldd	r30, Y+2	; 0x02
    1bc4:	fb 81       	ldd	r31, Y+3	; 0x03
    1bc6:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1bc8:	81 e0       	ldi	r24, 0x01	; 1
    1bca:	8d 83       	std	Y+5, r24	; 0x05
    1bcc:	01 c0       	rjmp	.+2      	; 0x1bd0 <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1bce:	1d 82       	std	Y+5, r1	; 0x05
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1bd0:	8d 81       	ldd	r24, Y+5	; 0x05
}
    1bd2:	2c 96       	adiw	r28, 0x0c	; 12
    1bd4:	0f b6       	in	r0, 0x3f	; 63
    1bd6:	f8 94       	cli
    1bd8:	de bf       	out	0x3e, r29	; 62
    1bda:	0f be       	out	0x3f, r0	; 63
    1bdc:	cd bf       	out	0x3d, r28	; 61
    1bde:	cf 91       	pop	r28
    1be0:	df 91       	pop	r29
    1be2:	08 95       	ret

00001be4 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1be4:	df 93       	push	r29
    1be6:	cf 93       	push	r28
    1be8:	cd b7       	in	r28, 0x3d	; 61
    1bea:	de b7       	in	r29, 0x3e	; 62
    1bec:	2a 97       	sbiw	r28, 0x0a	; 10
    1bee:	0f b6       	in	r0, 0x3f	; 63
    1bf0:	f8 94       	cli
    1bf2:	de bf       	out	0x3e, r29	; 62
    1bf4:	0f be       	out	0x3f, r0	; 63
    1bf6:	cd bf       	out	0x3d, r28	; 61
    1bf8:	98 87       	std	Y+8, r25	; 0x08
    1bfa:	8f 83       	std	Y+7, r24	; 0x07
    1bfc:	7a 87       	std	Y+10, r23	; 0x0a
    1bfe:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    1c00:	8f 81       	ldd	r24, Y+7	; 0x07
    1c02:	98 85       	ldd	r25, Y+8	; 0x08
    1c04:	9c 83       	std	Y+4, r25	; 0x04
    1c06:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1c08:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1c0a:	eb 81       	ldd	r30, Y+3	; 0x03
    1c0c:	fc 81       	ldd	r31, Y+4	; 0x04
    1c0e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c10:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    1c12:	eb 81       	ldd	r30, Y+3	; 0x03
    1c14:	fc 81       	ldd	r31, Y+4	; 0x04
    1c16:	93 8d       	ldd	r25, Z+27	; 0x1b
    1c18:	8a 81       	ldd	r24, Y+2	; 0x02
    1c1a:	89 17       	cp	r24, r25
    1c1c:	48 f5       	brcc	.+82     	; 0x1c70 <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1c1e:	eb 81       	ldd	r30, Y+3	; 0x03
    1c20:	fc 81       	ldd	r31, Y+4	; 0x04
    1c22:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c24:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1c26:	8a 81       	ldd	r24, Y+2	; 0x02
    1c28:	8f 5f       	subi	r24, 0xFF	; 255
    1c2a:	eb 81       	ldd	r30, Y+3	; 0x03
    1c2c:	fc 81       	ldd	r31, Y+4	; 0x04
    1c2e:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1c30:	89 81       	ldd	r24, Y+1	; 0x01
    1c32:	8f 3f       	cpi	r24, 0xFF	; 255
    1c34:	a9 f4       	brne	.+42     	; 0x1c60 <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1c36:	eb 81       	ldd	r30, Y+3	; 0x03
    1c38:	fc 81       	ldd	r31, Y+4	; 0x04
    1c3a:	81 89       	ldd	r24, Z+17	; 0x11
    1c3c:	88 23       	and	r24, r24
    1c3e:	a9 f0       	breq	.+42     	; 0x1c6a <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1c40:	8b 81       	ldd	r24, Y+3	; 0x03
    1c42:	9c 81       	ldd	r25, Y+4	; 0x04
    1c44:	41 96       	adiw	r24, 0x11	; 17
    1c46:	0e 94 8e 18 	call	0x311c	; 0x311c <xTaskRemoveFromEventList>
    1c4a:	88 23       	and	r24, r24
    1c4c:	71 f0       	breq	.+28     	; 0x1c6a <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1c4e:	89 85       	ldd	r24, Y+9	; 0x09
    1c50:	9a 85       	ldd	r25, Y+10	; 0x0a
    1c52:	00 97       	sbiw	r24, 0x00	; 0
    1c54:	51 f0       	breq	.+20     	; 0x1c6a <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1c56:	e9 85       	ldd	r30, Y+9	; 0x09
    1c58:	fa 85       	ldd	r31, Y+10	; 0x0a
    1c5a:	81 e0       	ldi	r24, 0x01	; 1
    1c5c:	80 83       	st	Z, r24
    1c5e:	05 c0       	rjmp	.+10     	; 0x1c6a <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1c60:	89 81       	ldd	r24, Y+1	; 0x01
    1c62:	8f 5f       	subi	r24, 0xFF	; 255
    1c64:	eb 81       	ldd	r30, Y+3	; 0x03
    1c66:	fc 81       	ldd	r31, Y+4	; 0x04
    1c68:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1c6a:	81 e0       	ldi	r24, 0x01	; 1
    1c6c:	8e 83       	std	Y+6, r24	; 0x06
    1c6e:	01 c0       	rjmp	.+2      	; 0x1c72 <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1c70:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1c72:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1c74:	2a 96       	adiw	r28, 0x0a	; 10
    1c76:	0f b6       	in	r0, 0x3f	; 63
    1c78:	f8 94       	cli
    1c7a:	de bf       	out	0x3e, r29	; 62
    1c7c:	0f be       	out	0x3f, r0	; 63
    1c7e:	cd bf       	out	0x3d, r28	; 61
    1c80:	cf 91       	pop	r28
    1c82:	df 91       	pop	r29
    1c84:	08 95       	ret

00001c86 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1c86:	df 93       	push	r29
    1c88:	cf 93       	push	r28
    1c8a:	cd b7       	in	r28, 0x3d	; 61
    1c8c:	de b7       	in	r29, 0x3e	; 62
    1c8e:	2e 97       	sbiw	r28, 0x0e	; 14
    1c90:	0f b6       	in	r0, 0x3f	; 63
    1c92:	f8 94       	cli
    1c94:	de bf       	out	0x3e, r29	; 62
    1c96:	0f be       	out	0x3f, r0	; 63
    1c98:	cd bf       	out	0x3d, r28	; 61
    1c9a:	99 87       	std	Y+9, r25	; 0x09
    1c9c:	88 87       	std	Y+8, r24	; 0x08
    1c9e:	7b 87       	std	Y+11, r23	; 0x0b
    1ca0:	6a 87       	std	Y+10, r22	; 0x0a
    1ca2:	5d 87       	std	Y+13, r21	; 0x0d
    1ca4:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    1ca6:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    1ca8:	88 85       	ldd	r24, Y+8	; 0x08
    1caa:	99 85       	ldd	r25, Y+9	; 0x09
    1cac:	9b 83       	std	Y+3, r25	; 0x03
    1cae:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1cb0:	0f b6       	in	r0, 0x3f	; 63
    1cb2:	f8 94       	cli
    1cb4:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1cb6:	ea 81       	ldd	r30, Y+2	; 0x02
    1cb8:	fb 81       	ldd	r31, Y+3	; 0x03
    1cba:	82 8d       	ldd	r24, Z+26	; 0x1a
    1cbc:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1cbe:	89 81       	ldd	r24, Y+1	; 0x01
    1cc0:	88 23       	and	r24, r24
    1cc2:	f9 f0       	breq	.+62     	; 0x1d02 <xQueueReceive+0x7c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1cc4:	8a 81       	ldd	r24, Y+2	; 0x02
    1cc6:	9b 81       	ldd	r25, Y+3	; 0x03
    1cc8:	2a 85       	ldd	r18, Y+10	; 0x0a
    1cca:	3b 85       	ldd	r19, Y+11	; 0x0b
    1ccc:	b9 01       	movw	r22, r18
    1cce:	0e 94 e6 11 	call	0x23cc	; 0x23cc <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1cd2:	89 81       	ldd	r24, Y+1	; 0x01
    1cd4:	81 50       	subi	r24, 0x01	; 1
    1cd6:	ea 81       	ldd	r30, Y+2	; 0x02
    1cd8:	fb 81       	ldd	r31, Y+3	; 0x03
    1cda:	82 8f       	std	Z+26, r24	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1cdc:	ea 81       	ldd	r30, Y+2	; 0x02
    1cde:	fb 81       	ldd	r31, Y+3	; 0x03
    1ce0:	80 85       	ldd	r24, Z+8	; 0x08
    1ce2:	88 23       	and	r24, r24
    1ce4:	49 f0       	breq	.+18     	; 0x1cf8 <xQueueReceive+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1ce6:	8a 81       	ldd	r24, Y+2	; 0x02
    1ce8:	9b 81       	ldd	r25, Y+3	; 0x03
    1cea:	08 96       	adiw	r24, 0x08	; 8
    1cec:	0e 94 8e 18 	call	0x311c	; 0x311c <xTaskRemoveFromEventList>
    1cf0:	88 23       	and	r24, r24
    1cf2:	11 f0       	breq	.+4      	; 0x1cf8 <xQueueReceive+0x72>
					{
						queueYIELD_IF_USING_PREEMPTION();
    1cf4:	0e 94 a7 0a 	call	0x154e	; 0x154e <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1cf8:	0f 90       	pop	r0
    1cfa:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1cfc:	81 e0       	ldi	r24, 0x01	; 1
    1cfe:	8e 87       	std	Y+14, r24	; 0x0e
    1d00:	63 c0       	rjmp	.+198    	; 0x1dc8 <xQueueReceive+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1d02:	8c 85       	ldd	r24, Y+12	; 0x0c
    1d04:	9d 85       	ldd	r25, Y+13	; 0x0d
    1d06:	00 97       	sbiw	r24, 0x00	; 0
    1d08:	21 f4       	brne	.+8      	; 0x1d12 <xQueueReceive+0x8c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1d0a:	0f 90       	pop	r0
    1d0c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1d0e:	1e 86       	std	Y+14, r1	; 0x0e
    1d10:	5b c0       	rjmp	.+182    	; 0x1dc8 <xQueueReceive+0x142>
				}
				else if( xEntryTimeSet == pdFALSE )
    1d12:	8c 81       	ldd	r24, Y+4	; 0x04
    1d14:	88 23       	and	r24, r24
    1d16:	31 f4       	brne	.+12     	; 0x1d24 <xQueueReceive+0x9e>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1d18:	ce 01       	movw	r24, r28
    1d1a:	05 96       	adiw	r24, 0x05	; 5
    1d1c:	0e 94 74 19 	call	0x32e8	; 0x32e8 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1d20:	81 e0       	ldi	r24, 0x01	; 1
    1d22:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1d24:	0f 90       	pop	r0
    1d26:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1d28:	0e 94 ee 15 	call	0x2bdc	; 0x2bdc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1d2c:	0f b6       	in	r0, 0x3f	; 63
    1d2e:	f8 94       	cli
    1d30:	0f 92       	push	r0
    1d32:	ea 81       	ldd	r30, Y+2	; 0x02
    1d34:	fb 81       	ldd	r31, Y+3	; 0x03
    1d36:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d38:	8f 3f       	cpi	r24, 0xFF	; 255
    1d3a:	19 f4       	brne	.+6      	; 0x1d42 <xQueueReceive+0xbc>
    1d3c:	ea 81       	ldd	r30, Y+2	; 0x02
    1d3e:	fb 81       	ldd	r31, Y+3	; 0x03
    1d40:	15 8e       	std	Z+29, r1	; 0x1d
    1d42:	ea 81       	ldd	r30, Y+2	; 0x02
    1d44:	fb 81       	ldd	r31, Y+3	; 0x03
    1d46:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d48:	8f 3f       	cpi	r24, 0xFF	; 255
    1d4a:	19 f4       	brne	.+6      	; 0x1d52 <xQueueReceive+0xcc>
    1d4c:	ea 81       	ldd	r30, Y+2	; 0x02
    1d4e:	fb 81       	ldd	r31, Y+3	; 0x03
    1d50:	16 8e       	std	Z+30, r1	; 0x1e
    1d52:	0f 90       	pop	r0
    1d54:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1d56:	ce 01       	movw	r24, r28
    1d58:	05 96       	adiw	r24, 0x05	; 5
    1d5a:	9e 01       	movw	r18, r28
    1d5c:	24 5f       	subi	r18, 0xF4	; 244
    1d5e:	3f 4f       	sbci	r19, 0xFF	; 255
    1d60:	b9 01       	movw	r22, r18
    1d62:	0e 94 8d 19 	call	0x331a	; 0x331a <xTaskCheckForTimeOut>
    1d66:	88 23       	and	r24, r24
    1d68:	09 f5       	brne	.+66     	; 0x1dac <xQueueReceive+0x126>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1d6a:	8a 81       	ldd	r24, Y+2	; 0x02
    1d6c:	9b 81       	ldd	r25, Y+3	; 0x03
    1d6e:	0e 94 80 12 	call	0x2500	; 0x2500 <prvIsQueueEmpty>
    1d72:	88 23       	and	r24, r24
    1d74:	a1 f0       	breq	.+40     	; 0x1d9e <xQueueReceive+0x118>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1d76:	8a 81       	ldd	r24, Y+2	; 0x02
    1d78:	9b 81       	ldd	r25, Y+3	; 0x03
    1d7a:	41 96       	adiw	r24, 0x11	; 17
    1d7c:	2c 85       	ldd	r18, Y+12	; 0x0c
    1d7e:	3d 85       	ldd	r19, Y+13	; 0x0d
    1d80:	b9 01       	movw	r22, r18
    1d82:	0e 94 3c 18 	call	0x3078	; 0x3078 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1d86:	8a 81       	ldd	r24, Y+2	; 0x02
    1d88:	9b 81       	ldd	r25, Y+3	; 0x03
    1d8a:	0e 94 2d 12 	call	0x245a	; 0x245a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1d8e:	0e 94 fa 15 	call	0x2bf4	; 0x2bf4 <xTaskResumeAll>
    1d92:	88 23       	and	r24, r24
    1d94:	09 f0       	breq	.+2      	; 0x1d98 <xQueueReceive+0x112>
    1d96:	8c cf       	rjmp	.-232    	; 0x1cb0 <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    1d98:	0e 94 a7 0a 	call	0x154e	; 0x154e <vPortYield>
    1d9c:	89 cf       	rjmp	.-238    	; 0x1cb0 <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    1d9e:	8a 81       	ldd	r24, Y+2	; 0x02
    1da0:	9b 81       	ldd	r25, Y+3	; 0x03
    1da2:	0e 94 2d 12 	call	0x245a	; 0x245a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1da6:	0e 94 fa 15 	call	0x2bf4	; 0x2bf4 <xTaskResumeAll>
    1daa:	82 cf       	rjmp	.-252    	; 0x1cb0 <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    1dac:	8a 81       	ldd	r24, Y+2	; 0x02
    1dae:	9b 81       	ldd	r25, Y+3	; 0x03
    1db0:	0e 94 2d 12 	call	0x245a	; 0x245a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1db4:	0e 94 fa 15 	call	0x2bf4	; 0x2bf4 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1db8:	8a 81       	ldd	r24, Y+2	; 0x02
    1dba:	9b 81       	ldd	r25, Y+3	; 0x03
    1dbc:	0e 94 80 12 	call	0x2500	; 0x2500 <prvIsQueueEmpty>
    1dc0:	88 23       	and	r24, r24
    1dc2:	09 f4       	brne	.+2      	; 0x1dc6 <xQueueReceive+0x140>
    1dc4:	75 cf       	rjmp	.-278    	; 0x1cb0 <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1dc6:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    1dc8:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    1dca:	2e 96       	adiw	r28, 0x0e	; 14
    1dcc:	0f b6       	in	r0, 0x3f	; 63
    1dce:	f8 94       	cli
    1dd0:	de bf       	out	0x3e, r29	; 62
    1dd2:	0f be       	out	0x3f, r0	; 63
    1dd4:	cd bf       	out	0x3d, r28	; 61
    1dd6:	cf 91       	pop	r28
    1dd8:	df 91       	pop	r29
    1dda:	08 95       	ret

00001ddc <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    1ddc:	df 93       	push	r29
    1dde:	cf 93       	push	r28
    1de0:	cd b7       	in	r28, 0x3d	; 61
    1de2:	de b7       	in	r29, 0x3e	; 62
    1de4:	2c 97       	sbiw	r28, 0x0c	; 12
    1de6:	0f b6       	in	r0, 0x3f	; 63
    1de8:	f8 94       	cli
    1dea:	de bf       	out	0x3e, r29	; 62
    1dec:	0f be       	out	0x3f, r0	; 63
    1dee:	cd bf       	out	0x3d, r28	; 61
    1df0:	99 87       	std	Y+9, r25	; 0x09
    1df2:	88 87       	std	Y+8, r24	; 0x08
    1df4:	7b 87       	std	Y+11, r23	; 0x0b
    1df6:	6a 87       	std	Y+10, r22	; 0x0a
BaseType_t xEntryTimeSet = pdFALSE;
    1df8:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    1dfa:	88 85       	ldd	r24, Y+8	; 0x08
    1dfc:	99 85       	ldd	r25, Y+9	; 0x09
    1dfe:	9b 83       	std	Y+3, r25	; 0x03
    1e00:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1e02:	0f b6       	in	r0, 0x3f	; 63
    1e04:	f8 94       	cli
    1e06:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    1e08:	ea 81       	ldd	r30, Y+2	; 0x02
    1e0a:	fb 81       	ldd	r31, Y+3	; 0x03
    1e0c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e0e:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    1e10:	89 81       	ldd	r24, Y+1	; 0x01
    1e12:	88 23       	and	r24, r24
    1e14:	c1 f0       	breq	.+48     	; 0x1e46 <xQueueSemaphoreTake+0x6a>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    1e16:	89 81       	ldd	r24, Y+1	; 0x01
    1e18:	81 50       	subi	r24, 0x01	; 1
    1e1a:	ea 81       	ldd	r30, Y+2	; 0x02
    1e1c:	fb 81       	ldd	r31, Y+3	; 0x03
    1e1e:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1e20:	ea 81       	ldd	r30, Y+2	; 0x02
    1e22:	fb 81       	ldd	r31, Y+3	; 0x03
    1e24:	80 85       	ldd	r24, Z+8	; 0x08
    1e26:	88 23       	and	r24, r24
    1e28:	49 f0       	breq	.+18     	; 0x1e3c <xQueueSemaphoreTake+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1e2a:	8a 81       	ldd	r24, Y+2	; 0x02
    1e2c:	9b 81       	ldd	r25, Y+3	; 0x03
    1e2e:	08 96       	adiw	r24, 0x08	; 8
    1e30:	0e 94 8e 18 	call	0x311c	; 0x311c <xTaskRemoveFromEventList>
    1e34:	88 23       	and	r24, r24
    1e36:	11 f0       	breq	.+4      	; 0x1e3c <xQueueSemaphoreTake+0x60>
					{
						queueYIELD_IF_USING_PREEMPTION();
    1e38:	0e 94 a7 0a 	call	0x154e	; 0x154e <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1e3c:	0f 90       	pop	r0
    1e3e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1e40:	81 e0       	ldi	r24, 0x01	; 1
    1e42:	8c 87       	std	Y+12, r24	; 0x0c
    1e44:	63 c0       	rjmp	.+198    	; 0x1f0c <xQueueSemaphoreTake+0x130>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1e46:	8a 85       	ldd	r24, Y+10	; 0x0a
    1e48:	9b 85       	ldd	r25, Y+11	; 0x0b
    1e4a:	00 97       	sbiw	r24, 0x00	; 0
    1e4c:	21 f4       	brne	.+8      	; 0x1e56 <xQueueSemaphoreTake+0x7a>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    1e4e:	0f 90       	pop	r0
    1e50:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1e52:	1c 86       	std	Y+12, r1	; 0x0c
    1e54:	5b c0       	rjmp	.+182    	; 0x1f0c <xQueueSemaphoreTake+0x130>
				}
				else if( xEntryTimeSet == pdFALSE )
    1e56:	8c 81       	ldd	r24, Y+4	; 0x04
    1e58:	88 23       	and	r24, r24
    1e5a:	31 f4       	brne	.+12     	; 0x1e68 <xQueueSemaphoreTake+0x8c>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1e5c:	ce 01       	movw	r24, r28
    1e5e:	05 96       	adiw	r24, 0x05	; 5
    1e60:	0e 94 74 19 	call	0x32e8	; 0x32e8 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1e64:	81 e0       	ldi	r24, 0x01	; 1
    1e66:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1e68:	0f 90       	pop	r0
    1e6a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    1e6c:	0e 94 ee 15 	call	0x2bdc	; 0x2bdc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1e70:	0f b6       	in	r0, 0x3f	; 63
    1e72:	f8 94       	cli
    1e74:	0f 92       	push	r0
    1e76:	ea 81       	ldd	r30, Y+2	; 0x02
    1e78:	fb 81       	ldd	r31, Y+3	; 0x03
    1e7a:	85 8d       	ldd	r24, Z+29	; 0x1d
    1e7c:	8f 3f       	cpi	r24, 0xFF	; 255
    1e7e:	19 f4       	brne	.+6      	; 0x1e86 <xQueueSemaphoreTake+0xaa>
    1e80:	ea 81       	ldd	r30, Y+2	; 0x02
    1e82:	fb 81       	ldd	r31, Y+3	; 0x03
    1e84:	15 8e       	std	Z+29, r1	; 0x1d
    1e86:	ea 81       	ldd	r30, Y+2	; 0x02
    1e88:	fb 81       	ldd	r31, Y+3	; 0x03
    1e8a:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e8c:	8f 3f       	cpi	r24, 0xFF	; 255
    1e8e:	19 f4       	brne	.+6      	; 0x1e96 <xQueueSemaphoreTake+0xba>
    1e90:	ea 81       	ldd	r30, Y+2	; 0x02
    1e92:	fb 81       	ldd	r31, Y+3	; 0x03
    1e94:	16 8e       	std	Z+30, r1	; 0x1e
    1e96:	0f 90       	pop	r0
    1e98:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1e9a:	ce 01       	movw	r24, r28
    1e9c:	05 96       	adiw	r24, 0x05	; 5
    1e9e:	9e 01       	movw	r18, r28
    1ea0:	26 5f       	subi	r18, 0xF6	; 246
    1ea2:	3f 4f       	sbci	r19, 0xFF	; 255
    1ea4:	b9 01       	movw	r22, r18
    1ea6:	0e 94 8d 19 	call	0x331a	; 0x331a <xTaskCheckForTimeOut>
    1eaa:	88 23       	and	r24, r24
    1eac:	09 f5       	brne	.+66     	; 0x1ef0 <xQueueSemaphoreTake+0x114>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1eae:	8a 81       	ldd	r24, Y+2	; 0x02
    1eb0:	9b 81       	ldd	r25, Y+3	; 0x03
    1eb2:	0e 94 80 12 	call	0x2500	; 0x2500 <prvIsQueueEmpty>
    1eb6:	88 23       	and	r24, r24
    1eb8:	a1 f0       	breq	.+40     	; 0x1ee2 <xQueueSemaphoreTake+0x106>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1eba:	8a 81       	ldd	r24, Y+2	; 0x02
    1ebc:	9b 81       	ldd	r25, Y+3	; 0x03
    1ebe:	41 96       	adiw	r24, 0x11	; 17
    1ec0:	2a 85       	ldd	r18, Y+10	; 0x0a
    1ec2:	3b 85       	ldd	r19, Y+11	; 0x0b
    1ec4:	b9 01       	movw	r22, r18
    1ec6:	0e 94 3c 18 	call	0x3078	; 0x3078 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1eca:	8a 81       	ldd	r24, Y+2	; 0x02
    1ecc:	9b 81       	ldd	r25, Y+3	; 0x03
    1ece:	0e 94 2d 12 	call	0x245a	; 0x245a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1ed2:	0e 94 fa 15 	call	0x2bf4	; 0x2bf4 <xTaskResumeAll>
    1ed6:	88 23       	and	r24, r24
    1ed8:	09 f0       	breq	.+2      	; 0x1edc <xQueueSemaphoreTake+0x100>
    1eda:	93 cf       	rjmp	.-218    	; 0x1e02 <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    1edc:	0e 94 a7 0a 	call	0x154e	; 0x154e <vPortYield>
    1ee0:	90 cf       	rjmp	.-224    	; 0x1e02 <xQueueSemaphoreTake+0x26>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    1ee2:	8a 81       	ldd	r24, Y+2	; 0x02
    1ee4:	9b 81       	ldd	r25, Y+3	; 0x03
    1ee6:	0e 94 2d 12 	call	0x245a	; 0x245a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1eea:	0e 94 fa 15 	call	0x2bf4	; 0x2bf4 <xTaskResumeAll>
    1eee:	89 cf       	rjmp	.-238    	; 0x1e02 <xQueueSemaphoreTake+0x26>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    1ef0:	8a 81       	ldd	r24, Y+2	; 0x02
    1ef2:	9b 81       	ldd	r25, Y+3	; 0x03
    1ef4:	0e 94 2d 12 	call	0x245a	; 0x245a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1ef8:	0e 94 fa 15 	call	0x2bf4	; 0x2bf4 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1efc:	8a 81       	ldd	r24, Y+2	; 0x02
    1efe:	9b 81       	ldd	r25, Y+3	; 0x03
    1f00:	0e 94 80 12 	call	0x2500	; 0x2500 <prvIsQueueEmpty>
    1f04:	88 23       	and	r24, r24
    1f06:	09 f4       	brne	.+2      	; 0x1f0a <xQueueSemaphoreTake+0x12e>
    1f08:	7c cf       	rjmp	.-264    	; 0x1e02 <xQueueSemaphoreTake+0x26>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1f0a:	1c 86       	std	Y+12, r1	; 0x0c
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    1f0c:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    1f0e:	2c 96       	adiw	r28, 0x0c	; 12
    1f10:	0f b6       	in	r0, 0x3f	; 63
    1f12:	f8 94       	cli
    1f14:	de bf       	out	0x3e, r29	; 62
    1f16:	0f be       	out	0x3f, r0	; 63
    1f18:	cd bf       	out	0x3d, r28	; 61
    1f1a:	cf 91       	pop	r28
    1f1c:	df 91       	pop	r29
    1f1e:	08 95       	ret

00001f20 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1f20:	df 93       	push	r29
    1f22:	cf 93       	push	r28
    1f24:	cd b7       	in	r28, 0x3d	; 61
    1f26:	de b7       	in	r29, 0x3e	; 62
    1f28:	60 97       	sbiw	r28, 0x10	; 16
    1f2a:	0f b6       	in	r0, 0x3f	; 63
    1f2c:	f8 94       	cli
    1f2e:	de bf       	out	0x3e, r29	; 62
    1f30:	0f be       	out	0x3f, r0	; 63
    1f32:	cd bf       	out	0x3d, r28	; 61
    1f34:	9b 87       	std	Y+11, r25	; 0x0b
    1f36:	8a 87       	std	Y+10, r24	; 0x0a
    1f38:	7d 87       	std	Y+13, r23	; 0x0d
    1f3a:	6c 87       	std	Y+12, r22	; 0x0c
    1f3c:	5f 87       	std	Y+15, r21	; 0x0f
    1f3e:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    1f40:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    1f42:	8a 85       	ldd	r24, Y+10	; 0x0a
    1f44:	9b 85       	ldd	r25, Y+11	; 0x0b
    1f46:	9b 83       	std	Y+3, r25	; 0x03
    1f48:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1f4a:	0f b6       	in	r0, 0x3f	; 63
    1f4c:	f8 94       	cli
    1f4e:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1f50:	ea 81       	ldd	r30, Y+2	; 0x02
    1f52:	fb 81       	ldd	r31, Y+3	; 0x03
    1f54:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f56:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1f58:	89 81       	ldd	r24, Y+1	; 0x01
    1f5a:	88 23       	and	r24, r24
    1f5c:	31 f1       	breq	.+76     	; 0x1faa <xQueuePeek+0x8a>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1f5e:	ea 81       	ldd	r30, Y+2	; 0x02
    1f60:	fb 81       	ldd	r31, Y+3	; 0x03
    1f62:	86 81       	ldd	r24, Z+6	; 0x06
    1f64:	97 81       	ldd	r25, Z+7	; 0x07
    1f66:	9d 83       	std	Y+5, r25	; 0x05
    1f68:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1f6a:	8a 81       	ldd	r24, Y+2	; 0x02
    1f6c:	9b 81       	ldd	r25, Y+3	; 0x03
    1f6e:	2c 85       	ldd	r18, Y+12	; 0x0c
    1f70:	3d 85       	ldd	r19, Y+13	; 0x0d
    1f72:	b9 01       	movw	r22, r18
    1f74:	0e 94 e6 11 	call	0x23cc	; 0x23cc <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1f78:	ea 81       	ldd	r30, Y+2	; 0x02
    1f7a:	fb 81       	ldd	r31, Y+3	; 0x03
    1f7c:	8c 81       	ldd	r24, Y+4	; 0x04
    1f7e:	9d 81       	ldd	r25, Y+5	; 0x05
    1f80:	97 83       	std	Z+7, r25	; 0x07
    1f82:	86 83       	std	Z+6, r24	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1f84:	ea 81       	ldd	r30, Y+2	; 0x02
    1f86:	fb 81       	ldd	r31, Y+3	; 0x03
    1f88:	81 89       	ldd	r24, Z+17	; 0x11
    1f8a:	88 23       	and	r24, r24
    1f8c:	49 f0       	breq	.+18     	; 0x1fa0 <xQueuePeek+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1f8e:	8a 81       	ldd	r24, Y+2	; 0x02
    1f90:	9b 81       	ldd	r25, Y+3	; 0x03
    1f92:	41 96       	adiw	r24, 0x11	; 17
    1f94:	0e 94 8e 18 	call	0x311c	; 0x311c <xTaskRemoveFromEventList>
    1f98:	88 23       	and	r24, r24
    1f9a:	11 f0       	breq	.+4      	; 0x1fa0 <xQueuePeek+0x80>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    1f9c:	0e 94 a7 0a 	call	0x154e	; 0x154e <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1fa0:	0f 90       	pop	r0
    1fa2:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1fa4:	81 e0       	ldi	r24, 0x01	; 1
    1fa6:	88 8b       	std	Y+16, r24	; 0x10
    1fa8:	63 c0       	rjmp	.+198    	; 0x2070 <xQueuePeek+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1faa:	8e 85       	ldd	r24, Y+14	; 0x0e
    1fac:	9f 85       	ldd	r25, Y+15	; 0x0f
    1fae:	00 97       	sbiw	r24, 0x00	; 0
    1fb0:	21 f4       	brne	.+8      	; 0x1fba <xQueuePeek+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1fb2:	0f 90       	pop	r0
    1fb4:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1fb6:	18 8a       	std	Y+16, r1	; 0x10
    1fb8:	5b c0       	rjmp	.+182    	; 0x2070 <xQueuePeek+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    1fba:	8e 81       	ldd	r24, Y+6	; 0x06
    1fbc:	88 23       	and	r24, r24
    1fbe:	31 f4       	brne	.+12     	; 0x1fcc <xQueuePeek+0xac>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1fc0:	ce 01       	movw	r24, r28
    1fc2:	07 96       	adiw	r24, 0x07	; 7
    1fc4:	0e 94 74 19 	call	0x32e8	; 0x32e8 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1fc8:	81 e0       	ldi	r24, 0x01	; 1
    1fca:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1fcc:	0f 90       	pop	r0
    1fce:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1fd0:	0e 94 ee 15 	call	0x2bdc	; 0x2bdc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1fd4:	0f b6       	in	r0, 0x3f	; 63
    1fd6:	f8 94       	cli
    1fd8:	0f 92       	push	r0
    1fda:	ea 81       	ldd	r30, Y+2	; 0x02
    1fdc:	fb 81       	ldd	r31, Y+3	; 0x03
    1fde:	85 8d       	ldd	r24, Z+29	; 0x1d
    1fe0:	8f 3f       	cpi	r24, 0xFF	; 255
    1fe2:	19 f4       	brne	.+6      	; 0x1fea <xQueuePeek+0xca>
    1fe4:	ea 81       	ldd	r30, Y+2	; 0x02
    1fe6:	fb 81       	ldd	r31, Y+3	; 0x03
    1fe8:	15 8e       	std	Z+29, r1	; 0x1d
    1fea:	ea 81       	ldd	r30, Y+2	; 0x02
    1fec:	fb 81       	ldd	r31, Y+3	; 0x03
    1fee:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ff0:	8f 3f       	cpi	r24, 0xFF	; 255
    1ff2:	19 f4       	brne	.+6      	; 0x1ffa <xQueuePeek+0xda>
    1ff4:	ea 81       	ldd	r30, Y+2	; 0x02
    1ff6:	fb 81       	ldd	r31, Y+3	; 0x03
    1ff8:	16 8e       	std	Z+30, r1	; 0x1e
    1ffa:	0f 90       	pop	r0
    1ffc:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1ffe:	ce 01       	movw	r24, r28
    2000:	07 96       	adiw	r24, 0x07	; 7
    2002:	9e 01       	movw	r18, r28
    2004:	22 5f       	subi	r18, 0xF2	; 242
    2006:	3f 4f       	sbci	r19, 0xFF	; 255
    2008:	b9 01       	movw	r22, r18
    200a:	0e 94 8d 19 	call	0x331a	; 0x331a <xTaskCheckForTimeOut>
    200e:	88 23       	and	r24, r24
    2010:	09 f5       	brne	.+66     	; 0x2054 <xQueuePeek+0x134>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2012:	8a 81       	ldd	r24, Y+2	; 0x02
    2014:	9b 81       	ldd	r25, Y+3	; 0x03
    2016:	0e 94 80 12 	call	0x2500	; 0x2500 <prvIsQueueEmpty>
    201a:	88 23       	and	r24, r24
    201c:	a1 f0       	breq	.+40     	; 0x2046 <xQueuePeek+0x126>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    201e:	8a 81       	ldd	r24, Y+2	; 0x02
    2020:	9b 81       	ldd	r25, Y+3	; 0x03
    2022:	41 96       	adiw	r24, 0x11	; 17
    2024:	2e 85       	ldd	r18, Y+14	; 0x0e
    2026:	3f 85       	ldd	r19, Y+15	; 0x0f
    2028:	b9 01       	movw	r22, r18
    202a:	0e 94 3c 18 	call	0x3078	; 0x3078 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    202e:	8a 81       	ldd	r24, Y+2	; 0x02
    2030:	9b 81       	ldd	r25, Y+3	; 0x03
    2032:	0e 94 2d 12 	call	0x245a	; 0x245a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2036:	0e 94 fa 15 	call	0x2bf4	; 0x2bf4 <xTaskResumeAll>
    203a:	88 23       	and	r24, r24
    203c:	09 f0       	breq	.+2      	; 0x2040 <xQueuePeek+0x120>
    203e:	85 cf       	rjmp	.-246    	; 0x1f4a <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    2040:	0e 94 a7 0a 	call	0x154e	; 0x154e <vPortYield>
    2044:	82 cf       	rjmp	.-252    	; 0x1f4a <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    2046:	8a 81       	ldd	r24, Y+2	; 0x02
    2048:	9b 81       	ldd	r25, Y+3	; 0x03
    204a:	0e 94 2d 12 	call	0x245a	; 0x245a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    204e:	0e 94 fa 15 	call	0x2bf4	; 0x2bf4 <xTaskResumeAll>
    2052:	7b cf       	rjmp	.-266    	; 0x1f4a <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    2054:	8a 81       	ldd	r24, Y+2	; 0x02
    2056:	9b 81       	ldd	r25, Y+3	; 0x03
    2058:	0e 94 2d 12 	call	0x245a	; 0x245a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    205c:	0e 94 fa 15 	call	0x2bf4	; 0x2bf4 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2060:	8a 81       	ldd	r24, Y+2	; 0x02
    2062:	9b 81       	ldd	r25, Y+3	; 0x03
    2064:	0e 94 80 12 	call	0x2500	; 0x2500 <prvIsQueueEmpty>
    2068:	88 23       	and	r24, r24
    206a:	09 f4       	brne	.+2      	; 0x206e <xQueuePeek+0x14e>
    206c:	6e cf       	rjmp	.-292    	; 0x1f4a <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    206e:	18 8a       	std	Y+16, r1	; 0x10
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    2070:	88 89       	ldd	r24, Y+16	; 0x10
}
    2072:	60 96       	adiw	r28, 0x10	; 16
    2074:	0f b6       	in	r0, 0x3f	; 63
    2076:	f8 94       	cli
    2078:	de bf       	out	0x3e, r29	; 62
    207a:	0f be       	out	0x3f, r0	; 63
    207c:	cd bf       	out	0x3d, r28	; 61
    207e:	cf 91       	pop	r28
    2080:	df 91       	pop	r29
    2082:	08 95       	ret

00002084 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    2084:	df 93       	push	r29
    2086:	cf 93       	push	r28
    2088:	cd b7       	in	r28, 0x3d	; 61
    208a:	de b7       	in	r29, 0x3e	; 62
    208c:	2c 97       	sbiw	r28, 0x0c	; 12
    208e:	0f b6       	in	r0, 0x3f	; 63
    2090:	f8 94       	cli
    2092:	de bf       	out	0x3e, r29	; 62
    2094:	0f be       	out	0x3f, r0	; 63
    2096:	cd bf       	out	0x3d, r28	; 61
    2098:	98 87       	std	Y+8, r25	; 0x08
    209a:	8f 83       	std	Y+7, r24	; 0x07
    209c:	7a 87       	std	Y+10, r23	; 0x0a
    209e:	69 87       	std	Y+9, r22	; 0x09
    20a0:	5c 87       	std	Y+12, r21	; 0x0c
    20a2:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    20a4:	8f 81       	ldd	r24, Y+7	; 0x07
    20a6:	98 85       	ldd	r25, Y+8	; 0x08
    20a8:	9c 83       	std	Y+4, r25	; 0x04
    20aa:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    20ac:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    20ae:	eb 81       	ldd	r30, Y+3	; 0x03
    20b0:	fc 81       	ldd	r31, Y+4	; 0x04
    20b2:	82 8d       	ldd	r24, Z+26	; 0x1a
    20b4:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    20b6:	8a 81       	ldd	r24, Y+2	; 0x02
    20b8:	88 23       	and	r24, r24
    20ba:	81 f1       	breq	.+96     	; 0x211c <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    20bc:	eb 81       	ldd	r30, Y+3	; 0x03
    20be:	fc 81       	ldd	r31, Y+4	; 0x04
    20c0:	85 8d       	ldd	r24, Z+29	; 0x1d
    20c2:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    20c4:	8b 81       	ldd	r24, Y+3	; 0x03
    20c6:	9c 81       	ldd	r25, Y+4	; 0x04
    20c8:	29 85       	ldd	r18, Y+9	; 0x09
    20ca:	3a 85       	ldd	r19, Y+10	; 0x0a
    20cc:	b9 01       	movw	r22, r18
    20ce:	0e 94 e6 11 	call	0x23cc	; 0x23cc <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    20d2:	8a 81       	ldd	r24, Y+2	; 0x02
    20d4:	81 50       	subi	r24, 0x01	; 1
    20d6:	eb 81       	ldd	r30, Y+3	; 0x03
    20d8:	fc 81       	ldd	r31, Y+4	; 0x04
    20da:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    20dc:	89 81       	ldd	r24, Y+1	; 0x01
    20de:	8f 3f       	cpi	r24, 0xFF	; 255
    20e0:	a9 f4       	brne	.+42     	; 0x210c <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    20e2:	eb 81       	ldd	r30, Y+3	; 0x03
    20e4:	fc 81       	ldd	r31, Y+4	; 0x04
    20e6:	80 85       	ldd	r24, Z+8	; 0x08
    20e8:	88 23       	and	r24, r24
    20ea:	a9 f0       	breq	.+42     	; 0x2116 <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    20ec:	8b 81       	ldd	r24, Y+3	; 0x03
    20ee:	9c 81       	ldd	r25, Y+4	; 0x04
    20f0:	08 96       	adiw	r24, 0x08	; 8
    20f2:	0e 94 8e 18 	call	0x311c	; 0x311c <xTaskRemoveFromEventList>
    20f6:	88 23       	and	r24, r24
    20f8:	71 f0       	breq	.+28     	; 0x2116 <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    20fa:	8b 85       	ldd	r24, Y+11	; 0x0b
    20fc:	9c 85       	ldd	r25, Y+12	; 0x0c
    20fe:	00 97       	sbiw	r24, 0x00	; 0
    2100:	51 f0       	breq	.+20     	; 0x2116 <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    2102:	eb 85       	ldd	r30, Y+11	; 0x0b
    2104:	fc 85       	ldd	r31, Y+12	; 0x0c
    2106:	81 e0       	ldi	r24, 0x01	; 1
    2108:	80 83       	st	Z, r24
    210a:	05 c0       	rjmp	.+10     	; 0x2116 <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    210c:	89 81       	ldd	r24, Y+1	; 0x01
    210e:	8f 5f       	subi	r24, 0xFF	; 255
    2110:	eb 81       	ldd	r30, Y+3	; 0x03
    2112:	fc 81       	ldd	r31, Y+4	; 0x04
    2114:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    2116:	81 e0       	ldi	r24, 0x01	; 1
    2118:	8e 83       	std	Y+6, r24	; 0x06
    211a:	01 c0       	rjmp	.+2      	; 0x211e <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    211c:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    211e:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2120:	2c 96       	adiw	r28, 0x0c	; 12
    2122:	0f b6       	in	r0, 0x3f	; 63
    2124:	f8 94       	cli
    2126:	de bf       	out	0x3e, r29	; 62
    2128:	0f be       	out	0x3f, r0	; 63
    212a:	cd bf       	out	0x3d, r28	; 61
    212c:	cf 91       	pop	r28
    212e:	df 91       	pop	r29
    2130:	08 95       	ret

00002132 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    2132:	df 93       	push	r29
    2134:	cf 93       	push	r28
    2136:	cd b7       	in	r28, 0x3d	; 61
    2138:	de b7       	in	r29, 0x3e	; 62
    213a:	2a 97       	sbiw	r28, 0x0a	; 10
    213c:	0f b6       	in	r0, 0x3f	; 63
    213e:	f8 94       	cli
    2140:	de bf       	out	0x3e, r29	; 62
    2142:	0f be       	out	0x3f, r0	; 63
    2144:	cd bf       	out	0x3d, r28	; 61
    2146:	98 87       	std	Y+8, r25	; 0x08
    2148:	8f 83       	std	Y+7, r24	; 0x07
    214a:	7a 87       	std	Y+10, r23	; 0x0a
    214c:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    214e:	8f 81       	ldd	r24, Y+7	; 0x07
    2150:	98 85       	ldd	r25, Y+8	; 0x08
    2152:	9a 83       	std	Y+2, r25	; 0x02
    2154:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2156:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2158:	e9 81       	ldd	r30, Y+1	; 0x01
    215a:	fa 81       	ldd	r31, Y+2	; 0x02
    215c:	82 8d       	ldd	r24, Z+26	; 0x1a
    215e:	88 23       	and	r24, r24
    2160:	b1 f0       	breq	.+44     	; 0x218e <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2162:	e9 81       	ldd	r30, Y+1	; 0x01
    2164:	fa 81       	ldd	r31, Y+2	; 0x02
    2166:	86 81       	ldd	r24, Z+6	; 0x06
    2168:	97 81       	ldd	r25, Z+7	; 0x07
    216a:	9c 83       	std	Y+4, r25	; 0x04
    216c:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    216e:	89 81       	ldd	r24, Y+1	; 0x01
    2170:	9a 81       	ldd	r25, Y+2	; 0x02
    2172:	29 85       	ldd	r18, Y+9	; 0x09
    2174:	3a 85       	ldd	r19, Y+10	; 0x0a
    2176:	b9 01       	movw	r22, r18
    2178:	0e 94 e6 11 	call	0x23cc	; 0x23cc <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    217c:	e9 81       	ldd	r30, Y+1	; 0x01
    217e:	fa 81       	ldd	r31, Y+2	; 0x02
    2180:	8b 81       	ldd	r24, Y+3	; 0x03
    2182:	9c 81       	ldd	r25, Y+4	; 0x04
    2184:	97 83       	std	Z+7, r25	; 0x07
    2186:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    2188:	81 e0       	ldi	r24, 0x01	; 1
    218a:	8e 83       	std	Y+6, r24	; 0x06
    218c:	01 c0       	rjmp	.+2      	; 0x2190 <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    218e:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2190:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2192:	2a 96       	adiw	r28, 0x0a	; 10
    2194:	0f b6       	in	r0, 0x3f	; 63
    2196:	f8 94       	cli
    2198:	de bf       	out	0x3e, r29	; 62
    219a:	0f be       	out	0x3f, r0	; 63
    219c:	cd bf       	out	0x3d, r28	; 61
    219e:	cf 91       	pop	r28
    21a0:	df 91       	pop	r29
    21a2:	08 95       	ret

000021a4 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    21a4:	df 93       	push	r29
    21a6:	cf 93       	push	r28
    21a8:	00 d0       	rcall	.+0      	; 0x21aa <uxQueueMessagesWaiting+0x6>
    21aa:	0f 92       	push	r0
    21ac:	cd b7       	in	r28, 0x3d	; 61
    21ae:	de b7       	in	r29, 0x3e	; 62
    21b0:	9b 83       	std	Y+3, r25	; 0x03
    21b2:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    21b4:	0f b6       	in	r0, 0x3f	; 63
    21b6:	f8 94       	cli
    21b8:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    21ba:	ea 81       	ldd	r30, Y+2	; 0x02
    21bc:	fb 81       	ldd	r31, Y+3	; 0x03
    21be:	82 8d       	ldd	r24, Z+26	; 0x1a
    21c0:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    21c2:	0f 90       	pop	r0
    21c4:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    21c6:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    21c8:	0f 90       	pop	r0
    21ca:	0f 90       	pop	r0
    21cc:	0f 90       	pop	r0
    21ce:	cf 91       	pop	r28
    21d0:	df 91       	pop	r29
    21d2:	08 95       	ret

000021d4 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    21d4:	df 93       	push	r29
    21d6:	cf 93       	push	r28
    21d8:	00 d0       	rcall	.+0      	; 0x21da <uxQueueSpacesAvailable+0x6>
    21da:	00 d0       	rcall	.+0      	; 0x21dc <uxQueueSpacesAvailable+0x8>
    21dc:	0f 92       	push	r0
    21de:	cd b7       	in	r28, 0x3d	; 61
    21e0:	de b7       	in	r29, 0x3e	; 62
    21e2:	9d 83       	std	Y+5, r25	; 0x05
    21e4:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    21e6:	8c 81       	ldd	r24, Y+4	; 0x04
    21e8:	9d 81       	ldd	r25, Y+5	; 0x05
    21ea:	9a 83       	std	Y+2, r25	; 0x02
    21ec:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    21ee:	0f b6       	in	r0, 0x3f	; 63
    21f0:	f8 94       	cli
    21f2:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    21f4:	e9 81       	ldd	r30, Y+1	; 0x01
    21f6:	fa 81       	ldd	r31, Y+2	; 0x02
    21f8:	93 8d       	ldd	r25, Z+27	; 0x1b
    21fa:	e9 81       	ldd	r30, Y+1	; 0x01
    21fc:	fa 81       	ldd	r31, Y+2	; 0x02
    21fe:	82 8d       	ldd	r24, Z+26	; 0x1a
    2200:	29 2f       	mov	r18, r25
    2202:	28 1b       	sub	r18, r24
    2204:	82 2f       	mov	r24, r18
    2206:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    2208:	0f 90       	pop	r0
    220a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    220c:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    220e:	0f 90       	pop	r0
    2210:	0f 90       	pop	r0
    2212:	0f 90       	pop	r0
    2214:	0f 90       	pop	r0
    2216:	0f 90       	pop	r0
    2218:	cf 91       	pop	r28
    221a:	df 91       	pop	r29
    221c:	08 95       	ret

0000221e <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    221e:	df 93       	push	r29
    2220:	cf 93       	push	r28
    2222:	00 d0       	rcall	.+0      	; 0x2224 <uxQueueMessagesWaitingFromISR+0x6>
    2224:	00 d0       	rcall	.+0      	; 0x2226 <uxQueueMessagesWaitingFromISR+0x8>
    2226:	0f 92       	push	r0
    2228:	cd b7       	in	r28, 0x3d	; 61
    222a:	de b7       	in	r29, 0x3e	; 62
    222c:	9d 83       	std	Y+5, r25	; 0x05
    222e:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    2230:	8c 81       	ldd	r24, Y+4	; 0x04
    2232:	9d 81       	ldd	r25, Y+5	; 0x05
    2234:	9a 83       	std	Y+2, r25	; 0x02
    2236:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    2238:	e9 81       	ldd	r30, Y+1	; 0x01
    223a:	fa 81       	ldd	r31, Y+2	; 0x02
    223c:	82 8d       	ldd	r24, Z+26	; 0x1a
    223e:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    2240:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2242:	0f 90       	pop	r0
    2244:	0f 90       	pop	r0
    2246:	0f 90       	pop	r0
    2248:	0f 90       	pop	r0
    224a:	0f 90       	pop	r0
    224c:	cf 91       	pop	r28
    224e:	df 91       	pop	r29
    2250:	08 95       	ret

00002252 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    2252:	df 93       	push	r29
    2254:	cf 93       	push	r28
    2256:	00 d0       	rcall	.+0      	; 0x2258 <vQueueDelete+0x6>
    2258:	00 d0       	rcall	.+0      	; 0x225a <vQueueDelete+0x8>
    225a:	cd b7       	in	r28, 0x3d	; 61
    225c:	de b7       	in	r29, 0x3e	; 62
    225e:	9c 83       	std	Y+4, r25	; 0x04
    2260:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    2262:	8b 81       	ldd	r24, Y+3	; 0x03
    2264:	9c 81       	ldd	r25, Y+4	; 0x04
    2266:	9a 83       	std	Y+2, r25	; 0x02
    2268:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    226a:	89 81       	ldd	r24, Y+1	; 0x01
    226c:	9a 81       	ldd	r25, Y+2	; 0x02
    226e:	0e 94 05 07 	call	0xe0a	; 0xe0a <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    2272:	0f 90       	pop	r0
    2274:	0f 90       	pop	r0
    2276:	0f 90       	pop	r0
    2278:	0f 90       	pop	r0
    227a:	cf 91       	pop	r28
    227c:	df 91       	pop	r29
    227e:	08 95       	ret

00002280 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    2280:	df 93       	push	r29
    2282:	cf 93       	push	r28
    2284:	cd b7       	in	r28, 0x3d	; 61
    2286:	de b7       	in	r29, 0x3e	; 62
    2288:	27 97       	sbiw	r28, 0x07	; 7
    228a:	0f b6       	in	r0, 0x3f	; 63
    228c:	f8 94       	cli
    228e:	de bf       	out	0x3e, r29	; 62
    2290:	0f be       	out	0x3f, r0	; 63
    2292:	cd bf       	out	0x3d, r28	; 61
    2294:	9c 83       	std	Y+4, r25	; 0x04
    2296:	8b 83       	std	Y+3, r24	; 0x03
    2298:	7e 83       	std	Y+6, r23	; 0x06
    229a:	6d 83       	std	Y+5, r22	; 0x05
    229c:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    229e:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    22a0:	eb 81       	ldd	r30, Y+3	; 0x03
    22a2:	fc 81       	ldd	r31, Y+4	; 0x04
    22a4:	82 8d       	ldd	r24, Z+26	; 0x1a
    22a6:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    22a8:	eb 81       	ldd	r30, Y+3	; 0x03
    22aa:	fc 81       	ldd	r31, Y+4	; 0x04
    22ac:	84 8d       	ldd	r24, Z+28	; 0x1c
    22ae:	88 23       	and	r24, r24
    22b0:	09 f4       	brne	.+2      	; 0x22b4 <prvCopyDataToQueue+0x34>
    22b2:	7d c0       	rjmp	.+250    	; 0x23ae <prvCopyDataToQueue+0x12e>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    22b4:	8f 81       	ldd	r24, Y+7	; 0x07
    22b6:	88 23       	and	r24, r24
    22b8:	99 f5       	brne	.+102    	; 0x2320 <prvCopyDataToQueue+0xa0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    22ba:	eb 81       	ldd	r30, Y+3	; 0x03
    22bc:	fc 81       	ldd	r31, Y+4	; 0x04
    22be:	62 81       	ldd	r22, Z+2	; 0x02
    22c0:	73 81       	ldd	r23, Z+3	; 0x03
    22c2:	eb 81       	ldd	r30, Y+3	; 0x03
    22c4:	fc 81       	ldd	r31, Y+4	; 0x04
    22c6:	84 8d       	ldd	r24, Z+28	; 0x1c
    22c8:	48 2f       	mov	r20, r24
    22ca:	50 e0       	ldi	r21, 0x00	; 0
    22cc:	2d 81       	ldd	r18, Y+5	; 0x05
    22ce:	3e 81       	ldd	r19, Y+6	; 0x06
    22d0:	cb 01       	movw	r24, r22
    22d2:	b9 01       	movw	r22, r18
    22d4:	0e 94 e6 1e 	call	0x3dcc	; 0x3dcc <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    22d8:	eb 81       	ldd	r30, Y+3	; 0x03
    22da:	fc 81       	ldd	r31, Y+4	; 0x04
    22dc:	22 81       	ldd	r18, Z+2	; 0x02
    22de:	33 81       	ldd	r19, Z+3	; 0x03
    22e0:	eb 81       	ldd	r30, Y+3	; 0x03
    22e2:	fc 81       	ldd	r31, Y+4	; 0x04
    22e4:	84 8d       	ldd	r24, Z+28	; 0x1c
    22e6:	88 2f       	mov	r24, r24
    22e8:	90 e0       	ldi	r25, 0x00	; 0
    22ea:	82 0f       	add	r24, r18
    22ec:	93 1f       	adc	r25, r19
    22ee:	eb 81       	ldd	r30, Y+3	; 0x03
    22f0:	fc 81       	ldd	r31, Y+4	; 0x04
    22f2:	93 83       	std	Z+3, r25	; 0x03
    22f4:	82 83       	std	Z+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    22f6:	eb 81       	ldd	r30, Y+3	; 0x03
    22f8:	fc 81       	ldd	r31, Y+4	; 0x04
    22fa:	22 81       	ldd	r18, Z+2	; 0x02
    22fc:	33 81       	ldd	r19, Z+3	; 0x03
    22fe:	eb 81       	ldd	r30, Y+3	; 0x03
    2300:	fc 81       	ldd	r31, Y+4	; 0x04
    2302:	84 81       	ldd	r24, Z+4	; 0x04
    2304:	95 81       	ldd	r25, Z+5	; 0x05
    2306:	28 17       	cp	r18, r24
    2308:	39 07       	cpc	r19, r25
    230a:	08 f4       	brcc	.+2      	; 0x230e <prvCopyDataToQueue+0x8e>
    230c:	50 c0       	rjmp	.+160    	; 0x23ae <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    230e:	eb 81       	ldd	r30, Y+3	; 0x03
    2310:	fc 81       	ldd	r31, Y+4	; 0x04
    2312:	80 81       	ld	r24, Z
    2314:	91 81       	ldd	r25, Z+1	; 0x01
    2316:	eb 81       	ldd	r30, Y+3	; 0x03
    2318:	fc 81       	ldd	r31, Y+4	; 0x04
    231a:	93 83       	std	Z+3, r25	; 0x03
    231c:	82 83       	std	Z+2, r24	; 0x02
    231e:	47 c0       	rjmp	.+142    	; 0x23ae <prvCopyDataToQueue+0x12e>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    2320:	eb 81       	ldd	r30, Y+3	; 0x03
    2322:	fc 81       	ldd	r31, Y+4	; 0x04
    2324:	66 81       	ldd	r22, Z+6	; 0x06
    2326:	77 81       	ldd	r23, Z+7	; 0x07
    2328:	eb 81       	ldd	r30, Y+3	; 0x03
    232a:	fc 81       	ldd	r31, Y+4	; 0x04
    232c:	84 8d       	ldd	r24, Z+28	; 0x1c
    232e:	48 2f       	mov	r20, r24
    2330:	50 e0       	ldi	r21, 0x00	; 0
    2332:	2d 81       	ldd	r18, Y+5	; 0x05
    2334:	3e 81       	ldd	r19, Y+6	; 0x06
    2336:	cb 01       	movw	r24, r22
    2338:	b9 01       	movw	r22, r18
    233a:	0e 94 e6 1e 	call	0x3dcc	; 0x3dcc <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    233e:	eb 81       	ldd	r30, Y+3	; 0x03
    2340:	fc 81       	ldd	r31, Y+4	; 0x04
    2342:	26 81       	ldd	r18, Z+6	; 0x06
    2344:	37 81       	ldd	r19, Z+7	; 0x07
    2346:	eb 81       	ldd	r30, Y+3	; 0x03
    2348:	fc 81       	ldd	r31, Y+4	; 0x04
    234a:	84 8d       	ldd	r24, Z+28	; 0x1c
    234c:	88 2f       	mov	r24, r24
    234e:	90 e0       	ldi	r25, 0x00	; 0
    2350:	90 95       	com	r25
    2352:	81 95       	neg	r24
    2354:	9f 4f       	sbci	r25, 0xFF	; 255
    2356:	82 0f       	add	r24, r18
    2358:	93 1f       	adc	r25, r19
    235a:	eb 81       	ldd	r30, Y+3	; 0x03
    235c:	fc 81       	ldd	r31, Y+4	; 0x04
    235e:	97 83       	std	Z+7, r25	; 0x07
    2360:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2362:	eb 81       	ldd	r30, Y+3	; 0x03
    2364:	fc 81       	ldd	r31, Y+4	; 0x04
    2366:	26 81       	ldd	r18, Z+6	; 0x06
    2368:	37 81       	ldd	r19, Z+7	; 0x07
    236a:	eb 81       	ldd	r30, Y+3	; 0x03
    236c:	fc 81       	ldd	r31, Y+4	; 0x04
    236e:	80 81       	ld	r24, Z
    2370:	91 81       	ldd	r25, Z+1	; 0x01
    2372:	28 17       	cp	r18, r24
    2374:	39 07       	cpc	r19, r25
    2376:	90 f4       	brcc	.+36     	; 0x239c <prvCopyDataToQueue+0x11c>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    2378:	eb 81       	ldd	r30, Y+3	; 0x03
    237a:	fc 81       	ldd	r31, Y+4	; 0x04
    237c:	24 81       	ldd	r18, Z+4	; 0x04
    237e:	35 81       	ldd	r19, Z+5	; 0x05
    2380:	eb 81       	ldd	r30, Y+3	; 0x03
    2382:	fc 81       	ldd	r31, Y+4	; 0x04
    2384:	84 8d       	ldd	r24, Z+28	; 0x1c
    2386:	88 2f       	mov	r24, r24
    2388:	90 e0       	ldi	r25, 0x00	; 0
    238a:	90 95       	com	r25
    238c:	81 95       	neg	r24
    238e:	9f 4f       	sbci	r25, 0xFF	; 255
    2390:	82 0f       	add	r24, r18
    2392:	93 1f       	adc	r25, r19
    2394:	eb 81       	ldd	r30, Y+3	; 0x03
    2396:	fc 81       	ldd	r31, Y+4	; 0x04
    2398:	97 83       	std	Z+7, r25	; 0x07
    239a:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    239c:	8f 81       	ldd	r24, Y+7	; 0x07
    239e:	82 30       	cpi	r24, 0x02	; 2
    23a0:	31 f4       	brne	.+12     	; 0x23ae <prvCopyDataToQueue+0x12e>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    23a2:	89 81       	ldd	r24, Y+1	; 0x01
    23a4:	88 23       	and	r24, r24
    23a6:	19 f0       	breq	.+6      	; 0x23ae <prvCopyDataToQueue+0x12e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    23a8:	89 81       	ldd	r24, Y+1	; 0x01
    23aa:	81 50       	subi	r24, 0x01	; 1
    23ac:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    23ae:	89 81       	ldd	r24, Y+1	; 0x01
    23b0:	8f 5f       	subi	r24, 0xFF	; 255
    23b2:	eb 81       	ldd	r30, Y+3	; 0x03
    23b4:	fc 81       	ldd	r31, Y+4	; 0x04
    23b6:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    23b8:	8a 81       	ldd	r24, Y+2	; 0x02
}
    23ba:	27 96       	adiw	r28, 0x07	; 7
    23bc:	0f b6       	in	r0, 0x3f	; 63
    23be:	f8 94       	cli
    23c0:	de bf       	out	0x3e, r29	; 62
    23c2:	0f be       	out	0x3f, r0	; 63
    23c4:	cd bf       	out	0x3d, r28	; 61
    23c6:	cf 91       	pop	r28
    23c8:	df 91       	pop	r29
    23ca:	08 95       	ret

000023cc <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    23cc:	df 93       	push	r29
    23ce:	cf 93       	push	r28
    23d0:	00 d0       	rcall	.+0      	; 0x23d2 <prvCopyDataFromQueue+0x6>
    23d2:	00 d0       	rcall	.+0      	; 0x23d4 <prvCopyDataFromQueue+0x8>
    23d4:	cd b7       	in	r28, 0x3d	; 61
    23d6:	de b7       	in	r29, 0x3e	; 62
    23d8:	9a 83       	std	Y+2, r25	; 0x02
    23da:	89 83       	std	Y+1, r24	; 0x01
    23dc:	7c 83       	std	Y+4, r23	; 0x04
    23de:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    23e0:	e9 81       	ldd	r30, Y+1	; 0x01
    23e2:	fa 81       	ldd	r31, Y+2	; 0x02
    23e4:	84 8d       	ldd	r24, Z+28	; 0x1c
    23e6:	88 23       	and	r24, r24
    23e8:	89 f1       	breq	.+98     	; 0x244c <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    23ea:	e9 81       	ldd	r30, Y+1	; 0x01
    23ec:	fa 81       	ldd	r31, Y+2	; 0x02
    23ee:	26 81       	ldd	r18, Z+6	; 0x06
    23f0:	37 81       	ldd	r19, Z+7	; 0x07
    23f2:	e9 81       	ldd	r30, Y+1	; 0x01
    23f4:	fa 81       	ldd	r31, Y+2	; 0x02
    23f6:	84 8d       	ldd	r24, Z+28	; 0x1c
    23f8:	88 2f       	mov	r24, r24
    23fa:	90 e0       	ldi	r25, 0x00	; 0
    23fc:	82 0f       	add	r24, r18
    23fe:	93 1f       	adc	r25, r19
    2400:	e9 81       	ldd	r30, Y+1	; 0x01
    2402:	fa 81       	ldd	r31, Y+2	; 0x02
    2404:	97 83       	std	Z+7, r25	; 0x07
    2406:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    2408:	e9 81       	ldd	r30, Y+1	; 0x01
    240a:	fa 81       	ldd	r31, Y+2	; 0x02
    240c:	26 81       	ldd	r18, Z+6	; 0x06
    240e:	37 81       	ldd	r19, Z+7	; 0x07
    2410:	e9 81       	ldd	r30, Y+1	; 0x01
    2412:	fa 81       	ldd	r31, Y+2	; 0x02
    2414:	84 81       	ldd	r24, Z+4	; 0x04
    2416:	95 81       	ldd	r25, Z+5	; 0x05
    2418:	28 17       	cp	r18, r24
    241a:	39 07       	cpc	r19, r25
    241c:	40 f0       	brcs	.+16     	; 0x242e <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    241e:	e9 81       	ldd	r30, Y+1	; 0x01
    2420:	fa 81       	ldd	r31, Y+2	; 0x02
    2422:	80 81       	ld	r24, Z
    2424:	91 81       	ldd	r25, Z+1	; 0x01
    2426:	e9 81       	ldd	r30, Y+1	; 0x01
    2428:	fa 81       	ldd	r31, Y+2	; 0x02
    242a:	97 83       	std	Z+7, r25	; 0x07
    242c:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    242e:	e9 81       	ldd	r30, Y+1	; 0x01
    2430:	fa 81       	ldd	r31, Y+2	; 0x02
    2432:	46 81       	ldd	r20, Z+6	; 0x06
    2434:	57 81       	ldd	r21, Z+7	; 0x07
    2436:	e9 81       	ldd	r30, Y+1	; 0x01
    2438:	fa 81       	ldd	r31, Y+2	; 0x02
    243a:	84 8d       	ldd	r24, Z+28	; 0x1c
    243c:	28 2f       	mov	r18, r24
    243e:	30 e0       	ldi	r19, 0x00	; 0
    2440:	8b 81       	ldd	r24, Y+3	; 0x03
    2442:	9c 81       	ldd	r25, Y+4	; 0x04
    2444:	ba 01       	movw	r22, r20
    2446:	a9 01       	movw	r20, r18
    2448:	0e 94 e6 1e 	call	0x3dcc	; 0x3dcc <memcpy>
	}
}
    244c:	0f 90       	pop	r0
    244e:	0f 90       	pop	r0
    2450:	0f 90       	pop	r0
    2452:	0f 90       	pop	r0
    2454:	cf 91       	pop	r28
    2456:	df 91       	pop	r29
    2458:	08 95       	ret

0000245a <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    245a:	df 93       	push	r29
    245c:	cf 93       	push	r28
    245e:	00 d0       	rcall	.+0      	; 0x2460 <prvUnlockQueue+0x6>
    2460:	00 d0       	rcall	.+0      	; 0x2462 <prvUnlockQueue+0x8>
    2462:	cd b7       	in	r28, 0x3d	; 61
    2464:	de b7       	in	r29, 0x3e	; 62
    2466:	9c 83       	std	Y+4, r25	; 0x04
    2468:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    246a:	0f b6       	in	r0, 0x3f	; 63
    246c:	f8 94       	cli
    246e:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    2470:	eb 81       	ldd	r30, Y+3	; 0x03
    2472:	fc 81       	ldd	r31, Y+4	; 0x04
    2474:	86 8d       	ldd	r24, Z+30	; 0x1e
    2476:	8a 83       	std	Y+2, r24	; 0x02
    2478:	11 c0       	rjmp	.+34     	; 0x249c <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    247a:	eb 81       	ldd	r30, Y+3	; 0x03
    247c:	fc 81       	ldd	r31, Y+4	; 0x04
    247e:	81 89       	ldd	r24, Z+17	; 0x11
    2480:	88 23       	and	r24, r24
    2482:	79 f0       	breq	.+30     	; 0x24a2 <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2484:	8b 81       	ldd	r24, Y+3	; 0x03
    2486:	9c 81       	ldd	r25, Y+4	; 0x04
    2488:	41 96       	adiw	r24, 0x11	; 17
    248a:	0e 94 8e 18 	call	0x311c	; 0x311c <xTaskRemoveFromEventList>
    248e:	88 23       	and	r24, r24
    2490:	11 f0       	breq	.+4      	; 0x2496 <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    2492:	0e 94 f0 19 	call	0x33e0	; 0x33e0 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    2496:	8a 81       	ldd	r24, Y+2	; 0x02
    2498:	81 50       	subi	r24, 0x01	; 1
    249a:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    249c:	8a 81       	ldd	r24, Y+2	; 0x02
    249e:	18 16       	cp	r1, r24
    24a0:	64 f3       	brlt	.-40     	; 0x247a <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    24a2:	eb 81       	ldd	r30, Y+3	; 0x03
    24a4:	fc 81       	ldd	r31, Y+4	; 0x04
    24a6:	8f ef       	ldi	r24, 0xFF	; 255
    24a8:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    24aa:	0f 90       	pop	r0
    24ac:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    24ae:	0f b6       	in	r0, 0x3f	; 63
    24b0:	f8 94       	cli
    24b2:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    24b4:	eb 81       	ldd	r30, Y+3	; 0x03
    24b6:	fc 81       	ldd	r31, Y+4	; 0x04
    24b8:	85 8d       	ldd	r24, Z+29	; 0x1d
    24ba:	89 83       	std	Y+1, r24	; 0x01
    24bc:	11 c0       	rjmp	.+34     	; 0x24e0 <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    24be:	eb 81       	ldd	r30, Y+3	; 0x03
    24c0:	fc 81       	ldd	r31, Y+4	; 0x04
    24c2:	80 85       	ldd	r24, Z+8	; 0x08
    24c4:	88 23       	and	r24, r24
    24c6:	79 f0       	breq	.+30     	; 0x24e6 <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    24c8:	8b 81       	ldd	r24, Y+3	; 0x03
    24ca:	9c 81       	ldd	r25, Y+4	; 0x04
    24cc:	08 96       	adiw	r24, 0x08	; 8
    24ce:	0e 94 8e 18 	call	0x311c	; 0x311c <xTaskRemoveFromEventList>
    24d2:	88 23       	and	r24, r24
    24d4:	11 f0       	breq	.+4      	; 0x24da <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    24d6:	0e 94 f0 19 	call	0x33e0	; 0x33e0 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    24da:	89 81       	ldd	r24, Y+1	; 0x01
    24dc:	81 50       	subi	r24, 0x01	; 1
    24de:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    24e0:	89 81       	ldd	r24, Y+1	; 0x01
    24e2:	18 16       	cp	r1, r24
    24e4:	64 f3       	brlt	.-40     	; 0x24be <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    24e6:	eb 81       	ldd	r30, Y+3	; 0x03
    24e8:	fc 81       	ldd	r31, Y+4	; 0x04
    24ea:	8f ef       	ldi	r24, 0xFF	; 255
    24ec:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    24ee:	0f 90       	pop	r0
    24f0:	0f be       	out	0x3f, r0	; 63
}
    24f2:	0f 90       	pop	r0
    24f4:	0f 90       	pop	r0
    24f6:	0f 90       	pop	r0
    24f8:	0f 90       	pop	r0
    24fa:	cf 91       	pop	r28
    24fc:	df 91       	pop	r29
    24fe:	08 95       	ret

00002500 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    2500:	df 93       	push	r29
    2502:	cf 93       	push	r28
    2504:	00 d0       	rcall	.+0      	; 0x2506 <prvIsQueueEmpty+0x6>
    2506:	0f 92       	push	r0
    2508:	cd b7       	in	r28, 0x3d	; 61
    250a:	de b7       	in	r29, 0x3e	; 62
    250c:	9b 83       	std	Y+3, r25	; 0x03
    250e:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2510:	0f b6       	in	r0, 0x3f	; 63
    2512:	f8 94       	cli
    2514:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2516:	ea 81       	ldd	r30, Y+2	; 0x02
    2518:	fb 81       	ldd	r31, Y+3	; 0x03
    251a:	82 8d       	ldd	r24, Z+26	; 0x1a
    251c:	88 23       	and	r24, r24
    251e:	19 f4       	brne	.+6      	; 0x2526 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    2520:	81 e0       	ldi	r24, 0x01	; 1
    2522:	89 83       	std	Y+1, r24	; 0x01
    2524:	01 c0       	rjmp	.+2      	; 0x2528 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    2526:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2528:	0f 90       	pop	r0
    252a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    252c:	89 81       	ldd	r24, Y+1	; 0x01
}
    252e:	0f 90       	pop	r0
    2530:	0f 90       	pop	r0
    2532:	0f 90       	pop	r0
    2534:	cf 91       	pop	r28
    2536:	df 91       	pop	r29
    2538:	08 95       	ret

0000253a <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    253a:	df 93       	push	r29
    253c:	cf 93       	push	r28
    253e:	00 d0       	rcall	.+0      	; 0x2540 <xQueueIsQueueEmptyFromISR+0x6>
    2540:	00 d0       	rcall	.+0      	; 0x2542 <xQueueIsQueueEmptyFromISR+0x8>
    2542:	0f 92       	push	r0
    2544:	cd b7       	in	r28, 0x3d	; 61
    2546:	de b7       	in	r29, 0x3e	; 62
    2548:	9d 83       	std	Y+5, r25	; 0x05
    254a:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    254c:	8c 81       	ldd	r24, Y+4	; 0x04
    254e:	9d 81       	ldd	r25, Y+5	; 0x05
    2550:	9a 83       	std	Y+2, r25	; 0x02
    2552:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2554:	e9 81       	ldd	r30, Y+1	; 0x01
    2556:	fa 81       	ldd	r31, Y+2	; 0x02
    2558:	82 8d       	ldd	r24, Z+26	; 0x1a
    255a:	88 23       	and	r24, r24
    255c:	19 f4       	brne	.+6      	; 0x2564 <xQueueIsQueueEmptyFromISR+0x2a>
	{
		xReturn = pdTRUE;
    255e:	81 e0       	ldi	r24, 0x01	; 1
    2560:	8b 83       	std	Y+3, r24	; 0x03
    2562:	01 c0       	rjmp	.+2      	; 0x2566 <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    2564:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    2566:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2568:	0f 90       	pop	r0
    256a:	0f 90       	pop	r0
    256c:	0f 90       	pop	r0
    256e:	0f 90       	pop	r0
    2570:	0f 90       	pop	r0
    2572:	cf 91       	pop	r28
    2574:	df 91       	pop	r29
    2576:	08 95       	ret

00002578 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    2578:	df 93       	push	r29
    257a:	cf 93       	push	r28
    257c:	00 d0       	rcall	.+0      	; 0x257e <prvIsQueueFull+0x6>
    257e:	0f 92       	push	r0
    2580:	cd b7       	in	r28, 0x3d	; 61
    2582:	de b7       	in	r29, 0x3e	; 62
    2584:	9b 83       	std	Y+3, r25	; 0x03
    2586:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2588:	0f b6       	in	r0, 0x3f	; 63
    258a:	f8 94       	cli
    258c:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    258e:	ea 81       	ldd	r30, Y+2	; 0x02
    2590:	fb 81       	ldd	r31, Y+3	; 0x03
    2592:	92 8d       	ldd	r25, Z+26	; 0x1a
    2594:	ea 81       	ldd	r30, Y+2	; 0x02
    2596:	fb 81       	ldd	r31, Y+3	; 0x03
    2598:	83 8d       	ldd	r24, Z+27	; 0x1b
    259a:	98 17       	cp	r25, r24
    259c:	19 f4       	brne	.+6      	; 0x25a4 <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    259e:	81 e0       	ldi	r24, 0x01	; 1
    25a0:	89 83       	std	Y+1, r24	; 0x01
    25a2:	01 c0       	rjmp	.+2      	; 0x25a6 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    25a4:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    25a6:	0f 90       	pop	r0
    25a8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    25aa:	89 81       	ldd	r24, Y+1	; 0x01
}
    25ac:	0f 90       	pop	r0
    25ae:	0f 90       	pop	r0
    25b0:	0f 90       	pop	r0
    25b2:	cf 91       	pop	r28
    25b4:	df 91       	pop	r29
    25b6:	08 95       	ret

000025b8 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    25b8:	df 93       	push	r29
    25ba:	cf 93       	push	r28
    25bc:	00 d0       	rcall	.+0      	; 0x25be <xQueueIsQueueFullFromISR+0x6>
    25be:	00 d0       	rcall	.+0      	; 0x25c0 <xQueueIsQueueFullFromISR+0x8>
    25c0:	0f 92       	push	r0
    25c2:	cd b7       	in	r28, 0x3d	; 61
    25c4:	de b7       	in	r29, 0x3e	; 62
    25c6:	9d 83       	std	Y+5, r25	; 0x05
    25c8:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    25ca:	8c 81       	ldd	r24, Y+4	; 0x04
    25cc:	9d 81       	ldd	r25, Y+5	; 0x05
    25ce:	9a 83       	std	Y+2, r25	; 0x02
    25d0:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    25d2:	e9 81       	ldd	r30, Y+1	; 0x01
    25d4:	fa 81       	ldd	r31, Y+2	; 0x02
    25d6:	92 8d       	ldd	r25, Z+26	; 0x1a
    25d8:	e9 81       	ldd	r30, Y+1	; 0x01
    25da:	fa 81       	ldd	r31, Y+2	; 0x02
    25dc:	83 8d       	ldd	r24, Z+27	; 0x1b
    25de:	98 17       	cp	r25, r24
    25e0:	19 f4       	brne	.+6      	; 0x25e8 <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
    25e2:	81 e0       	ldi	r24, 0x01	; 1
    25e4:	8b 83       	std	Y+3, r24	; 0x03
    25e6:	01 c0       	rjmp	.+2      	; 0x25ea <xQueueIsQueueFullFromISR+0x32>
	}
	else
	{
		xReturn = pdFALSE;
    25e8:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    25ea:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    25ec:	0f 90       	pop	r0
    25ee:	0f 90       	pop	r0
    25f0:	0f 90       	pop	r0
    25f2:	0f 90       	pop	r0
    25f4:	0f 90       	pop	r0
    25f6:	cf 91       	pop	r28
    25f8:	df 91       	pop	r29
    25fa:	08 95       	ret

000025fc <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    25fc:	8f 92       	push	r8
    25fe:	9f 92       	push	r9
    2600:	af 92       	push	r10
    2602:	bf 92       	push	r11
    2604:	cf 92       	push	r12
    2606:	df 92       	push	r13
    2608:	ef 92       	push	r14
    260a:	ff 92       	push	r15
    260c:	0f 93       	push	r16
    260e:	1f 93       	push	r17
    2610:	df 93       	push	r29
    2612:	cf 93       	push	r28
    2614:	cd b7       	in	r28, 0x3d	; 61
    2616:	de b7       	in	r29, 0x3e	; 62
    2618:	60 97       	sbiw	r28, 0x10	; 16
    261a:	0f b6       	in	r0, 0x3f	; 63
    261c:	f8 94       	cli
    261e:	de bf       	out	0x3e, r29	; 62
    2620:	0f be       	out	0x3f, r0	; 63
    2622:	cd bf       	out	0x3d, r28	; 61
    2624:	9f 83       	std	Y+7, r25	; 0x07
    2626:	8e 83       	std	Y+6, r24	; 0x06
    2628:	79 87       	std	Y+9, r23	; 0x09
    262a:	68 87       	std	Y+8, r22	; 0x08
    262c:	5b 87       	std	Y+11, r21	; 0x0b
    262e:	4a 87       	std	Y+10, r20	; 0x0a
    2630:	3d 87       	std	Y+13, r19	; 0x0d
    2632:	2c 87       	std	Y+12, r18	; 0x0c
    2634:	0e 87       	std	Y+14, r16	; 0x0e
    2636:	f8 8a       	std	Y+16, r15	; 0x10
    2638:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    263a:	8a 85       	ldd	r24, Y+10	; 0x0a
    263c:	9b 85       	ldd	r25, Y+11	; 0x0b
    263e:	0e 94 af 06 	call	0xd5e	; 0xd5e <pvPortMalloc>
    2642:	9a 83       	std	Y+2, r25	; 0x02
    2644:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    2646:	89 81       	ldd	r24, Y+1	; 0x01
    2648:	9a 81       	ldd	r25, Y+2	; 0x02
    264a:	00 97       	sbiw	r24, 0x00	; 0
    264c:	b1 f0       	breq	.+44     	; 0x267a <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    264e:	86 e2       	ldi	r24, 0x26	; 38
    2650:	90 e0       	ldi	r25, 0x00	; 0
    2652:	0e 94 af 06 	call	0xd5e	; 0xd5e <pvPortMalloc>
    2656:	9d 83       	std	Y+5, r25	; 0x05
    2658:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    265a:	8c 81       	ldd	r24, Y+4	; 0x04
    265c:	9d 81       	ldd	r25, Y+5	; 0x05
    265e:	00 97       	sbiw	r24, 0x00	; 0
    2660:	39 f0       	breq	.+14     	; 0x2670 <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    2662:	ec 81       	ldd	r30, Y+4	; 0x04
    2664:	fd 81       	ldd	r31, Y+5	; 0x05
    2666:	89 81       	ldd	r24, Y+1	; 0x01
    2668:	9a 81       	ldd	r25, Y+2	; 0x02
    266a:	90 8f       	std	Z+24, r25	; 0x18
    266c:	87 8b       	std	Z+23, r24	; 0x17
    266e:	07 c0       	rjmp	.+14     	; 0x267e <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    2670:	89 81       	ldd	r24, Y+1	; 0x01
    2672:	9a 81       	ldd	r25, Y+2	; 0x02
    2674:	0e 94 05 07 	call	0xe0a	; 0xe0a <vPortFree>
    2678:	02 c0       	rjmp	.+4      	; 0x267e <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    267a:	1d 82       	std	Y+5, r1	; 0x05
    267c:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    267e:	8c 81       	ldd	r24, Y+4	; 0x04
    2680:	9d 81       	ldd	r25, Y+5	; 0x05
    2682:	00 97       	sbiw	r24, 0x00	; 0
    2684:	e9 f0       	breq	.+58     	; 0x26c0 <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    2686:	8a 85       	ldd	r24, Y+10	; 0x0a
    2688:	9b 85       	ldd	r25, Y+11	; 0x0b
    268a:	9c 01       	movw	r18, r24
    268c:	40 e0       	ldi	r20, 0x00	; 0
    268e:	50 e0       	ldi	r21, 0x00	; 0
    2690:	8e 81       	ldd	r24, Y+6	; 0x06
    2692:	9f 81       	ldd	r25, Y+7	; 0x07
    2694:	68 85       	ldd	r22, Y+8	; 0x08
    2696:	79 85       	ldd	r23, Y+9	; 0x09
    2698:	ec 85       	ldd	r30, Y+12	; 0x0c
    269a:	fd 85       	ldd	r31, Y+13	; 0x0d
    269c:	af 85       	ldd	r26, Y+15	; 0x0f
    269e:	b8 89       	ldd	r27, Y+16	; 0x10
    26a0:	ac 80       	ldd	r10, Y+4	; 0x04
    26a2:	bd 80       	ldd	r11, Y+5	; 0x05
    26a4:	8f 01       	movw	r16, r30
    26a6:	ee 84       	ldd	r14, Y+14	; 0x0e
    26a8:	6d 01       	movw	r12, r26
    26aa:	88 24       	eor	r8, r8
    26ac:	99 24       	eor	r9, r9
    26ae:	0e 94 76 13 	call	0x26ec	; 0x26ec <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    26b2:	8c 81       	ldd	r24, Y+4	; 0x04
    26b4:	9d 81       	ldd	r25, Y+5	; 0x05
    26b6:	0e 94 32 14 	call	0x2864	; 0x2864 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    26ba:	81 e0       	ldi	r24, 0x01	; 1
    26bc:	8b 83       	std	Y+3, r24	; 0x03
    26be:	02 c0       	rjmp	.+4      	; 0x26c4 <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    26c0:	8f ef       	ldi	r24, 0xFF	; 255
    26c2:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    26c4:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    26c6:	60 96       	adiw	r28, 0x10	; 16
    26c8:	0f b6       	in	r0, 0x3f	; 63
    26ca:	f8 94       	cli
    26cc:	de bf       	out	0x3e, r29	; 62
    26ce:	0f be       	out	0x3f, r0	; 63
    26d0:	cd bf       	out	0x3d, r28	; 61
    26d2:	cf 91       	pop	r28
    26d4:	df 91       	pop	r29
    26d6:	1f 91       	pop	r17
    26d8:	0f 91       	pop	r16
    26da:	ff 90       	pop	r15
    26dc:	ef 90       	pop	r14
    26de:	df 90       	pop	r13
    26e0:	cf 90       	pop	r12
    26e2:	bf 90       	pop	r11
    26e4:	af 90       	pop	r10
    26e6:	9f 90       	pop	r9
    26e8:	8f 90       	pop	r8
    26ea:	08 95       	ret

000026ec <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    26ec:	8f 92       	push	r8
    26ee:	9f 92       	push	r9
    26f0:	af 92       	push	r10
    26f2:	bf 92       	push	r11
    26f4:	cf 92       	push	r12
    26f6:	df 92       	push	r13
    26f8:	ef 92       	push	r14
    26fa:	0f 93       	push	r16
    26fc:	1f 93       	push	r17
    26fe:	df 93       	push	r29
    2700:	cf 93       	push	r28
    2702:	cd b7       	in	r28, 0x3d	; 61
    2704:	de b7       	in	r29, 0x3e	; 62
    2706:	64 97       	sbiw	r28, 0x14	; 20
    2708:	0f b6       	in	r0, 0x3f	; 63
    270a:	f8 94       	cli
    270c:	de bf       	out	0x3e, r29	; 62
    270e:	0f be       	out	0x3f, r0	; 63
    2710:	cd bf       	out	0x3d, r28	; 61
    2712:	9d 83       	std	Y+5, r25	; 0x05
    2714:	8c 83       	std	Y+4, r24	; 0x04
    2716:	7f 83       	std	Y+7, r23	; 0x07
    2718:	6e 83       	std	Y+6, r22	; 0x06
    271a:	28 87       	std	Y+8, r18	; 0x08
    271c:	39 87       	std	Y+9, r19	; 0x09
    271e:	4a 87       	std	Y+10, r20	; 0x0a
    2720:	5b 87       	std	Y+11, r21	; 0x0b
    2722:	1d 87       	std	Y+13, r17	; 0x0d
    2724:	0c 87       	std	Y+12, r16	; 0x0c
    2726:	ee 86       	std	Y+14, r14	; 0x0e
    2728:	d8 8a       	std	Y+16, r13	; 0x10
    272a:	cf 86       	std	Y+15, r12	; 0x0f
    272c:	ba 8a       	std	Y+18, r11	; 0x12
    272e:	a9 8a       	std	Y+17, r10	; 0x11
    2730:	9c 8a       	std	Y+20, r9	; 0x14
    2732:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    2734:	e9 89       	ldd	r30, Y+17	; 0x11
    2736:	fa 89       	ldd	r31, Y+18	; 0x12
    2738:	27 89       	ldd	r18, Z+23	; 0x17
    273a:	30 8d       	ldd	r19, Z+24	; 0x18
    273c:	88 85       	ldd	r24, Y+8	; 0x08
    273e:	99 85       	ldd	r25, Y+9	; 0x09
    2740:	01 97       	sbiw	r24, 0x01	; 1
    2742:	82 0f       	add	r24, r18
    2744:	93 1f       	adc	r25, r19
    2746:	9b 83       	std	Y+3, r25	; 0x03
    2748:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    274a:	8e 81       	ldd	r24, Y+6	; 0x06
    274c:	9f 81       	ldd	r25, Y+7	; 0x07
    274e:	00 97       	sbiw	r24, 0x00	; 0
    2750:	51 f1       	breq	.+84     	; 0x27a6 <prvInitialiseNewTask+0xba>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    2752:	19 82       	std	Y+1, r1	; 0x01
    2754:	21 c0       	rjmp	.+66     	; 0x2798 <prvInitialiseNewTask+0xac>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    2756:	89 81       	ldd	r24, Y+1	; 0x01
    2758:	48 2f       	mov	r20, r24
    275a:	50 e0       	ldi	r21, 0x00	; 0
    275c:	89 81       	ldd	r24, Y+1	; 0x01
    275e:	28 2f       	mov	r18, r24
    2760:	30 e0       	ldi	r19, 0x00	; 0
    2762:	8e 81       	ldd	r24, Y+6	; 0x06
    2764:	9f 81       	ldd	r25, Y+7	; 0x07
    2766:	fc 01       	movw	r30, r24
    2768:	e2 0f       	add	r30, r18
    276a:	f3 1f       	adc	r31, r19
    276c:	20 81       	ld	r18, Z
    276e:	89 89       	ldd	r24, Y+17	; 0x11
    2770:	9a 89       	ldd	r25, Y+18	; 0x12
    2772:	84 0f       	add	r24, r20
    2774:	95 1f       	adc	r25, r21
    2776:	fc 01       	movw	r30, r24
    2778:	79 96       	adiw	r30, 0x19	; 25
    277a:	20 83       	st	Z, r18

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    277c:	89 81       	ldd	r24, Y+1	; 0x01
    277e:	28 2f       	mov	r18, r24
    2780:	30 e0       	ldi	r19, 0x00	; 0
    2782:	8e 81       	ldd	r24, Y+6	; 0x06
    2784:	9f 81       	ldd	r25, Y+7	; 0x07
    2786:	fc 01       	movw	r30, r24
    2788:	e2 0f       	add	r30, r18
    278a:	f3 1f       	adc	r31, r19
    278c:	80 81       	ld	r24, Z
    278e:	88 23       	and	r24, r24
    2790:	31 f0       	breq	.+12     	; 0x279e <prvInitialiseNewTask+0xb2>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    2792:	89 81       	ldd	r24, Y+1	; 0x01
    2794:	8f 5f       	subi	r24, 0xFF	; 255
    2796:	89 83       	std	Y+1, r24	; 0x01
    2798:	89 81       	ldd	r24, Y+1	; 0x01
    279a:	88 30       	cpi	r24, 0x08	; 8
    279c:	e0 f2       	brcs	.-72     	; 0x2756 <prvInitialiseNewTask+0x6a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    279e:	e9 89       	ldd	r30, Y+17	; 0x11
    27a0:	fa 89       	ldd	r31, Y+18	; 0x12
    27a2:	10 a2       	std	Z+32, r1	; 0x20
    27a4:	03 c0       	rjmp	.+6      	; 0x27ac <prvInitialiseNewTask+0xc0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    27a6:	e9 89       	ldd	r30, Y+17	; 0x11
    27a8:	fa 89       	ldd	r31, Y+18	; 0x12
    27aa:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    27ac:	8e 85       	ldd	r24, Y+14	; 0x0e
    27ae:	84 30       	cpi	r24, 0x04	; 4
    27b0:	10 f0       	brcs	.+4      	; 0x27b6 <prvInitialiseNewTask+0xca>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    27b2:	83 e0       	ldi	r24, 0x03	; 3
    27b4:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    27b6:	e9 89       	ldd	r30, Y+17	; 0x11
    27b8:	fa 89       	ldd	r31, Y+18	; 0x12
    27ba:	8e 85       	ldd	r24, Y+14	; 0x0e
    27bc:	86 8b       	std	Z+22, r24	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    27be:	89 89       	ldd	r24, Y+17	; 0x11
    27c0:	9a 89       	ldd	r25, Y+18	; 0x12
    27c2:	02 96       	adiw	r24, 0x02	; 2
    27c4:	0e 94 55 07 	call	0xeaa	; 0xeaa <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    27c8:	89 89       	ldd	r24, Y+17	; 0x11
    27ca:	9a 89       	ldd	r25, Y+18	; 0x12
    27cc:	0c 96       	adiw	r24, 0x0c	; 12
    27ce:	0e 94 55 07 	call	0xeaa	; 0xeaa <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    27d2:	e9 89       	ldd	r30, Y+17	; 0x11
    27d4:	fa 89       	ldd	r31, Y+18	; 0x12
    27d6:	89 89       	ldd	r24, Y+17	; 0x11
    27d8:	9a 89       	ldd	r25, Y+18	; 0x12
    27da:	91 87       	std	Z+9, r25	; 0x09
    27dc:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    27de:	8e 85       	ldd	r24, Y+14	; 0x0e
    27e0:	28 2f       	mov	r18, r24
    27e2:	30 e0       	ldi	r19, 0x00	; 0
    27e4:	84 e0       	ldi	r24, 0x04	; 4
    27e6:	90 e0       	ldi	r25, 0x00	; 0
    27e8:	82 1b       	sub	r24, r18
    27ea:	93 0b       	sbc	r25, r19
    27ec:	e9 89       	ldd	r30, Y+17	; 0x11
    27ee:	fa 89       	ldd	r31, Y+18	; 0x12
    27f0:	95 87       	std	Z+13, r25	; 0x0d
    27f2:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    27f4:	e9 89       	ldd	r30, Y+17	; 0x11
    27f6:	fa 89       	ldd	r31, Y+18	; 0x12
    27f8:	89 89       	ldd	r24, Y+17	; 0x11
    27fa:	9a 89       	ldd	r25, Y+18	; 0x12
    27fc:	93 8b       	std	Z+19, r25	; 0x13
    27fe:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    2800:	e9 89       	ldd	r30, Y+17	; 0x11
    2802:	fa 89       	ldd	r31, Y+18	; 0x12
    2804:	11 a2       	std	Z+33, r1	; 0x21
    2806:	12 a2       	std	Z+34, r1	; 0x22
    2808:	13 a2       	std	Z+35, r1	; 0x23
    280a:	14 a2       	std	Z+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    280c:	e9 89       	ldd	r30, Y+17	; 0x11
    280e:	fa 89       	ldd	r31, Y+18	; 0x12
    2810:	15 a2       	std	Z+37, r1	; 0x25
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    2812:	8a 81       	ldd	r24, Y+2	; 0x02
    2814:	9b 81       	ldd	r25, Y+3	; 0x03
    2816:	2c 81       	ldd	r18, Y+4	; 0x04
    2818:	3d 81       	ldd	r19, Y+5	; 0x05
    281a:	4c 85       	ldd	r20, Y+12	; 0x0c
    281c:	5d 85       	ldd	r21, Y+13	; 0x0d
    281e:	b9 01       	movw	r22, r18
    2820:	0e 94 e8 08 	call	0x11d0	; 0x11d0 <pxPortInitialiseStack>
    2824:	e9 89       	ldd	r30, Y+17	; 0x11
    2826:	fa 89       	ldd	r31, Y+18	; 0x12
    2828:	91 83       	std	Z+1, r25	; 0x01
    282a:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    282c:	8f 85       	ldd	r24, Y+15	; 0x0f
    282e:	98 89       	ldd	r25, Y+16	; 0x10
    2830:	00 97       	sbiw	r24, 0x00	; 0
    2832:	31 f0       	breq	.+12     	; 0x2840 <prvInitialiseNewTask+0x154>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    2834:	ef 85       	ldd	r30, Y+15	; 0x0f
    2836:	f8 89       	ldd	r31, Y+16	; 0x10
    2838:	89 89       	ldd	r24, Y+17	; 0x11
    283a:	9a 89       	ldd	r25, Y+18	; 0x12
    283c:	91 83       	std	Z+1, r25	; 0x01
    283e:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    2840:	64 96       	adiw	r28, 0x14	; 20
    2842:	0f b6       	in	r0, 0x3f	; 63
    2844:	f8 94       	cli
    2846:	de bf       	out	0x3e, r29	; 62
    2848:	0f be       	out	0x3f, r0	; 63
    284a:	cd bf       	out	0x3d, r28	; 61
    284c:	cf 91       	pop	r28
    284e:	df 91       	pop	r29
    2850:	1f 91       	pop	r17
    2852:	0f 91       	pop	r16
    2854:	ef 90       	pop	r14
    2856:	df 90       	pop	r13
    2858:	cf 90       	pop	r12
    285a:	bf 90       	pop	r11
    285c:	af 90       	pop	r10
    285e:	9f 90       	pop	r9
    2860:	8f 90       	pop	r8
    2862:	08 95       	ret

00002864 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    2864:	df 93       	push	r29
    2866:	cf 93       	push	r28
    2868:	00 d0       	rcall	.+0      	; 0x286a <prvAddNewTaskToReadyList+0x6>
    286a:	cd b7       	in	r28, 0x3d	; 61
    286c:	de b7       	in	r29, 0x3e	; 62
    286e:	9a 83       	std	Y+2, r25	; 0x02
    2870:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    2872:	0f b6       	in	r0, 0x3f	; 63
    2874:	f8 94       	cli
    2876:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    2878:	80 91 cb 02 	lds	r24, 0x02CB
    287c:	8f 5f       	subi	r24, 0xFF	; 255
    287e:	80 93 cb 02 	sts	0x02CB, r24
		if( pxCurrentTCB == NULL )
    2882:	80 91 c8 02 	lds	r24, 0x02C8
    2886:	90 91 c9 02 	lds	r25, 0x02C9
    288a:	00 97       	sbiw	r24, 0x00	; 0
    288c:	69 f4       	brne	.+26     	; 0x28a8 <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    288e:	89 81       	ldd	r24, Y+1	; 0x01
    2890:	9a 81       	ldd	r25, Y+2	; 0x02
    2892:	90 93 c9 02 	sts	0x02C9, r25
    2896:	80 93 c8 02 	sts	0x02C8, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    289a:	80 91 cb 02 	lds	r24, 0x02CB
    289e:	81 30       	cpi	r24, 0x01	; 1
    28a0:	b9 f4       	brne	.+46     	; 0x28d0 <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    28a2:	0e 94 04 1a 	call	0x3408	; 0x3408 <prvInitialiseTaskLists>
    28a6:	14 c0       	rjmp	.+40     	; 0x28d0 <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    28a8:	80 91 cf 02 	lds	r24, 0x02CF
    28ac:	88 23       	and	r24, r24
    28ae:	81 f4       	brne	.+32     	; 0x28d0 <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    28b0:	e0 91 c8 02 	lds	r30, 0x02C8
    28b4:	f0 91 c9 02 	lds	r31, 0x02C9
    28b8:	96 89       	ldd	r25, Z+22	; 0x16
    28ba:	e9 81       	ldd	r30, Y+1	; 0x01
    28bc:	fa 81       	ldd	r31, Y+2	; 0x02
    28be:	86 89       	ldd	r24, Z+22	; 0x16
    28c0:	89 17       	cp	r24, r25
    28c2:	30 f0       	brcs	.+12     	; 0x28d0 <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    28c4:	89 81       	ldd	r24, Y+1	; 0x01
    28c6:	9a 81       	ldd	r25, Y+2	; 0x02
    28c8:	90 93 c9 02 	sts	0x02C9, r25
    28cc:	80 93 c8 02 	sts	0x02C8, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    28d0:	80 91 d3 02 	lds	r24, 0x02D3
    28d4:	8f 5f       	subi	r24, 0xFF	; 255
    28d6:	80 93 d3 02 	sts	0x02D3, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    28da:	e9 81       	ldd	r30, Y+1	; 0x01
    28dc:	fa 81       	ldd	r31, Y+2	; 0x02
    28de:	96 89       	ldd	r25, Z+22	; 0x16
    28e0:	80 91 ce 02 	lds	r24, 0x02CE
    28e4:	89 17       	cp	r24, r25
    28e6:	28 f4       	brcc	.+10     	; 0x28f2 <prvAddNewTaskToReadyList+0x8e>
    28e8:	e9 81       	ldd	r30, Y+1	; 0x01
    28ea:	fa 81       	ldd	r31, Y+2	; 0x02
    28ec:	86 89       	ldd	r24, Z+22	; 0x16
    28ee:	80 93 ce 02 	sts	0x02CE, r24
    28f2:	e9 81       	ldd	r30, Y+1	; 0x01
    28f4:	fa 81       	ldd	r31, Y+2	; 0x02
    28f6:	86 89       	ldd	r24, Z+22	; 0x16
    28f8:	28 2f       	mov	r18, r24
    28fa:	30 e0       	ldi	r19, 0x00	; 0
    28fc:	c9 01       	movw	r24, r18
    28fe:	88 0f       	add	r24, r24
    2900:	99 1f       	adc	r25, r25
    2902:	88 0f       	add	r24, r24
    2904:	99 1f       	adc	r25, r25
    2906:	88 0f       	add	r24, r24
    2908:	99 1f       	adc	r25, r25
    290a:	82 0f       	add	r24, r18
    290c:	93 1f       	adc	r25, r19
    290e:	ac 01       	movw	r20, r24
    2910:	47 52       	subi	r20, 0x27	; 39
    2912:	5d 4f       	sbci	r21, 0xFD	; 253
    2914:	89 81       	ldd	r24, Y+1	; 0x01
    2916:	9a 81       	ldd	r25, Y+2	; 0x02
    2918:	9c 01       	movw	r18, r24
    291a:	2e 5f       	subi	r18, 0xFE	; 254
    291c:	3f 4f       	sbci	r19, 0xFF	; 255
    291e:	ca 01       	movw	r24, r20
    2920:	b9 01       	movw	r22, r18
    2922:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    2926:	0f 90       	pop	r0
    2928:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    292a:	80 91 cf 02 	lds	r24, 0x02CF
    292e:	88 23       	and	r24, r24
    2930:	61 f0       	breq	.+24     	; 0x294a <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    2932:	e0 91 c8 02 	lds	r30, 0x02C8
    2936:	f0 91 c9 02 	lds	r31, 0x02C9
    293a:	96 89       	ldd	r25, Z+22	; 0x16
    293c:	e9 81       	ldd	r30, Y+1	; 0x01
    293e:	fa 81       	ldd	r31, Y+2	; 0x02
    2940:	86 89       	ldd	r24, Z+22	; 0x16
    2942:	98 17       	cp	r25, r24
    2944:	10 f4       	brcc	.+4      	; 0x294a <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    2946:	0e 94 a7 0a 	call	0x154e	; 0x154e <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    294a:	0f 90       	pop	r0
    294c:	0f 90       	pop	r0
    294e:	cf 91       	pop	r28
    2950:	df 91       	pop	r29
    2952:	08 95       	ret

00002954 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    2954:	df 93       	push	r29
    2956:	cf 93       	push	r28
    2958:	00 d0       	rcall	.+0      	; 0x295a <vTaskDelete+0x6>
    295a:	00 d0       	rcall	.+0      	; 0x295c <vTaskDelete+0x8>
    295c:	00 d0       	rcall	.+0      	; 0x295e <vTaskDelete+0xa>
    295e:	cd b7       	in	r28, 0x3d	; 61
    2960:	de b7       	in	r29, 0x3e	; 62
    2962:	9c 83       	std	Y+4, r25	; 0x04
    2964:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    2966:	0f b6       	in	r0, 0x3f	; 63
    2968:	f8 94       	cli
    296a:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    296c:	8b 81       	ldd	r24, Y+3	; 0x03
    296e:	9c 81       	ldd	r25, Y+4	; 0x04
    2970:	00 97       	sbiw	r24, 0x00	; 0
    2972:	39 f4       	brne	.+14     	; 0x2982 <vTaskDelete+0x2e>
    2974:	80 91 c8 02 	lds	r24, 0x02C8
    2978:	90 91 c9 02 	lds	r25, 0x02C9
    297c:	9e 83       	std	Y+6, r25	; 0x06
    297e:	8d 83       	std	Y+5, r24	; 0x05
    2980:	04 c0       	rjmp	.+8      	; 0x298a <vTaskDelete+0x36>
    2982:	8b 81       	ldd	r24, Y+3	; 0x03
    2984:	9c 81       	ldd	r25, Y+4	; 0x04
    2986:	9e 83       	std	Y+6, r25	; 0x06
    2988:	8d 83       	std	Y+5, r24	; 0x05
    298a:	8d 81       	ldd	r24, Y+5	; 0x05
    298c:	9e 81       	ldd	r25, Y+6	; 0x06
    298e:	9a 83       	std	Y+2, r25	; 0x02
    2990:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2992:	89 81       	ldd	r24, Y+1	; 0x01
    2994:	9a 81       	ldd	r25, Y+2	; 0x02
    2996:	02 96       	adiw	r24, 0x02	; 2
    2998:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    299c:	e9 81       	ldd	r30, Y+1	; 0x01
    299e:	fa 81       	ldd	r31, Y+2	; 0x02
    29a0:	84 89       	ldd	r24, Z+20	; 0x14
    29a2:	95 89       	ldd	r25, Z+21	; 0x15
    29a4:	00 97       	sbiw	r24, 0x00	; 0
    29a6:	29 f0       	breq	.+10     	; 0x29b2 <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    29a8:	89 81       	ldd	r24, Y+1	; 0x01
    29aa:	9a 81       	ldd	r25, Y+2	; 0x02
    29ac:	0c 96       	adiw	r24, 0x0c	; 12
    29ae:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    29b2:	80 91 d3 02 	lds	r24, 0x02D3
    29b6:	8f 5f       	subi	r24, 0xFF	; 255
    29b8:	80 93 d3 02 	sts	0x02D3, r24

			if( pxTCB == pxCurrentTCB )
    29bc:	20 91 c8 02 	lds	r18, 0x02C8
    29c0:	30 91 c9 02 	lds	r19, 0x02C9
    29c4:	89 81       	ldd	r24, Y+1	; 0x01
    29c6:	9a 81       	ldd	r25, Y+2	; 0x02
    29c8:	82 17       	cp	r24, r18
    29ca:	93 07       	cpc	r25, r19
    29cc:	81 f4       	brne	.+32     	; 0x29ee <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    29ce:	89 81       	ldd	r24, Y+1	; 0x01
    29d0:	9a 81       	ldd	r25, Y+2	; 0x02
    29d2:	9c 01       	movw	r18, r24
    29d4:	2e 5f       	subi	r18, 0xFE	; 254
    29d6:	3f 4f       	sbci	r19, 0xFF	; 255
    29d8:	8c e1       	ldi	r24, 0x1C	; 28
    29da:	93 e0       	ldi	r25, 0x03	; 3
    29dc:	b9 01       	movw	r22, r18
    29de:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    29e2:	80 91 ca 02 	lds	r24, 0x02CA
    29e6:	8f 5f       	subi	r24, 0xFF	; 255
    29e8:	80 93 ca 02 	sts	0x02CA, r24
    29ec:	0b c0       	rjmp	.+22     	; 0x2a04 <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    29ee:	80 91 cb 02 	lds	r24, 0x02CB
    29f2:	81 50       	subi	r24, 0x01	; 1
    29f4:	80 93 cb 02 	sts	0x02CB, r24
				prvDeleteTCB( pxTCB );
    29f8:	89 81       	ldd	r24, Y+1	; 0x01
    29fa:	9a 81       	ldd	r25, Y+2	; 0x02
    29fc:	0e 94 70 1a 	call	0x34e0	; 0x34e0 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    2a00:	0e 94 86 1a 	call	0x350c	; 0x350c <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    2a04:	0f 90       	pop	r0
    2a06:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    2a08:	80 91 cf 02 	lds	r24, 0x02CF
    2a0c:	88 23       	and	r24, r24
    2a0e:	59 f0       	breq	.+22     	; 0x2a26 <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    2a10:	20 91 c8 02 	lds	r18, 0x02C8
    2a14:	30 91 c9 02 	lds	r19, 0x02C9
    2a18:	89 81       	ldd	r24, Y+1	; 0x01
    2a1a:	9a 81       	ldd	r25, Y+2	; 0x02
    2a1c:	82 17       	cp	r24, r18
    2a1e:	93 07       	cpc	r25, r19
    2a20:	11 f4       	brne	.+4      	; 0x2a26 <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    2a22:	0e 94 a7 0a 	call	0x154e	; 0x154e <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    2a26:	26 96       	adiw	r28, 0x06	; 6
    2a28:	0f b6       	in	r0, 0x3f	; 63
    2a2a:	f8 94       	cli
    2a2c:	de bf       	out	0x3e, r29	; 62
    2a2e:	0f be       	out	0x3f, r0	; 63
    2a30:	cd bf       	out	0x3d, r28	; 61
    2a32:	cf 91       	pop	r28
    2a34:	df 91       	pop	r29
    2a36:	08 95       	ret

00002a38 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    2a38:	df 93       	push	r29
    2a3a:	cf 93       	push	r28
    2a3c:	cd b7       	in	r28, 0x3d	; 61
    2a3e:	de b7       	in	r29, 0x3e	; 62
    2a40:	2a 97       	sbiw	r28, 0x0a	; 10
    2a42:	0f b6       	in	r0, 0x3f	; 63
    2a44:	f8 94       	cli
    2a46:	de bf       	out	0x3e, r29	; 62
    2a48:	0f be       	out	0x3f, r0	; 63
    2a4a:	cd bf       	out	0x3d, r28	; 61
    2a4c:	98 87       	std	Y+8, r25	; 0x08
    2a4e:	8f 83       	std	Y+7, r24	; 0x07
    2a50:	7a 87       	std	Y+10, r23	; 0x0a
    2a52:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    2a54:	1b 82       	std	Y+3, r1	; 0x03

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    2a56:	0e 94 ee 15 	call	0x2bdc	; 0x2bdc <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    2a5a:	80 91 cc 02 	lds	r24, 0x02CC
    2a5e:	90 91 cd 02 	lds	r25, 0x02CD
    2a62:	9a 83       	std	Y+2, r25	; 0x02
    2a64:	89 83       	std	Y+1, r24	; 0x01

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2a66:	ef 81       	ldd	r30, Y+7	; 0x07
    2a68:	f8 85       	ldd	r31, Y+8	; 0x08
    2a6a:	20 81       	ld	r18, Z
    2a6c:	31 81       	ldd	r19, Z+1	; 0x01
    2a6e:	89 85       	ldd	r24, Y+9	; 0x09
    2a70:	9a 85       	ldd	r25, Y+10	; 0x0a
    2a72:	82 0f       	add	r24, r18
    2a74:	93 1f       	adc	r25, r19
    2a76:	9e 83       	std	Y+6, r25	; 0x06
    2a78:	8d 83       	std	Y+5, r24	; 0x05

			if( xConstTickCount < *pxPreviousWakeTime )
    2a7a:	ef 81       	ldd	r30, Y+7	; 0x07
    2a7c:	f8 85       	ldd	r31, Y+8	; 0x08
    2a7e:	20 81       	ld	r18, Z
    2a80:	31 81       	ldd	r19, Z+1	; 0x01
    2a82:	89 81       	ldd	r24, Y+1	; 0x01
    2a84:	9a 81       	ldd	r25, Y+2	; 0x02
    2a86:	82 17       	cp	r24, r18
    2a88:	93 07       	cpc	r25, r19
    2a8a:	98 f4       	brcc	.+38     	; 0x2ab2 <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    2a8c:	ef 81       	ldd	r30, Y+7	; 0x07
    2a8e:	f8 85       	ldd	r31, Y+8	; 0x08
    2a90:	20 81       	ld	r18, Z
    2a92:	31 81       	ldd	r19, Z+1	; 0x01
    2a94:	8d 81       	ldd	r24, Y+5	; 0x05
    2a96:	9e 81       	ldd	r25, Y+6	; 0x06
    2a98:	82 17       	cp	r24, r18
    2a9a:	93 07       	cpc	r25, r19
    2a9c:	e0 f4       	brcc	.+56     	; 0x2ad6 <vTaskDelayUntil+0x9e>
    2a9e:	2d 81       	ldd	r18, Y+5	; 0x05
    2aa0:	3e 81       	ldd	r19, Y+6	; 0x06
    2aa2:	89 81       	ldd	r24, Y+1	; 0x01
    2aa4:	9a 81       	ldd	r25, Y+2	; 0x02
    2aa6:	82 17       	cp	r24, r18
    2aa8:	93 07       	cpc	r25, r19
    2aaa:	a8 f4       	brcc	.+42     	; 0x2ad6 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    2aac:	81 e0       	ldi	r24, 0x01	; 1
    2aae:	8b 83       	std	Y+3, r24	; 0x03
    2ab0:	12 c0       	rjmp	.+36     	; 0x2ad6 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    2ab2:	ef 81       	ldd	r30, Y+7	; 0x07
    2ab4:	f8 85       	ldd	r31, Y+8	; 0x08
    2ab6:	20 81       	ld	r18, Z
    2ab8:	31 81       	ldd	r19, Z+1	; 0x01
    2aba:	8d 81       	ldd	r24, Y+5	; 0x05
    2abc:	9e 81       	ldd	r25, Y+6	; 0x06
    2abe:	82 17       	cp	r24, r18
    2ac0:	93 07       	cpc	r25, r19
    2ac2:	38 f0       	brcs	.+14     	; 0x2ad2 <vTaskDelayUntil+0x9a>
    2ac4:	2d 81       	ldd	r18, Y+5	; 0x05
    2ac6:	3e 81       	ldd	r19, Y+6	; 0x06
    2ac8:	89 81       	ldd	r24, Y+1	; 0x01
    2aca:	9a 81       	ldd	r25, Y+2	; 0x02
    2acc:	82 17       	cp	r24, r18
    2ace:	93 07       	cpc	r25, r19
    2ad0:	10 f4       	brcc	.+4      	; 0x2ad6 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    2ad2:	81 e0       	ldi	r24, 0x01	; 1
    2ad4:	8b 83       	std	Y+3, r24	; 0x03
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2ad6:	ef 81       	ldd	r30, Y+7	; 0x07
    2ad8:	f8 85       	ldd	r31, Y+8	; 0x08
    2ada:	8d 81       	ldd	r24, Y+5	; 0x05
    2adc:	9e 81       	ldd	r25, Y+6	; 0x06
    2ade:	91 83       	std	Z+1, r25	; 0x01
    2ae0:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    2ae2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ae4:	88 23       	and	r24, r24
    2ae6:	49 f0       	breq	.+18     	; 0x2afa <vTaskDelayUntil+0xc2>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    2ae8:	8d 81       	ldd	r24, Y+5	; 0x05
    2aea:	9e 81       	ldd	r25, Y+6	; 0x06
    2aec:	29 81       	ldd	r18, Y+1	; 0x01
    2aee:	3a 81       	ldd	r19, Y+2	; 0x02
    2af0:	82 1b       	sub	r24, r18
    2af2:	93 0b       	sbc	r25, r19
    2af4:	60 e0       	ldi	r22, 0x00	; 0
    2af6:	0e 94 80 1e 	call	0x3d00	; 0x3d00 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2afa:	0e 94 fa 15 	call	0x2bf4	; 0x2bf4 <xTaskResumeAll>
    2afe:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2b00:	8c 81       	ldd	r24, Y+4	; 0x04
    2b02:	88 23       	and	r24, r24
    2b04:	11 f4       	brne	.+4      	; 0x2b0a <vTaskDelayUntil+0xd2>
		{
			portYIELD_WITHIN_API();
    2b06:	0e 94 a7 0a 	call	0x154e	; 0x154e <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2b0a:	2a 96       	adiw	r28, 0x0a	; 10
    2b0c:	0f b6       	in	r0, 0x3f	; 63
    2b0e:	f8 94       	cli
    2b10:	de bf       	out	0x3e, r29	; 62
    2b12:	0f be       	out	0x3f, r0	; 63
    2b14:	cd bf       	out	0x3d, r28	; 61
    2b16:	cf 91       	pop	r28
    2b18:	df 91       	pop	r29
    2b1a:	08 95       	ret

00002b1c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    2b1c:	df 93       	push	r29
    2b1e:	cf 93       	push	r28
    2b20:	00 d0       	rcall	.+0      	; 0x2b22 <vTaskDelay+0x6>
    2b22:	0f 92       	push	r0
    2b24:	cd b7       	in	r28, 0x3d	; 61
    2b26:	de b7       	in	r29, 0x3e	; 62
    2b28:	9b 83       	std	Y+3, r25	; 0x03
    2b2a:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    2b2c:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    2b2e:	8a 81       	ldd	r24, Y+2	; 0x02
    2b30:	9b 81       	ldd	r25, Y+3	; 0x03
    2b32:	00 97       	sbiw	r24, 0x00	; 0
    2b34:	51 f0       	breq	.+20     	; 0x2b4a <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    2b36:	0e 94 ee 15 	call	0x2bdc	; 0x2bdc <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    2b3a:	8a 81       	ldd	r24, Y+2	; 0x02
    2b3c:	9b 81       	ldd	r25, Y+3	; 0x03
    2b3e:	60 e0       	ldi	r22, 0x00	; 0
    2b40:	0e 94 80 1e 	call	0x3d00	; 0x3d00 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2b44:	0e 94 fa 15 	call	0x2bf4	; 0x2bf4 <xTaskResumeAll>
    2b48:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2b4a:	89 81       	ldd	r24, Y+1	; 0x01
    2b4c:	88 23       	and	r24, r24
    2b4e:	11 f4       	brne	.+4      	; 0x2b54 <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    2b50:	0e 94 a7 0a 	call	0x154e	; 0x154e <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2b54:	0f 90       	pop	r0
    2b56:	0f 90       	pop	r0
    2b58:	0f 90       	pop	r0
    2b5a:	cf 91       	pop	r28
    2b5c:	df 91       	pop	r29
    2b5e:	08 95       	ret

00002b60 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    2b60:	ef 92       	push	r14
    2b62:	ff 92       	push	r15
    2b64:	0f 93       	push	r16
    2b66:	df 93       	push	r29
    2b68:	cf 93       	push	r28
    2b6a:	0f 92       	push	r0
    2b6c:	cd b7       	in	r28, 0x3d	; 61
    2b6e:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    2b70:	8a ef       	ldi	r24, 0xFA	; 250
    2b72:	99 e1       	ldi	r25, 0x19	; 25
    2b74:	27 e6       	ldi	r18, 0x67	; 103
    2b76:	30 e0       	ldi	r19, 0x00	; 0
    2b78:	e6 ed       	ldi	r30, 0xD6	; 214
    2b7a:	f2 e0       	ldi	r31, 0x02	; 2
    2b7c:	b9 01       	movw	r22, r18
    2b7e:	45 e5       	ldi	r20, 0x55	; 85
    2b80:	50 e0       	ldi	r21, 0x00	; 0
    2b82:	20 e0       	ldi	r18, 0x00	; 0
    2b84:	30 e0       	ldi	r19, 0x00	; 0
    2b86:	00 e0       	ldi	r16, 0x00	; 0
    2b88:	7f 01       	movw	r14, r30
    2b8a:	0e 94 fe 12 	call	0x25fc	; 0x25fc <xTaskCreate>
    2b8e:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    2b90:	89 81       	ldd	r24, Y+1	; 0x01
    2b92:	81 30       	cpi	r24, 0x01	; 1
    2b94:	81 f4       	brne	.+32     	; 0x2bb6 <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    2b96:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    2b98:	8f ef       	ldi	r24, 0xFF	; 255
    2b9a:	9f ef       	ldi	r25, 0xFF	; 255
    2b9c:	90 93 d5 02 	sts	0x02D5, r25
    2ba0:	80 93 d4 02 	sts	0x02D4, r24
		xSchedulerRunning = pdTRUE;
    2ba4:	81 e0       	ldi	r24, 0x01	; 1
    2ba6:	80 93 cf 02 	sts	0x02CF, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    2baa:	10 92 cd 02 	sts	0x02CD, r1
    2bae:	10 92 cc 02 	sts	0x02CC, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    2bb2:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    2bb6:	0f 90       	pop	r0
    2bb8:	cf 91       	pop	r28
    2bba:	df 91       	pop	r29
    2bbc:	0f 91       	pop	r16
    2bbe:	ff 90       	pop	r15
    2bc0:	ef 90       	pop	r14
    2bc2:	08 95       	ret

00002bc4 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    2bc4:	df 93       	push	r29
    2bc6:	cf 93       	push	r28
    2bc8:	cd b7       	in	r28, 0x3d	; 61
    2bca:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    2bcc:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    2bce:	10 92 cf 02 	sts	0x02CF, r1
	vPortEndScheduler();
    2bd2:	0e 94 a0 0a 	call	0x1540	; 0x1540 <vPortEndScheduler>
}
    2bd6:	cf 91       	pop	r28
    2bd8:	df 91       	pop	r29
    2bda:	08 95       	ret

00002bdc <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    2bdc:	df 93       	push	r29
    2bde:	cf 93       	push	r28
    2be0:	cd b7       	in	r28, 0x3d	; 61
    2be2:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    2be4:	80 91 d8 02 	lds	r24, 0x02D8
    2be8:	8f 5f       	subi	r24, 0xFF	; 255
    2bea:	80 93 d8 02 	sts	0x02D8, r24
	portMEMORY_BARRIER();
}
    2bee:	cf 91       	pop	r28
    2bf0:	df 91       	pop	r29
    2bf2:	08 95       	ret

00002bf4 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    2bf4:	df 93       	push	r29
    2bf6:	cf 93       	push	r28
    2bf8:	00 d0       	rcall	.+0      	; 0x2bfa <xTaskResumeAll+0x6>
    2bfa:	00 d0       	rcall	.+0      	; 0x2bfc <xTaskResumeAll+0x8>
    2bfc:	cd b7       	in	r28, 0x3d	; 61
    2bfe:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    2c00:	1c 82       	std	Y+4, r1	; 0x04
    2c02:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xAlreadyYielded = pdFALSE;
    2c04:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2c06:	0f b6       	in	r0, 0x3f	; 63
    2c08:	f8 94       	cli
    2c0a:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2c0c:	80 91 d8 02 	lds	r24, 0x02D8
    2c10:	81 50       	subi	r24, 0x01	; 1
    2c12:	80 93 d8 02 	sts	0x02D8, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2c16:	80 91 d8 02 	lds	r24, 0x02D8
    2c1a:	88 23       	and	r24, r24
    2c1c:	09 f0       	breq	.+2      	; 0x2c20 <xTaskResumeAll+0x2c>
    2c1e:	73 c0       	rjmp	.+230    	; 0x2d06 <xTaskResumeAll+0x112>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    2c20:	80 91 cb 02 	lds	r24, 0x02CB
    2c24:	88 23       	and	r24, r24
    2c26:	09 f4       	brne	.+2      	; 0x2c2a <xTaskResumeAll+0x36>
    2c28:	6e c0       	rjmp	.+220    	; 0x2d06 <xTaskResumeAll+0x112>
    2c2a:	45 c0       	rjmp	.+138    	; 0x2cb6 <xTaskResumeAll+0xc2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2c2c:	e0 91 18 03 	lds	r30, 0x0318
    2c30:	f0 91 19 03 	lds	r31, 0x0319
    2c34:	86 81       	ldd	r24, Z+6	; 0x06
    2c36:	97 81       	ldd	r25, Z+7	; 0x07
    2c38:	9c 83       	std	Y+4, r25	; 0x04
    2c3a:	8b 83       	std	Y+3, r24	; 0x03
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2c3c:	8b 81       	ldd	r24, Y+3	; 0x03
    2c3e:	9c 81       	ldd	r25, Y+4	; 0x04
    2c40:	0c 96       	adiw	r24, 0x0c	; 12
    2c42:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2c46:	8b 81       	ldd	r24, Y+3	; 0x03
    2c48:	9c 81       	ldd	r25, Y+4	; 0x04
    2c4a:	02 96       	adiw	r24, 0x02	; 2
    2c4c:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2c50:	eb 81       	ldd	r30, Y+3	; 0x03
    2c52:	fc 81       	ldd	r31, Y+4	; 0x04
    2c54:	96 89       	ldd	r25, Z+22	; 0x16
    2c56:	80 91 ce 02 	lds	r24, 0x02CE
    2c5a:	89 17       	cp	r24, r25
    2c5c:	28 f4       	brcc	.+10     	; 0x2c68 <xTaskResumeAll+0x74>
    2c5e:	eb 81       	ldd	r30, Y+3	; 0x03
    2c60:	fc 81       	ldd	r31, Y+4	; 0x04
    2c62:	86 89       	ldd	r24, Z+22	; 0x16
    2c64:	80 93 ce 02 	sts	0x02CE, r24
    2c68:	eb 81       	ldd	r30, Y+3	; 0x03
    2c6a:	fc 81       	ldd	r31, Y+4	; 0x04
    2c6c:	86 89       	ldd	r24, Z+22	; 0x16
    2c6e:	28 2f       	mov	r18, r24
    2c70:	30 e0       	ldi	r19, 0x00	; 0
    2c72:	c9 01       	movw	r24, r18
    2c74:	88 0f       	add	r24, r24
    2c76:	99 1f       	adc	r25, r25
    2c78:	88 0f       	add	r24, r24
    2c7a:	99 1f       	adc	r25, r25
    2c7c:	88 0f       	add	r24, r24
    2c7e:	99 1f       	adc	r25, r25
    2c80:	82 0f       	add	r24, r18
    2c82:	93 1f       	adc	r25, r19
    2c84:	ac 01       	movw	r20, r24
    2c86:	47 52       	subi	r20, 0x27	; 39
    2c88:	5d 4f       	sbci	r21, 0xFD	; 253
    2c8a:	8b 81       	ldd	r24, Y+3	; 0x03
    2c8c:	9c 81       	ldd	r25, Y+4	; 0x04
    2c8e:	9c 01       	movw	r18, r24
    2c90:	2e 5f       	subi	r18, 0xFE	; 254
    2c92:	3f 4f       	sbci	r19, 0xFF	; 255
    2c94:	ca 01       	movw	r24, r20
    2c96:	b9 01       	movw	r22, r18
    2c98:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2c9c:	eb 81       	ldd	r30, Y+3	; 0x03
    2c9e:	fc 81       	ldd	r31, Y+4	; 0x04
    2ca0:	96 89       	ldd	r25, Z+22	; 0x16
    2ca2:	e0 91 c8 02 	lds	r30, 0x02C8
    2ca6:	f0 91 c9 02 	lds	r31, 0x02C9
    2caa:	86 89       	ldd	r24, Z+22	; 0x16
    2cac:	98 17       	cp	r25, r24
    2cae:	18 f0       	brcs	.+6      	; 0x2cb6 <xTaskResumeAll+0xc2>
					{
						xYieldPending = pdTRUE;
    2cb0:	81 e0       	ldi	r24, 0x01	; 1
    2cb2:	80 93 d1 02 	sts	0x02D1, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    2cb6:	80 91 13 03 	lds	r24, 0x0313
    2cba:	88 23       	and	r24, r24
    2cbc:	09 f0       	breq	.+2      	; 0x2cc0 <xTaskResumeAll+0xcc>
    2cbe:	b6 cf       	rjmp	.-148    	; 0x2c2c <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    2cc0:	8b 81       	ldd	r24, Y+3	; 0x03
    2cc2:	9c 81       	ldd	r25, Y+4	; 0x04
    2cc4:	00 97       	sbiw	r24, 0x00	; 0
    2cc6:	11 f0       	breq	.+4      	; 0x2ccc <xTaskResumeAll+0xd8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    2cc8:	0e 94 86 1a 	call	0x350c	; 0x350c <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    2ccc:	80 91 d0 02 	lds	r24, 0x02D0
    2cd0:	89 83       	std	Y+1, r24	; 0x01

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    2cd2:	89 81       	ldd	r24, Y+1	; 0x01
    2cd4:	88 23       	and	r24, r24
    2cd6:	79 f0       	breq	.+30     	; 0x2cf6 <xTaskResumeAll+0x102>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    2cd8:	0e 94 ea 16 	call	0x2dd4	; 0x2dd4 <xTaskIncrementTick>
    2cdc:	88 23       	and	r24, r24
    2cde:	19 f0       	breq	.+6      	; 0x2ce6 <xTaskResumeAll+0xf2>
							{
								xYieldPending = pdTRUE;
    2ce0:	81 e0       	ldi	r24, 0x01	; 1
    2ce2:	80 93 d1 02 	sts	0x02D1, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    2ce6:	89 81       	ldd	r24, Y+1	; 0x01
    2ce8:	81 50       	subi	r24, 0x01	; 1
    2cea:	89 83       	std	Y+1, r24	; 0x01
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    2cec:	89 81       	ldd	r24, Y+1	; 0x01
    2cee:	88 23       	and	r24, r24
    2cf0:	99 f7       	brne	.-26     	; 0x2cd8 <xTaskResumeAll+0xe4>

						uxPendedTicks = 0;
    2cf2:	10 92 d0 02 	sts	0x02D0, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    2cf6:	80 91 d1 02 	lds	r24, 0x02D1
    2cfa:	88 23       	and	r24, r24
    2cfc:	21 f0       	breq	.+8      	; 0x2d06 <xTaskResumeAll+0x112>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    2cfe:	81 e0       	ldi	r24, 0x01	; 1
    2d00:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    2d02:	0e 94 a7 0a 	call	0x154e	; 0x154e <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    2d06:	0f 90       	pop	r0
    2d08:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    2d0a:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2d0c:	0f 90       	pop	r0
    2d0e:	0f 90       	pop	r0
    2d10:	0f 90       	pop	r0
    2d12:	0f 90       	pop	r0
    2d14:	cf 91       	pop	r28
    2d16:	df 91       	pop	r29
    2d18:	08 95       	ret

00002d1a <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    2d1a:	df 93       	push	r29
    2d1c:	cf 93       	push	r28
    2d1e:	00 d0       	rcall	.+0      	; 0x2d20 <xTaskGetTickCount+0x6>
    2d20:	cd b7       	in	r28, 0x3d	; 61
    2d22:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    2d24:	0f b6       	in	r0, 0x3f	; 63
    2d26:	f8 94       	cli
    2d28:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    2d2a:	80 91 cc 02 	lds	r24, 0x02CC
    2d2e:	90 91 cd 02 	lds	r25, 0x02CD
    2d32:	9a 83       	std	Y+2, r25	; 0x02
    2d34:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    2d36:	0f 90       	pop	r0
    2d38:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    2d3a:	89 81       	ldd	r24, Y+1	; 0x01
    2d3c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2d3e:	0f 90       	pop	r0
    2d40:	0f 90       	pop	r0
    2d42:	cf 91       	pop	r28
    2d44:	df 91       	pop	r29
    2d46:	08 95       	ret

00002d48 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    2d48:	df 93       	push	r29
    2d4a:	cf 93       	push	r28
    2d4c:	00 d0       	rcall	.+0      	; 0x2d4e <xTaskGetTickCountFromISR+0x6>
    2d4e:	0f 92       	push	r0
    2d50:	cd b7       	in	r28, 0x3d	; 61
    2d52:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    2d54:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    2d56:	80 91 cc 02 	lds	r24, 0x02CC
    2d5a:	90 91 cd 02 	lds	r25, 0x02CD
    2d5e:	9b 83       	std	Y+3, r25	; 0x03
    2d60:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2d62:	8a 81       	ldd	r24, Y+2	; 0x02
    2d64:	9b 81       	ldd	r25, Y+3	; 0x03
}
    2d66:	0f 90       	pop	r0
    2d68:	0f 90       	pop	r0
    2d6a:	0f 90       	pop	r0
    2d6c:	cf 91       	pop	r28
    2d6e:	df 91       	pop	r29
    2d70:	08 95       	ret

00002d72 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    2d72:	df 93       	push	r29
    2d74:	cf 93       	push	r28
    2d76:	cd b7       	in	r28, 0x3d	; 61
    2d78:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    2d7a:	80 91 cb 02 	lds	r24, 0x02CB
}
    2d7e:	cf 91       	pop	r28
    2d80:	df 91       	pop	r29
    2d82:	08 95       	ret

00002d84 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    2d84:	df 93       	push	r29
    2d86:	cf 93       	push	r28
    2d88:	00 d0       	rcall	.+0      	; 0x2d8a <pcTaskGetName+0x6>
    2d8a:	00 d0       	rcall	.+0      	; 0x2d8c <pcTaskGetName+0x8>
    2d8c:	00 d0       	rcall	.+0      	; 0x2d8e <pcTaskGetName+0xa>
    2d8e:	cd b7       	in	r28, 0x3d	; 61
    2d90:	de b7       	in	r29, 0x3e	; 62
    2d92:	9c 83       	std	Y+4, r25	; 0x04
    2d94:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    2d96:	8b 81       	ldd	r24, Y+3	; 0x03
    2d98:	9c 81       	ldd	r25, Y+4	; 0x04
    2d9a:	00 97       	sbiw	r24, 0x00	; 0
    2d9c:	39 f4       	brne	.+14     	; 0x2dac <pcTaskGetName+0x28>
    2d9e:	80 91 c8 02 	lds	r24, 0x02C8
    2da2:	90 91 c9 02 	lds	r25, 0x02C9
    2da6:	9e 83       	std	Y+6, r25	; 0x06
    2da8:	8d 83       	std	Y+5, r24	; 0x05
    2daa:	04 c0       	rjmp	.+8      	; 0x2db4 <pcTaskGetName+0x30>
    2dac:	8b 81       	ldd	r24, Y+3	; 0x03
    2dae:	9c 81       	ldd	r25, Y+4	; 0x04
    2db0:	9e 83       	std	Y+6, r25	; 0x06
    2db2:	8d 83       	std	Y+5, r24	; 0x05
    2db4:	8d 81       	ldd	r24, Y+5	; 0x05
    2db6:	9e 81       	ldd	r25, Y+6	; 0x06
    2db8:	9a 83       	std	Y+2, r25	; 0x02
    2dba:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    2dbc:	89 81       	ldd	r24, Y+1	; 0x01
    2dbe:	9a 81       	ldd	r25, Y+2	; 0x02
    2dc0:	49 96       	adiw	r24, 0x19	; 25
}
    2dc2:	26 96       	adiw	r28, 0x06	; 6
    2dc4:	0f b6       	in	r0, 0x3f	; 63
    2dc6:	f8 94       	cli
    2dc8:	de bf       	out	0x3e, r29	; 62
    2dca:	0f be       	out	0x3f, r0	; 63
    2dcc:	cd bf       	out	0x3d, r28	; 61
    2dce:	cf 91       	pop	r28
    2dd0:	df 91       	pop	r29
    2dd2:	08 95       	ret

00002dd4 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    2dd4:	df 93       	push	r29
    2dd6:	cf 93       	push	r28
    2dd8:	cd b7       	in	r28, 0x3d	; 61
    2dda:	de b7       	in	r29, 0x3e	; 62
    2ddc:	29 97       	sbiw	r28, 0x09	; 9
    2dde:	0f b6       	in	r0, 0x3f	; 63
    2de0:	f8 94       	cli
    2de2:	de bf       	out	0x3e, r29	; 62
    2de4:	0f be       	out	0x3f, r0	; 63
    2de6:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    2de8:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2dea:	80 91 d8 02 	lds	r24, 0x02D8
    2dee:	88 23       	and	r24, r24
    2df0:	09 f0       	breq	.+2      	; 0x2df4 <xTaskIncrementTick+0x20>
    2df2:	c0 c0       	rjmp	.+384    	; 0x2f74 <xTaskIncrementTick+0x1a0>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    2df4:	80 91 cc 02 	lds	r24, 0x02CC
    2df8:	90 91 cd 02 	lds	r25, 0x02CD
    2dfc:	01 96       	adiw	r24, 0x01	; 1
    2dfe:	9c 83       	std	Y+4, r25	; 0x04
    2e00:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    2e02:	8b 81       	ldd	r24, Y+3	; 0x03
    2e04:	9c 81       	ldd	r25, Y+4	; 0x04
    2e06:	90 93 cd 02 	sts	0x02CD, r25
    2e0a:	80 93 cc 02 	sts	0x02CC, r24

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    2e0e:	8b 81       	ldd	r24, Y+3	; 0x03
    2e10:	9c 81       	ldd	r25, Y+4	; 0x04
    2e12:	00 97       	sbiw	r24, 0x00	; 0
    2e14:	d9 f4       	brne	.+54     	; 0x2e4c <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    2e16:	80 91 0f 03 	lds	r24, 0x030F
    2e1a:	90 91 10 03 	lds	r25, 0x0310
    2e1e:	9a 83       	std	Y+2, r25	; 0x02
    2e20:	89 83       	std	Y+1, r24	; 0x01
    2e22:	80 91 11 03 	lds	r24, 0x0311
    2e26:	90 91 12 03 	lds	r25, 0x0312
    2e2a:	90 93 10 03 	sts	0x0310, r25
    2e2e:	80 93 0f 03 	sts	0x030F, r24
    2e32:	89 81       	ldd	r24, Y+1	; 0x01
    2e34:	9a 81       	ldd	r25, Y+2	; 0x02
    2e36:	90 93 12 03 	sts	0x0312, r25
    2e3a:	80 93 11 03 	sts	0x0311, r24
    2e3e:	80 91 d2 02 	lds	r24, 0x02D2
    2e42:	8f 5f       	subi	r24, 0xFF	; 255
    2e44:	80 93 d2 02 	sts	0x02D2, r24
    2e48:	0e 94 86 1a 	call	0x350c	; 0x350c <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    2e4c:	20 91 d4 02 	lds	r18, 0x02D4
    2e50:	30 91 d5 02 	lds	r19, 0x02D5
    2e54:	8b 81       	ldd	r24, Y+3	; 0x03
    2e56:	9c 81       	ldd	r25, Y+4	; 0x04
    2e58:	82 17       	cp	r24, r18
    2e5a:	93 07       	cpc	r25, r19
    2e5c:	08 f4       	brcc	.+2      	; 0x2e60 <xTaskIncrementTick+0x8c>
    2e5e:	71 c0       	rjmp	.+226    	; 0x2f42 <xTaskIncrementTick+0x16e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2e60:	e0 91 0f 03 	lds	r30, 0x030F
    2e64:	f0 91 10 03 	lds	r31, 0x0310
    2e68:	80 81       	ld	r24, Z
    2e6a:	88 23       	and	r24, r24
    2e6c:	39 f4       	brne	.+14     	; 0x2e7c <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2e6e:	8f ef       	ldi	r24, 0xFF	; 255
    2e70:	9f ef       	ldi	r25, 0xFF	; 255
    2e72:	90 93 d5 02 	sts	0x02D5, r25
    2e76:	80 93 d4 02 	sts	0x02D4, r24
    2e7a:	63 c0       	rjmp	.+198    	; 0x2f42 <xTaskIncrementTick+0x16e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2e7c:	e0 91 0f 03 	lds	r30, 0x030F
    2e80:	f0 91 10 03 	lds	r31, 0x0310
    2e84:	05 80       	ldd	r0, Z+5	; 0x05
    2e86:	f6 81       	ldd	r31, Z+6	; 0x06
    2e88:	e0 2d       	mov	r30, r0
    2e8a:	86 81       	ldd	r24, Z+6	; 0x06
    2e8c:	97 81       	ldd	r25, Z+7	; 0x07
    2e8e:	99 87       	std	Y+9, r25	; 0x09
    2e90:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    2e92:	e8 85       	ldd	r30, Y+8	; 0x08
    2e94:	f9 85       	ldd	r31, Y+9	; 0x09
    2e96:	82 81       	ldd	r24, Z+2	; 0x02
    2e98:	93 81       	ldd	r25, Z+3	; 0x03
    2e9a:	9f 83       	std	Y+7, r25	; 0x07
    2e9c:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    2e9e:	2b 81       	ldd	r18, Y+3	; 0x03
    2ea0:	3c 81       	ldd	r19, Y+4	; 0x04
    2ea2:	8e 81       	ldd	r24, Y+6	; 0x06
    2ea4:	9f 81       	ldd	r25, Y+7	; 0x07
    2ea6:	28 17       	cp	r18, r24
    2ea8:	39 07       	cpc	r19, r25
    2eaa:	38 f4       	brcc	.+14     	; 0x2eba <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    2eac:	8e 81       	ldd	r24, Y+6	; 0x06
    2eae:	9f 81       	ldd	r25, Y+7	; 0x07
    2eb0:	90 93 d5 02 	sts	0x02D5, r25
    2eb4:	80 93 d4 02 	sts	0x02D4, r24
    2eb8:	44 c0       	rjmp	.+136    	; 0x2f42 <xTaskIncrementTick+0x16e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2eba:	88 85       	ldd	r24, Y+8	; 0x08
    2ebc:	99 85       	ldd	r25, Y+9	; 0x09
    2ebe:	02 96       	adiw	r24, 0x02	; 2
    2ec0:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    2ec4:	e8 85       	ldd	r30, Y+8	; 0x08
    2ec6:	f9 85       	ldd	r31, Y+9	; 0x09
    2ec8:	84 89       	ldd	r24, Z+20	; 0x14
    2eca:	95 89       	ldd	r25, Z+21	; 0x15
    2ecc:	00 97       	sbiw	r24, 0x00	; 0
    2ece:	29 f0       	breq	.+10     	; 0x2eda <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2ed0:	88 85       	ldd	r24, Y+8	; 0x08
    2ed2:	99 85       	ldd	r25, Y+9	; 0x09
    2ed4:	0c 96       	adiw	r24, 0x0c	; 12
    2ed6:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    2eda:	e8 85       	ldd	r30, Y+8	; 0x08
    2edc:	f9 85       	ldd	r31, Y+9	; 0x09
    2ede:	96 89       	ldd	r25, Z+22	; 0x16
    2ee0:	80 91 ce 02 	lds	r24, 0x02CE
    2ee4:	89 17       	cp	r24, r25
    2ee6:	28 f4       	brcc	.+10     	; 0x2ef2 <xTaskIncrementTick+0x11e>
    2ee8:	e8 85       	ldd	r30, Y+8	; 0x08
    2eea:	f9 85       	ldd	r31, Y+9	; 0x09
    2eec:	86 89       	ldd	r24, Z+22	; 0x16
    2eee:	80 93 ce 02 	sts	0x02CE, r24
    2ef2:	e8 85       	ldd	r30, Y+8	; 0x08
    2ef4:	f9 85       	ldd	r31, Y+9	; 0x09
    2ef6:	86 89       	ldd	r24, Z+22	; 0x16
    2ef8:	28 2f       	mov	r18, r24
    2efa:	30 e0       	ldi	r19, 0x00	; 0
    2efc:	c9 01       	movw	r24, r18
    2efe:	88 0f       	add	r24, r24
    2f00:	99 1f       	adc	r25, r25
    2f02:	88 0f       	add	r24, r24
    2f04:	99 1f       	adc	r25, r25
    2f06:	88 0f       	add	r24, r24
    2f08:	99 1f       	adc	r25, r25
    2f0a:	82 0f       	add	r24, r18
    2f0c:	93 1f       	adc	r25, r19
    2f0e:	ac 01       	movw	r20, r24
    2f10:	47 52       	subi	r20, 0x27	; 39
    2f12:	5d 4f       	sbci	r21, 0xFD	; 253
    2f14:	88 85       	ldd	r24, Y+8	; 0x08
    2f16:	99 85       	ldd	r25, Y+9	; 0x09
    2f18:	9c 01       	movw	r18, r24
    2f1a:	2e 5f       	subi	r18, 0xFE	; 254
    2f1c:	3f 4f       	sbci	r19, 0xFF	; 255
    2f1e:	ca 01       	movw	r24, r20
    2f20:	b9 01       	movw	r22, r18
    2f22:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2f26:	e8 85       	ldd	r30, Y+8	; 0x08
    2f28:	f9 85       	ldd	r31, Y+9	; 0x09
    2f2a:	96 89       	ldd	r25, Z+22	; 0x16
    2f2c:	e0 91 c8 02 	lds	r30, 0x02C8
    2f30:	f0 91 c9 02 	lds	r31, 0x02C9
    2f34:	86 89       	ldd	r24, Z+22	; 0x16
    2f36:	98 17       	cp	r25, r24
    2f38:	08 f4       	brcc	.+2      	; 0x2f3c <xTaskIncrementTick+0x168>
    2f3a:	92 cf       	rjmp	.-220    	; 0x2e60 <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    2f3c:	81 e0       	ldi	r24, 0x01	; 1
    2f3e:	8d 83       	std	Y+5, r24	; 0x05
    2f40:	8f cf       	rjmp	.-226    	; 0x2e60 <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    2f42:	e0 91 c8 02 	lds	r30, 0x02C8
    2f46:	f0 91 c9 02 	lds	r31, 0x02C9
    2f4a:	86 89       	ldd	r24, Z+22	; 0x16
    2f4c:	28 2f       	mov	r18, r24
    2f4e:	30 e0       	ldi	r19, 0x00	; 0
    2f50:	c9 01       	movw	r24, r18
    2f52:	88 0f       	add	r24, r24
    2f54:	99 1f       	adc	r25, r25
    2f56:	88 0f       	add	r24, r24
    2f58:	99 1f       	adc	r25, r25
    2f5a:	88 0f       	add	r24, r24
    2f5c:	99 1f       	adc	r25, r25
    2f5e:	82 0f       	add	r24, r18
    2f60:	93 1f       	adc	r25, r19
    2f62:	fc 01       	movw	r30, r24
    2f64:	e7 52       	subi	r30, 0x27	; 39
    2f66:	fd 4f       	sbci	r31, 0xFD	; 253
    2f68:	80 81       	ld	r24, Z
    2f6a:	82 30       	cpi	r24, 0x02	; 2
    2f6c:	40 f0       	brcs	.+16     	; 0x2f7e <xTaskIncrementTick+0x1aa>
			{
				xSwitchRequired = pdTRUE;
    2f6e:	81 e0       	ldi	r24, 0x01	; 1
    2f70:	8d 83       	std	Y+5, r24	; 0x05
    2f72:	05 c0       	rjmp	.+10     	; 0x2f7e <xTaskIncrementTick+0x1aa>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    2f74:	80 91 d0 02 	lds	r24, 0x02D0
    2f78:	8f 5f       	subi	r24, 0xFF	; 255
    2f7a:	80 93 d0 02 	sts	0x02D0, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    2f7e:	80 91 d1 02 	lds	r24, 0x02D1
    2f82:	88 23       	and	r24, r24
    2f84:	11 f0       	breq	.+4      	; 0x2f8a <xTaskIncrementTick+0x1b6>
		{
			xSwitchRequired = pdTRUE;
    2f86:	81 e0       	ldi	r24, 0x01	; 1
    2f88:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    2f8a:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2f8c:	29 96       	adiw	r28, 0x09	; 9
    2f8e:	0f b6       	in	r0, 0x3f	; 63
    2f90:	f8 94       	cli
    2f92:	de bf       	out	0x3e, r29	; 62
    2f94:	0f be       	out	0x3f, r0	; 63
    2f96:	cd bf       	out	0x3d, r28	; 61
    2f98:	cf 91       	pop	r28
    2f9a:	df 91       	pop	r29
    2f9c:	08 95       	ret

00002f9e <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    2f9e:	df 93       	push	r29
    2fa0:	cf 93       	push	r28
    2fa2:	00 d0       	rcall	.+0      	; 0x2fa4 <vTaskSwitchContext+0x6>
    2fa4:	0f 92       	push	r0
    2fa6:	cd b7       	in	r28, 0x3d	; 61
    2fa8:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    2faa:	80 91 d8 02 	lds	r24, 0x02D8
    2fae:	88 23       	and	r24, r24
    2fb0:	21 f0       	breq	.+8      	; 0x2fba <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    2fb2:	81 e0       	ldi	r24, 0x01	; 1
    2fb4:	80 93 d1 02 	sts	0x02D1, r24
    2fb8:	59 c0       	rjmp	.+178    	; 0x306c <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    2fba:	10 92 d1 02 	sts	0x02D1, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2fbe:	80 91 ce 02 	lds	r24, 0x02CE
    2fc2:	8b 83       	std	Y+3, r24	; 0x03
    2fc4:	03 c0       	rjmp	.+6      	; 0x2fcc <vTaskSwitchContext+0x2e>
    2fc6:	8b 81       	ldd	r24, Y+3	; 0x03
    2fc8:	81 50       	subi	r24, 0x01	; 1
    2fca:	8b 83       	std	Y+3, r24	; 0x03
    2fcc:	8b 81       	ldd	r24, Y+3	; 0x03
    2fce:	28 2f       	mov	r18, r24
    2fd0:	30 e0       	ldi	r19, 0x00	; 0
    2fd2:	c9 01       	movw	r24, r18
    2fd4:	88 0f       	add	r24, r24
    2fd6:	99 1f       	adc	r25, r25
    2fd8:	88 0f       	add	r24, r24
    2fda:	99 1f       	adc	r25, r25
    2fdc:	88 0f       	add	r24, r24
    2fde:	99 1f       	adc	r25, r25
    2fe0:	82 0f       	add	r24, r18
    2fe2:	93 1f       	adc	r25, r19
    2fe4:	fc 01       	movw	r30, r24
    2fe6:	e7 52       	subi	r30, 0x27	; 39
    2fe8:	fd 4f       	sbci	r31, 0xFD	; 253
    2fea:	80 81       	ld	r24, Z
    2fec:	88 23       	and	r24, r24
    2fee:	59 f3       	breq	.-42     	; 0x2fc6 <vTaskSwitchContext+0x28>
    2ff0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ff2:	28 2f       	mov	r18, r24
    2ff4:	30 e0       	ldi	r19, 0x00	; 0
    2ff6:	c9 01       	movw	r24, r18
    2ff8:	88 0f       	add	r24, r24
    2ffa:	99 1f       	adc	r25, r25
    2ffc:	88 0f       	add	r24, r24
    2ffe:	99 1f       	adc	r25, r25
    3000:	88 0f       	add	r24, r24
    3002:	99 1f       	adc	r25, r25
    3004:	82 0f       	add	r24, r18
    3006:	93 1f       	adc	r25, r19
    3008:	87 52       	subi	r24, 0x27	; 39
    300a:	9d 4f       	sbci	r25, 0xFD	; 253
    300c:	9a 83       	std	Y+2, r25	; 0x02
    300e:	89 83       	std	Y+1, r24	; 0x01
    3010:	e9 81       	ldd	r30, Y+1	; 0x01
    3012:	fa 81       	ldd	r31, Y+2	; 0x02
    3014:	01 80       	ldd	r0, Z+1	; 0x01
    3016:	f2 81       	ldd	r31, Z+2	; 0x02
    3018:	e0 2d       	mov	r30, r0
    301a:	82 81       	ldd	r24, Z+2	; 0x02
    301c:	93 81       	ldd	r25, Z+3	; 0x03
    301e:	e9 81       	ldd	r30, Y+1	; 0x01
    3020:	fa 81       	ldd	r31, Y+2	; 0x02
    3022:	92 83       	std	Z+2, r25	; 0x02
    3024:	81 83       	std	Z+1, r24	; 0x01
    3026:	e9 81       	ldd	r30, Y+1	; 0x01
    3028:	fa 81       	ldd	r31, Y+2	; 0x02
    302a:	21 81       	ldd	r18, Z+1	; 0x01
    302c:	32 81       	ldd	r19, Z+2	; 0x02
    302e:	89 81       	ldd	r24, Y+1	; 0x01
    3030:	9a 81       	ldd	r25, Y+2	; 0x02
    3032:	03 96       	adiw	r24, 0x03	; 3
    3034:	28 17       	cp	r18, r24
    3036:	39 07       	cpc	r19, r25
    3038:	59 f4       	brne	.+22     	; 0x3050 <vTaskSwitchContext+0xb2>
    303a:	e9 81       	ldd	r30, Y+1	; 0x01
    303c:	fa 81       	ldd	r31, Y+2	; 0x02
    303e:	01 80       	ldd	r0, Z+1	; 0x01
    3040:	f2 81       	ldd	r31, Z+2	; 0x02
    3042:	e0 2d       	mov	r30, r0
    3044:	82 81       	ldd	r24, Z+2	; 0x02
    3046:	93 81       	ldd	r25, Z+3	; 0x03
    3048:	e9 81       	ldd	r30, Y+1	; 0x01
    304a:	fa 81       	ldd	r31, Y+2	; 0x02
    304c:	92 83       	std	Z+2, r25	; 0x02
    304e:	81 83       	std	Z+1, r24	; 0x01
    3050:	e9 81       	ldd	r30, Y+1	; 0x01
    3052:	fa 81       	ldd	r31, Y+2	; 0x02
    3054:	01 80       	ldd	r0, Z+1	; 0x01
    3056:	f2 81       	ldd	r31, Z+2	; 0x02
    3058:	e0 2d       	mov	r30, r0
    305a:	86 81       	ldd	r24, Z+6	; 0x06
    305c:	97 81       	ldd	r25, Z+7	; 0x07
    305e:	90 93 c9 02 	sts	0x02C9, r25
    3062:	80 93 c8 02 	sts	0x02C8, r24
    3066:	8b 81       	ldd	r24, Y+3	; 0x03
    3068:	80 93 ce 02 	sts	0x02CE, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    306c:	0f 90       	pop	r0
    306e:	0f 90       	pop	r0
    3070:	0f 90       	pop	r0
    3072:	cf 91       	pop	r28
    3074:	df 91       	pop	r29
    3076:	08 95       	ret

00003078 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    3078:	df 93       	push	r29
    307a:	cf 93       	push	r28
    307c:	00 d0       	rcall	.+0      	; 0x307e <vTaskPlaceOnEventList+0x6>
    307e:	00 d0       	rcall	.+0      	; 0x3080 <vTaskPlaceOnEventList+0x8>
    3080:	cd b7       	in	r28, 0x3d	; 61
    3082:	de b7       	in	r29, 0x3e	; 62
    3084:	9a 83       	std	Y+2, r25	; 0x02
    3086:	89 83       	std	Y+1, r24	; 0x01
    3088:	7c 83       	std	Y+4, r23	; 0x04
    308a:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    308c:	80 91 c8 02 	lds	r24, 0x02C8
    3090:	90 91 c9 02 	lds	r25, 0x02C9
    3094:	9c 01       	movw	r18, r24
    3096:	24 5f       	subi	r18, 0xF4	; 244
    3098:	3f 4f       	sbci	r19, 0xFF	; 255
    309a:	89 81       	ldd	r24, Y+1	; 0x01
    309c:	9a 81       	ldd	r25, Y+2	; 0x02
    309e:	b9 01       	movw	r22, r18
    30a0:	0e 94 a9 07 	call	0xf52	; 0xf52 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    30a4:	8b 81       	ldd	r24, Y+3	; 0x03
    30a6:	9c 81       	ldd	r25, Y+4	; 0x04
    30a8:	61 e0       	ldi	r22, 0x01	; 1
    30aa:	0e 94 80 1e 	call	0x3d00	; 0x3d00 <prvAddCurrentTaskToDelayedList>
}
    30ae:	0f 90       	pop	r0
    30b0:	0f 90       	pop	r0
    30b2:	0f 90       	pop	r0
    30b4:	0f 90       	pop	r0
    30b6:	cf 91       	pop	r28
    30b8:	df 91       	pop	r29
    30ba:	08 95       	ret

000030bc <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    30bc:	df 93       	push	r29
    30be:	cf 93       	push	r28
    30c0:	00 d0       	rcall	.+0      	; 0x30c2 <vTaskPlaceOnUnorderedEventList+0x6>
    30c2:	00 d0       	rcall	.+0      	; 0x30c4 <vTaskPlaceOnUnorderedEventList+0x8>
    30c4:	00 d0       	rcall	.+0      	; 0x30c6 <vTaskPlaceOnUnorderedEventList+0xa>
    30c6:	cd b7       	in	r28, 0x3d	; 61
    30c8:	de b7       	in	r29, 0x3e	; 62
    30ca:	9a 83       	std	Y+2, r25	; 0x02
    30cc:	89 83       	std	Y+1, r24	; 0x01
    30ce:	7c 83       	std	Y+4, r23	; 0x04
    30d0:	6b 83       	std	Y+3, r22	; 0x03
    30d2:	5e 83       	std	Y+6, r21	; 0x06
    30d4:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    30d6:	e0 91 c8 02 	lds	r30, 0x02C8
    30da:	f0 91 c9 02 	lds	r31, 0x02C9
    30de:	8b 81       	ldd	r24, Y+3	; 0x03
    30e0:	9c 81       	ldd	r25, Y+4	; 0x04
    30e2:	90 68       	ori	r25, 0x80	; 128
    30e4:	95 87       	std	Z+13, r25	; 0x0d
    30e6:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    30e8:	80 91 c8 02 	lds	r24, 0x02C8
    30ec:	90 91 c9 02 	lds	r25, 0x02C9
    30f0:	9c 01       	movw	r18, r24
    30f2:	24 5f       	subi	r18, 0xF4	; 244
    30f4:	3f 4f       	sbci	r19, 0xFF	; 255
    30f6:	89 81       	ldd	r24, Y+1	; 0x01
    30f8:	9a 81       	ldd	r25, Y+2	; 0x02
    30fa:	b9 01       	movw	r22, r18
    30fc:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3100:	8d 81       	ldd	r24, Y+5	; 0x05
    3102:	9e 81       	ldd	r25, Y+6	; 0x06
    3104:	61 e0       	ldi	r22, 0x01	; 1
    3106:	0e 94 80 1e 	call	0x3d00	; 0x3d00 <prvAddCurrentTaskToDelayedList>
}
    310a:	26 96       	adiw	r28, 0x06	; 6
    310c:	0f b6       	in	r0, 0x3f	; 63
    310e:	f8 94       	cli
    3110:	de bf       	out	0x3e, r29	; 62
    3112:	0f be       	out	0x3f, r0	; 63
    3114:	cd bf       	out	0x3d, r28	; 61
    3116:	cf 91       	pop	r28
    3118:	df 91       	pop	r29
    311a:	08 95       	ret

0000311c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    311c:	df 93       	push	r29
    311e:	cf 93       	push	r28
    3120:	00 d0       	rcall	.+0      	; 0x3122 <xTaskRemoveFromEventList+0x6>
    3122:	00 d0       	rcall	.+0      	; 0x3124 <xTaskRemoveFromEventList+0x8>
    3124:	0f 92       	push	r0
    3126:	cd b7       	in	r28, 0x3d	; 61
    3128:	de b7       	in	r29, 0x3e	; 62
    312a:	9d 83       	std	Y+5, r25	; 0x05
    312c:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    312e:	ec 81       	ldd	r30, Y+4	; 0x04
    3130:	fd 81       	ldd	r31, Y+5	; 0x05
    3132:	05 80       	ldd	r0, Z+5	; 0x05
    3134:	f6 81       	ldd	r31, Z+6	; 0x06
    3136:	e0 2d       	mov	r30, r0
    3138:	86 81       	ldd	r24, Z+6	; 0x06
    313a:	97 81       	ldd	r25, Z+7	; 0x07
    313c:	9b 83       	std	Y+3, r25	; 0x03
    313e:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    3140:	8a 81       	ldd	r24, Y+2	; 0x02
    3142:	9b 81       	ldd	r25, Y+3	; 0x03
    3144:	0c 96       	adiw	r24, 0x0c	; 12
    3146:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    314a:	80 91 d8 02 	lds	r24, 0x02D8
    314e:	88 23       	and	r24, r24
    3150:	61 f5       	brne	.+88     	; 0x31aa <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    3152:	8a 81       	ldd	r24, Y+2	; 0x02
    3154:	9b 81       	ldd	r25, Y+3	; 0x03
    3156:	02 96       	adiw	r24, 0x02	; 2
    3158:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    315c:	ea 81       	ldd	r30, Y+2	; 0x02
    315e:	fb 81       	ldd	r31, Y+3	; 0x03
    3160:	96 89       	ldd	r25, Z+22	; 0x16
    3162:	80 91 ce 02 	lds	r24, 0x02CE
    3166:	89 17       	cp	r24, r25
    3168:	28 f4       	brcc	.+10     	; 0x3174 <xTaskRemoveFromEventList+0x58>
    316a:	ea 81       	ldd	r30, Y+2	; 0x02
    316c:	fb 81       	ldd	r31, Y+3	; 0x03
    316e:	86 89       	ldd	r24, Z+22	; 0x16
    3170:	80 93 ce 02 	sts	0x02CE, r24
    3174:	ea 81       	ldd	r30, Y+2	; 0x02
    3176:	fb 81       	ldd	r31, Y+3	; 0x03
    3178:	86 89       	ldd	r24, Z+22	; 0x16
    317a:	28 2f       	mov	r18, r24
    317c:	30 e0       	ldi	r19, 0x00	; 0
    317e:	c9 01       	movw	r24, r18
    3180:	88 0f       	add	r24, r24
    3182:	99 1f       	adc	r25, r25
    3184:	88 0f       	add	r24, r24
    3186:	99 1f       	adc	r25, r25
    3188:	88 0f       	add	r24, r24
    318a:	99 1f       	adc	r25, r25
    318c:	82 0f       	add	r24, r18
    318e:	93 1f       	adc	r25, r19
    3190:	ac 01       	movw	r20, r24
    3192:	47 52       	subi	r20, 0x27	; 39
    3194:	5d 4f       	sbci	r21, 0xFD	; 253
    3196:	8a 81       	ldd	r24, Y+2	; 0x02
    3198:	9b 81       	ldd	r25, Y+3	; 0x03
    319a:	9c 01       	movw	r18, r24
    319c:	2e 5f       	subi	r18, 0xFE	; 254
    319e:	3f 4f       	sbci	r19, 0xFF	; 255
    31a0:	ca 01       	movw	r24, r20
    31a2:	b9 01       	movw	r22, r18
    31a4:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>
    31a8:	0a c0       	rjmp	.+20     	; 0x31be <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    31aa:	8a 81       	ldd	r24, Y+2	; 0x02
    31ac:	9b 81       	ldd	r25, Y+3	; 0x03
    31ae:	9c 01       	movw	r18, r24
    31b0:	24 5f       	subi	r18, 0xF4	; 244
    31b2:	3f 4f       	sbci	r19, 0xFF	; 255
    31b4:	83 e1       	ldi	r24, 0x13	; 19
    31b6:	93 e0       	ldi	r25, 0x03	; 3
    31b8:	b9 01       	movw	r22, r18
    31ba:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    31be:	ea 81       	ldd	r30, Y+2	; 0x02
    31c0:	fb 81       	ldd	r31, Y+3	; 0x03
    31c2:	96 89       	ldd	r25, Z+22	; 0x16
    31c4:	e0 91 c8 02 	lds	r30, 0x02C8
    31c8:	f0 91 c9 02 	lds	r31, 0x02C9
    31cc:	86 89       	ldd	r24, Z+22	; 0x16
    31ce:	89 17       	cp	r24, r25
    31d0:	30 f4       	brcc	.+12     	; 0x31de <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    31d2:	81 e0       	ldi	r24, 0x01	; 1
    31d4:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    31d6:	81 e0       	ldi	r24, 0x01	; 1
    31d8:	80 93 d1 02 	sts	0x02D1, r24
    31dc:	01 c0       	rjmp	.+2      	; 0x31e0 <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    31de:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    31e0:	89 81       	ldd	r24, Y+1	; 0x01
}
    31e2:	0f 90       	pop	r0
    31e4:	0f 90       	pop	r0
    31e6:	0f 90       	pop	r0
    31e8:	0f 90       	pop	r0
    31ea:	0f 90       	pop	r0
    31ec:	cf 91       	pop	r28
    31ee:	df 91       	pop	r29
    31f0:	08 95       	ret

000031f2 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    31f2:	df 93       	push	r29
    31f4:	cf 93       	push	r28
    31f6:	00 d0       	rcall	.+0      	; 0x31f8 <vTaskRemoveFromUnorderedEventList+0x6>
    31f8:	00 d0       	rcall	.+0      	; 0x31fa <vTaskRemoveFromUnorderedEventList+0x8>
    31fa:	00 d0       	rcall	.+0      	; 0x31fc <vTaskRemoveFromUnorderedEventList+0xa>
    31fc:	cd b7       	in	r28, 0x3d	; 61
    31fe:	de b7       	in	r29, 0x3e	; 62
    3200:	9c 83       	std	Y+4, r25	; 0x04
    3202:	8b 83       	std	Y+3, r24	; 0x03
    3204:	7e 83       	std	Y+6, r23	; 0x06
    3206:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3208:	8d 81       	ldd	r24, Y+5	; 0x05
    320a:	9e 81       	ldd	r25, Y+6	; 0x06
    320c:	90 68       	ori	r25, 0x80	; 128
    320e:	eb 81       	ldd	r30, Y+3	; 0x03
    3210:	fc 81       	ldd	r31, Y+4	; 0x04
    3212:	91 83       	std	Z+1, r25	; 0x01
    3214:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3216:	eb 81       	ldd	r30, Y+3	; 0x03
    3218:	fc 81       	ldd	r31, Y+4	; 0x04
    321a:	86 81       	ldd	r24, Z+6	; 0x06
    321c:	97 81       	ldd	r25, Z+7	; 0x07
    321e:	9a 83       	std	Y+2, r25	; 0x02
    3220:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    3222:	8b 81       	ldd	r24, Y+3	; 0x03
    3224:	9c 81       	ldd	r25, Y+4	; 0x04
    3226:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    322a:	89 81       	ldd	r24, Y+1	; 0x01
    322c:	9a 81       	ldd	r25, Y+2	; 0x02
    322e:	02 96       	adiw	r24, 0x02	; 2
    3230:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    3234:	e9 81       	ldd	r30, Y+1	; 0x01
    3236:	fa 81       	ldd	r31, Y+2	; 0x02
    3238:	96 89       	ldd	r25, Z+22	; 0x16
    323a:	80 91 ce 02 	lds	r24, 0x02CE
    323e:	89 17       	cp	r24, r25
    3240:	28 f4       	brcc	.+10     	; 0x324c <vTaskRemoveFromUnorderedEventList+0x5a>
    3242:	e9 81       	ldd	r30, Y+1	; 0x01
    3244:	fa 81       	ldd	r31, Y+2	; 0x02
    3246:	86 89       	ldd	r24, Z+22	; 0x16
    3248:	80 93 ce 02 	sts	0x02CE, r24
    324c:	e9 81       	ldd	r30, Y+1	; 0x01
    324e:	fa 81       	ldd	r31, Y+2	; 0x02
    3250:	86 89       	ldd	r24, Z+22	; 0x16
    3252:	28 2f       	mov	r18, r24
    3254:	30 e0       	ldi	r19, 0x00	; 0
    3256:	c9 01       	movw	r24, r18
    3258:	88 0f       	add	r24, r24
    325a:	99 1f       	adc	r25, r25
    325c:	88 0f       	add	r24, r24
    325e:	99 1f       	adc	r25, r25
    3260:	88 0f       	add	r24, r24
    3262:	99 1f       	adc	r25, r25
    3264:	82 0f       	add	r24, r18
    3266:	93 1f       	adc	r25, r19
    3268:	ac 01       	movw	r20, r24
    326a:	47 52       	subi	r20, 0x27	; 39
    326c:	5d 4f       	sbci	r21, 0xFD	; 253
    326e:	89 81       	ldd	r24, Y+1	; 0x01
    3270:	9a 81       	ldd	r25, Y+2	; 0x02
    3272:	9c 01       	movw	r18, r24
    3274:	2e 5f       	subi	r18, 0xFE	; 254
    3276:	3f 4f       	sbci	r19, 0xFF	; 255
    3278:	ca 01       	movw	r24, r20
    327a:	b9 01       	movw	r22, r18
    327c:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3280:	e9 81       	ldd	r30, Y+1	; 0x01
    3282:	fa 81       	ldd	r31, Y+2	; 0x02
    3284:	96 89       	ldd	r25, Z+22	; 0x16
    3286:	e0 91 c8 02 	lds	r30, 0x02C8
    328a:	f0 91 c9 02 	lds	r31, 0x02C9
    328e:	86 89       	ldd	r24, Z+22	; 0x16
    3290:	89 17       	cp	r24, r25
    3292:	18 f4       	brcc	.+6      	; 0x329a <vTaskRemoveFromUnorderedEventList+0xa8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    3294:	81 e0       	ldi	r24, 0x01	; 1
    3296:	80 93 d1 02 	sts	0x02D1, r24
	}
}
    329a:	26 96       	adiw	r28, 0x06	; 6
    329c:	0f b6       	in	r0, 0x3f	; 63
    329e:	f8 94       	cli
    32a0:	de bf       	out	0x3e, r29	; 62
    32a2:	0f be       	out	0x3f, r0	; 63
    32a4:	cd bf       	out	0x3d, r28	; 61
    32a6:	cf 91       	pop	r28
    32a8:	df 91       	pop	r29
    32aa:	08 95       	ret

000032ac <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    32ac:	df 93       	push	r29
    32ae:	cf 93       	push	r28
    32b0:	00 d0       	rcall	.+0      	; 0x32b2 <vTaskSetTimeOutState+0x6>
    32b2:	cd b7       	in	r28, 0x3d	; 61
    32b4:	de b7       	in	r29, 0x3e	; 62
    32b6:	9a 83       	std	Y+2, r25	; 0x02
    32b8:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    32ba:	0f b6       	in	r0, 0x3f	; 63
    32bc:	f8 94       	cli
    32be:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    32c0:	80 91 d2 02 	lds	r24, 0x02D2
    32c4:	e9 81       	ldd	r30, Y+1	; 0x01
    32c6:	fa 81       	ldd	r31, Y+2	; 0x02
    32c8:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    32ca:	80 91 cc 02 	lds	r24, 0x02CC
    32ce:	90 91 cd 02 	lds	r25, 0x02CD
    32d2:	e9 81       	ldd	r30, Y+1	; 0x01
    32d4:	fa 81       	ldd	r31, Y+2	; 0x02
    32d6:	92 83       	std	Z+2, r25	; 0x02
    32d8:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    32da:	0f 90       	pop	r0
    32dc:	0f be       	out	0x3f, r0	; 63
}
    32de:	0f 90       	pop	r0
    32e0:	0f 90       	pop	r0
    32e2:	cf 91       	pop	r28
    32e4:	df 91       	pop	r29
    32e6:	08 95       	ret

000032e8 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    32e8:	df 93       	push	r29
    32ea:	cf 93       	push	r28
    32ec:	00 d0       	rcall	.+0      	; 0x32ee <vTaskInternalSetTimeOutState+0x6>
    32ee:	cd b7       	in	r28, 0x3d	; 61
    32f0:	de b7       	in	r29, 0x3e	; 62
    32f2:	9a 83       	std	Y+2, r25	; 0x02
    32f4:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    32f6:	80 91 d2 02 	lds	r24, 0x02D2
    32fa:	e9 81       	ldd	r30, Y+1	; 0x01
    32fc:	fa 81       	ldd	r31, Y+2	; 0x02
    32fe:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    3300:	80 91 cc 02 	lds	r24, 0x02CC
    3304:	90 91 cd 02 	lds	r25, 0x02CD
    3308:	e9 81       	ldd	r30, Y+1	; 0x01
    330a:	fa 81       	ldd	r31, Y+2	; 0x02
    330c:	92 83       	std	Z+2, r25	; 0x02
    330e:	81 83       	std	Z+1, r24	; 0x01
}
    3310:	0f 90       	pop	r0
    3312:	0f 90       	pop	r0
    3314:	cf 91       	pop	r28
    3316:	df 91       	pop	r29
    3318:	08 95       	ret

0000331a <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    331a:	df 93       	push	r29
    331c:	cf 93       	push	r28
    331e:	cd b7       	in	r28, 0x3d	; 61
    3320:	de b7       	in	r29, 0x3e	; 62
    3322:	29 97       	sbiw	r28, 0x09	; 9
    3324:	0f b6       	in	r0, 0x3f	; 63
    3326:	f8 94       	cli
    3328:	de bf       	out	0x3e, r29	; 62
    332a:	0f be       	out	0x3f, r0	; 63
    332c:	cd bf       	out	0x3d, r28	; 61
    332e:	9f 83       	std	Y+7, r25	; 0x07
    3330:	8e 83       	std	Y+6, r24	; 0x06
    3332:	79 87       	std	Y+9, r23	; 0x09
    3334:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    3336:	0f b6       	in	r0, 0x3f	; 63
    3338:	f8 94       	cli
    333a:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    333c:	80 91 cc 02 	lds	r24, 0x02CC
    3340:	90 91 cd 02 	lds	r25, 0x02CD
    3344:	9c 83       	std	Y+4, r25	; 0x04
    3346:	8b 83       	std	Y+3, r24	; 0x03
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    3348:	ee 81       	ldd	r30, Y+6	; 0x06
    334a:	ff 81       	ldd	r31, Y+7	; 0x07
    334c:	21 81       	ldd	r18, Z+1	; 0x01
    334e:	32 81       	ldd	r19, Z+2	; 0x02
    3350:	8b 81       	ldd	r24, Y+3	; 0x03
    3352:	9c 81       	ldd	r25, Y+4	; 0x04
    3354:	82 1b       	sub	r24, r18
    3356:	93 0b       	sbc	r25, r19
    3358:	9a 83       	std	Y+2, r25	; 0x02
    335a:	89 83       	std	Y+1, r24	; 0x01
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    335c:	ee 81       	ldd	r30, Y+6	; 0x06
    335e:	ff 81       	ldd	r31, Y+7	; 0x07
    3360:	90 81       	ld	r25, Z
    3362:	80 91 d2 02 	lds	r24, 0x02D2
    3366:	98 17       	cp	r25, r24
    3368:	61 f0       	breq	.+24     	; 0x3382 <xTaskCheckForTimeOut+0x68>
    336a:	ee 81       	ldd	r30, Y+6	; 0x06
    336c:	ff 81       	ldd	r31, Y+7	; 0x07
    336e:	21 81       	ldd	r18, Z+1	; 0x01
    3370:	32 81       	ldd	r19, Z+2	; 0x02
    3372:	8b 81       	ldd	r24, Y+3	; 0x03
    3374:	9c 81       	ldd	r25, Y+4	; 0x04
    3376:	82 17       	cp	r24, r18
    3378:	93 07       	cpc	r25, r19
    337a:	18 f0       	brcs	.+6      	; 0x3382 <xTaskCheckForTimeOut+0x68>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    337c:	81 e0       	ldi	r24, 0x01	; 1
    337e:	8d 83       	std	Y+5, r24	; 0x05
    3380:	23 c0       	rjmp	.+70     	; 0x33c8 <xTaskCheckForTimeOut+0xae>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    3382:	e8 85       	ldd	r30, Y+8	; 0x08
    3384:	f9 85       	ldd	r31, Y+9	; 0x09
    3386:	20 81       	ld	r18, Z
    3388:	31 81       	ldd	r19, Z+1	; 0x01
    338a:	89 81       	ldd	r24, Y+1	; 0x01
    338c:	9a 81       	ldd	r25, Y+2	; 0x02
    338e:	82 17       	cp	r24, r18
    3390:	93 07       	cpc	r25, r19
    3392:	a0 f4       	brcc	.+40     	; 0x33bc <xTaskCheckForTimeOut+0xa2>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    3394:	e8 85       	ldd	r30, Y+8	; 0x08
    3396:	f9 85       	ldd	r31, Y+9	; 0x09
    3398:	20 81       	ld	r18, Z
    339a:	31 81       	ldd	r19, Z+1	; 0x01
    339c:	89 81       	ldd	r24, Y+1	; 0x01
    339e:	9a 81       	ldd	r25, Y+2	; 0x02
    33a0:	a9 01       	movw	r20, r18
    33a2:	48 1b       	sub	r20, r24
    33a4:	59 0b       	sbc	r21, r25
    33a6:	ca 01       	movw	r24, r20
    33a8:	e8 85       	ldd	r30, Y+8	; 0x08
    33aa:	f9 85       	ldd	r31, Y+9	; 0x09
    33ac:	91 83       	std	Z+1, r25	; 0x01
    33ae:	80 83       	st	Z, r24
			vTaskInternalSetTimeOutState( pxTimeOut );
    33b0:	8e 81       	ldd	r24, Y+6	; 0x06
    33b2:	9f 81       	ldd	r25, Y+7	; 0x07
    33b4:	0e 94 74 19 	call	0x32e8	; 0x32e8 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    33b8:	1d 82       	std	Y+5, r1	; 0x05
    33ba:	06 c0       	rjmp	.+12     	; 0x33c8 <xTaskCheckForTimeOut+0xae>
		}
		else
		{
			*pxTicksToWait = 0;
    33bc:	e8 85       	ldd	r30, Y+8	; 0x08
    33be:	f9 85       	ldd	r31, Y+9	; 0x09
    33c0:	11 82       	std	Z+1, r1	; 0x01
    33c2:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    33c4:	81 e0       	ldi	r24, 0x01	; 1
    33c6:	8d 83       	std	Y+5, r24	; 0x05
		}
	}
	taskEXIT_CRITICAL();
    33c8:	0f 90       	pop	r0
    33ca:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    33cc:	8d 81       	ldd	r24, Y+5	; 0x05
}
    33ce:	29 96       	adiw	r28, 0x09	; 9
    33d0:	0f b6       	in	r0, 0x3f	; 63
    33d2:	f8 94       	cli
    33d4:	de bf       	out	0x3e, r29	; 62
    33d6:	0f be       	out	0x3f, r0	; 63
    33d8:	cd bf       	out	0x3d, r28	; 61
    33da:	cf 91       	pop	r28
    33dc:	df 91       	pop	r29
    33de:	08 95       	ret

000033e0 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    33e0:	df 93       	push	r29
    33e2:	cf 93       	push	r28
    33e4:	cd b7       	in	r28, 0x3d	; 61
    33e6:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    33e8:	81 e0       	ldi	r24, 0x01	; 1
    33ea:	80 93 d1 02 	sts	0x02D1, r24
}
    33ee:	cf 91       	pop	r28
    33f0:	df 91       	pop	r29
    33f2:	08 95       	ret

000033f4 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    33f4:	df 93       	push	r29
    33f6:	cf 93       	push	r28
    33f8:	00 d0       	rcall	.+0      	; 0x33fa <prvIdleTask+0x6>
    33fa:	cd b7       	in	r28, 0x3d	; 61
    33fc:	de b7       	in	r29, 0x3e	; 62
    33fe:	9a 83       	std	Y+2, r25	; 0x02
    3400:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    3402:	0e 94 41 1a 	call	0x3482	; 0x3482 <prvCheckTasksWaitingTermination>
    3406:	fd cf       	rjmp	.-6      	; 0x3402 <prvIdleTask+0xe>

00003408 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    3408:	df 93       	push	r29
    340a:	cf 93       	push	r28
    340c:	0f 92       	push	r0
    340e:	cd b7       	in	r28, 0x3d	; 61
    3410:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    3412:	19 82       	std	Y+1, r1	; 0x01
    3414:	13 c0       	rjmp	.+38     	; 0x343c <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    3416:	89 81       	ldd	r24, Y+1	; 0x01
    3418:	28 2f       	mov	r18, r24
    341a:	30 e0       	ldi	r19, 0x00	; 0
    341c:	c9 01       	movw	r24, r18
    341e:	88 0f       	add	r24, r24
    3420:	99 1f       	adc	r25, r25
    3422:	88 0f       	add	r24, r24
    3424:	99 1f       	adc	r25, r25
    3426:	88 0f       	add	r24, r24
    3428:	99 1f       	adc	r25, r25
    342a:	82 0f       	add	r24, r18
    342c:	93 1f       	adc	r25, r19
    342e:	87 52       	subi	r24, 0x27	; 39
    3430:	9d 4f       	sbci	r25, 0xFD	; 253
    3432:	0e 94 2b 07 	call	0xe56	; 0xe56 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    3436:	89 81       	ldd	r24, Y+1	; 0x01
    3438:	8f 5f       	subi	r24, 0xFF	; 255
    343a:	89 83       	std	Y+1, r24	; 0x01
    343c:	89 81       	ldd	r24, Y+1	; 0x01
    343e:	84 30       	cpi	r24, 0x04	; 4
    3440:	50 f3       	brcs	.-44     	; 0x3416 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    3442:	8d ef       	ldi	r24, 0xFD	; 253
    3444:	92 e0       	ldi	r25, 0x02	; 2
    3446:	0e 94 2b 07 	call	0xe56	; 0xe56 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    344a:	86 e0       	ldi	r24, 0x06	; 6
    344c:	93 e0       	ldi	r25, 0x03	; 3
    344e:	0e 94 2b 07 	call	0xe56	; 0xe56 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    3452:	83 e1       	ldi	r24, 0x13	; 19
    3454:	93 e0       	ldi	r25, 0x03	; 3
    3456:	0e 94 2b 07 	call	0xe56	; 0xe56 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    345a:	8c e1       	ldi	r24, 0x1C	; 28
    345c:	93 e0       	ldi	r25, 0x03	; 3
    345e:	0e 94 2b 07 	call	0xe56	; 0xe56 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    3462:	8d ef       	ldi	r24, 0xFD	; 253
    3464:	92 e0       	ldi	r25, 0x02	; 2
    3466:	90 93 10 03 	sts	0x0310, r25
    346a:	80 93 0f 03 	sts	0x030F, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    346e:	86 e0       	ldi	r24, 0x06	; 6
    3470:	93 e0       	ldi	r25, 0x03	; 3
    3472:	90 93 12 03 	sts	0x0312, r25
    3476:	80 93 11 03 	sts	0x0311, r24
}
    347a:	0f 90       	pop	r0
    347c:	cf 91       	pop	r28
    347e:	df 91       	pop	r29
    3480:	08 95       	ret

00003482 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    3482:	df 93       	push	r29
    3484:	cf 93       	push	r28
    3486:	00 d0       	rcall	.+0      	; 0x3488 <prvCheckTasksWaitingTermination+0x6>
    3488:	cd b7       	in	r28, 0x3d	; 61
    348a:	de b7       	in	r29, 0x3e	; 62
    348c:	20 c0       	rjmp	.+64     	; 0x34ce <prvCheckTasksWaitingTermination+0x4c>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
    348e:	0f b6       	in	r0, 0x3f	; 63
    3490:	f8 94       	cli
    3492:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3494:	e0 91 21 03 	lds	r30, 0x0321
    3498:	f0 91 22 03 	lds	r31, 0x0322
    349c:	86 81       	ldd	r24, Z+6	; 0x06
    349e:	97 81       	ldd	r25, Z+7	; 0x07
    34a0:	9a 83       	std	Y+2, r25	; 0x02
    34a2:	89 83       	std	Y+1, r24	; 0x01
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    34a4:	89 81       	ldd	r24, Y+1	; 0x01
    34a6:	9a 81       	ldd	r25, Y+2	; 0x02
    34a8:	02 96       	adiw	r24, 0x02	; 2
    34aa:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>
				--uxCurrentNumberOfTasks;
    34ae:	80 91 cb 02 	lds	r24, 0x02CB
    34b2:	81 50       	subi	r24, 0x01	; 1
    34b4:	80 93 cb 02 	sts	0x02CB, r24
				--uxDeletedTasksWaitingCleanUp;
    34b8:	80 91 ca 02 	lds	r24, 0x02CA
    34bc:	81 50       	subi	r24, 0x01	; 1
    34be:	80 93 ca 02 	sts	0x02CA, r24
			}
			taskEXIT_CRITICAL();
    34c2:	0f 90       	pop	r0
    34c4:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    34c6:	89 81       	ldd	r24, Y+1	; 0x01
    34c8:	9a 81       	ldd	r25, Y+2	; 0x02
    34ca:	0e 94 70 1a 	call	0x34e0	; 0x34e0 <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    34ce:	80 91 ca 02 	lds	r24, 0x02CA
    34d2:	88 23       	and	r24, r24
    34d4:	e1 f6       	brne	.-72     	; 0x348e <prvCheckTasksWaitingTermination+0xc>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    34d6:	0f 90       	pop	r0
    34d8:	0f 90       	pop	r0
    34da:	cf 91       	pop	r28
    34dc:	df 91       	pop	r29
    34de:	08 95       	ret

000034e0 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    34e0:	df 93       	push	r29
    34e2:	cf 93       	push	r28
    34e4:	00 d0       	rcall	.+0      	; 0x34e6 <prvDeleteTCB+0x6>
    34e6:	cd b7       	in	r28, 0x3d	; 61
    34e8:	de b7       	in	r29, 0x3e	; 62
    34ea:	9a 83       	std	Y+2, r25	; 0x02
    34ec:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    34ee:	e9 81       	ldd	r30, Y+1	; 0x01
    34f0:	fa 81       	ldd	r31, Y+2	; 0x02
    34f2:	87 89       	ldd	r24, Z+23	; 0x17
    34f4:	90 8d       	ldd	r25, Z+24	; 0x18
    34f6:	0e 94 05 07 	call	0xe0a	; 0xe0a <vPortFree>
			vPortFree( pxTCB );
    34fa:	89 81       	ldd	r24, Y+1	; 0x01
    34fc:	9a 81       	ldd	r25, Y+2	; 0x02
    34fe:	0e 94 05 07 	call	0xe0a	; 0xe0a <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    3502:	0f 90       	pop	r0
    3504:	0f 90       	pop	r0
    3506:	cf 91       	pop	r28
    3508:	df 91       	pop	r29
    350a:	08 95       	ret

0000350c <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    350c:	df 93       	push	r29
    350e:	cf 93       	push	r28
    3510:	00 d0       	rcall	.+0      	; 0x3512 <prvResetNextTaskUnblockTime+0x6>
    3512:	cd b7       	in	r28, 0x3d	; 61
    3514:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3516:	e0 91 0f 03 	lds	r30, 0x030F
    351a:	f0 91 10 03 	lds	r31, 0x0310
    351e:	80 81       	ld	r24, Z
    3520:	88 23       	and	r24, r24
    3522:	39 f4       	brne	.+14     	; 0x3532 <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    3524:	8f ef       	ldi	r24, 0xFF	; 255
    3526:	9f ef       	ldi	r25, 0xFF	; 255
    3528:	90 93 d5 02 	sts	0x02D5, r25
    352c:	80 93 d4 02 	sts	0x02D4, r24
    3530:	13 c0       	rjmp	.+38     	; 0x3558 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3532:	e0 91 0f 03 	lds	r30, 0x030F
    3536:	f0 91 10 03 	lds	r31, 0x0310
    353a:	05 80       	ldd	r0, Z+5	; 0x05
    353c:	f6 81       	ldd	r31, Z+6	; 0x06
    353e:	e0 2d       	mov	r30, r0
    3540:	86 81       	ldd	r24, Z+6	; 0x06
    3542:	97 81       	ldd	r25, Z+7	; 0x07
    3544:	9a 83       	std	Y+2, r25	; 0x02
    3546:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    3548:	e9 81       	ldd	r30, Y+1	; 0x01
    354a:	fa 81       	ldd	r31, Y+2	; 0x02
    354c:	82 81       	ldd	r24, Z+2	; 0x02
    354e:	93 81       	ldd	r25, Z+3	; 0x03
    3550:	90 93 d5 02 	sts	0x02D5, r25
    3554:	80 93 d4 02 	sts	0x02D4, r24
	}
}
    3558:	0f 90       	pop	r0
    355a:	0f 90       	pop	r0
    355c:	cf 91       	pop	r28
    355e:	df 91       	pop	r29
    3560:	08 95       	ret

00003562 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    3562:	df 93       	push	r29
    3564:	cf 93       	push	r28
    3566:	00 d0       	rcall	.+0      	; 0x3568 <uxTaskResetEventItemValue+0x6>
    3568:	cd b7       	in	r28, 0x3d	; 61
    356a:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    356c:	e0 91 c8 02 	lds	r30, 0x02C8
    3570:	f0 91 c9 02 	lds	r31, 0x02C9
    3574:	84 85       	ldd	r24, Z+12	; 0x0c
    3576:	95 85       	ldd	r25, Z+13	; 0x0d
    3578:	9a 83       	std	Y+2, r25	; 0x02
    357a:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    357c:	a0 91 c8 02 	lds	r26, 0x02C8
    3580:	b0 91 c9 02 	lds	r27, 0x02C9
    3584:	e0 91 c8 02 	lds	r30, 0x02C8
    3588:	f0 91 c9 02 	lds	r31, 0x02C9
    358c:	86 89       	ldd	r24, Z+22	; 0x16
    358e:	28 2f       	mov	r18, r24
    3590:	30 e0       	ldi	r19, 0x00	; 0
    3592:	84 e0       	ldi	r24, 0x04	; 4
    3594:	90 e0       	ldi	r25, 0x00	; 0
    3596:	82 1b       	sub	r24, r18
    3598:	93 0b       	sbc	r25, r19
    359a:	1d 96       	adiw	r26, 0x0d	; 13
    359c:	9c 93       	st	X, r25
    359e:	8e 93       	st	-X, r24
    35a0:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    35a2:	89 81       	ldd	r24, Y+1	; 0x01
    35a4:	9a 81       	ldd	r25, Y+2	; 0x02
}
    35a6:	0f 90       	pop	r0
    35a8:	0f 90       	pop	r0
    35aa:	cf 91       	pop	r28
    35ac:	df 91       	pop	r29
    35ae:	08 95       	ret

000035b0 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    35b0:	df 93       	push	r29
    35b2:	cf 93       	push	r28
    35b4:	cd b7       	in	r28, 0x3d	; 61
    35b6:	de b7       	in	r29, 0x3e	; 62
    35b8:	27 97       	sbiw	r28, 0x07	; 7
    35ba:	0f b6       	in	r0, 0x3f	; 63
    35bc:	f8 94       	cli
    35be:	de bf       	out	0x3e, r29	; 62
    35c0:	0f be       	out	0x3f, r0	; 63
    35c2:	cd bf       	out	0x3d, r28	; 61
    35c4:	8d 83       	std	Y+5, r24	; 0x05
    35c6:	7f 83       	std	Y+7, r23	; 0x07
    35c8:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    35ca:	0f b6       	in	r0, 0x3f	; 63
    35cc:	f8 94       	cli
    35ce:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    35d0:	e0 91 c8 02 	lds	r30, 0x02C8
    35d4:	f0 91 c9 02 	lds	r31, 0x02C9
    35d8:	81 a1       	ldd	r24, Z+33	; 0x21
    35da:	92 a1       	ldd	r25, Z+34	; 0x22
    35dc:	a3 a1       	ldd	r26, Z+35	; 0x23
    35de:	b4 a1       	ldd	r27, Z+36	; 0x24
    35e0:	00 97       	sbiw	r24, 0x00	; 0
    35e2:	a1 05       	cpc	r26, r1
    35e4:	b1 05       	cpc	r27, r1
    35e6:	89 f4       	brne	.+34     	; 0x360a <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    35e8:	e0 91 c8 02 	lds	r30, 0x02C8
    35ec:	f0 91 c9 02 	lds	r31, 0x02C9
    35f0:	81 e0       	ldi	r24, 0x01	; 1
    35f2:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    35f4:	8e 81       	ldd	r24, Y+6	; 0x06
    35f6:	9f 81       	ldd	r25, Y+7	; 0x07
    35f8:	00 97       	sbiw	r24, 0x00	; 0
    35fa:	39 f0       	breq	.+14     	; 0x360a <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    35fc:	8e 81       	ldd	r24, Y+6	; 0x06
    35fe:	9f 81       	ldd	r25, Y+7	; 0x07
    3600:	61 e0       	ldi	r22, 0x01	; 1
    3602:	0e 94 80 1e 	call	0x3d00	; 0x3d00 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    3606:	0e 94 a7 0a 	call	0x154e	; 0x154e <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    360a:	0f 90       	pop	r0
    360c:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    360e:	0f b6       	in	r0, 0x3f	; 63
    3610:	f8 94       	cli
    3612:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    3614:	e0 91 c8 02 	lds	r30, 0x02C8
    3618:	f0 91 c9 02 	lds	r31, 0x02C9
    361c:	81 a1       	ldd	r24, Z+33	; 0x21
    361e:	92 a1       	ldd	r25, Z+34	; 0x22
    3620:	a3 a1       	ldd	r26, Z+35	; 0x23
    3622:	b4 a1       	ldd	r27, Z+36	; 0x24
    3624:	89 83       	std	Y+1, r24	; 0x01
    3626:	9a 83       	std	Y+2, r25	; 0x02
    3628:	ab 83       	std	Y+3, r26	; 0x03
    362a:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    362c:	89 81       	ldd	r24, Y+1	; 0x01
    362e:	9a 81       	ldd	r25, Y+2	; 0x02
    3630:	ab 81       	ldd	r26, Y+3	; 0x03
    3632:	bc 81       	ldd	r27, Y+4	; 0x04
    3634:	00 97       	sbiw	r24, 0x00	; 0
    3636:	a1 05       	cpc	r26, r1
    3638:	b1 05       	cpc	r27, r1
    363a:	d9 f0       	breq	.+54     	; 0x3672 <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    363c:	8d 81       	ldd	r24, Y+5	; 0x05
    363e:	88 23       	and	r24, r24
    3640:	49 f0       	breq	.+18     	; 0x3654 <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    3642:	e0 91 c8 02 	lds	r30, 0x02C8
    3646:	f0 91 c9 02 	lds	r31, 0x02C9
    364a:	11 a2       	std	Z+33, r1	; 0x21
    364c:	12 a2       	std	Z+34, r1	; 0x22
    364e:	13 a2       	std	Z+35, r1	; 0x23
    3650:	14 a2       	std	Z+36, r1	; 0x24
    3652:	0f c0       	rjmp	.+30     	; 0x3672 <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    3654:	e0 91 c8 02 	lds	r30, 0x02C8
    3658:	f0 91 c9 02 	lds	r31, 0x02C9
    365c:	89 81       	ldd	r24, Y+1	; 0x01
    365e:	9a 81       	ldd	r25, Y+2	; 0x02
    3660:	ab 81       	ldd	r26, Y+3	; 0x03
    3662:	bc 81       	ldd	r27, Y+4	; 0x04
    3664:	01 97       	sbiw	r24, 0x01	; 1
    3666:	a1 09       	sbc	r26, r1
    3668:	b1 09       	sbc	r27, r1
    366a:	81 a3       	std	Z+33, r24	; 0x21
    366c:	92 a3       	std	Z+34, r25	; 0x22
    366e:	a3 a3       	std	Z+35, r26	; 0x23
    3670:	b4 a3       	std	Z+36, r27	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3672:	e0 91 c8 02 	lds	r30, 0x02C8
    3676:	f0 91 c9 02 	lds	r31, 0x02C9
    367a:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    367c:	0f 90       	pop	r0
    367e:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    3680:	89 81       	ldd	r24, Y+1	; 0x01
    3682:	9a 81       	ldd	r25, Y+2	; 0x02
    3684:	ab 81       	ldd	r26, Y+3	; 0x03
    3686:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    3688:	bc 01       	movw	r22, r24
    368a:	cd 01       	movw	r24, r26
    368c:	27 96       	adiw	r28, 0x07	; 7
    368e:	0f b6       	in	r0, 0x3f	; 63
    3690:	f8 94       	cli
    3692:	de bf       	out	0x3e, r29	; 62
    3694:	0f be       	out	0x3f, r0	; 63
    3696:	cd bf       	out	0x3d, r28	; 61
    3698:	cf 91       	pop	r28
    369a:	df 91       	pop	r29
    369c:	08 95       	ret

0000369e <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    369e:	ef 92       	push	r14
    36a0:	ff 92       	push	r15
    36a2:	0f 93       	push	r16
    36a4:	1f 93       	push	r17
    36a6:	df 93       	push	r29
    36a8:	cf 93       	push	r28
    36aa:	cd b7       	in	r28, 0x3d	; 61
    36ac:	de b7       	in	r29, 0x3e	; 62
    36ae:	2d 97       	sbiw	r28, 0x0d	; 13
    36b0:	0f b6       	in	r0, 0x3f	; 63
    36b2:	f8 94       	cli
    36b4:	de bf       	out	0x3e, r29	; 62
    36b6:	0f be       	out	0x3f, r0	; 63
    36b8:	cd bf       	out	0x3d, r28	; 61
    36ba:	6a 83       	std	Y+2, r22	; 0x02
    36bc:	7b 83       	std	Y+3, r23	; 0x03
    36be:	8c 83       	std	Y+4, r24	; 0x04
    36c0:	9d 83       	std	Y+5, r25	; 0x05
    36c2:	2e 83       	std	Y+6, r18	; 0x06
    36c4:	3f 83       	std	Y+7, r19	; 0x07
    36c6:	48 87       	std	Y+8, r20	; 0x08
    36c8:	59 87       	std	Y+9, r21	; 0x09
    36ca:	1b 87       	std	Y+11, r17	; 0x0b
    36cc:	0a 87       	std	Y+10, r16	; 0x0a
    36ce:	fd 86       	std	Y+13, r15	; 0x0d
    36d0:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    36d2:	0f b6       	in	r0, 0x3f	; 63
    36d4:	f8 94       	cli
    36d6:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    36d8:	e0 91 c8 02 	lds	r30, 0x02C8
    36dc:	f0 91 c9 02 	lds	r31, 0x02C9
    36e0:	85 a1       	ldd	r24, Z+37	; 0x25
    36e2:	82 30       	cpi	r24, 0x02	; 2
    36e4:	49 f1       	breq	.+82     	; 0x3738 <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    36e6:	e0 91 c8 02 	lds	r30, 0x02C8
    36ea:	f0 91 c9 02 	lds	r31, 0x02C9
    36ee:	21 a1       	ldd	r18, Z+33	; 0x21
    36f0:	32 a1       	ldd	r19, Z+34	; 0x22
    36f2:	43 a1       	ldd	r20, Z+35	; 0x23
    36f4:	54 a1       	ldd	r21, Z+36	; 0x24
    36f6:	8a 81       	ldd	r24, Y+2	; 0x02
    36f8:	9b 81       	ldd	r25, Y+3	; 0x03
    36fa:	ac 81       	ldd	r26, Y+4	; 0x04
    36fc:	bd 81       	ldd	r27, Y+5	; 0x05
    36fe:	80 95       	com	r24
    3700:	90 95       	com	r25
    3702:	a0 95       	com	r26
    3704:	b0 95       	com	r27
    3706:	82 23       	and	r24, r18
    3708:	93 23       	and	r25, r19
    370a:	a4 23       	and	r26, r20
    370c:	b5 23       	and	r27, r21
    370e:	81 a3       	std	Z+33, r24	; 0x21
    3710:	92 a3       	std	Z+34, r25	; 0x22
    3712:	a3 a3       	std	Z+35, r26	; 0x23
    3714:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    3716:	e0 91 c8 02 	lds	r30, 0x02C8
    371a:	f0 91 c9 02 	lds	r31, 0x02C9
    371e:	81 e0       	ldi	r24, 0x01	; 1
    3720:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    3722:	8c 85       	ldd	r24, Y+12	; 0x0c
    3724:	9d 85       	ldd	r25, Y+13	; 0x0d
    3726:	00 97       	sbiw	r24, 0x00	; 0
    3728:	39 f0       	breq	.+14     	; 0x3738 <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    372a:	8c 85       	ldd	r24, Y+12	; 0x0c
    372c:	9d 85       	ldd	r25, Y+13	; 0x0d
    372e:	61 e0       	ldi	r22, 0x01	; 1
    3730:	0e 94 80 1e 	call	0x3d00	; 0x3d00 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    3734:	0e 94 a7 0a 	call	0x154e	; 0x154e <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    3738:	0f 90       	pop	r0
    373a:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    373c:	0f b6       	in	r0, 0x3f	; 63
    373e:	f8 94       	cli
    3740:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    3742:	8a 85       	ldd	r24, Y+10	; 0x0a
    3744:	9b 85       	ldd	r25, Y+11	; 0x0b
    3746:	00 97       	sbiw	r24, 0x00	; 0
    3748:	71 f0       	breq	.+28     	; 0x3766 <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    374a:	e0 91 c8 02 	lds	r30, 0x02C8
    374e:	f0 91 c9 02 	lds	r31, 0x02C9
    3752:	81 a1       	ldd	r24, Z+33	; 0x21
    3754:	92 a1       	ldd	r25, Z+34	; 0x22
    3756:	a3 a1       	ldd	r26, Z+35	; 0x23
    3758:	b4 a1       	ldd	r27, Z+36	; 0x24
    375a:	ea 85       	ldd	r30, Y+10	; 0x0a
    375c:	fb 85       	ldd	r31, Y+11	; 0x0b
    375e:	80 83       	st	Z, r24
    3760:	91 83       	std	Z+1, r25	; 0x01
    3762:	a2 83       	std	Z+2, r26	; 0x02
    3764:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    3766:	e0 91 c8 02 	lds	r30, 0x02C8
    376a:	f0 91 c9 02 	lds	r31, 0x02C9
    376e:	85 a1       	ldd	r24, Z+37	; 0x25
    3770:	82 30       	cpi	r24, 0x02	; 2
    3772:	11 f0       	breq	.+4      	; 0x3778 <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    3774:	19 82       	std	Y+1, r1	; 0x01
    3776:	1a c0       	rjmp	.+52     	; 0x37ac <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    3778:	e0 91 c8 02 	lds	r30, 0x02C8
    377c:	f0 91 c9 02 	lds	r31, 0x02C9
    3780:	21 a1       	ldd	r18, Z+33	; 0x21
    3782:	32 a1       	ldd	r19, Z+34	; 0x22
    3784:	43 a1       	ldd	r20, Z+35	; 0x23
    3786:	54 a1       	ldd	r21, Z+36	; 0x24
    3788:	8e 81       	ldd	r24, Y+6	; 0x06
    378a:	9f 81       	ldd	r25, Y+7	; 0x07
    378c:	a8 85       	ldd	r26, Y+8	; 0x08
    378e:	b9 85       	ldd	r27, Y+9	; 0x09
    3790:	80 95       	com	r24
    3792:	90 95       	com	r25
    3794:	a0 95       	com	r26
    3796:	b0 95       	com	r27
    3798:	82 23       	and	r24, r18
    379a:	93 23       	and	r25, r19
    379c:	a4 23       	and	r26, r20
    379e:	b5 23       	and	r27, r21
    37a0:	81 a3       	std	Z+33, r24	; 0x21
    37a2:	92 a3       	std	Z+34, r25	; 0x22
    37a4:	a3 a3       	std	Z+35, r26	; 0x23
    37a6:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
    37a8:	81 e0       	ldi	r24, 0x01	; 1
    37aa:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    37ac:	e0 91 c8 02 	lds	r30, 0x02C8
    37b0:	f0 91 c9 02 	lds	r31, 0x02C9
    37b4:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    37b6:	0f 90       	pop	r0
    37b8:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    37ba:	89 81       	ldd	r24, Y+1	; 0x01
	}
    37bc:	2d 96       	adiw	r28, 0x0d	; 13
    37be:	0f b6       	in	r0, 0x3f	; 63
    37c0:	f8 94       	cli
    37c2:	de bf       	out	0x3e, r29	; 62
    37c4:	0f be       	out	0x3f, r0	; 63
    37c6:	cd bf       	out	0x3d, r28	; 61
    37c8:	cf 91       	pop	r28
    37ca:	df 91       	pop	r29
    37cc:	1f 91       	pop	r17
    37ce:	0f 91       	pop	r16
    37d0:	ff 90       	pop	r15
    37d2:	ef 90       	pop	r14
    37d4:	08 95       	ret

000037d6 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    37d6:	0f 93       	push	r16
    37d8:	1f 93       	push	r17
    37da:	df 93       	push	r29
    37dc:	cf 93       	push	r28
    37de:	cd b7       	in	r28, 0x3d	; 61
    37e0:	de b7       	in	r29, 0x3e	; 62
    37e2:	2f 97       	sbiw	r28, 0x0f	; 15
    37e4:	0f b6       	in	r0, 0x3f	; 63
    37e6:	f8 94       	cli
    37e8:	de bf       	out	0x3e, r29	; 62
    37ea:	0f be       	out	0x3f, r0	; 63
    37ec:	cd bf       	out	0x3d, r28	; 61
    37ee:	9e 83       	std	Y+6, r25	; 0x06
    37f0:	8d 83       	std	Y+5, r24	; 0x05
    37f2:	4f 83       	std	Y+7, r20	; 0x07
    37f4:	58 87       	std	Y+8, r21	; 0x08
    37f6:	69 87       	std	Y+9, r22	; 0x09
    37f8:	7a 87       	std	Y+10, r23	; 0x0a
    37fa:	2b 87       	std	Y+11, r18	; 0x0b
    37fc:	1d 87       	std	Y+13, r17	; 0x0d
    37fe:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    3800:	81 e0       	ldi	r24, 0x01	; 1
    3802:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    3804:	8d 81       	ldd	r24, Y+5	; 0x05
    3806:	9e 81       	ldd	r25, Y+6	; 0x06
    3808:	9c 83       	std	Y+4, r25	; 0x04
    380a:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    380c:	0f b6       	in	r0, 0x3f	; 63
    380e:	f8 94       	cli
    3810:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    3812:	8c 85       	ldd	r24, Y+12	; 0x0c
    3814:	9d 85       	ldd	r25, Y+13	; 0x0d
    3816:	00 97       	sbiw	r24, 0x00	; 0
    3818:	61 f0       	breq	.+24     	; 0x3832 <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    381a:	eb 81       	ldd	r30, Y+3	; 0x03
    381c:	fc 81       	ldd	r31, Y+4	; 0x04
    381e:	81 a1       	ldd	r24, Z+33	; 0x21
    3820:	92 a1       	ldd	r25, Z+34	; 0x22
    3822:	a3 a1       	ldd	r26, Z+35	; 0x23
    3824:	b4 a1       	ldd	r27, Z+36	; 0x24
    3826:	ec 85       	ldd	r30, Y+12	; 0x0c
    3828:	fd 85       	ldd	r31, Y+13	; 0x0d
    382a:	80 83       	st	Z, r24
    382c:	91 83       	std	Z+1, r25	; 0x01
    382e:	a2 83       	std	Z+2, r26	; 0x02
    3830:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    3832:	eb 81       	ldd	r30, Y+3	; 0x03
    3834:	fc 81       	ldd	r31, Y+4	; 0x04
    3836:	85 a1       	ldd	r24, Z+37	; 0x25
    3838:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    383a:	eb 81       	ldd	r30, Y+3	; 0x03
    383c:	fc 81       	ldd	r31, Y+4	; 0x04
    383e:	82 e0       	ldi	r24, 0x02	; 2
    3840:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    3842:	8b 85       	ldd	r24, Y+11	; 0x0b
    3844:	28 2f       	mov	r18, r24
    3846:	30 e0       	ldi	r19, 0x00	; 0
    3848:	3f 87       	std	Y+15, r19	; 0x0f
    384a:	2e 87       	std	Y+14, r18	; 0x0e
    384c:	8e 85       	ldd	r24, Y+14	; 0x0e
    384e:	9f 85       	ldd	r25, Y+15	; 0x0f
    3850:	82 30       	cpi	r24, 0x02	; 2
    3852:	91 05       	cpc	r25, r1
    3854:	59 f1       	breq	.+86     	; 0x38ac <xTaskGenericNotify+0xd6>
    3856:	2e 85       	ldd	r18, Y+14	; 0x0e
    3858:	3f 85       	ldd	r19, Y+15	; 0x0f
    385a:	23 30       	cpi	r18, 0x03	; 3
    385c:	31 05       	cpc	r19, r1
    385e:	34 f4       	brge	.+12     	; 0x386c <xTaskGenericNotify+0x96>
    3860:	8e 85       	ldd	r24, Y+14	; 0x0e
    3862:	9f 85       	ldd	r25, Y+15	; 0x0f
    3864:	81 30       	cpi	r24, 0x01	; 1
    3866:	91 05       	cpc	r25, r1
    3868:	61 f0       	breq	.+24     	; 0x3882 <xTaskGenericNotify+0xac>
    386a:	4a c0       	rjmp	.+148    	; 0x3900 <xTaskGenericNotify+0x12a>
    386c:	2e 85       	ldd	r18, Y+14	; 0x0e
    386e:	3f 85       	ldd	r19, Y+15	; 0x0f
    3870:	23 30       	cpi	r18, 0x03	; 3
    3872:	31 05       	cpc	r19, r1
    3874:	59 f1       	breq	.+86     	; 0x38cc <xTaskGenericNotify+0xf6>
    3876:	8e 85       	ldd	r24, Y+14	; 0x0e
    3878:	9f 85       	ldd	r25, Y+15	; 0x0f
    387a:	84 30       	cpi	r24, 0x04	; 4
    387c:	91 05       	cpc	r25, r1
    387e:	89 f1       	breq	.+98     	; 0x38e2 <xTaskGenericNotify+0x10c>
    3880:	3f c0       	rjmp	.+126    	; 0x3900 <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    3882:	eb 81       	ldd	r30, Y+3	; 0x03
    3884:	fc 81       	ldd	r31, Y+4	; 0x04
    3886:	21 a1       	ldd	r18, Z+33	; 0x21
    3888:	32 a1       	ldd	r19, Z+34	; 0x22
    388a:	43 a1       	ldd	r20, Z+35	; 0x23
    388c:	54 a1       	ldd	r21, Z+36	; 0x24
    388e:	8f 81       	ldd	r24, Y+7	; 0x07
    3890:	98 85       	ldd	r25, Y+8	; 0x08
    3892:	a9 85       	ldd	r26, Y+9	; 0x09
    3894:	ba 85       	ldd	r27, Y+10	; 0x0a
    3896:	82 2b       	or	r24, r18
    3898:	93 2b       	or	r25, r19
    389a:	a4 2b       	or	r26, r20
    389c:	b5 2b       	or	r27, r21
    389e:	eb 81       	ldd	r30, Y+3	; 0x03
    38a0:	fc 81       	ldd	r31, Y+4	; 0x04
    38a2:	81 a3       	std	Z+33, r24	; 0x21
    38a4:	92 a3       	std	Z+34, r25	; 0x22
    38a6:	a3 a3       	std	Z+35, r26	; 0x23
    38a8:	b4 a3       	std	Z+36, r27	; 0x24
    38aa:	2a c0       	rjmp	.+84     	; 0x3900 <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    38ac:	eb 81       	ldd	r30, Y+3	; 0x03
    38ae:	fc 81       	ldd	r31, Y+4	; 0x04
    38b0:	81 a1       	ldd	r24, Z+33	; 0x21
    38b2:	92 a1       	ldd	r25, Z+34	; 0x22
    38b4:	a3 a1       	ldd	r26, Z+35	; 0x23
    38b6:	b4 a1       	ldd	r27, Z+36	; 0x24
    38b8:	01 96       	adiw	r24, 0x01	; 1
    38ba:	a1 1d       	adc	r26, r1
    38bc:	b1 1d       	adc	r27, r1
    38be:	eb 81       	ldd	r30, Y+3	; 0x03
    38c0:	fc 81       	ldd	r31, Y+4	; 0x04
    38c2:	81 a3       	std	Z+33, r24	; 0x21
    38c4:	92 a3       	std	Z+34, r25	; 0x22
    38c6:	a3 a3       	std	Z+35, r26	; 0x23
    38c8:	b4 a3       	std	Z+36, r27	; 0x24
    38ca:	1a c0       	rjmp	.+52     	; 0x3900 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    38cc:	eb 81       	ldd	r30, Y+3	; 0x03
    38ce:	fc 81       	ldd	r31, Y+4	; 0x04
    38d0:	8f 81       	ldd	r24, Y+7	; 0x07
    38d2:	98 85       	ldd	r25, Y+8	; 0x08
    38d4:	a9 85       	ldd	r26, Y+9	; 0x09
    38d6:	ba 85       	ldd	r27, Y+10	; 0x0a
    38d8:	81 a3       	std	Z+33, r24	; 0x21
    38da:	92 a3       	std	Z+34, r25	; 0x22
    38dc:	a3 a3       	std	Z+35, r26	; 0x23
    38de:	b4 a3       	std	Z+36, r27	; 0x24
    38e0:	0f c0       	rjmp	.+30     	; 0x3900 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    38e2:	89 81       	ldd	r24, Y+1	; 0x01
    38e4:	82 30       	cpi	r24, 0x02	; 2
    38e6:	59 f0       	breq	.+22     	; 0x38fe <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    38e8:	eb 81       	ldd	r30, Y+3	; 0x03
    38ea:	fc 81       	ldd	r31, Y+4	; 0x04
    38ec:	8f 81       	ldd	r24, Y+7	; 0x07
    38ee:	98 85       	ldd	r25, Y+8	; 0x08
    38f0:	a9 85       	ldd	r26, Y+9	; 0x09
    38f2:	ba 85       	ldd	r27, Y+10	; 0x0a
    38f4:	81 a3       	std	Z+33, r24	; 0x21
    38f6:	92 a3       	std	Z+34, r25	; 0x22
    38f8:	a3 a3       	std	Z+35, r26	; 0x23
    38fa:	b4 a3       	std	Z+36, r27	; 0x24
    38fc:	01 c0       	rjmp	.+2      	; 0x3900 <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    38fe:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    3900:	89 81       	ldd	r24, Y+1	; 0x01
    3902:	81 30       	cpi	r24, 0x01	; 1
    3904:	b9 f5       	brne	.+110    	; 0x3974 <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3906:	8b 81       	ldd	r24, Y+3	; 0x03
    3908:	9c 81       	ldd	r25, Y+4	; 0x04
    390a:	02 96       	adiw	r24, 0x02	; 2
    390c:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    3910:	eb 81       	ldd	r30, Y+3	; 0x03
    3912:	fc 81       	ldd	r31, Y+4	; 0x04
    3914:	96 89       	ldd	r25, Z+22	; 0x16
    3916:	80 91 ce 02 	lds	r24, 0x02CE
    391a:	89 17       	cp	r24, r25
    391c:	28 f4       	brcc	.+10     	; 0x3928 <xTaskGenericNotify+0x152>
    391e:	eb 81       	ldd	r30, Y+3	; 0x03
    3920:	fc 81       	ldd	r31, Y+4	; 0x04
    3922:	86 89       	ldd	r24, Z+22	; 0x16
    3924:	80 93 ce 02 	sts	0x02CE, r24
    3928:	eb 81       	ldd	r30, Y+3	; 0x03
    392a:	fc 81       	ldd	r31, Y+4	; 0x04
    392c:	86 89       	ldd	r24, Z+22	; 0x16
    392e:	28 2f       	mov	r18, r24
    3930:	30 e0       	ldi	r19, 0x00	; 0
    3932:	c9 01       	movw	r24, r18
    3934:	88 0f       	add	r24, r24
    3936:	99 1f       	adc	r25, r25
    3938:	88 0f       	add	r24, r24
    393a:	99 1f       	adc	r25, r25
    393c:	88 0f       	add	r24, r24
    393e:	99 1f       	adc	r25, r25
    3940:	82 0f       	add	r24, r18
    3942:	93 1f       	adc	r25, r19
    3944:	ac 01       	movw	r20, r24
    3946:	47 52       	subi	r20, 0x27	; 39
    3948:	5d 4f       	sbci	r21, 0xFD	; 253
    394a:	8b 81       	ldd	r24, Y+3	; 0x03
    394c:	9c 81       	ldd	r25, Y+4	; 0x04
    394e:	9c 01       	movw	r18, r24
    3950:	2e 5f       	subi	r18, 0xFE	; 254
    3952:	3f 4f       	sbci	r19, 0xFF	; 255
    3954:	ca 01       	movw	r24, r20
    3956:	b9 01       	movw	r22, r18
    3958:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    395c:	eb 81       	ldd	r30, Y+3	; 0x03
    395e:	fc 81       	ldd	r31, Y+4	; 0x04
    3960:	96 89       	ldd	r25, Z+22	; 0x16
    3962:	e0 91 c8 02 	lds	r30, 0x02C8
    3966:	f0 91 c9 02 	lds	r31, 0x02C9
    396a:	86 89       	ldd	r24, Z+22	; 0x16
    396c:	89 17       	cp	r24, r25
    396e:	10 f4       	brcc	.+4      	; 0x3974 <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    3970:	0e 94 a7 0a 	call	0x154e	; 0x154e <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    3974:	0f 90       	pop	r0
    3976:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    3978:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    397a:	2f 96       	adiw	r28, 0x0f	; 15
    397c:	0f b6       	in	r0, 0x3f	; 63
    397e:	f8 94       	cli
    3980:	de bf       	out	0x3e, r29	; 62
    3982:	0f be       	out	0x3f, r0	; 63
    3984:	cd bf       	out	0x3d, r28	; 61
    3986:	cf 91       	pop	r28
    3988:	df 91       	pop	r29
    398a:	1f 91       	pop	r17
    398c:	0f 91       	pop	r16
    398e:	08 95       	ret

00003990 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    3990:	ef 92       	push	r14
    3992:	ff 92       	push	r15
    3994:	0f 93       	push	r16
    3996:	1f 93       	push	r17
    3998:	df 93       	push	r29
    399a:	cf 93       	push	r28
    399c:	cd b7       	in	r28, 0x3d	; 61
    399e:	de b7       	in	r29, 0x3e	; 62
    39a0:	62 97       	sbiw	r28, 0x12	; 18
    39a2:	0f b6       	in	r0, 0x3f	; 63
    39a4:	f8 94       	cli
    39a6:	de bf       	out	0x3e, r29	; 62
    39a8:	0f be       	out	0x3f, r0	; 63
    39aa:	cd bf       	out	0x3d, r28	; 61
    39ac:	9f 83       	std	Y+7, r25	; 0x07
    39ae:	8e 83       	std	Y+6, r24	; 0x06
    39b0:	48 87       	std	Y+8, r20	; 0x08
    39b2:	59 87       	std	Y+9, r21	; 0x09
    39b4:	6a 87       	std	Y+10, r22	; 0x0a
    39b6:	7b 87       	std	Y+11, r23	; 0x0b
    39b8:	2c 87       	std	Y+12, r18	; 0x0c
    39ba:	1e 87       	std	Y+14, r17	; 0x0e
    39bc:	0d 87       	std	Y+13, r16	; 0x0d
    39be:	f8 8a       	std	Y+16, r15	; 0x10
    39c0:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    39c2:	81 e0       	ldi	r24, 0x01	; 1
    39c4:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    39c6:	8e 81       	ldd	r24, Y+6	; 0x06
    39c8:	9f 81       	ldd	r25, Y+7	; 0x07
    39ca:	9d 83       	std	Y+5, r25	; 0x05
    39cc:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    39ce:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    39d0:	8d 85       	ldd	r24, Y+13	; 0x0d
    39d2:	9e 85       	ldd	r25, Y+14	; 0x0e
    39d4:	00 97       	sbiw	r24, 0x00	; 0
    39d6:	61 f0       	breq	.+24     	; 0x39f0 <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    39d8:	ec 81       	ldd	r30, Y+4	; 0x04
    39da:	fd 81       	ldd	r31, Y+5	; 0x05
    39dc:	81 a1       	ldd	r24, Z+33	; 0x21
    39de:	92 a1       	ldd	r25, Z+34	; 0x22
    39e0:	a3 a1       	ldd	r26, Z+35	; 0x23
    39e2:	b4 a1       	ldd	r27, Z+36	; 0x24
    39e4:	ed 85       	ldd	r30, Y+13	; 0x0d
    39e6:	fe 85       	ldd	r31, Y+14	; 0x0e
    39e8:	80 83       	st	Z, r24
    39ea:	91 83       	std	Z+1, r25	; 0x01
    39ec:	a2 83       	std	Z+2, r26	; 0x02
    39ee:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    39f0:	ec 81       	ldd	r30, Y+4	; 0x04
    39f2:	fd 81       	ldd	r31, Y+5	; 0x05
    39f4:	85 a1       	ldd	r24, Z+37	; 0x25
    39f6:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    39f8:	ec 81       	ldd	r30, Y+4	; 0x04
    39fa:	fd 81       	ldd	r31, Y+5	; 0x05
    39fc:	82 e0       	ldi	r24, 0x02	; 2
    39fe:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    3a00:	8c 85       	ldd	r24, Y+12	; 0x0c
    3a02:	28 2f       	mov	r18, r24
    3a04:	30 e0       	ldi	r19, 0x00	; 0
    3a06:	3a 8b       	std	Y+18, r19	; 0x12
    3a08:	29 8b       	std	Y+17, r18	; 0x11
    3a0a:	89 89       	ldd	r24, Y+17	; 0x11
    3a0c:	9a 89       	ldd	r25, Y+18	; 0x12
    3a0e:	82 30       	cpi	r24, 0x02	; 2
    3a10:	91 05       	cpc	r25, r1
    3a12:	59 f1       	breq	.+86     	; 0x3a6a <xTaskGenericNotifyFromISR+0xda>
    3a14:	29 89       	ldd	r18, Y+17	; 0x11
    3a16:	3a 89       	ldd	r19, Y+18	; 0x12
    3a18:	23 30       	cpi	r18, 0x03	; 3
    3a1a:	31 05       	cpc	r19, r1
    3a1c:	34 f4       	brge	.+12     	; 0x3a2a <xTaskGenericNotifyFromISR+0x9a>
    3a1e:	89 89       	ldd	r24, Y+17	; 0x11
    3a20:	9a 89       	ldd	r25, Y+18	; 0x12
    3a22:	81 30       	cpi	r24, 0x01	; 1
    3a24:	91 05       	cpc	r25, r1
    3a26:	61 f0       	breq	.+24     	; 0x3a40 <xTaskGenericNotifyFromISR+0xb0>
    3a28:	4a c0       	rjmp	.+148    	; 0x3abe <xTaskGenericNotifyFromISR+0x12e>
    3a2a:	29 89       	ldd	r18, Y+17	; 0x11
    3a2c:	3a 89       	ldd	r19, Y+18	; 0x12
    3a2e:	23 30       	cpi	r18, 0x03	; 3
    3a30:	31 05       	cpc	r19, r1
    3a32:	59 f1       	breq	.+86     	; 0x3a8a <xTaskGenericNotifyFromISR+0xfa>
    3a34:	89 89       	ldd	r24, Y+17	; 0x11
    3a36:	9a 89       	ldd	r25, Y+18	; 0x12
    3a38:	84 30       	cpi	r24, 0x04	; 4
    3a3a:	91 05       	cpc	r25, r1
    3a3c:	89 f1       	breq	.+98     	; 0x3aa0 <xTaskGenericNotifyFromISR+0x110>
    3a3e:	3f c0       	rjmp	.+126    	; 0x3abe <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    3a40:	ec 81       	ldd	r30, Y+4	; 0x04
    3a42:	fd 81       	ldd	r31, Y+5	; 0x05
    3a44:	21 a1       	ldd	r18, Z+33	; 0x21
    3a46:	32 a1       	ldd	r19, Z+34	; 0x22
    3a48:	43 a1       	ldd	r20, Z+35	; 0x23
    3a4a:	54 a1       	ldd	r21, Z+36	; 0x24
    3a4c:	88 85       	ldd	r24, Y+8	; 0x08
    3a4e:	99 85       	ldd	r25, Y+9	; 0x09
    3a50:	aa 85       	ldd	r26, Y+10	; 0x0a
    3a52:	bb 85       	ldd	r27, Y+11	; 0x0b
    3a54:	82 2b       	or	r24, r18
    3a56:	93 2b       	or	r25, r19
    3a58:	a4 2b       	or	r26, r20
    3a5a:	b5 2b       	or	r27, r21
    3a5c:	ec 81       	ldd	r30, Y+4	; 0x04
    3a5e:	fd 81       	ldd	r31, Y+5	; 0x05
    3a60:	81 a3       	std	Z+33, r24	; 0x21
    3a62:	92 a3       	std	Z+34, r25	; 0x22
    3a64:	a3 a3       	std	Z+35, r26	; 0x23
    3a66:	b4 a3       	std	Z+36, r27	; 0x24
    3a68:	2a c0       	rjmp	.+84     	; 0x3abe <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    3a6a:	ec 81       	ldd	r30, Y+4	; 0x04
    3a6c:	fd 81       	ldd	r31, Y+5	; 0x05
    3a6e:	81 a1       	ldd	r24, Z+33	; 0x21
    3a70:	92 a1       	ldd	r25, Z+34	; 0x22
    3a72:	a3 a1       	ldd	r26, Z+35	; 0x23
    3a74:	b4 a1       	ldd	r27, Z+36	; 0x24
    3a76:	01 96       	adiw	r24, 0x01	; 1
    3a78:	a1 1d       	adc	r26, r1
    3a7a:	b1 1d       	adc	r27, r1
    3a7c:	ec 81       	ldd	r30, Y+4	; 0x04
    3a7e:	fd 81       	ldd	r31, Y+5	; 0x05
    3a80:	81 a3       	std	Z+33, r24	; 0x21
    3a82:	92 a3       	std	Z+34, r25	; 0x22
    3a84:	a3 a3       	std	Z+35, r26	; 0x23
    3a86:	b4 a3       	std	Z+36, r27	; 0x24
    3a88:	1a c0       	rjmp	.+52     	; 0x3abe <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    3a8a:	ec 81       	ldd	r30, Y+4	; 0x04
    3a8c:	fd 81       	ldd	r31, Y+5	; 0x05
    3a8e:	88 85       	ldd	r24, Y+8	; 0x08
    3a90:	99 85       	ldd	r25, Y+9	; 0x09
    3a92:	aa 85       	ldd	r26, Y+10	; 0x0a
    3a94:	bb 85       	ldd	r27, Y+11	; 0x0b
    3a96:	81 a3       	std	Z+33, r24	; 0x21
    3a98:	92 a3       	std	Z+34, r25	; 0x22
    3a9a:	a3 a3       	std	Z+35, r26	; 0x23
    3a9c:	b4 a3       	std	Z+36, r27	; 0x24
    3a9e:	0f c0       	rjmp	.+30     	; 0x3abe <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    3aa0:	8b 81       	ldd	r24, Y+3	; 0x03
    3aa2:	82 30       	cpi	r24, 0x02	; 2
    3aa4:	59 f0       	breq	.+22     	; 0x3abc <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    3aa6:	ec 81       	ldd	r30, Y+4	; 0x04
    3aa8:	fd 81       	ldd	r31, Y+5	; 0x05
    3aaa:	88 85       	ldd	r24, Y+8	; 0x08
    3aac:	99 85       	ldd	r25, Y+9	; 0x09
    3aae:	aa 85       	ldd	r26, Y+10	; 0x0a
    3ab0:	bb 85       	ldd	r27, Y+11	; 0x0b
    3ab2:	81 a3       	std	Z+33, r24	; 0x21
    3ab4:	92 a3       	std	Z+34, r25	; 0x22
    3ab6:	a3 a3       	std	Z+35, r26	; 0x23
    3ab8:	b4 a3       	std	Z+36, r27	; 0x24
    3aba:	01 c0       	rjmp	.+2      	; 0x3abe <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    3abc:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    3abe:	8b 81       	ldd	r24, Y+3	; 0x03
    3ac0:	81 30       	cpi	r24, 0x01	; 1
    3ac2:	09 f0       	breq	.+2      	; 0x3ac6 <xTaskGenericNotifyFromISR+0x136>
    3ac4:	4f c0       	rjmp	.+158    	; 0x3b64 <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3ac6:	80 91 d8 02 	lds	r24, 0x02D8
    3aca:	88 23       	and	r24, r24
    3acc:	61 f5       	brne	.+88     	; 0x3b26 <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3ace:	8c 81       	ldd	r24, Y+4	; 0x04
    3ad0:	9d 81       	ldd	r25, Y+5	; 0x05
    3ad2:	02 96       	adiw	r24, 0x02	; 2
    3ad4:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3ad8:	ec 81       	ldd	r30, Y+4	; 0x04
    3ada:	fd 81       	ldd	r31, Y+5	; 0x05
    3adc:	96 89       	ldd	r25, Z+22	; 0x16
    3ade:	80 91 ce 02 	lds	r24, 0x02CE
    3ae2:	89 17       	cp	r24, r25
    3ae4:	28 f4       	brcc	.+10     	; 0x3af0 <xTaskGenericNotifyFromISR+0x160>
    3ae6:	ec 81       	ldd	r30, Y+4	; 0x04
    3ae8:	fd 81       	ldd	r31, Y+5	; 0x05
    3aea:	86 89       	ldd	r24, Z+22	; 0x16
    3aec:	80 93 ce 02 	sts	0x02CE, r24
    3af0:	ec 81       	ldd	r30, Y+4	; 0x04
    3af2:	fd 81       	ldd	r31, Y+5	; 0x05
    3af4:	86 89       	ldd	r24, Z+22	; 0x16
    3af6:	28 2f       	mov	r18, r24
    3af8:	30 e0       	ldi	r19, 0x00	; 0
    3afa:	c9 01       	movw	r24, r18
    3afc:	88 0f       	add	r24, r24
    3afe:	99 1f       	adc	r25, r25
    3b00:	88 0f       	add	r24, r24
    3b02:	99 1f       	adc	r25, r25
    3b04:	88 0f       	add	r24, r24
    3b06:	99 1f       	adc	r25, r25
    3b08:	82 0f       	add	r24, r18
    3b0a:	93 1f       	adc	r25, r19
    3b0c:	ac 01       	movw	r20, r24
    3b0e:	47 52       	subi	r20, 0x27	; 39
    3b10:	5d 4f       	sbci	r21, 0xFD	; 253
    3b12:	8c 81       	ldd	r24, Y+4	; 0x04
    3b14:	9d 81       	ldd	r25, Y+5	; 0x05
    3b16:	9c 01       	movw	r18, r24
    3b18:	2e 5f       	subi	r18, 0xFE	; 254
    3b1a:	3f 4f       	sbci	r19, 0xFF	; 255
    3b1c:	ca 01       	movw	r24, r20
    3b1e:	b9 01       	movw	r22, r18
    3b20:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>
    3b24:	0a c0       	rjmp	.+20     	; 0x3b3a <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    3b26:	8c 81       	ldd	r24, Y+4	; 0x04
    3b28:	9d 81       	ldd	r25, Y+5	; 0x05
    3b2a:	9c 01       	movw	r18, r24
    3b2c:	24 5f       	subi	r18, 0xF4	; 244
    3b2e:	3f 4f       	sbci	r19, 0xFF	; 255
    3b30:	83 e1       	ldi	r24, 0x13	; 19
    3b32:	93 e0       	ldi	r25, 0x03	; 3
    3b34:	b9 01       	movw	r22, r18
    3b36:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    3b3a:	ec 81       	ldd	r30, Y+4	; 0x04
    3b3c:	fd 81       	ldd	r31, Y+5	; 0x05
    3b3e:	96 89       	ldd	r25, Z+22	; 0x16
    3b40:	e0 91 c8 02 	lds	r30, 0x02C8
    3b44:	f0 91 c9 02 	lds	r31, 0x02C9
    3b48:	86 89       	ldd	r24, Z+22	; 0x16
    3b4a:	89 17       	cp	r24, r25
    3b4c:	58 f4       	brcc	.+22     	; 0x3b64 <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    3b4e:	8f 85       	ldd	r24, Y+15	; 0x0f
    3b50:	98 89       	ldd	r25, Y+16	; 0x10
    3b52:	00 97       	sbiw	r24, 0x00	; 0
    3b54:	21 f0       	breq	.+8      	; 0x3b5e <xTaskGenericNotifyFromISR+0x1ce>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    3b56:	ef 85       	ldd	r30, Y+15	; 0x0f
    3b58:	f8 89       	ldd	r31, Y+16	; 0x10
    3b5a:	81 e0       	ldi	r24, 0x01	; 1
    3b5c:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    3b5e:	81 e0       	ldi	r24, 0x01	; 1
    3b60:	80 93 d1 02 	sts	0x02D1, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    3b64:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    3b66:	62 96       	adiw	r28, 0x12	; 18
    3b68:	0f b6       	in	r0, 0x3f	; 63
    3b6a:	f8 94       	cli
    3b6c:	de bf       	out	0x3e, r29	; 62
    3b6e:	0f be       	out	0x3f, r0	; 63
    3b70:	cd bf       	out	0x3d, r28	; 61
    3b72:	cf 91       	pop	r28
    3b74:	df 91       	pop	r29
    3b76:	1f 91       	pop	r17
    3b78:	0f 91       	pop	r16
    3b7a:	ff 90       	pop	r15
    3b7c:	ef 90       	pop	r14
    3b7e:	08 95       	ret

00003b80 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    3b80:	df 93       	push	r29
    3b82:	cf 93       	push	r28
    3b84:	cd b7       	in	r28, 0x3d	; 61
    3b86:	de b7       	in	r29, 0x3e	; 62
    3b88:	28 97       	sbiw	r28, 0x08	; 8
    3b8a:	0f b6       	in	r0, 0x3f	; 63
    3b8c:	f8 94       	cli
    3b8e:	de bf       	out	0x3e, r29	; 62
    3b90:	0f be       	out	0x3f, r0	; 63
    3b92:	cd bf       	out	0x3d, r28	; 61
    3b94:	9e 83       	std	Y+6, r25	; 0x06
    3b96:	8d 83       	std	Y+5, r24	; 0x05
    3b98:	78 87       	std	Y+8, r23	; 0x08
    3b9a:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    3b9c:	8d 81       	ldd	r24, Y+5	; 0x05
    3b9e:	9e 81       	ldd	r25, Y+6	; 0x06
    3ba0:	9c 83       	std	Y+4, r25	; 0x04
    3ba2:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3ba4:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    3ba6:	eb 81       	ldd	r30, Y+3	; 0x03
    3ba8:	fc 81       	ldd	r31, Y+4	; 0x04
    3baa:	85 a1       	ldd	r24, Z+37	; 0x25
    3bac:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    3bae:	eb 81       	ldd	r30, Y+3	; 0x03
    3bb0:	fc 81       	ldd	r31, Y+4	; 0x04
    3bb2:	82 e0       	ldi	r24, 0x02	; 2
    3bb4:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    3bb6:	eb 81       	ldd	r30, Y+3	; 0x03
    3bb8:	fc 81       	ldd	r31, Y+4	; 0x04
    3bba:	81 a1       	ldd	r24, Z+33	; 0x21
    3bbc:	92 a1       	ldd	r25, Z+34	; 0x22
    3bbe:	a3 a1       	ldd	r26, Z+35	; 0x23
    3bc0:	b4 a1       	ldd	r27, Z+36	; 0x24
    3bc2:	01 96       	adiw	r24, 0x01	; 1
    3bc4:	a1 1d       	adc	r26, r1
    3bc6:	b1 1d       	adc	r27, r1
    3bc8:	eb 81       	ldd	r30, Y+3	; 0x03
    3bca:	fc 81       	ldd	r31, Y+4	; 0x04
    3bcc:	81 a3       	std	Z+33, r24	; 0x21
    3bce:	92 a3       	std	Z+34, r25	; 0x22
    3bd0:	a3 a3       	std	Z+35, r26	; 0x23
    3bd2:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    3bd4:	8a 81       	ldd	r24, Y+2	; 0x02
    3bd6:	81 30       	cpi	r24, 0x01	; 1
    3bd8:	09 f0       	breq	.+2      	; 0x3bdc <vTaskNotifyGiveFromISR+0x5c>
    3bda:	4f c0       	rjmp	.+158    	; 0x3c7a <vTaskNotifyGiveFromISR+0xfa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3bdc:	80 91 d8 02 	lds	r24, 0x02D8
    3be0:	88 23       	and	r24, r24
    3be2:	61 f5       	brne	.+88     	; 0x3c3c <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3be4:	8b 81       	ldd	r24, Y+3	; 0x03
    3be6:	9c 81       	ldd	r25, Y+4	; 0x04
    3be8:	02 96       	adiw	r24, 0x02	; 2
    3bea:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3bee:	eb 81       	ldd	r30, Y+3	; 0x03
    3bf0:	fc 81       	ldd	r31, Y+4	; 0x04
    3bf2:	96 89       	ldd	r25, Z+22	; 0x16
    3bf4:	80 91 ce 02 	lds	r24, 0x02CE
    3bf8:	89 17       	cp	r24, r25
    3bfa:	28 f4       	brcc	.+10     	; 0x3c06 <vTaskNotifyGiveFromISR+0x86>
    3bfc:	eb 81       	ldd	r30, Y+3	; 0x03
    3bfe:	fc 81       	ldd	r31, Y+4	; 0x04
    3c00:	86 89       	ldd	r24, Z+22	; 0x16
    3c02:	80 93 ce 02 	sts	0x02CE, r24
    3c06:	eb 81       	ldd	r30, Y+3	; 0x03
    3c08:	fc 81       	ldd	r31, Y+4	; 0x04
    3c0a:	86 89       	ldd	r24, Z+22	; 0x16
    3c0c:	28 2f       	mov	r18, r24
    3c0e:	30 e0       	ldi	r19, 0x00	; 0
    3c10:	c9 01       	movw	r24, r18
    3c12:	88 0f       	add	r24, r24
    3c14:	99 1f       	adc	r25, r25
    3c16:	88 0f       	add	r24, r24
    3c18:	99 1f       	adc	r25, r25
    3c1a:	88 0f       	add	r24, r24
    3c1c:	99 1f       	adc	r25, r25
    3c1e:	82 0f       	add	r24, r18
    3c20:	93 1f       	adc	r25, r19
    3c22:	ac 01       	movw	r20, r24
    3c24:	47 52       	subi	r20, 0x27	; 39
    3c26:	5d 4f       	sbci	r21, 0xFD	; 253
    3c28:	8b 81       	ldd	r24, Y+3	; 0x03
    3c2a:	9c 81       	ldd	r25, Y+4	; 0x04
    3c2c:	9c 01       	movw	r18, r24
    3c2e:	2e 5f       	subi	r18, 0xFE	; 254
    3c30:	3f 4f       	sbci	r19, 0xFF	; 255
    3c32:	ca 01       	movw	r24, r20
    3c34:	b9 01       	movw	r22, r18
    3c36:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>
    3c3a:	0a c0       	rjmp	.+20     	; 0x3c50 <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    3c3c:	8b 81       	ldd	r24, Y+3	; 0x03
    3c3e:	9c 81       	ldd	r25, Y+4	; 0x04
    3c40:	9c 01       	movw	r18, r24
    3c42:	24 5f       	subi	r18, 0xF4	; 244
    3c44:	3f 4f       	sbci	r19, 0xFF	; 255
    3c46:	83 e1       	ldi	r24, 0x13	; 19
    3c48:	93 e0       	ldi	r25, 0x03	; 3
    3c4a:	b9 01       	movw	r22, r18
    3c4c:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    3c50:	eb 81       	ldd	r30, Y+3	; 0x03
    3c52:	fc 81       	ldd	r31, Y+4	; 0x04
    3c54:	96 89       	ldd	r25, Z+22	; 0x16
    3c56:	e0 91 c8 02 	lds	r30, 0x02C8
    3c5a:	f0 91 c9 02 	lds	r31, 0x02C9
    3c5e:	86 89       	ldd	r24, Z+22	; 0x16
    3c60:	89 17       	cp	r24, r25
    3c62:	58 f4       	brcc	.+22     	; 0x3c7a <vTaskNotifyGiveFromISR+0xfa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    3c64:	8f 81       	ldd	r24, Y+7	; 0x07
    3c66:	98 85       	ldd	r25, Y+8	; 0x08
    3c68:	00 97       	sbiw	r24, 0x00	; 0
    3c6a:	21 f0       	breq	.+8      	; 0x3c74 <vTaskNotifyGiveFromISR+0xf4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    3c6c:	ef 81       	ldd	r30, Y+7	; 0x07
    3c6e:	f8 85       	ldd	r31, Y+8	; 0x08
    3c70:	81 e0       	ldi	r24, 0x01	; 1
    3c72:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    3c74:	81 e0       	ldi	r24, 0x01	; 1
    3c76:	80 93 d1 02 	sts	0x02D1, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    3c7a:	28 96       	adiw	r28, 0x08	; 8
    3c7c:	0f b6       	in	r0, 0x3f	; 63
    3c7e:	f8 94       	cli
    3c80:	de bf       	out	0x3e, r29	; 62
    3c82:	0f be       	out	0x3f, r0	; 63
    3c84:	cd bf       	out	0x3d, r28	; 61
    3c86:	cf 91       	pop	r28
    3c88:	df 91       	pop	r29
    3c8a:	08 95       	ret

00003c8c <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    3c8c:	df 93       	push	r29
    3c8e:	cf 93       	push	r28
    3c90:	cd b7       	in	r28, 0x3d	; 61
    3c92:	de b7       	in	r29, 0x3e	; 62
    3c94:	27 97       	sbiw	r28, 0x07	; 7
    3c96:	0f b6       	in	r0, 0x3f	; 63
    3c98:	f8 94       	cli
    3c9a:	de bf       	out	0x3e, r29	; 62
    3c9c:	0f be       	out	0x3f, r0	; 63
    3c9e:	cd bf       	out	0x3d, r28	; 61
    3ca0:	9d 83       	std	Y+5, r25	; 0x05
    3ca2:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    3ca4:	8c 81       	ldd	r24, Y+4	; 0x04
    3ca6:	9d 81       	ldd	r25, Y+5	; 0x05
    3ca8:	00 97       	sbiw	r24, 0x00	; 0
    3caa:	39 f4       	brne	.+14     	; 0x3cba <xTaskNotifyStateClear+0x2e>
    3cac:	80 91 c8 02 	lds	r24, 0x02C8
    3cb0:	90 91 c9 02 	lds	r25, 0x02C9
    3cb4:	9f 83       	std	Y+7, r25	; 0x07
    3cb6:	8e 83       	std	Y+6, r24	; 0x06
    3cb8:	04 c0       	rjmp	.+8      	; 0x3cc2 <xTaskNotifyStateClear+0x36>
    3cba:	8c 81       	ldd	r24, Y+4	; 0x04
    3cbc:	9d 81       	ldd	r25, Y+5	; 0x05
    3cbe:	9f 83       	std	Y+7, r25	; 0x07
    3cc0:	8e 83       	std	Y+6, r24	; 0x06
    3cc2:	8e 81       	ldd	r24, Y+6	; 0x06
    3cc4:	9f 81       	ldd	r25, Y+7	; 0x07
    3cc6:	9b 83       	std	Y+3, r25	; 0x03
    3cc8:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    3cca:	0f b6       	in	r0, 0x3f	; 63
    3ccc:	f8 94       	cli
    3cce:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    3cd0:	ea 81       	ldd	r30, Y+2	; 0x02
    3cd2:	fb 81       	ldd	r31, Y+3	; 0x03
    3cd4:	85 a1       	ldd	r24, Z+37	; 0x25
    3cd6:	82 30       	cpi	r24, 0x02	; 2
    3cd8:	31 f4       	brne	.+12     	; 0x3ce6 <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3cda:	ea 81       	ldd	r30, Y+2	; 0x02
    3cdc:	fb 81       	ldd	r31, Y+3	; 0x03
    3cde:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    3ce0:	81 e0       	ldi	r24, 0x01	; 1
    3ce2:	89 83       	std	Y+1, r24	; 0x01
    3ce4:	01 c0       	rjmp	.+2      	; 0x3ce8 <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    3ce6:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    3ce8:	0f 90       	pop	r0
    3cea:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    3cec:	89 81       	ldd	r24, Y+1	; 0x01
	}
    3cee:	27 96       	adiw	r28, 0x07	; 7
    3cf0:	0f b6       	in	r0, 0x3f	; 63
    3cf2:	f8 94       	cli
    3cf4:	de bf       	out	0x3e, r29	; 62
    3cf6:	0f be       	out	0x3f, r0	; 63
    3cf8:	cd bf       	out	0x3d, r28	; 61
    3cfa:	cf 91       	pop	r28
    3cfc:	df 91       	pop	r29
    3cfe:	08 95       	ret

00003d00 <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    3d00:	df 93       	push	r29
    3d02:	cf 93       	push	r28
    3d04:	cd b7       	in	r28, 0x3d	; 61
    3d06:	de b7       	in	r29, 0x3e	; 62
    3d08:	27 97       	sbiw	r28, 0x07	; 7
    3d0a:	0f b6       	in	r0, 0x3f	; 63
    3d0c:	f8 94       	cli
    3d0e:	de bf       	out	0x3e, r29	; 62
    3d10:	0f be       	out	0x3f, r0	; 63
    3d12:	cd bf       	out	0x3d, r28	; 61
    3d14:	9e 83       	std	Y+6, r25	; 0x06
    3d16:	8d 83       	std	Y+5, r24	; 0x05
    3d18:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    3d1a:	80 91 cc 02 	lds	r24, 0x02CC
    3d1e:	90 91 cd 02 	lds	r25, 0x02CD
    3d22:	9a 83       	std	Y+2, r25	; 0x02
    3d24:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3d26:	80 91 c8 02 	lds	r24, 0x02C8
    3d2a:	90 91 c9 02 	lds	r25, 0x02C9
    3d2e:	02 96       	adiw	r24, 0x02	; 2
    3d30:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
		/* Calculate the time at which the task should be woken if the event
		does not occur.  This may overflow but this doesn't matter, the kernel
		will manage it correctly. */
		xTimeToWake = xConstTickCount + xTicksToWait;
    3d34:	29 81       	ldd	r18, Y+1	; 0x01
    3d36:	3a 81       	ldd	r19, Y+2	; 0x02
    3d38:	8d 81       	ldd	r24, Y+5	; 0x05
    3d3a:	9e 81       	ldd	r25, Y+6	; 0x06
    3d3c:	82 0f       	add	r24, r18
    3d3e:	93 1f       	adc	r25, r19
    3d40:	9c 83       	std	Y+4, r25	; 0x04
    3d42:	8b 83       	std	Y+3, r24	; 0x03

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    3d44:	e0 91 c8 02 	lds	r30, 0x02C8
    3d48:	f0 91 c9 02 	lds	r31, 0x02C9
    3d4c:	8b 81       	ldd	r24, Y+3	; 0x03
    3d4e:	9c 81       	ldd	r25, Y+4	; 0x04
    3d50:	93 83       	std	Z+3, r25	; 0x03
    3d52:	82 83       	std	Z+2, r24	; 0x02

		if( xTimeToWake < xConstTickCount )
    3d54:	2b 81       	ldd	r18, Y+3	; 0x03
    3d56:	3c 81       	ldd	r19, Y+4	; 0x04
    3d58:	89 81       	ldd	r24, Y+1	; 0x01
    3d5a:	9a 81       	ldd	r25, Y+2	; 0x02
    3d5c:	28 17       	cp	r18, r24
    3d5e:	39 07       	cpc	r19, r25
    3d60:	70 f4       	brcc	.+28     	; 0x3d7e <prvAddCurrentTaskToDelayedList+0x7e>
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    3d62:	80 91 11 03 	lds	r24, 0x0311
    3d66:	90 91 12 03 	lds	r25, 0x0312
    3d6a:	20 91 c8 02 	lds	r18, 0x02C8
    3d6e:	30 91 c9 02 	lds	r19, 0x02C9
    3d72:	2e 5f       	subi	r18, 0xFE	; 254
    3d74:	3f 4f       	sbci	r19, 0xFF	; 255
    3d76:	b9 01       	movw	r22, r18
    3d78:	0e 94 a9 07 	call	0xf52	; 0xf52 <vListInsert>
    3d7c:	1e c0       	rjmp	.+60     	; 0x3dba <prvAddCurrentTaskToDelayedList+0xba>
		}
		else
		{
			/* The wake time has not overflowed, so the current block list is used. */
			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    3d7e:	40 91 0f 03 	lds	r20, 0x030F
    3d82:	50 91 10 03 	lds	r21, 0x0310
    3d86:	80 91 c8 02 	lds	r24, 0x02C8
    3d8a:	90 91 c9 02 	lds	r25, 0x02C9
    3d8e:	9c 01       	movw	r18, r24
    3d90:	2e 5f       	subi	r18, 0xFE	; 254
    3d92:	3f 4f       	sbci	r19, 0xFF	; 255
    3d94:	ca 01       	movw	r24, r20
    3d96:	b9 01       	movw	r22, r18
    3d98:	0e 94 a9 07 	call	0xf52	; 0xf52 <vListInsert>

			/* If the task entering the blocked state was placed at the head of the
			list of blocked tasks then xNextTaskUnblockTime needs to be updated
			too. */
			if( xTimeToWake < xNextTaskUnblockTime )
    3d9c:	20 91 d4 02 	lds	r18, 0x02D4
    3da0:	30 91 d5 02 	lds	r19, 0x02D5
    3da4:	8b 81       	ldd	r24, Y+3	; 0x03
    3da6:	9c 81       	ldd	r25, Y+4	; 0x04
    3da8:	82 17       	cp	r24, r18
    3daa:	93 07       	cpc	r25, r19
    3dac:	30 f4       	brcc	.+12     	; 0x3dba <prvAddCurrentTaskToDelayedList+0xba>
			{
				xNextTaskUnblockTime = xTimeToWake;
    3dae:	8b 81       	ldd	r24, Y+3	; 0x03
    3db0:	9c 81       	ldd	r25, Y+4	; 0x04
    3db2:	90 93 d5 02 	sts	0x02D5, r25
    3db6:	80 93 d4 02 	sts	0x02D4, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    3dba:	27 96       	adiw	r28, 0x07	; 7
    3dbc:	0f b6       	in	r0, 0x3f	; 63
    3dbe:	f8 94       	cli
    3dc0:	de bf       	out	0x3e, r29	; 62
    3dc2:	0f be       	out	0x3f, r0	; 63
    3dc4:	cd bf       	out	0x3d, r28	; 61
    3dc6:	cf 91       	pop	r28
    3dc8:	df 91       	pop	r29
    3dca:	08 95       	ret

00003dcc <memcpy>:
    3dcc:	fb 01       	movw	r30, r22
    3dce:	dc 01       	movw	r26, r24
    3dd0:	02 c0       	rjmp	.+4      	; 0x3dd6 <memcpy+0xa>
    3dd2:	01 90       	ld	r0, Z+
    3dd4:	0d 92       	st	X+, r0
    3dd6:	41 50       	subi	r20, 0x01	; 1
    3dd8:	50 40       	sbci	r21, 0x00	; 0
    3dda:	d8 f7       	brcc	.-10     	; 0x3dd2 <memcpy+0x6>
    3ddc:	08 95       	ret

00003dde <_exit>:
    3dde:	f8 94       	cli

00003de0 <__stop_program>:
    3de0:	ff cf       	rjmp	.-2      	; 0x3de0 <__stop_program>
