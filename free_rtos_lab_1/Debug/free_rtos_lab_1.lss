
free_rtos_lab_1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003dba  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000c  00800060  00003dba  00003e4e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002bc  0080006c  0080006c  00003e5a  2**0
                  ALLOC
  3 .stab         00006924  00000000  00000000  00003e5c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003dfb  00000000  00000000  0000a780  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 c5 0b 	jmp	0x178a	; 0x178a <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ea eb       	ldi	r30, 0xBA	; 186
      68:	fd e3       	ldi	r31, 0x3D	; 61
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	ac 36       	cpi	r26, 0x6C	; 108
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	13 e0       	ldi	r17, 0x03	; 3
      78:	ac e6       	ldi	r26, 0x6C	; 108
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a8 32       	cpi	r26, 0x28	; 40
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 ac 08 	call	0x1158	; 0x1158 <main>
      8a:	0c 94 db 1e 	jmp	0x3db6	; 0x3db6 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DIO_SET_PIN_VALUE>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	00 d0       	rcall	.+0      	; 0x98 <DIO_SET_PIN_VALUE+0x6>
      98:	00 d0       	rcall	.+0      	; 0x9a <DIO_SET_PIN_VALUE+0x8>
      9a:	00 d0       	rcall	.+0      	; 0x9c <DIO_SET_PIN_VALUE+0xa>
      9c:	cd b7       	in	r28, 0x3d	; 61
      9e:	de b7       	in	r29, 0x3e	; 62
      a0:	8a 83       	std	Y+2, r24	; 0x02
      a2:	6b 83       	std	Y+3, r22	; 0x03
      a4:	4c 83       	std	Y+4, r20	; 0x04
      a6:	19 82       	std	Y+1, r1	; 0x01
      a8:	8a 81       	ldd	r24, Y+2	; 0x02
      aa:	84 30       	cpi	r24, 0x04	; 4
      ac:	18 f0       	brcs	.+6      	; 0xb4 <DIO_SET_PIN_VALUE+0x22>
      ae:	81 e0       	ldi	r24, 0x01	; 1
      b0:	89 83       	std	Y+1, r24	; 0x01
      b2:	e0 c0       	rjmp	.+448    	; 0x274 <DIO_SET_PIN_VALUE+0x1e2>
      b4:	8b 81       	ldd	r24, Y+3	; 0x03
      b6:	88 30       	cpi	r24, 0x08	; 8
      b8:	18 f0       	brcs	.+6      	; 0xc0 <DIO_SET_PIN_VALUE+0x2e>
      ba:	82 e0       	ldi	r24, 0x02	; 2
      bc:	89 83       	std	Y+1, r24	; 0x01
      be:	da c0       	rjmp	.+436    	; 0x274 <DIO_SET_PIN_VALUE+0x1e2>
      c0:	8c 81       	ldd	r24, Y+4	; 0x04
      c2:	88 23       	and	r24, r24
      c4:	31 f0       	breq	.+12     	; 0xd2 <DIO_SET_PIN_VALUE+0x40>
      c6:	8c 81       	ldd	r24, Y+4	; 0x04
      c8:	81 30       	cpi	r24, 0x01	; 1
      ca:	19 f0       	breq	.+6      	; 0xd2 <DIO_SET_PIN_VALUE+0x40>
      cc:	83 e0       	ldi	r24, 0x03	; 3
      ce:	89 83       	std	Y+1, r24	; 0x01
      d0:	d1 c0       	rjmp	.+418    	; 0x274 <DIO_SET_PIN_VALUE+0x1e2>
      d2:	8a 81       	ldd	r24, Y+2	; 0x02
      d4:	28 2f       	mov	r18, r24
      d6:	30 e0       	ldi	r19, 0x00	; 0
      d8:	3e 83       	std	Y+6, r19	; 0x06
      da:	2d 83       	std	Y+5, r18	; 0x05
      dc:	8d 81       	ldd	r24, Y+5	; 0x05
      de:	9e 81       	ldd	r25, Y+6	; 0x06
      e0:	81 30       	cpi	r24, 0x01	; 1
      e2:	91 05       	cpc	r25, r1
      e4:	09 f4       	brne	.+2      	; 0xe8 <DIO_SET_PIN_VALUE+0x56>
      e6:	43 c0       	rjmp	.+134    	; 0x16e <DIO_SET_PIN_VALUE+0xdc>
      e8:	2d 81       	ldd	r18, Y+5	; 0x05
      ea:	3e 81       	ldd	r19, Y+6	; 0x06
      ec:	22 30       	cpi	r18, 0x02	; 2
      ee:	31 05       	cpc	r19, r1
      f0:	2c f4       	brge	.+10     	; 0xfc <DIO_SET_PIN_VALUE+0x6a>
      f2:	8d 81       	ldd	r24, Y+5	; 0x05
      f4:	9e 81       	ldd	r25, Y+6	; 0x06
      f6:	00 97       	sbiw	r24, 0x00	; 0
      f8:	71 f0       	breq	.+28     	; 0x116 <DIO_SET_PIN_VALUE+0x84>
      fa:	bc c0       	rjmp	.+376    	; 0x274 <DIO_SET_PIN_VALUE+0x1e2>
      fc:	2d 81       	ldd	r18, Y+5	; 0x05
      fe:	3e 81       	ldd	r19, Y+6	; 0x06
     100:	22 30       	cpi	r18, 0x02	; 2
     102:	31 05       	cpc	r19, r1
     104:	09 f4       	brne	.+2      	; 0x108 <DIO_SET_PIN_VALUE+0x76>
     106:	5f c0       	rjmp	.+190    	; 0x1c6 <DIO_SET_PIN_VALUE+0x134>
     108:	8d 81       	ldd	r24, Y+5	; 0x05
     10a:	9e 81       	ldd	r25, Y+6	; 0x06
     10c:	83 30       	cpi	r24, 0x03	; 3
     10e:	91 05       	cpc	r25, r1
     110:	09 f4       	brne	.+2      	; 0x114 <DIO_SET_PIN_VALUE+0x82>
     112:	85 c0       	rjmp	.+266    	; 0x21e <DIO_SET_PIN_VALUE+0x18c>
     114:	af c0       	rjmp	.+350    	; 0x274 <DIO_SET_PIN_VALUE+0x1e2>
     116:	8c 81       	ldd	r24, Y+4	; 0x04
     118:	81 30       	cpi	r24, 0x01	; 1
     11a:	a1 f4       	brne	.+40     	; 0x144 <DIO_SET_PIN_VALUE+0xb2>
     11c:	ab e3       	ldi	r26, 0x3B	; 59
     11e:	b0 e0       	ldi	r27, 0x00	; 0
     120:	eb e3       	ldi	r30, 0x3B	; 59
     122:	f0 e0       	ldi	r31, 0x00	; 0
     124:	80 81       	ld	r24, Z
     126:	48 2f       	mov	r20, r24
     128:	8b 81       	ldd	r24, Y+3	; 0x03
     12a:	28 2f       	mov	r18, r24
     12c:	30 e0       	ldi	r19, 0x00	; 0
     12e:	81 e0       	ldi	r24, 0x01	; 1
     130:	90 e0       	ldi	r25, 0x00	; 0
     132:	02 2e       	mov	r0, r18
     134:	02 c0       	rjmp	.+4      	; 0x13a <DIO_SET_PIN_VALUE+0xa8>
     136:	88 0f       	add	r24, r24
     138:	99 1f       	adc	r25, r25
     13a:	0a 94       	dec	r0
     13c:	e2 f7       	brpl	.-8      	; 0x136 <DIO_SET_PIN_VALUE+0xa4>
     13e:	84 2b       	or	r24, r20
     140:	8c 93       	st	X, r24
     142:	98 c0       	rjmp	.+304    	; 0x274 <DIO_SET_PIN_VALUE+0x1e2>
     144:	ab e3       	ldi	r26, 0x3B	; 59
     146:	b0 e0       	ldi	r27, 0x00	; 0
     148:	eb e3       	ldi	r30, 0x3B	; 59
     14a:	f0 e0       	ldi	r31, 0x00	; 0
     14c:	80 81       	ld	r24, Z
     14e:	48 2f       	mov	r20, r24
     150:	8b 81       	ldd	r24, Y+3	; 0x03
     152:	28 2f       	mov	r18, r24
     154:	30 e0       	ldi	r19, 0x00	; 0
     156:	81 e0       	ldi	r24, 0x01	; 1
     158:	90 e0       	ldi	r25, 0x00	; 0
     15a:	02 2e       	mov	r0, r18
     15c:	02 c0       	rjmp	.+4      	; 0x162 <DIO_SET_PIN_VALUE+0xd0>
     15e:	88 0f       	add	r24, r24
     160:	99 1f       	adc	r25, r25
     162:	0a 94       	dec	r0
     164:	e2 f7       	brpl	.-8      	; 0x15e <DIO_SET_PIN_VALUE+0xcc>
     166:	80 95       	com	r24
     168:	84 23       	and	r24, r20
     16a:	8c 93       	st	X, r24
     16c:	83 c0       	rjmp	.+262    	; 0x274 <DIO_SET_PIN_VALUE+0x1e2>
     16e:	8c 81       	ldd	r24, Y+4	; 0x04
     170:	81 30       	cpi	r24, 0x01	; 1
     172:	a1 f4       	brne	.+40     	; 0x19c <DIO_SET_PIN_VALUE+0x10a>
     174:	a8 e3       	ldi	r26, 0x38	; 56
     176:	b0 e0       	ldi	r27, 0x00	; 0
     178:	e8 e3       	ldi	r30, 0x38	; 56
     17a:	f0 e0       	ldi	r31, 0x00	; 0
     17c:	80 81       	ld	r24, Z
     17e:	48 2f       	mov	r20, r24
     180:	8b 81       	ldd	r24, Y+3	; 0x03
     182:	28 2f       	mov	r18, r24
     184:	30 e0       	ldi	r19, 0x00	; 0
     186:	81 e0       	ldi	r24, 0x01	; 1
     188:	90 e0       	ldi	r25, 0x00	; 0
     18a:	02 2e       	mov	r0, r18
     18c:	02 c0       	rjmp	.+4      	; 0x192 <DIO_SET_PIN_VALUE+0x100>
     18e:	88 0f       	add	r24, r24
     190:	99 1f       	adc	r25, r25
     192:	0a 94       	dec	r0
     194:	e2 f7       	brpl	.-8      	; 0x18e <DIO_SET_PIN_VALUE+0xfc>
     196:	84 2b       	or	r24, r20
     198:	8c 93       	st	X, r24
     19a:	6c c0       	rjmp	.+216    	; 0x274 <DIO_SET_PIN_VALUE+0x1e2>
     19c:	a8 e3       	ldi	r26, 0x38	; 56
     19e:	b0 e0       	ldi	r27, 0x00	; 0
     1a0:	e8 e3       	ldi	r30, 0x38	; 56
     1a2:	f0 e0       	ldi	r31, 0x00	; 0
     1a4:	80 81       	ld	r24, Z
     1a6:	48 2f       	mov	r20, r24
     1a8:	8b 81       	ldd	r24, Y+3	; 0x03
     1aa:	28 2f       	mov	r18, r24
     1ac:	30 e0       	ldi	r19, 0x00	; 0
     1ae:	81 e0       	ldi	r24, 0x01	; 1
     1b0:	90 e0       	ldi	r25, 0x00	; 0
     1b2:	02 2e       	mov	r0, r18
     1b4:	02 c0       	rjmp	.+4      	; 0x1ba <DIO_SET_PIN_VALUE+0x128>
     1b6:	88 0f       	add	r24, r24
     1b8:	99 1f       	adc	r25, r25
     1ba:	0a 94       	dec	r0
     1bc:	e2 f7       	brpl	.-8      	; 0x1b6 <DIO_SET_PIN_VALUE+0x124>
     1be:	80 95       	com	r24
     1c0:	84 23       	and	r24, r20
     1c2:	8c 93       	st	X, r24
     1c4:	57 c0       	rjmp	.+174    	; 0x274 <DIO_SET_PIN_VALUE+0x1e2>
     1c6:	8c 81       	ldd	r24, Y+4	; 0x04
     1c8:	81 30       	cpi	r24, 0x01	; 1
     1ca:	a1 f4       	brne	.+40     	; 0x1f4 <DIO_SET_PIN_VALUE+0x162>
     1cc:	a5 e3       	ldi	r26, 0x35	; 53
     1ce:	b0 e0       	ldi	r27, 0x00	; 0
     1d0:	e5 e3       	ldi	r30, 0x35	; 53
     1d2:	f0 e0       	ldi	r31, 0x00	; 0
     1d4:	80 81       	ld	r24, Z
     1d6:	48 2f       	mov	r20, r24
     1d8:	8b 81       	ldd	r24, Y+3	; 0x03
     1da:	28 2f       	mov	r18, r24
     1dc:	30 e0       	ldi	r19, 0x00	; 0
     1de:	81 e0       	ldi	r24, 0x01	; 1
     1e0:	90 e0       	ldi	r25, 0x00	; 0
     1e2:	02 2e       	mov	r0, r18
     1e4:	02 c0       	rjmp	.+4      	; 0x1ea <DIO_SET_PIN_VALUE+0x158>
     1e6:	88 0f       	add	r24, r24
     1e8:	99 1f       	adc	r25, r25
     1ea:	0a 94       	dec	r0
     1ec:	e2 f7       	brpl	.-8      	; 0x1e6 <DIO_SET_PIN_VALUE+0x154>
     1ee:	84 2b       	or	r24, r20
     1f0:	8c 93       	st	X, r24
     1f2:	40 c0       	rjmp	.+128    	; 0x274 <DIO_SET_PIN_VALUE+0x1e2>
     1f4:	a5 e3       	ldi	r26, 0x35	; 53
     1f6:	b0 e0       	ldi	r27, 0x00	; 0
     1f8:	e5 e3       	ldi	r30, 0x35	; 53
     1fa:	f0 e0       	ldi	r31, 0x00	; 0
     1fc:	80 81       	ld	r24, Z
     1fe:	48 2f       	mov	r20, r24
     200:	8b 81       	ldd	r24, Y+3	; 0x03
     202:	28 2f       	mov	r18, r24
     204:	30 e0       	ldi	r19, 0x00	; 0
     206:	81 e0       	ldi	r24, 0x01	; 1
     208:	90 e0       	ldi	r25, 0x00	; 0
     20a:	02 2e       	mov	r0, r18
     20c:	02 c0       	rjmp	.+4      	; 0x212 <DIO_SET_PIN_VALUE+0x180>
     20e:	88 0f       	add	r24, r24
     210:	99 1f       	adc	r25, r25
     212:	0a 94       	dec	r0
     214:	e2 f7       	brpl	.-8      	; 0x20e <DIO_SET_PIN_VALUE+0x17c>
     216:	80 95       	com	r24
     218:	84 23       	and	r24, r20
     21a:	8c 93       	st	X, r24
     21c:	2b c0       	rjmp	.+86     	; 0x274 <DIO_SET_PIN_VALUE+0x1e2>
     21e:	8c 81       	ldd	r24, Y+4	; 0x04
     220:	81 30       	cpi	r24, 0x01	; 1
     222:	a1 f4       	brne	.+40     	; 0x24c <DIO_SET_PIN_VALUE+0x1ba>
     224:	a2 e3       	ldi	r26, 0x32	; 50
     226:	b0 e0       	ldi	r27, 0x00	; 0
     228:	e2 e3       	ldi	r30, 0x32	; 50
     22a:	f0 e0       	ldi	r31, 0x00	; 0
     22c:	80 81       	ld	r24, Z
     22e:	48 2f       	mov	r20, r24
     230:	8b 81       	ldd	r24, Y+3	; 0x03
     232:	28 2f       	mov	r18, r24
     234:	30 e0       	ldi	r19, 0x00	; 0
     236:	81 e0       	ldi	r24, 0x01	; 1
     238:	90 e0       	ldi	r25, 0x00	; 0
     23a:	02 2e       	mov	r0, r18
     23c:	02 c0       	rjmp	.+4      	; 0x242 <DIO_SET_PIN_VALUE+0x1b0>
     23e:	88 0f       	add	r24, r24
     240:	99 1f       	adc	r25, r25
     242:	0a 94       	dec	r0
     244:	e2 f7       	brpl	.-8      	; 0x23e <DIO_SET_PIN_VALUE+0x1ac>
     246:	84 2b       	or	r24, r20
     248:	8c 93       	st	X, r24
     24a:	14 c0       	rjmp	.+40     	; 0x274 <DIO_SET_PIN_VALUE+0x1e2>
     24c:	a2 e3       	ldi	r26, 0x32	; 50
     24e:	b0 e0       	ldi	r27, 0x00	; 0
     250:	e2 e3       	ldi	r30, 0x32	; 50
     252:	f0 e0       	ldi	r31, 0x00	; 0
     254:	80 81       	ld	r24, Z
     256:	48 2f       	mov	r20, r24
     258:	8b 81       	ldd	r24, Y+3	; 0x03
     25a:	28 2f       	mov	r18, r24
     25c:	30 e0       	ldi	r19, 0x00	; 0
     25e:	81 e0       	ldi	r24, 0x01	; 1
     260:	90 e0       	ldi	r25, 0x00	; 0
     262:	02 2e       	mov	r0, r18
     264:	02 c0       	rjmp	.+4      	; 0x26a <DIO_SET_PIN_VALUE+0x1d8>
     266:	88 0f       	add	r24, r24
     268:	99 1f       	adc	r25, r25
     26a:	0a 94       	dec	r0
     26c:	e2 f7       	brpl	.-8      	; 0x266 <DIO_SET_PIN_VALUE+0x1d4>
     26e:	80 95       	com	r24
     270:	84 23       	and	r24, r20
     272:	8c 93       	st	X, r24
     274:	89 81       	ldd	r24, Y+1	; 0x01
     276:	26 96       	adiw	r28, 0x06	; 6
     278:	0f b6       	in	r0, 0x3f	; 63
     27a:	f8 94       	cli
     27c:	de bf       	out	0x3e, r29	; 62
     27e:	0f be       	out	0x3f, r0	; 63
     280:	cd bf       	out	0x3d, r28	; 61
     282:	cf 91       	pop	r28
     284:	df 91       	pop	r29
     286:	08 95       	ret

00000288 <DIO_SET_PIN_DIRECTION>:

//FUNCTION FOR DIRECTION (REG DDR) FOR 1 PIN **************


u8 DIO_SET_PIN_DIRECTION(u8 PORT_NB,u8 PIN_NB,u8 PIN_DIRECTION)//RIGESTER PORT PIN PIN....
{u8 ERROR_STATE=0;
     288:	df 93       	push	r29
     28a:	cf 93       	push	r28
     28c:	00 d0       	rcall	.+0      	; 0x28e <DIO_SET_PIN_DIRECTION+0x6>
     28e:	00 d0       	rcall	.+0      	; 0x290 <DIO_SET_PIN_DIRECTION+0x8>
     290:	00 d0       	rcall	.+0      	; 0x292 <DIO_SET_PIN_DIRECTION+0xa>
     292:	cd b7       	in	r28, 0x3d	; 61
     294:	de b7       	in	r29, 0x3e	; 62
     296:	8a 83       	std	Y+2, r24	; 0x02
     298:	6b 83       	std	Y+3, r22	; 0x03
     29a:	4c 83       	std	Y+4, r20	; 0x04
     29c:	19 82       	std	Y+1, r1	; 0x01
	if (PORT_NB>=DIO_MAX_PORT_NB)
     29e:	8a 81       	ldd	r24, Y+2	; 0x02
     2a0:	84 30       	cpi	r24, 0x04	; 4
     2a2:	18 f0       	brcs	.+6      	; 0x2aa <DIO_SET_PIN_DIRECTION+0x22>
	{
		ERROR_STATE=1;//PORT ERROR
     2a4:	81 e0       	ldi	r24, 0x01	; 1
     2a6:	89 83       	std	Y+1, r24	; 0x01
     2a8:	e0 c0       	rjmp	.+448    	; 0x46a <DIO_SET_PIN_DIRECTION+0x1e2>

	}else if (PIN_NB >= DIO_MAX_PIN_NB)
     2aa:	8b 81       	ldd	r24, Y+3	; 0x03
     2ac:	88 30       	cpi	r24, 0x08	; 8
     2ae:	18 f0       	brcs	.+6      	; 0x2b6 <DIO_SET_PIN_DIRECTION+0x2e>

	{
		ERROR_STATE=2;//PIN ERROR
     2b0:	82 e0       	ldi	r24, 0x02	; 2
     2b2:	89 83       	std	Y+1, r24	; 0x01
     2b4:	da c0       	rjmp	.+436    	; 0x46a <DIO_SET_PIN_DIRECTION+0x1e2>

	}else if((PIN_DIRECTION !=DIO_INPUT)&&(PIN_DIRECTION!=DIO_OUTPUT))
     2b6:	8c 81       	ldd	r24, Y+4	; 0x04
     2b8:	88 23       	and	r24, r24
     2ba:	31 f0       	breq	.+12     	; 0x2c8 <DIO_SET_PIN_DIRECTION+0x40>
     2bc:	8c 81       	ldd	r24, Y+4	; 0x04
     2be:	81 30       	cpi	r24, 0x01	; 1
     2c0:	19 f0       	breq	.+6      	; 0x2c8 <DIO_SET_PIN_DIRECTION+0x40>
	{

		ERROR_STATE=3;//VALUE ERROR
     2c2:	83 e0       	ldi	r24, 0x03	; 3
     2c4:	89 83       	std	Y+1, r24	; 0x01
     2c6:	d1 c0       	rjmp	.+418    	; 0x46a <DIO_SET_PIN_DIRECTION+0x1e2>
	}
	else
	{

		switch (PORT_NB)
     2c8:	8a 81       	ldd	r24, Y+2	; 0x02
     2ca:	28 2f       	mov	r18, r24
     2cc:	30 e0       	ldi	r19, 0x00	; 0
     2ce:	3e 83       	std	Y+6, r19	; 0x06
     2d0:	2d 83       	std	Y+5, r18	; 0x05
     2d2:	8d 81       	ldd	r24, Y+5	; 0x05
     2d4:	9e 81       	ldd	r25, Y+6	; 0x06
     2d6:	81 30       	cpi	r24, 0x01	; 1
     2d8:	91 05       	cpc	r25, r1
     2da:	09 f4       	brne	.+2      	; 0x2de <DIO_SET_PIN_DIRECTION+0x56>
     2dc:	43 c0       	rjmp	.+134    	; 0x364 <DIO_SET_PIN_DIRECTION+0xdc>
     2de:	2d 81       	ldd	r18, Y+5	; 0x05
     2e0:	3e 81       	ldd	r19, Y+6	; 0x06
     2e2:	22 30       	cpi	r18, 0x02	; 2
     2e4:	31 05       	cpc	r19, r1
     2e6:	2c f4       	brge	.+10     	; 0x2f2 <DIO_SET_PIN_DIRECTION+0x6a>
     2e8:	8d 81       	ldd	r24, Y+5	; 0x05
     2ea:	9e 81       	ldd	r25, Y+6	; 0x06
     2ec:	00 97       	sbiw	r24, 0x00	; 0
     2ee:	71 f0       	breq	.+28     	; 0x30c <DIO_SET_PIN_DIRECTION+0x84>
     2f0:	bc c0       	rjmp	.+376    	; 0x46a <DIO_SET_PIN_DIRECTION+0x1e2>
     2f2:	2d 81       	ldd	r18, Y+5	; 0x05
     2f4:	3e 81       	ldd	r19, Y+6	; 0x06
     2f6:	22 30       	cpi	r18, 0x02	; 2
     2f8:	31 05       	cpc	r19, r1
     2fa:	09 f4       	brne	.+2      	; 0x2fe <DIO_SET_PIN_DIRECTION+0x76>
     2fc:	5f c0       	rjmp	.+190    	; 0x3bc <DIO_SET_PIN_DIRECTION+0x134>
     2fe:	8d 81       	ldd	r24, Y+5	; 0x05
     300:	9e 81       	ldd	r25, Y+6	; 0x06
     302:	83 30       	cpi	r24, 0x03	; 3
     304:	91 05       	cpc	r25, r1
     306:	09 f4       	brne	.+2      	; 0x30a <DIO_SET_PIN_DIRECTION+0x82>
     308:	85 c0       	rjmp	.+266    	; 0x414 <DIO_SET_PIN_DIRECTION+0x18c>
     30a:	af c0       	rjmp	.+350    	; 0x46a <DIO_SET_PIN_DIRECTION+0x1e2>
		{
		case GROUP_A:
					assign_bit(DIO_U8_DDRA,PIN_NB,PIN_DIRECTION);
     30c:	8c 81       	ldd	r24, Y+4	; 0x04
     30e:	81 30       	cpi	r24, 0x01	; 1
     310:	a1 f4       	brne	.+40     	; 0x33a <DIO_SET_PIN_DIRECTION+0xb2>
     312:	aa e3       	ldi	r26, 0x3A	; 58
     314:	b0 e0       	ldi	r27, 0x00	; 0
     316:	ea e3       	ldi	r30, 0x3A	; 58
     318:	f0 e0       	ldi	r31, 0x00	; 0
     31a:	80 81       	ld	r24, Z
     31c:	48 2f       	mov	r20, r24
     31e:	8b 81       	ldd	r24, Y+3	; 0x03
     320:	28 2f       	mov	r18, r24
     322:	30 e0       	ldi	r19, 0x00	; 0
     324:	81 e0       	ldi	r24, 0x01	; 1
     326:	90 e0       	ldi	r25, 0x00	; 0
     328:	02 2e       	mov	r0, r18
     32a:	02 c0       	rjmp	.+4      	; 0x330 <DIO_SET_PIN_DIRECTION+0xa8>
     32c:	88 0f       	add	r24, r24
     32e:	99 1f       	adc	r25, r25
     330:	0a 94       	dec	r0
     332:	e2 f7       	brpl	.-8      	; 0x32c <DIO_SET_PIN_DIRECTION+0xa4>
     334:	84 2b       	or	r24, r20
     336:	8c 93       	st	X, r24
     338:	98 c0       	rjmp	.+304    	; 0x46a <DIO_SET_PIN_DIRECTION+0x1e2>
     33a:	aa e3       	ldi	r26, 0x3A	; 58
     33c:	b0 e0       	ldi	r27, 0x00	; 0
     33e:	ea e3       	ldi	r30, 0x3A	; 58
     340:	f0 e0       	ldi	r31, 0x00	; 0
     342:	80 81       	ld	r24, Z
     344:	48 2f       	mov	r20, r24
     346:	8b 81       	ldd	r24, Y+3	; 0x03
     348:	28 2f       	mov	r18, r24
     34a:	30 e0       	ldi	r19, 0x00	; 0
     34c:	81 e0       	ldi	r24, 0x01	; 1
     34e:	90 e0       	ldi	r25, 0x00	; 0
     350:	02 2e       	mov	r0, r18
     352:	02 c0       	rjmp	.+4      	; 0x358 <DIO_SET_PIN_DIRECTION+0xd0>
     354:	88 0f       	add	r24, r24
     356:	99 1f       	adc	r25, r25
     358:	0a 94       	dec	r0
     35a:	e2 f7       	brpl	.-8      	; 0x354 <DIO_SET_PIN_DIRECTION+0xcc>
     35c:	80 95       	com	r24
     35e:	84 23       	and	r24, r20
     360:	8c 93       	st	X, r24
     362:	83 c0       	rjmp	.+262    	; 0x46a <DIO_SET_PIN_DIRECTION+0x1e2>
			break;
		case GROUP_B:
					assign_bit(DIO_U8_DDRB,PIN_NB,PIN_DIRECTION);
     364:	8c 81       	ldd	r24, Y+4	; 0x04
     366:	81 30       	cpi	r24, 0x01	; 1
     368:	a1 f4       	brne	.+40     	; 0x392 <DIO_SET_PIN_DIRECTION+0x10a>
     36a:	a7 e3       	ldi	r26, 0x37	; 55
     36c:	b0 e0       	ldi	r27, 0x00	; 0
     36e:	e7 e3       	ldi	r30, 0x37	; 55
     370:	f0 e0       	ldi	r31, 0x00	; 0
     372:	80 81       	ld	r24, Z
     374:	48 2f       	mov	r20, r24
     376:	8b 81       	ldd	r24, Y+3	; 0x03
     378:	28 2f       	mov	r18, r24
     37a:	30 e0       	ldi	r19, 0x00	; 0
     37c:	81 e0       	ldi	r24, 0x01	; 1
     37e:	90 e0       	ldi	r25, 0x00	; 0
     380:	02 2e       	mov	r0, r18
     382:	02 c0       	rjmp	.+4      	; 0x388 <DIO_SET_PIN_DIRECTION+0x100>
     384:	88 0f       	add	r24, r24
     386:	99 1f       	adc	r25, r25
     388:	0a 94       	dec	r0
     38a:	e2 f7       	brpl	.-8      	; 0x384 <DIO_SET_PIN_DIRECTION+0xfc>
     38c:	84 2b       	or	r24, r20
     38e:	8c 93       	st	X, r24
     390:	6c c0       	rjmp	.+216    	; 0x46a <DIO_SET_PIN_DIRECTION+0x1e2>
     392:	a7 e3       	ldi	r26, 0x37	; 55
     394:	b0 e0       	ldi	r27, 0x00	; 0
     396:	e7 e3       	ldi	r30, 0x37	; 55
     398:	f0 e0       	ldi	r31, 0x00	; 0
     39a:	80 81       	ld	r24, Z
     39c:	48 2f       	mov	r20, r24
     39e:	8b 81       	ldd	r24, Y+3	; 0x03
     3a0:	28 2f       	mov	r18, r24
     3a2:	30 e0       	ldi	r19, 0x00	; 0
     3a4:	81 e0       	ldi	r24, 0x01	; 1
     3a6:	90 e0       	ldi	r25, 0x00	; 0
     3a8:	02 2e       	mov	r0, r18
     3aa:	02 c0       	rjmp	.+4      	; 0x3b0 <DIO_SET_PIN_DIRECTION+0x128>
     3ac:	88 0f       	add	r24, r24
     3ae:	99 1f       	adc	r25, r25
     3b0:	0a 94       	dec	r0
     3b2:	e2 f7       	brpl	.-8      	; 0x3ac <DIO_SET_PIN_DIRECTION+0x124>
     3b4:	80 95       	com	r24
     3b6:	84 23       	and	r24, r20
     3b8:	8c 93       	st	X, r24
     3ba:	57 c0       	rjmp	.+174    	; 0x46a <DIO_SET_PIN_DIRECTION+0x1e2>
			break;
		case GROUP_C:
					assign_bit(DIO_U8_DDRC,PIN_NB,PIN_DIRECTION);
     3bc:	8c 81       	ldd	r24, Y+4	; 0x04
     3be:	81 30       	cpi	r24, 0x01	; 1
     3c0:	a1 f4       	brne	.+40     	; 0x3ea <DIO_SET_PIN_DIRECTION+0x162>
     3c2:	a4 e3       	ldi	r26, 0x34	; 52
     3c4:	b0 e0       	ldi	r27, 0x00	; 0
     3c6:	e4 e3       	ldi	r30, 0x34	; 52
     3c8:	f0 e0       	ldi	r31, 0x00	; 0
     3ca:	80 81       	ld	r24, Z
     3cc:	48 2f       	mov	r20, r24
     3ce:	8b 81       	ldd	r24, Y+3	; 0x03
     3d0:	28 2f       	mov	r18, r24
     3d2:	30 e0       	ldi	r19, 0x00	; 0
     3d4:	81 e0       	ldi	r24, 0x01	; 1
     3d6:	90 e0       	ldi	r25, 0x00	; 0
     3d8:	02 2e       	mov	r0, r18
     3da:	02 c0       	rjmp	.+4      	; 0x3e0 <DIO_SET_PIN_DIRECTION+0x158>
     3dc:	88 0f       	add	r24, r24
     3de:	99 1f       	adc	r25, r25
     3e0:	0a 94       	dec	r0
     3e2:	e2 f7       	brpl	.-8      	; 0x3dc <DIO_SET_PIN_DIRECTION+0x154>
     3e4:	84 2b       	or	r24, r20
     3e6:	8c 93       	st	X, r24
     3e8:	40 c0       	rjmp	.+128    	; 0x46a <DIO_SET_PIN_DIRECTION+0x1e2>
     3ea:	a4 e3       	ldi	r26, 0x34	; 52
     3ec:	b0 e0       	ldi	r27, 0x00	; 0
     3ee:	e4 e3       	ldi	r30, 0x34	; 52
     3f0:	f0 e0       	ldi	r31, 0x00	; 0
     3f2:	80 81       	ld	r24, Z
     3f4:	48 2f       	mov	r20, r24
     3f6:	8b 81       	ldd	r24, Y+3	; 0x03
     3f8:	28 2f       	mov	r18, r24
     3fa:	30 e0       	ldi	r19, 0x00	; 0
     3fc:	81 e0       	ldi	r24, 0x01	; 1
     3fe:	90 e0       	ldi	r25, 0x00	; 0
     400:	02 2e       	mov	r0, r18
     402:	02 c0       	rjmp	.+4      	; 0x408 <DIO_SET_PIN_DIRECTION+0x180>
     404:	88 0f       	add	r24, r24
     406:	99 1f       	adc	r25, r25
     408:	0a 94       	dec	r0
     40a:	e2 f7       	brpl	.-8      	; 0x404 <DIO_SET_PIN_DIRECTION+0x17c>
     40c:	80 95       	com	r24
     40e:	84 23       	and	r24, r20
     410:	8c 93       	st	X, r24
     412:	2b c0       	rjmp	.+86     	; 0x46a <DIO_SET_PIN_DIRECTION+0x1e2>
			break;
		case GROUP_D:
					assign_bit(DIO_U8_DDRD,PIN_NB,PIN_DIRECTION);
     414:	8c 81       	ldd	r24, Y+4	; 0x04
     416:	81 30       	cpi	r24, 0x01	; 1
     418:	a1 f4       	brne	.+40     	; 0x442 <DIO_SET_PIN_DIRECTION+0x1ba>
     41a:	a1 e3       	ldi	r26, 0x31	; 49
     41c:	b0 e0       	ldi	r27, 0x00	; 0
     41e:	e1 e3       	ldi	r30, 0x31	; 49
     420:	f0 e0       	ldi	r31, 0x00	; 0
     422:	80 81       	ld	r24, Z
     424:	48 2f       	mov	r20, r24
     426:	8b 81       	ldd	r24, Y+3	; 0x03
     428:	28 2f       	mov	r18, r24
     42a:	30 e0       	ldi	r19, 0x00	; 0
     42c:	81 e0       	ldi	r24, 0x01	; 1
     42e:	90 e0       	ldi	r25, 0x00	; 0
     430:	02 2e       	mov	r0, r18
     432:	02 c0       	rjmp	.+4      	; 0x438 <DIO_SET_PIN_DIRECTION+0x1b0>
     434:	88 0f       	add	r24, r24
     436:	99 1f       	adc	r25, r25
     438:	0a 94       	dec	r0
     43a:	e2 f7       	brpl	.-8      	; 0x434 <DIO_SET_PIN_DIRECTION+0x1ac>
     43c:	84 2b       	or	r24, r20
     43e:	8c 93       	st	X, r24
     440:	14 c0       	rjmp	.+40     	; 0x46a <DIO_SET_PIN_DIRECTION+0x1e2>
     442:	a1 e3       	ldi	r26, 0x31	; 49
     444:	b0 e0       	ldi	r27, 0x00	; 0
     446:	e1 e3       	ldi	r30, 0x31	; 49
     448:	f0 e0       	ldi	r31, 0x00	; 0
     44a:	80 81       	ld	r24, Z
     44c:	48 2f       	mov	r20, r24
     44e:	8b 81       	ldd	r24, Y+3	; 0x03
     450:	28 2f       	mov	r18, r24
     452:	30 e0       	ldi	r19, 0x00	; 0
     454:	81 e0       	ldi	r24, 0x01	; 1
     456:	90 e0       	ldi	r25, 0x00	; 0
     458:	02 2e       	mov	r0, r18
     45a:	02 c0       	rjmp	.+4      	; 0x460 <DIO_SET_PIN_DIRECTION+0x1d8>
     45c:	88 0f       	add	r24, r24
     45e:	99 1f       	adc	r25, r25
     460:	0a 94       	dec	r0
     462:	e2 f7       	brpl	.-8      	; 0x45c <DIO_SET_PIN_DIRECTION+0x1d4>
     464:	80 95       	com	r24
     466:	84 23       	and	r24, r20
     468:	8c 93       	st	X, r24

	}



return ERROR_STATE;
     46a:	89 81       	ldd	r24, Y+1	; 0x01
}
     46c:	26 96       	adiw	r28, 0x06	; 6
     46e:	0f b6       	in	r0, 0x3f	; 63
     470:	f8 94       	cli
     472:	de bf       	out	0x3e, r29	; 62
     474:	0f be       	out	0x3f, r0	; 63
     476:	cd bf       	out	0x3d, r28	; 61
     478:	cf 91       	pop	r28
     47a:	df 91       	pop	r29
     47c:	08 95       	ret

0000047e <DIO_GET_PIN_VALUE>:

//FUNCTION FOR GET VALUE (REG PIN) FOR 1 PIN **************


u8 DIO_GET_PIN_VALUE(u8 PORT_NB,u8 PIN_NB,u8 *PIN_VALUE)//RIGESTER PORT PIN PIN....
{u8 ERROR_STATE=0;
     47e:	df 93       	push	r29
     480:	cf 93       	push	r28
     482:	cd b7       	in	r28, 0x3d	; 61
     484:	de b7       	in	r29, 0x3e	; 62
     486:	27 97       	sbiw	r28, 0x07	; 7
     488:	0f b6       	in	r0, 0x3f	; 63
     48a:	f8 94       	cli
     48c:	de bf       	out	0x3e, r29	; 62
     48e:	0f be       	out	0x3f, r0	; 63
     490:	cd bf       	out	0x3d, r28	; 61
     492:	8a 83       	std	Y+2, r24	; 0x02
     494:	6b 83       	std	Y+3, r22	; 0x03
     496:	5d 83       	std	Y+5, r21	; 0x05
     498:	4c 83       	std	Y+4, r20	; 0x04
     49a:	19 82       	std	Y+1, r1	; 0x01
	if (PORT_NB>=DIO_MAX_PORT_NB)
     49c:	8a 81       	ldd	r24, Y+2	; 0x02
     49e:	84 30       	cpi	r24, 0x04	; 4
     4a0:	18 f0       	brcs	.+6      	; 0x4a8 <DIO_GET_PIN_VALUE+0x2a>
	{
		ERROR_STATE=1;//PORT ERROR
     4a2:	81 e0       	ldi	r24, 0x01	; 1
     4a4:	89 83       	std	Y+1, r24	; 0x01
     4a6:	76 c0       	rjmp	.+236    	; 0x594 <DIO_GET_PIN_VALUE+0x116>

	}else if (PIN_NB >= DIO_MAX_PIN_NB)
     4a8:	8b 81       	ldd	r24, Y+3	; 0x03
     4aa:	88 30       	cpi	r24, 0x08	; 8
     4ac:	18 f0       	brcs	.+6      	; 0x4b4 <DIO_GET_PIN_VALUE+0x36>

	{
		ERROR_STATE=2;//PIN ERROR
     4ae:	82 e0       	ldi	r24, 0x02	; 2
     4b0:	89 83       	std	Y+1, r24	; 0x01
     4b2:	70 c0       	rjmp	.+224    	; 0x594 <DIO_GET_PIN_VALUE+0x116>

	}
	else
	{

		switch (PORT_NB)
     4b4:	8a 81       	ldd	r24, Y+2	; 0x02
     4b6:	28 2f       	mov	r18, r24
     4b8:	30 e0       	ldi	r19, 0x00	; 0
     4ba:	3f 83       	std	Y+7, r19	; 0x07
     4bc:	2e 83       	std	Y+6, r18	; 0x06
     4be:	4e 81       	ldd	r20, Y+6	; 0x06
     4c0:	5f 81       	ldd	r21, Y+7	; 0x07
     4c2:	41 30       	cpi	r20, 0x01	; 1
     4c4:	51 05       	cpc	r21, r1
     4c6:	59 f1       	breq	.+86     	; 0x51e <DIO_GET_PIN_VALUE+0xa0>
     4c8:	8e 81       	ldd	r24, Y+6	; 0x06
     4ca:	9f 81       	ldd	r25, Y+7	; 0x07
     4cc:	82 30       	cpi	r24, 0x02	; 2
     4ce:	91 05       	cpc	r25, r1
     4d0:	34 f4       	brge	.+12     	; 0x4de <DIO_GET_PIN_VALUE+0x60>
     4d2:	2e 81       	ldd	r18, Y+6	; 0x06
     4d4:	3f 81       	ldd	r19, Y+7	; 0x07
     4d6:	21 15       	cp	r18, r1
     4d8:	31 05       	cpc	r19, r1
     4da:	69 f0       	breq	.+26     	; 0x4f6 <DIO_GET_PIN_VALUE+0x78>
     4dc:	5b c0       	rjmp	.+182    	; 0x594 <DIO_GET_PIN_VALUE+0x116>
     4de:	4e 81       	ldd	r20, Y+6	; 0x06
     4e0:	5f 81       	ldd	r21, Y+7	; 0x07
     4e2:	42 30       	cpi	r20, 0x02	; 2
     4e4:	51 05       	cpc	r21, r1
     4e6:	79 f1       	breq	.+94     	; 0x546 <DIO_GET_PIN_VALUE+0xc8>
     4e8:	8e 81       	ldd	r24, Y+6	; 0x06
     4ea:	9f 81       	ldd	r25, Y+7	; 0x07
     4ec:	83 30       	cpi	r24, 0x03	; 3
     4ee:	91 05       	cpc	r25, r1
     4f0:	09 f4       	brne	.+2      	; 0x4f4 <DIO_GET_PIN_VALUE+0x76>
     4f2:	3d c0       	rjmp	.+122    	; 0x56e <DIO_GET_PIN_VALUE+0xf0>
     4f4:	4f c0       	rjmp	.+158    	; 0x594 <DIO_GET_PIN_VALUE+0x116>
		{
		case GROUP_A:
			*PIN_VALUE = get_bit(DIO_U8_PINA,PIN_NB);
     4f6:	e9 e3       	ldi	r30, 0x39	; 57
     4f8:	f0 e0       	ldi	r31, 0x00	; 0
     4fa:	80 81       	ld	r24, Z
     4fc:	28 2f       	mov	r18, r24
     4fe:	30 e0       	ldi	r19, 0x00	; 0
     500:	8b 81       	ldd	r24, Y+3	; 0x03
     502:	88 2f       	mov	r24, r24
     504:	90 e0       	ldi	r25, 0x00	; 0
     506:	a9 01       	movw	r20, r18
     508:	02 c0       	rjmp	.+4      	; 0x50e <DIO_GET_PIN_VALUE+0x90>
     50a:	55 95       	asr	r21
     50c:	47 95       	ror	r20
     50e:	8a 95       	dec	r24
     510:	e2 f7       	brpl	.-8      	; 0x50a <DIO_GET_PIN_VALUE+0x8c>
     512:	ca 01       	movw	r24, r20
     514:	81 70       	andi	r24, 0x01	; 1
     516:	ec 81       	ldd	r30, Y+4	; 0x04
     518:	fd 81       	ldd	r31, Y+5	; 0x05
     51a:	80 83       	st	Z, r24
     51c:	3b c0       	rjmp	.+118    	; 0x594 <DIO_GET_PIN_VALUE+0x116>
			break;
		case GROUP_B:
			*PIN_VALUE = get_bit(DIO_U8_PINB,PIN_NB);
     51e:	e6 e3       	ldi	r30, 0x36	; 54
     520:	f0 e0       	ldi	r31, 0x00	; 0
     522:	80 81       	ld	r24, Z
     524:	28 2f       	mov	r18, r24
     526:	30 e0       	ldi	r19, 0x00	; 0
     528:	8b 81       	ldd	r24, Y+3	; 0x03
     52a:	88 2f       	mov	r24, r24
     52c:	90 e0       	ldi	r25, 0x00	; 0
     52e:	a9 01       	movw	r20, r18
     530:	02 c0       	rjmp	.+4      	; 0x536 <DIO_GET_PIN_VALUE+0xb8>
     532:	55 95       	asr	r21
     534:	47 95       	ror	r20
     536:	8a 95       	dec	r24
     538:	e2 f7       	brpl	.-8      	; 0x532 <DIO_GET_PIN_VALUE+0xb4>
     53a:	ca 01       	movw	r24, r20
     53c:	81 70       	andi	r24, 0x01	; 1
     53e:	ec 81       	ldd	r30, Y+4	; 0x04
     540:	fd 81       	ldd	r31, Y+5	; 0x05
     542:	80 83       	st	Z, r24
     544:	27 c0       	rjmp	.+78     	; 0x594 <DIO_GET_PIN_VALUE+0x116>
			break;
		case GROUP_C:
			*PIN_VALUE = get_bit(DIO_U8_PINC,PIN_NB);
     546:	e3 e3       	ldi	r30, 0x33	; 51
     548:	f0 e0       	ldi	r31, 0x00	; 0
     54a:	80 81       	ld	r24, Z
     54c:	28 2f       	mov	r18, r24
     54e:	30 e0       	ldi	r19, 0x00	; 0
     550:	8b 81       	ldd	r24, Y+3	; 0x03
     552:	88 2f       	mov	r24, r24
     554:	90 e0       	ldi	r25, 0x00	; 0
     556:	a9 01       	movw	r20, r18
     558:	02 c0       	rjmp	.+4      	; 0x55e <DIO_GET_PIN_VALUE+0xe0>
     55a:	55 95       	asr	r21
     55c:	47 95       	ror	r20
     55e:	8a 95       	dec	r24
     560:	e2 f7       	brpl	.-8      	; 0x55a <DIO_GET_PIN_VALUE+0xdc>
     562:	ca 01       	movw	r24, r20
     564:	81 70       	andi	r24, 0x01	; 1
     566:	ec 81       	ldd	r30, Y+4	; 0x04
     568:	fd 81       	ldd	r31, Y+5	; 0x05
     56a:	80 83       	st	Z, r24
     56c:	13 c0       	rjmp	.+38     	; 0x594 <DIO_GET_PIN_VALUE+0x116>
			break;
		case GROUP_D:
			*PIN_VALUE = get_bit(DIO_U8_PIND,PIN_NB);
     56e:	e0 e3       	ldi	r30, 0x30	; 48
     570:	f0 e0       	ldi	r31, 0x00	; 0
     572:	80 81       	ld	r24, Z
     574:	28 2f       	mov	r18, r24
     576:	30 e0       	ldi	r19, 0x00	; 0
     578:	8b 81       	ldd	r24, Y+3	; 0x03
     57a:	88 2f       	mov	r24, r24
     57c:	90 e0       	ldi	r25, 0x00	; 0
     57e:	a9 01       	movw	r20, r18
     580:	02 c0       	rjmp	.+4      	; 0x586 <DIO_GET_PIN_VALUE+0x108>
     582:	55 95       	asr	r21
     584:	47 95       	ror	r20
     586:	8a 95       	dec	r24
     588:	e2 f7       	brpl	.-8      	; 0x582 <DIO_GET_PIN_VALUE+0x104>
     58a:	ca 01       	movw	r24, r20
     58c:	81 70       	andi	r24, 0x01	; 1
     58e:	ec 81       	ldd	r30, Y+4	; 0x04
     590:	fd 81       	ldd	r31, Y+5	; 0x05
     592:	80 83       	st	Z, r24

	}



return ERROR_STATE;
     594:	89 81       	ldd	r24, Y+1	; 0x01
}
     596:	27 96       	adiw	r28, 0x07	; 7
     598:	0f b6       	in	r0, 0x3f	; 63
     59a:	f8 94       	cli
     59c:	de bf       	out	0x3e, r29	; 62
     59e:	0f be       	out	0x3f, r0	; 63
     5a0:	cd bf       	out	0x3d, r28	; 61
     5a2:	cf 91       	pop	r28
     5a4:	df 91       	pop	r29
     5a6:	08 95       	ret

000005a8 <DIO_SET_PORT_VALUE>:

//FUNCTION FOR OUTPUT VALUE (REG PORT) FOR 8 PIN **************


u8 DIO_SET_PORT_VALUE(u8 PORT_NB,u8 PORT_VALUE)//RIGESTER PORT (PORT PORT....
{u8 ERROR_STATE=0;
     5a8:	df 93       	push	r29
     5aa:	cf 93       	push	r28
     5ac:	00 d0       	rcall	.+0      	; 0x5ae <DIO_SET_PORT_VALUE+0x6>
     5ae:	00 d0       	rcall	.+0      	; 0x5b0 <DIO_SET_PORT_VALUE+0x8>
     5b0:	0f 92       	push	r0
     5b2:	cd b7       	in	r28, 0x3d	; 61
     5b4:	de b7       	in	r29, 0x3e	; 62
     5b6:	8a 83       	std	Y+2, r24	; 0x02
     5b8:	6b 83       	std	Y+3, r22	; 0x03
     5ba:	19 82       	std	Y+1, r1	; 0x01
	if (PORT_NB>=DIO_MAX_PORT_NB)
     5bc:	8a 81       	ldd	r24, Y+2	; 0x02
     5be:	84 30       	cpi	r24, 0x04	; 4
     5c0:	18 f0       	brcs	.+6      	; 0x5c8 <DIO_SET_PORT_VALUE+0x20>
	{
		ERROR_STATE=1;//PORT ERROR
     5c2:	81 e0       	ldi	r24, 0x01	; 1
     5c4:	89 83       	std	Y+1, r24	; 0x01
     5c6:	32 c0       	rjmp	.+100    	; 0x62c <DIO_SET_PORT_VALUE+0x84>

	}
	else
	{

		switch (PORT_NB)
     5c8:	8a 81       	ldd	r24, Y+2	; 0x02
     5ca:	28 2f       	mov	r18, r24
     5cc:	30 e0       	ldi	r19, 0x00	; 0
     5ce:	3d 83       	std	Y+5, r19	; 0x05
     5d0:	2c 83       	std	Y+4, r18	; 0x04
     5d2:	8c 81       	ldd	r24, Y+4	; 0x04
     5d4:	9d 81       	ldd	r25, Y+5	; 0x05
     5d6:	81 30       	cpi	r24, 0x01	; 1
     5d8:	91 05       	cpc	r25, r1
     5da:	d1 f0       	breq	.+52     	; 0x610 <DIO_SET_PORT_VALUE+0x68>
     5dc:	2c 81       	ldd	r18, Y+4	; 0x04
     5de:	3d 81       	ldd	r19, Y+5	; 0x05
     5e0:	22 30       	cpi	r18, 0x02	; 2
     5e2:	31 05       	cpc	r19, r1
     5e4:	2c f4       	brge	.+10     	; 0x5f0 <DIO_SET_PORT_VALUE+0x48>
     5e6:	8c 81       	ldd	r24, Y+4	; 0x04
     5e8:	9d 81       	ldd	r25, Y+5	; 0x05
     5ea:	00 97       	sbiw	r24, 0x00	; 0
     5ec:	61 f0       	breq	.+24     	; 0x606 <DIO_SET_PORT_VALUE+0x5e>
     5ee:	1e c0       	rjmp	.+60     	; 0x62c <DIO_SET_PORT_VALUE+0x84>
     5f0:	2c 81       	ldd	r18, Y+4	; 0x04
     5f2:	3d 81       	ldd	r19, Y+5	; 0x05
     5f4:	22 30       	cpi	r18, 0x02	; 2
     5f6:	31 05       	cpc	r19, r1
     5f8:	81 f0       	breq	.+32     	; 0x61a <DIO_SET_PORT_VALUE+0x72>
     5fa:	8c 81       	ldd	r24, Y+4	; 0x04
     5fc:	9d 81       	ldd	r25, Y+5	; 0x05
     5fe:	83 30       	cpi	r24, 0x03	; 3
     600:	91 05       	cpc	r25, r1
     602:	81 f0       	breq	.+32     	; 0x624 <DIO_SET_PORT_VALUE+0x7c>
     604:	13 c0       	rjmp	.+38     	; 0x62c <DIO_SET_PORT_VALUE+0x84>
		{
		case GROUP_A:
			DIO_U8_PORTA=PORT_VALUE;
     606:	eb e3       	ldi	r30, 0x3B	; 59
     608:	f0 e0       	ldi	r31, 0x00	; 0
     60a:	8b 81       	ldd	r24, Y+3	; 0x03
     60c:	80 83       	st	Z, r24
     60e:	0e c0       	rjmp	.+28     	; 0x62c <DIO_SET_PORT_VALUE+0x84>
			break;
		case GROUP_B:
			DIO_U8_PORTB=PORT_VALUE;
     610:	e8 e3       	ldi	r30, 0x38	; 56
     612:	f0 e0       	ldi	r31, 0x00	; 0
     614:	8b 81       	ldd	r24, Y+3	; 0x03
     616:	80 83       	st	Z, r24
     618:	09 c0       	rjmp	.+18     	; 0x62c <DIO_SET_PORT_VALUE+0x84>
			break;
		case GROUP_C:
			DIO_U8_PORTC=PORT_VALUE;
     61a:	e5 e3       	ldi	r30, 0x35	; 53
     61c:	f0 e0       	ldi	r31, 0x00	; 0
     61e:	8b 81       	ldd	r24, Y+3	; 0x03
     620:	80 83       	st	Z, r24
     622:	04 c0       	rjmp	.+8      	; 0x62c <DIO_SET_PORT_VALUE+0x84>
			break;
		case GROUP_D:
			DIO_U8_PORTD=PORT_VALUE;
     624:	e2 e3       	ldi	r30, 0x32	; 50
     626:	f0 e0       	ldi	r31, 0x00	; 0
     628:	8b 81       	ldd	r24, Y+3	; 0x03
     62a:	80 83       	st	Z, r24

	}



return ERROR_STATE;
     62c:	89 81       	ldd	r24, Y+1	; 0x01
}
     62e:	0f 90       	pop	r0
     630:	0f 90       	pop	r0
     632:	0f 90       	pop	r0
     634:	0f 90       	pop	r0
     636:	0f 90       	pop	r0
     638:	cf 91       	pop	r28
     63a:	df 91       	pop	r29
     63c:	08 95       	ret

0000063e <DIO_SET_PORT_DIRECTION>:

//FUNCTION FOR DIRECTION (REG DDR) FOR 8 PIN **************


u8 DIO_SET_PORT_DIRECTION(u8 PORT_NB,u8 PORT_DIRECTION)//RIGESTER PORT (PORT PORT....
{u8 ERROR_STATE=0;
     63e:	df 93       	push	r29
     640:	cf 93       	push	r28
     642:	00 d0       	rcall	.+0      	; 0x644 <DIO_SET_PORT_DIRECTION+0x6>
     644:	00 d0       	rcall	.+0      	; 0x646 <DIO_SET_PORT_DIRECTION+0x8>
     646:	0f 92       	push	r0
     648:	cd b7       	in	r28, 0x3d	; 61
     64a:	de b7       	in	r29, 0x3e	; 62
     64c:	8a 83       	std	Y+2, r24	; 0x02
     64e:	6b 83       	std	Y+3, r22	; 0x03
     650:	19 82       	std	Y+1, r1	; 0x01
	if (PORT_NB>=DIO_MAX_PORT_NB)
     652:	8a 81       	ldd	r24, Y+2	; 0x02
     654:	84 30       	cpi	r24, 0x04	; 4
     656:	18 f0       	brcs	.+6      	; 0x65e <DIO_SET_PORT_DIRECTION+0x20>
	{
		ERROR_STATE=1;//PORT ERROR
     658:	81 e0       	ldi	r24, 0x01	; 1
     65a:	89 83       	std	Y+1, r24	; 0x01
     65c:	32 c0       	rjmp	.+100    	; 0x6c2 <DIO_SET_PORT_DIRECTION+0x84>

	}
	else
	{

		switch (PORT_NB)
     65e:	8a 81       	ldd	r24, Y+2	; 0x02
     660:	28 2f       	mov	r18, r24
     662:	30 e0       	ldi	r19, 0x00	; 0
     664:	3d 83       	std	Y+5, r19	; 0x05
     666:	2c 83       	std	Y+4, r18	; 0x04
     668:	8c 81       	ldd	r24, Y+4	; 0x04
     66a:	9d 81       	ldd	r25, Y+5	; 0x05
     66c:	81 30       	cpi	r24, 0x01	; 1
     66e:	91 05       	cpc	r25, r1
     670:	d1 f0       	breq	.+52     	; 0x6a6 <DIO_SET_PORT_DIRECTION+0x68>
     672:	2c 81       	ldd	r18, Y+4	; 0x04
     674:	3d 81       	ldd	r19, Y+5	; 0x05
     676:	22 30       	cpi	r18, 0x02	; 2
     678:	31 05       	cpc	r19, r1
     67a:	2c f4       	brge	.+10     	; 0x686 <DIO_SET_PORT_DIRECTION+0x48>
     67c:	8c 81       	ldd	r24, Y+4	; 0x04
     67e:	9d 81       	ldd	r25, Y+5	; 0x05
     680:	00 97       	sbiw	r24, 0x00	; 0
     682:	61 f0       	breq	.+24     	; 0x69c <DIO_SET_PORT_DIRECTION+0x5e>
     684:	1e c0       	rjmp	.+60     	; 0x6c2 <DIO_SET_PORT_DIRECTION+0x84>
     686:	2c 81       	ldd	r18, Y+4	; 0x04
     688:	3d 81       	ldd	r19, Y+5	; 0x05
     68a:	22 30       	cpi	r18, 0x02	; 2
     68c:	31 05       	cpc	r19, r1
     68e:	81 f0       	breq	.+32     	; 0x6b0 <DIO_SET_PORT_DIRECTION+0x72>
     690:	8c 81       	ldd	r24, Y+4	; 0x04
     692:	9d 81       	ldd	r25, Y+5	; 0x05
     694:	83 30       	cpi	r24, 0x03	; 3
     696:	91 05       	cpc	r25, r1
     698:	81 f0       	breq	.+32     	; 0x6ba <DIO_SET_PORT_DIRECTION+0x7c>
     69a:	13 c0       	rjmp	.+38     	; 0x6c2 <DIO_SET_PORT_DIRECTION+0x84>
		{
		case GROUP_A:
			DIO_U8_DDRA=PORT_DIRECTION;
     69c:	ea e3       	ldi	r30, 0x3A	; 58
     69e:	f0 e0       	ldi	r31, 0x00	; 0
     6a0:	8b 81       	ldd	r24, Y+3	; 0x03
     6a2:	80 83       	st	Z, r24
     6a4:	0e c0       	rjmp	.+28     	; 0x6c2 <DIO_SET_PORT_DIRECTION+0x84>
			break;
		case GROUP_B:
			DIO_U8_DDRB=PORT_DIRECTION;
     6a6:	e7 e3       	ldi	r30, 0x37	; 55
     6a8:	f0 e0       	ldi	r31, 0x00	; 0
     6aa:	8b 81       	ldd	r24, Y+3	; 0x03
     6ac:	80 83       	st	Z, r24
     6ae:	09 c0       	rjmp	.+18     	; 0x6c2 <DIO_SET_PORT_DIRECTION+0x84>
			break;
		case GROUP_C:
			DIO_U8_DDRC=PORT_DIRECTION;
     6b0:	e4 e3       	ldi	r30, 0x34	; 52
     6b2:	f0 e0       	ldi	r31, 0x00	; 0
     6b4:	8b 81       	ldd	r24, Y+3	; 0x03
     6b6:	80 83       	st	Z, r24
     6b8:	04 c0       	rjmp	.+8      	; 0x6c2 <DIO_SET_PORT_DIRECTION+0x84>
			break;
		case GROUP_D:
			DIO_U8_DDRD=PORT_DIRECTION;
     6ba:	e1 e3       	ldi	r30, 0x31	; 49
     6bc:	f0 e0       	ldi	r31, 0x00	; 0
     6be:	8b 81       	ldd	r24, Y+3	; 0x03
     6c0:	80 83       	st	Z, r24

	}



return ERROR_STATE;
     6c2:	89 81       	ldd	r24, Y+1	; 0x01
}
     6c4:	0f 90       	pop	r0
     6c6:	0f 90       	pop	r0
     6c8:	0f 90       	pop	r0
     6ca:	0f 90       	pop	r0
     6cc:	0f 90       	pop	r0
     6ce:	cf 91       	pop	r28
     6d0:	df 91       	pop	r29
     6d2:	08 95       	ret

000006d4 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
     6d4:	df 93       	push	r29
     6d6:	cf 93       	push	r28
     6d8:	00 d0       	rcall	.+0      	; 0x6da <xEventGroupCreate+0x6>
     6da:	cd b7       	in	r28, 0x3d	; 61
     6dc:	de b7       	in	r29, 0x3e	; 62
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
     6de:	8b e0       	ldi	r24, 0x0B	; 11
     6e0:	90 e0       	ldi	r25, 0x00	; 0
     6e2:	0e 94 af 06 	call	0xd5e	; 0xd5e <pvPortMalloc>
     6e6:	9a 83       	std	Y+2, r25	; 0x02
     6e8:	89 83       	std	Y+1, r24	; 0x01

		if( pxEventBits != NULL )
     6ea:	89 81       	ldd	r24, Y+1	; 0x01
     6ec:	9a 81       	ldd	r25, Y+2	; 0x02
     6ee:	00 97       	sbiw	r24, 0x00	; 0
     6f0:	49 f0       	breq	.+18     	; 0x704 <xEventGroupCreate+0x30>
		{
			pxEventBits->uxEventBits = 0;
     6f2:	e9 81       	ldd	r30, Y+1	; 0x01
     6f4:	fa 81       	ldd	r31, Y+2	; 0x02
     6f6:	11 82       	std	Z+1, r1	; 0x01
     6f8:	10 82       	st	Z, r1
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     6fa:	89 81       	ldd	r24, Y+1	; 0x01
     6fc:	9a 81       	ldd	r25, Y+2	; 0x02
     6fe:	02 96       	adiw	r24, 0x02	; 2
     700:	0e 94 2b 07 	call	0xe56	; 0xe56 <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
     704:	89 81       	ldd	r24, Y+1	; 0x01
     706:	9a 81       	ldd	r25, Y+2	; 0x02
	}
     708:	0f 90       	pop	r0
     70a:	0f 90       	pop	r0
     70c:	cf 91       	pop	r28
     70e:	df 91       	pop	r29
     710:	08 95       	ret

00000712 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
     712:	df 93       	push	r29
     714:	cf 93       	push	r28
     716:	cd b7       	in	r28, 0x3d	; 61
     718:	de b7       	in	r29, 0x3e	; 62
     71a:	60 97       	sbiw	r28, 0x10	; 16
     71c:	0f b6       	in	r0, 0x3f	; 63
     71e:	f8 94       	cli
     720:	de bf       	out	0x3e, r29	; 62
     722:	0f be       	out	0x3f, r0	; 63
     724:	cd bf       	out	0x3d, r28	; 61
     726:	9a 87       	std	Y+10, r25	; 0x0a
     728:	89 87       	std	Y+9, r24	; 0x09
     72a:	7c 87       	std	Y+12, r23	; 0x0c
     72c:	6b 87       	std	Y+11, r22	; 0x0b
     72e:	5e 87       	std	Y+14, r21	; 0x0e
     730:	4d 87       	std	Y+13, r20	; 0x0d
     732:	38 8b       	std	Y+16, r19	; 0x10
     734:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
     736:	89 85       	ldd	r24, Y+9	; 0x09
     738:	9a 85       	ldd	r25, Y+10	; 0x0a
     73a:	9c 83       	std	Y+4, r25	; 0x04
     73c:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     73e:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     740:	0e 94 da 15 	call	0x2bb4	; 0x2bb4 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     744:	eb 81       	ldd	r30, Y+3	; 0x03
     746:	fc 81       	ldd	r31, Y+4	; 0x04
     748:	80 81       	ld	r24, Z
     74a:	91 81       	ldd	r25, Z+1	; 0x01
     74c:	98 87       	std	Y+8, r25	; 0x08
     74e:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     750:	89 85       	ldd	r24, Y+9	; 0x09
     752:	9a 85       	ldd	r25, Y+10	; 0x0a
     754:	2b 85       	ldd	r18, Y+11	; 0x0b
     756:	3c 85       	ldd	r19, Y+12	; 0x0c
     758:	b9 01       	movw	r22, r18
     75a:	0e 94 60 05 	call	0xac0	; 0xac0 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     75e:	2f 81       	ldd	r18, Y+7	; 0x07
     760:	38 85       	ldd	r19, Y+8	; 0x08
     762:	8b 85       	ldd	r24, Y+11	; 0x0b
     764:	9c 85       	ldd	r25, Y+12	; 0x0c
     766:	28 2b       	or	r18, r24
     768:	39 2b       	or	r19, r25
     76a:	8d 85       	ldd	r24, Y+13	; 0x0d
     76c:	9e 85       	ldd	r25, Y+14	; 0x0e
     76e:	28 23       	and	r18, r24
     770:	39 23       	and	r19, r25
     772:	8d 85       	ldd	r24, Y+13	; 0x0d
     774:	9e 85       	ldd	r25, Y+14	; 0x0e
     776:	28 17       	cp	r18, r24
     778:	39 07       	cpc	r19, r25
     77a:	c9 f4       	brne	.+50     	; 0x7ae <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
     77c:	2f 81       	ldd	r18, Y+7	; 0x07
     77e:	38 85       	ldd	r19, Y+8	; 0x08
     780:	8b 85       	ldd	r24, Y+11	; 0x0b
     782:	9c 85       	ldd	r25, Y+12	; 0x0c
     784:	82 2b       	or	r24, r18
     786:	93 2b       	or	r25, r19
     788:	9e 83       	std	Y+6, r25	; 0x06
     78a:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     78c:	eb 81       	ldd	r30, Y+3	; 0x03
     78e:	fc 81       	ldd	r31, Y+4	; 0x04
     790:	20 81       	ld	r18, Z
     792:	31 81       	ldd	r19, Z+1	; 0x01
     794:	8d 85       	ldd	r24, Y+13	; 0x0d
     796:	9e 85       	ldd	r25, Y+14	; 0x0e
     798:	80 95       	com	r24
     79a:	90 95       	com	r25
     79c:	82 23       	and	r24, r18
     79e:	93 23       	and	r25, r19
     7a0:	eb 81       	ldd	r30, Y+3	; 0x03
     7a2:	fc 81       	ldd	r31, Y+4	; 0x04
     7a4:	91 83       	std	Z+1, r25	; 0x01
     7a6:	80 83       	st	Z, r24

			xTicksToWait = 0;
     7a8:	18 8a       	std	Y+16, r1	; 0x10
     7aa:	1f 86       	std	Y+15, r1	; 0x0f
     7ac:	1e c0       	rjmp	.+60     	; 0x7ea <xEventGroupSync+0xd8>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     7ae:	8f 85       	ldd	r24, Y+15	; 0x0f
     7b0:	98 89       	ldd	r25, Y+16	; 0x10
     7b2:	00 97       	sbiw	r24, 0x00	; 0
     7b4:	91 f0       	breq	.+36     	; 0x7da <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     7b6:	8b 81       	ldd	r24, Y+3	; 0x03
     7b8:	9c 81       	ldd	r25, Y+4	; 0x04
     7ba:	bc 01       	movw	r22, r24
     7bc:	6e 5f       	subi	r22, 0xFE	; 254
     7be:	7f 4f       	sbci	r23, 0xFF	; 255
     7c0:	8d 85       	ldd	r24, Y+13	; 0x0d
     7c2:	9e 85       	ldd	r25, Y+14	; 0x0e
     7c4:	9c 01       	movw	r18, r24
     7c6:	35 60       	ori	r19, 0x05	; 5
     7c8:	4f 85       	ldd	r20, Y+15	; 0x0f
     7ca:	58 89       	ldd	r21, Y+16	; 0x10
     7cc:	cb 01       	movw	r24, r22
     7ce:	b9 01       	movw	r22, r18
     7d0:	0e 94 4a 18 	call	0x3094	; 0x3094 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
     7d4:	1e 82       	std	Y+6, r1	; 0x06
     7d6:	1d 82       	std	Y+5, r1	; 0x05
     7d8:	08 c0       	rjmp	.+16     	; 0x7ea <xEventGroupSync+0xd8>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     7da:	eb 81       	ldd	r30, Y+3	; 0x03
     7dc:	fc 81       	ldd	r31, Y+4	; 0x04
     7de:	80 81       	ld	r24, Z
     7e0:	91 81       	ldd	r25, Z+1	; 0x01
     7e2:	9e 83       	std	Y+6, r25	; 0x06
     7e4:	8d 83       	std	Y+5, r24	; 0x05
				xTimeoutOccurred = pdTRUE;
     7e6:	81 e0       	ldi	r24, 0x01	; 1
     7e8:	89 83       	std	Y+1, r24	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     7ea:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <xTaskResumeAll>
     7ee:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
     7f0:	8f 85       	ldd	r24, Y+15	; 0x0f
     7f2:	98 89       	ldd	r25, Y+16	; 0x10
     7f4:	00 97       	sbiw	r24, 0x00	; 0
     7f6:	09 f4       	brne	.+2      	; 0x7fa <xEventGroupSync+0xe8>
     7f8:	3a c0       	rjmp	.+116    	; 0x86e <__stack+0xf>
	{
		if( xAlreadyYielded == pdFALSE )
     7fa:	8a 81       	ldd	r24, Y+2	; 0x02
     7fc:	88 23       	and	r24, r24
     7fe:	11 f4       	brne	.+4      	; 0x804 <xEventGroupSync+0xf2>
		{
			portYIELD_WITHIN_API();
     800:	0e 94 b3 0a 	call	0x1566	; 0x1566 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     804:	0e 94 9d 1a 	call	0x353a	; 0x353a <uxTaskResetEventItemValue>
     808:	9e 83       	std	Y+6, r25	; 0x06
     80a:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     80c:	8d 81       	ldd	r24, Y+5	; 0x05
     80e:	9e 81       	ldd	r25, Y+6	; 0x06
     810:	80 70       	andi	r24, 0x00	; 0
     812:	92 70       	andi	r25, 0x02	; 2
     814:	00 97       	sbiw	r24, 0x00	; 0
     816:	31 f5       	brne	.+76     	; 0x864 <__stack+0x5>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     818:	0f b6       	in	r0, 0x3f	; 63
     81a:	f8 94       	cli
     81c:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     81e:	eb 81       	ldd	r30, Y+3	; 0x03
     820:	fc 81       	ldd	r31, Y+4	; 0x04
     822:	80 81       	ld	r24, Z
     824:	91 81       	ldd	r25, Z+1	; 0x01
     826:	9e 83       	std	Y+6, r25	; 0x06
     828:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     82a:	2d 81       	ldd	r18, Y+5	; 0x05
     82c:	3e 81       	ldd	r19, Y+6	; 0x06
     82e:	8d 85       	ldd	r24, Y+13	; 0x0d
     830:	9e 85       	ldd	r25, Y+14	; 0x0e
     832:	28 23       	and	r18, r24
     834:	39 23       	and	r19, r25
     836:	8d 85       	ldd	r24, Y+13	; 0x0d
     838:	9e 85       	ldd	r25, Y+14	; 0x0e
     83a:	28 17       	cp	r18, r24
     83c:	39 07       	cpc	r19, r25
     83e:	71 f4       	brne	.+28     	; 0x85c <xEventGroupSync+0x14a>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     840:	eb 81       	ldd	r30, Y+3	; 0x03
     842:	fc 81       	ldd	r31, Y+4	; 0x04
     844:	20 81       	ld	r18, Z
     846:	31 81       	ldd	r19, Z+1	; 0x01
     848:	8d 85       	ldd	r24, Y+13	; 0x0d
     84a:	9e 85       	ldd	r25, Y+14	; 0x0e
     84c:	80 95       	com	r24
     84e:	90 95       	com	r25
     850:	82 23       	and	r24, r18
     852:	93 23       	and	r25, r19
     854:	eb 81       	ldd	r30, Y+3	; 0x03
     856:	fc 81       	ldd	r31, Y+4	; 0x04
     858:	91 83       	std	Z+1, r25	; 0x01
     85a:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     85c:	0f 90       	pop	r0
     85e:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
     860:	81 e0       	ldi	r24, 0x01	; 1
     862:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     864:	8d 81       	ldd	r24, Y+5	; 0x05
     866:	9e 81       	ldd	r25, Y+6	; 0x06
     868:	90 70       	andi	r25, 0x00	; 0
     86a:	9e 83       	std	Y+6, r25	; 0x06
     86c:	8d 83       	std	Y+5, r24	; 0x05
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     86e:	8d 81       	ldd	r24, Y+5	; 0x05
     870:	9e 81       	ldd	r25, Y+6	; 0x06
}
     872:	60 96       	adiw	r28, 0x10	; 16
     874:	0f b6       	in	r0, 0x3f	; 63
     876:	f8 94       	cli
     878:	de bf       	out	0x3e, r29	; 62
     87a:	0f be       	out	0x3f, r0	; 63
     87c:	cd bf       	out	0x3d, r28	; 61
     87e:	cf 91       	pop	r28
     880:	df 91       	pop	r29
     882:	08 95       	ret

00000884 <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
     884:	0f 93       	push	r16
     886:	1f 93       	push	r17
     888:	df 93       	push	r29
     88a:	cf 93       	push	r28
     88c:	cd b7       	in	r28, 0x3d	; 61
     88e:	de b7       	in	r29, 0x3e	; 62
     890:	63 97       	sbiw	r28, 0x13	; 19
     892:	0f b6       	in	r0, 0x3f	; 63
     894:	f8 94       	cli
     896:	de bf       	out	0x3e, r29	; 62
     898:	0f be       	out	0x3f, r0	; 63
     89a:	cd bf       	out	0x3d, r28	; 61
     89c:	9d 87       	std	Y+13, r25	; 0x0d
     89e:	8c 87       	std	Y+12, r24	; 0x0c
     8a0:	7f 87       	std	Y+15, r23	; 0x0f
     8a2:	6e 87       	std	Y+14, r22	; 0x0e
     8a4:	48 8b       	std	Y+16, r20	; 0x10
     8a6:	29 8b       	std	Y+17, r18	; 0x11
     8a8:	1b 8b       	std	Y+19, r17	; 0x13
     8aa:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
     8ac:	8c 85       	ldd	r24, Y+12	; 0x0c
     8ae:	9d 85       	ldd	r25, Y+13	; 0x0d
     8b0:	9b 87       	std	Y+11, r25	; 0x0b
     8b2:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
     8b4:	1f 82       	std	Y+7, r1	; 0x07
     8b6:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     8b8:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     8ba:	0e 94 da 15 	call	0x2bb4	; 0x2bb4 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     8be:	ea 85       	ldd	r30, Y+10	; 0x0a
     8c0:	fb 85       	ldd	r31, Y+11	; 0x0b
     8c2:	80 81       	ld	r24, Z
     8c4:	91 81       	ldd	r25, Z+1	; 0x01
     8c6:	9a 83       	std	Y+2, r25	; 0x02
     8c8:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     8ca:	89 81       	ldd	r24, Y+1	; 0x01
     8cc:	9a 81       	ldd	r25, Y+2	; 0x02
     8ce:	2e 85       	ldd	r18, Y+14	; 0x0e
     8d0:	3f 85       	ldd	r19, Y+15	; 0x0f
     8d2:	b9 01       	movw	r22, r18
     8d4:	49 89       	ldd	r20, Y+17	; 0x11
     8d6:	0e 94 7d 06 	call	0xcfa	; 0xcfa <prvTestWaitCondition>
     8da:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
     8dc:	8d 81       	ldd	r24, Y+5	; 0x05
     8de:	88 23       	and	r24, r24
     8e0:	c1 f0       	breq	.+48     	; 0x912 <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
     8e2:	89 81       	ldd	r24, Y+1	; 0x01
     8e4:	9a 81       	ldd	r25, Y+2	; 0x02
     8e6:	99 87       	std	Y+9, r25	; 0x09
     8e8:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
     8ea:	1b 8a       	std	Y+19, r1	; 0x13
     8ec:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     8ee:	88 89       	ldd	r24, Y+16	; 0x10
     8f0:	88 23       	and	r24, r24
     8f2:	e9 f1       	breq	.+122    	; 0x96e <xEventGroupWaitBits+0xea>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     8f4:	ea 85       	ldd	r30, Y+10	; 0x0a
     8f6:	fb 85       	ldd	r31, Y+11	; 0x0b
     8f8:	20 81       	ld	r18, Z
     8fa:	31 81       	ldd	r19, Z+1	; 0x01
     8fc:	8e 85       	ldd	r24, Y+14	; 0x0e
     8fe:	9f 85       	ldd	r25, Y+15	; 0x0f
     900:	80 95       	com	r24
     902:	90 95       	com	r25
     904:	82 23       	and	r24, r18
     906:	93 23       	and	r25, r19
     908:	ea 85       	ldd	r30, Y+10	; 0x0a
     90a:	fb 85       	ldd	r31, Y+11	; 0x0b
     90c:	91 83       	std	Z+1, r25	; 0x01
     90e:	80 83       	st	Z, r24
     910:	2e c0       	rjmp	.+92     	; 0x96e <xEventGroupWaitBits+0xea>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     912:	8a 89       	ldd	r24, Y+18	; 0x12
     914:	9b 89       	ldd	r25, Y+19	; 0x13
     916:	00 97       	sbiw	r24, 0x00	; 0
     918:	39 f4       	brne	.+14     	; 0x928 <xEventGroupWaitBits+0xa4>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
     91a:	89 81       	ldd	r24, Y+1	; 0x01
     91c:	9a 81       	ldd	r25, Y+2	; 0x02
     91e:	99 87       	std	Y+9, r25	; 0x09
     920:	88 87       	std	Y+8, r24	; 0x08
			xTimeoutOccurred = pdTRUE;
     922:	81 e0       	ldi	r24, 0x01	; 1
     924:	8b 83       	std	Y+3, r24	; 0x03
     926:	23 c0       	rjmp	.+70     	; 0x96e <xEventGroupWaitBits+0xea>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     928:	88 89       	ldd	r24, Y+16	; 0x10
     92a:	88 23       	and	r24, r24
     92c:	29 f0       	breq	.+10     	; 0x938 <xEventGroupWaitBits+0xb4>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     92e:	8e 81       	ldd	r24, Y+6	; 0x06
     930:	9f 81       	ldd	r25, Y+7	; 0x07
     932:	91 60       	ori	r25, 0x01	; 1
     934:	9f 83       	std	Y+7, r25	; 0x07
     936:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     938:	89 89       	ldd	r24, Y+17	; 0x11
     93a:	88 23       	and	r24, r24
     93c:	29 f0       	breq	.+10     	; 0x948 <xEventGroupWaitBits+0xc4>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     93e:	8e 81       	ldd	r24, Y+6	; 0x06
     940:	9f 81       	ldd	r25, Y+7	; 0x07
     942:	94 60       	ori	r25, 0x04	; 4
     944:	9f 83       	std	Y+7, r25	; 0x07
     946:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     948:	8a 85       	ldd	r24, Y+10	; 0x0a
     94a:	9b 85       	ldd	r25, Y+11	; 0x0b
     94c:	bc 01       	movw	r22, r24
     94e:	6e 5f       	subi	r22, 0xFE	; 254
     950:	7f 4f       	sbci	r23, 0xFF	; 255
     952:	2e 85       	ldd	r18, Y+14	; 0x0e
     954:	3f 85       	ldd	r19, Y+15	; 0x0f
     956:	8e 81       	ldd	r24, Y+6	; 0x06
     958:	9f 81       	ldd	r25, Y+7	; 0x07
     95a:	28 2b       	or	r18, r24
     95c:	39 2b       	or	r19, r25
     95e:	4a 89       	ldd	r20, Y+18	; 0x12
     960:	5b 89       	ldd	r21, Y+19	; 0x13
     962:	cb 01       	movw	r24, r22
     964:	b9 01       	movw	r22, r18
     966:	0e 94 4a 18 	call	0x3094	; 0x3094 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
     96a:	19 86       	std	Y+9, r1	; 0x09
     96c:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     96e:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <xTaskResumeAll>
     972:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
     974:	8a 89       	ldd	r24, Y+18	; 0x12
     976:	9b 89       	ldd	r25, Y+19	; 0x13
     978:	00 97       	sbiw	r24, 0x00	; 0
     97a:	09 f4       	brne	.+2      	; 0x97e <xEventGroupWaitBits+0xfa>
     97c:	3c c0       	rjmp	.+120    	; 0x9f6 <xEventGroupWaitBits+0x172>
	{
		if( xAlreadyYielded == pdFALSE )
     97e:	8c 81       	ldd	r24, Y+4	; 0x04
     980:	88 23       	and	r24, r24
     982:	11 f4       	brne	.+4      	; 0x988 <xEventGroupWaitBits+0x104>
		{
			portYIELD_WITHIN_API();
     984:	0e 94 b3 0a 	call	0x1566	; 0x1566 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     988:	0e 94 9d 1a 	call	0x353a	; 0x353a <uxTaskResetEventItemValue>
     98c:	99 87       	std	Y+9, r25	; 0x09
     98e:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     990:	88 85       	ldd	r24, Y+8	; 0x08
     992:	99 85       	ldd	r25, Y+9	; 0x09
     994:	80 70       	andi	r24, 0x00	; 0
     996:	92 70       	andi	r25, 0x02	; 2
     998:	00 97       	sbiw	r24, 0x00	; 0
     99a:	41 f5       	brne	.+80     	; 0x9ec <xEventGroupWaitBits+0x168>
		{
			taskENTER_CRITICAL();
     99c:	0f b6       	in	r0, 0x3f	; 63
     99e:	f8 94       	cli
     9a0:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     9a2:	ea 85       	ldd	r30, Y+10	; 0x0a
     9a4:	fb 85       	ldd	r31, Y+11	; 0x0b
     9a6:	80 81       	ld	r24, Z
     9a8:	91 81       	ldd	r25, Z+1	; 0x01
     9aa:	99 87       	std	Y+9, r25	; 0x09
     9ac:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     9ae:	88 85       	ldd	r24, Y+8	; 0x08
     9b0:	99 85       	ldd	r25, Y+9	; 0x09
     9b2:	2e 85       	ldd	r18, Y+14	; 0x0e
     9b4:	3f 85       	ldd	r19, Y+15	; 0x0f
     9b6:	b9 01       	movw	r22, r18
     9b8:	49 89       	ldd	r20, Y+17	; 0x11
     9ba:	0e 94 7d 06 	call	0xcfa	; 0xcfa <prvTestWaitCondition>
     9be:	88 23       	and	r24, r24
     9c0:	89 f0       	breq	.+34     	; 0x9e4 <xEventGroupWaitBits+0x160>
				{
					if( xClearOnExit != pdFALSE )
     9c2:	88 89       	ldd	r24, Y+16	; 0x10
     9c4:	88 23       	and	r24, r24
     9c6:	71 f0       	breq	.+28     	; 0x9e4 <xEventGroupWaitBits+0x160>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     9c8:	ea 85       	ldd	r30, Y+10	; 0x0a
     9ca:	fb 85       	ldd	r31, Y+11	; 0x0b
     9cc:	20 81       	ld	r18, Z
     9ce:	31 81       	ldd	r19, Z+1	; 0x01
     9d0:	8e 85       	ldd	r24, Y+14	; 0x0e
     9d2:	9f 85       	ldd	r25, Y+15	; 0x0f
     9d4:	80 95       	com	r24
     9d6:	90 95       	com	r25
     9d8:	82 23       	and	r24, r18
     9da:	93 23       	and	r25, r19
     9dc:	ea 85       	ldd	r30, Y+10	; 0x0a
     9de:	fb 85       	ldd	r31, Y+11	; 0x0b
     9e0:	91 83       	std	Z+1, r25	; 0x01
     9e2:	80 83       	st	Z, r24
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
     9e4:	81 e0       	ldi	r24, 0x01	; 1
     9e6:	8b 83       	std	Y+3, r24	; 0x03
			}
			taskEXIT_CRITICAL();
     9e8:	0f 90       	pop	r0
     9ea:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     9ec:	88 85       	ldd	r24, Y+8	; 0x08
     9ee:	99 85       	ldd	r25, Y+9	; 0x09
     9f0:	90 70       	andi	r25, 0x00	; 0
     9f2:	99 87       	std	Y+9, r25	; 0x09
     9f4:	88 87       	std	Y+8, r24	; 0x08
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     9f6:	88 85       	ldd	r24, Y+8	; 0x08
     9f8:	99 85       	ldd	r25, Y+9	; 0x09
}
     9fa:	63 96       	adiw	r28, 0x13	; 19
     9fc:	0f b6       	in	r0, 0x3f	; 63
     9fe:	f8 94       	cli
     a00:	de bf       	out	0x3e, r29	; 62
     a02:	0f be       	out	0x3f, r0	; 63
     a04:	cd bf       	out	0x3d, r28	; 61
     a06:	cf 91       	pop	r28
     a08:	df 91       	pop	r29
     a0a:	1f 91       	pop	r17
     a0c:	0f 91       	pop	r16
     a0e:	08 95       	ret

00000a10 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
     a10:	df 93       	push	r29
     a12:	cf 93       	push	r28
     a14:	cd b7       	in	r28, 0x3d	; 61
     a16:	de b7       	in	r29, 0x3e	; 62
     a18:	28 97       	sbiw	r28, 0x08	; 8
     a1a:	0f b6       	in	r0, 0x3f	; 63
     a1c:	f8 94       	cli
     a1e:	de bf       	out	0x3e, r29	; 62
     a20:	0f be       	out	0x3f, r0	; 63
     a22:	cd bf       	out	0x3d, r28	; 61
     a24:	9e 83       	std	Y+6, r25	; 0x06
     a26:	8d 83       	std	Y+5, r24	; 0x05
     a28:	78 87       	std	Y+8, r23	; 0x08
     a2a:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
     a2c:	8d 81       	ldd	r24, Y+5	; 0x05
     a2e:	9e 81       	ldd	r25, Y+6	; 0x06
     a30:	9c 83       	std	Y+4, r25	; 0x04
     a32:	8b 83       	std	Y+3, r24	; 0x03
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
     a34:	0f b6       	in	r0, 0x3f	; 63
     a36:	f8 94       	cli
     a38:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
     a3a:	eb 81       	ldd	r30, Y+3	; 0x03
     a3c:	fc 81       	ldd	r31, Y+4	; 0x04
     a3e:	80 81       	ld	r24, Z
     a40:	91 81       	ldd	r25, Z+1	; 0x01
     a42:	9a 83       	std	Y+2, r25	; 0x02
     a44:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     a46:	eb 81       	ldd	r30, Y+3	; 0x03
     a48:	fc 81       	ldd	r31, Y+4	; 0x04
     a4a:	20 81       	ld	r18, Z
     a4c:	31 81       	ldd	r19, Z+1	; 0x01
     a4e:	8f 81       	ldd	r24, Y+7	; 0x07
     a50:	98 85       	ldd	r25, Y+8	; 0x08
     a52:	80 95       	com	r24
     a54:	90 95       	com	r25
     a56:	82 23       	and	r24, r18
     a58:	93 23       	and	r25, r19
     a5a:	eb 81       	ldd	r30, Y+3	; 0x03
     a5c:	fc 81       	ldd	r31, Y+4	; 0x04
     a5e:	91 83       	std	Z+1, r25	; 0x01
     a60:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
     a62:	0f 90       	pop	r0
     a64:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
     a66:	89 81       	ldd	r24, Y+1	; 0x01
     a68:	9a 81       	ldd	r25, Y+2	; 0x02
}
     a6a:	28 96       	adiw	r28, 0x08	; 8
     a6c:	0f b6       	in	r0, 0x3f	; 63
     a6e:	f8 94       	cli
     a70:	de bf       	out	0x3e, r29	; 62
     a72:	0f be       	out	0x3f, r0	; 63
     a74:	cd bf       	out	0x3d, r28	; 61
     a76:	cf 91       	pop	r28
     a78:	df 91       	pop	r29
     a7a:	08 95       	ret

00000a7c <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
     a7c:	df 93       	push	r29
     a7e:	cf 93       	push	r28
     a80:	cd b7       	in	r28, 0x3d	; 61
     a82:	de b7       	in	r29, 0x3e	; 62
     a84:	27 97       	sbiw	r28, 0x07	; 7
     a86:	0f b6       	in	r0, 0x3f	; 63
     a88:	f8 94       	cli
     a8a:	de bf       	out	0x3e, r29	; 62
     a8c:	0f be       	out	0x3f, r0	; 63
     a8e:	cd bf       	out	0x3d, r28	; 61
     a90:	9f 83       	std	Y+7, r25	; 0x07
     a92:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
     a94:	8e 81       	ldd	r24, Y+6	; 0x06
     a96:	9f 81       	ldd	r25, Y+7	; 0x07
     a98:	9c 83       	std	Y+4, r25	; 0x04
     a9a:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     a9c:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
     a9e:	eb 81       	ldd	r30, Y+3	; 0x03
     aa0:	fc 81       	ldd	r31, Y+4	; 0x04
     aa2:	80 81       	ld	r24, Z
     aa4:	91 81       	ldd	r25, Z+1	; 0x01
     aa6:	9a 83       	std	Y+2, r25	; 0x02
     aa8:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
     aaa:	89 81       	ldd	r24, Y+1	; 0x01
     aac:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
     aae:	27 96       	adiw	r28, 0x07	; 7
     ab0:	0f b6       	in	r0, 0x3f	; 63
     ab2:	f8 94       	cli
     ab4:	de bf       	out	0x3e, r29	; 62
     ab6:	0f be       	out	0x3f, r0	; 63
     ab8:	cd bf       	out	0x3d, r28	; 61
     aba:	cf 91       	pop	r28
     abc:	df 91       	pop	r29
     abe:	08 95       	ret

00000ac0 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     ac0:	df 93       	push	r29
     ac2:	cf 93       	push	r28
     ac4:	cd b7       	in	r28, 0x3d	; 61
     ac6:	de b7       	in	r29, 0x3e	; 62
     ac8:	65 97       	sbiw	r28, 0x15	; 21
     aca:	0f b6       	in	r0, 0x3f	; 63
     acc:	f8 94       	cli
     ace:	de bf       	out	0x3e, r29	; 62
     ad0:	0f be       	out	0x3f, r0	; 63
     ad2:	cd bf       	out	0x3d, r28	; 61
     ad4:	9b 8b       	std	Y+19, r25	; 0x13
     ad6:	8a 8b       	std	Y+18, r24	; 0x12
     ad8:	7d 8b       	std	Y+21, r23	; 0x15
     ada:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     adc:	19 86       	std	Y+9, r1	; 0x09
     ade:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = xEventGroup;
     ae0:	8a 89       	ldd	r24, Y+18	; 0x12
     ae2:	9b 89       	ldd	r25, Y+19	; 0x13
     ae4:	9b 83       	std	Y+3, r25	; 0x03
     ae6:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
     ae8:	19 82       	std	Y+1, r1	; 0x01
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
     aea:	8a 81       	ldd	r24, Y+2	; 0x02
     aec:	9b 81       	ldd	r25, Y+3	; 0x03
     aee:	02 96       	adiw	r24, 0x02	; 2
     af0:	9b 87       	std	Y+11, r25	; 0x0b
     af2:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     af4:	8a 85       	ldd	r24, Y+10	; 0x0a
     af6:	9b 85       	ldd	r25, Y+11	; 0x0b
     af8:	03 96       	adiw	r24, 0x03	; 3
     afa:	9d 87       	std	Y+13, r25	; 0x0d
     afc:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
     afe:	0e 94 da 15 	call	0x2bb4	; 0x2bb4 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     b02:	ea 85       	ldd	r30, Y+10	; 0x0a
     b04:	fb 85       	ldd	r31, Y+11	; 0x0b
     b06:	85 81       	ldd	r24, Z+5	; 0x05
     b08:	96 81       	ldd	r25, Z+6	; 0x06
     b0a:	99 8b       	std	Y+17, r25	; 0x11
     b0c:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     b0e:	ea 81       	ldd	r30, Y+2	; 0x02
     b10:	fb 81       	ldd	r31, Y+3	; 0x03
     b12:	20 81       	ld	r18, Z
     b14:	31 81       	ldd	r19, Z+1	; 0x01
     b16:	8c 89       	ldd	r24, Y+20	; 0x14
     b18:	9d 89       	ldd	r25, Y+21	; 0x15
     b1a:	82 2b       	or	r24, r18
     b1c:	93 2b       	or	r25, r19
     b1e:	ea 81       	ldd	r30, Y+2	; 0x02
     b20:	fb 81       	ldd	r31, Y+3	; 0x03
     b22:	91 83       	std	Z+1, r25	; 0x01
     b24:	80 83       	st	Z, r24
     b26:	59 c0       	rjmp	.+178    	; 0xbda <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
     b28:	e8 89       	ldd	r30, Y+16	; 0x10
     b2a:	f9 89       	ldd	r31, Y+17	; 0x11
     b2c:	82 81       	ldd	r24, Z+2	; 0x02
     b2e:	93 81       	ldd	r25, Z+3	; 0x03
     b30:	9f 87       	std	Y+15, r25	; 0x0f
     b32:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     b34:	e8 89       	ldd	r30, Y+16	; 0x10
     b36:	f9 89       	ldd	r31, Y+17	; 0x11
     b38:	80 81       	ld	r24, Z
     b3a:	91 81       	ldd	r25, Z+1	; 0x01
     b3c:	9f 83       	std	Y+7, r25	; 0x07
     b3e:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
     b40:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
     b42:	8e 81       	ldd	r24, Y+6	; 0x06
     b44:	9f 81       	ldd	r25, Y+7	; 0x07
     b46:	80 70       	andi	r24, 0x00	; 0
     b48:	9d 83       	std	Y+5, r25	; 0x05
     b4a:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     b4c:	8e 81       	ldd	r24, Y+6	; 0x06
     b4e:	9f 81       	ldd	r25, Y+7	; 0x07
     b50:	90 70       	andi	r25, 0x00	; 0
     b52:	9f 83       	std	Y+7, r25	; 0x07
     b54:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     b56:	8c 81       	ldd	r24, Y+4	; 0x04
     b58:	9d 81       	ldd	r25, Y+5	; 0x05
     b5a:	80 70       	andi	r24, 0x00	; 0
     b5c:	94 70       	andi	r25, 0x04	; 4
     b5e:	00 97       	sbiw	r24, 0x00	; 0
     b60:	69 f4       	brne	.+26     	; 0xb7c <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     b62:	ea 81       	ldd	r30, Y+2	; 0x02
     b64:	fb 81       	ldd	r31, Y+3	; 0x03
     b66:	20 81       	ld	r18, Z
     b68:	31 81       	ldd	r19, Z+1	; 0x01
     b6a:	8e 81       	ldd	r24, Y+6	; 0x06
     b6c:	9f 81       	ldd	r25, Y+7	; 0x07
     b6e:	82 23       	and	r24, r18
     b70:	93 23       	and	r25, r19
     b72:	00 97       	sbiw	r24, 0x00	; 0
     b74:	91 f0       	breq	.+36     	; 0xb9a <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
     b76:	81 e0       	ldi	r24, 0x01	; 1
     b78:	89 83       	std	Y+1, r24	; 0x01
     b7a:	0f c0       	rjmp	.+30     	; 0xb9a <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     b7c:	ea 81       	ldd	r30, Y+2	; 0x02
     b7e:	fb 81       	ldd	r31, Y+3	; 0x03
     b80:	20 81       	ld	r18, Z
     b82:	31 81       	ldd	r19, Z+1	; 0x01
     b84:	8e 81       	ldd	r24, Y+6	; 0x06
     b86:	9f 81       	ldd	r25, Y+7	; 0x07
     b88:	28 23       	and	r18, r24
     b8a:	39 23       	and	r19, r25
     b8c:	8e 81       	ldd	r24, Y+6	; 0x06
     b8e:	9f 81       	ldd	r25, Y+7	; 0x07
     b90:	28 17       	cp	r18, r24
     b92:	39 07       	cpc	r19, r25
     b94:	11 f4       	brne	.+4      	; 0xb9a <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
     b96:	81 e0       	ldi	r24, 0x01	; 1
     b98:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     b9a:	89 81       	ldd	r24, Y+1	; 0x01
     b9c:	88 23       	and	r24, r24
     b9e:	c9 f0       	breq	.+50     	; 0xbd2 <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     ba0:	8c 81       	ldd	r24, Y+4	; 0x04
     ba2:	9d 81       	ldd	r25, Y+5	; 0x05
     ba4:	80 70       	andi	r24, 0x00	; 0
     ba6:	91 70       	andi	r25, 0x01	; 1
     ba8:	00 97       	sbiw	r24, 0x00	; 0
     baa:	41 f0       	breq	.+16     	; 0xbbc <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     bac:	88 85       	ldd	r24, Y+8	; 0x08
     bae:	99 85       	ldd	r25, Y+9	; 0x09
     bb0:	2e 81       	ldd	r18, Y+6	; 0x06
     bb2:	3f 81       	ldd	r19, Y+7	; 0x07
     bb4:	82 2b       	or	r24, r18
     bb6:	93 2b       	or	r25, r19
     bb8:	99 87       	std	Y+9, r25	; 0x09
     bba:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     bbc:	ea 81       	ldd	r30, Y+2	; 0x02
     bbe:	fb 81       	ldd	r31, Y+3	; 0x03
     bc0:	80 81       	ld	r24, Z
     bc2:	91 81       	ldd	r25, Z+1	; 0x01
     bc4:	9c 01       	movw	r18, r24
     bc6:	32 60       	ori	r19, 0x02	; 2
     bc8:	88 89       	ldd	r24, Y+16	; 0x10
     bca:	99 89       	ldd	r25, Y+17	; 0x11
     bcc:	b9 01       	movw	r22, r18
     bce:	0e 94 e5 18 	call	0x31ca	; 0x31ca <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
     bd2:	8e 85       	ldd	r24, Y+14	; 0x0e
     bd4:	9f 85       	ldd	r25, Y+15	; 0x0f
     bd6:	99 8b       	std	Y+17, r25	; 0x11
     bd8:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     bda:	28 89       	ldd	r18, Y+16	; 0x10
     bdc:	39 89       	ldd	r19, Y+17	; 0x11
     bde:	8c 85       	ldd	r24, Y+12	; 0x0c
     be0:	9d 85       	ldd	r25, Y+13	; 0x0d
     be2:	28 17       	cp	r18, r24
     be4:	39 07       	cpc	r19, r25
     be6:	09 f0       	breq	.+2      	; 0xbea <xEventGroupSetBits+0x12a>
     be8:	9f cf       	rjmp	.-194    	; 0xb28 <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     bea:	ea 81       	ldd	r30, Y+2	; 0x02
     bec:	fb 81       	ldd	r31, Y+3	; 0x03
     bee:	20 81       	ld	r18, Z
     bf0:	31 81       	ldd	r19, Z+1	; 0x01
     bf2:	88 85       	ldd	r24, Y+8	; 0x08
     bf4:	99 85       	ldd	r25, Y+9	; 0x09
     bf6:	80 95       	com	r24
     bf8:	90 95       	com	r25
     bfa:	82 23       	and	r24, r18
     bfc:	93 23       	and	r25, r19
     bfe:	ea 81       	ldd	r30, Y+2	; 0x02
     c00:	fb 81       	ldd	r31, Y+3	; 0x03
     c02:	91 83       	std	Z+1, r25	; 0x01
     c04:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
     c06:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <xTaskResumeAll>

	return pxEventBits->uxEventBits;
     c0a:	ea 81       	ldd	r30, Y+2	; 0x02
     c0c:	fb 81       	ldd	r31, Y+3	; 0x03
     c0e:	80 81       	ld	r24, Z
     c10:	91 81       	ldd	r25, Z+1	; 0x01
}
     c12:	65 96       	adiw	r28, 0x15	; 21
     c14:	0f b6       	in	r0, 0x3f	; 63
     c16:	f8 94       	cli
     c18:	de bf       	out	0x3e, r29	; 62
     c1a:	0f be       	out	0x3f, r0	; 63
     c1c:	cd bf       	out	0x3d, r28	; 61
     c1e:	cf 91       	pop	r28
     c20:	df 91       	pop	r29
     c22:	08 95       	ret

00000c24 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
     c24:	df 93       	push	r29
     c26:	cf 93       	push	r28
     c28:	00 d0       	rcall	.+0      	; 0xc2a <vEventGroupDelete+0x6>
     c2a:	00 d0       	rcall	.+0      	; 0xc2c <vEventGroupDelete+0x8>
     c2c:	00 d0       	rcall	.+0      	; 0xc2e <vEventGroupDelete+0xa>
     c2e:	cd b7       	in	r28, 0x3d	; 61
     c30:	de b7       	in	r29, 0x3e	; 62
     c32:	9e 83       	std	Y+6, r25	; 0x06
     c34:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
     c36:	8d 81       	ldd	r24, Y+5	; 0x05
     c38:	9e 81       	ldd	r25, Y+6	; 0x06
     c3a:	9c 83       	std	Y+4, r25	; 0x04
     c3c:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
     c3e:	8b 81       	ldd	r24, Y+3	; 0x03
     c40:	9c 81       	ldd	r25, Y+4	; 0x04
     c42:	02 96       	adiw	r24, 0x02	; 2
     c44:	9a 83       	std	Y+2, r25	; 0x02
     c46:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
     c48:	0e 94 da 15 	call	0x2bb4	; 0x2bb4 <vTaskSuspendAll>
     c4c:	08 c0       	rjmp	.+16     	; 0xc5e <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
     c4e:	e9 81       	ldd	r30, Y+1	; 0x01
     c50:	fa 81       	ldd	r31, Y+2	; 0x02
     c52:	85 81       	ldd	r24, Z+5	; 0x05
     c54:	96 81       	ldd	r25, Z+6	; 0x06
     c56:	60 e0       	ldi	r22, 0x00	; 0
     c58:	72 e0       	ldi	r23, 0x02	; 2
     c5a:	0e 94 e5 18 	call	0x31ca	; 0x31ca <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     c5e:	e9 81       	ldd	r30, Y+1	; 0x01
     c60:	fa 81       	ldd	r31, Y+2	; 0x02
     c62:	80 81       	ld	r24, Z
     c64:	88 23       	and	r24, r24
     c66:	99 f7       	brne	.-26     	; 0xc4e <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
     c68:	8b 81       	ldd	r24, Y+3	; 0x03
     c6a:	9c 81       	ldd	r25, Y+4	; 0x04
     c6c:	0e 94 05 07 	call	0xe0a	; 0xe0a <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
     c70:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <xTaskResumeAll>
}
     c74:	26 96       	adiw	r28, 0x06	; 6
     c76:	0f b6       	in	r0, 0x3f	; 63
     c78:	f8 94       	cli
     c7a:	de bf       	out	0x3e, r29	; 62
     c7c:	0f be       	out	0x3f, r0	; 63
     c7e:	cd bf       	out	0x3d, r28	; 61
     c80:	cf 91       	pop	r28
     c82:	df 91       	pop	r29
     c84:	08 95       	ret

00000c86 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
     c86:	df 93       	push	r29
     c88:	cf 93       	push	r28
     c8a:	00 d0       	rcall	.+0      	; 0xc8c <vEventGroupSetBitsCallback+0x6>
     c8c:	00 d0       	rcall	.+0      	; 0xc8e <vEventGroupSetBitsCallback+0x8>
     c8e:	00 d0       	rcall	.+0      	; 0xc90 <vEventGroupSetBitsCallback+0xa>
     c90:	cd b7       	in	r28, 0x3d	; 61
     c92:	de b7       	in	r29, 0x3e	; 62
     c94:	9a 83       	std	Y+2, r25	; 0x02
     c96:	89 83       	std	Y+1, r24	; 0x01
     c98:	4b 83       	std	Y+3, r20	; 0x03
     c9a:	5c 83       	std	Y+4, r21	; 0x04
     c9c:	6d 83       	std	Y+5, r22	; 0x05
     c9e:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     ca0:	89 81       	ldd	r24, Y+1	; 0x01
     ca2:	9a 81       	ldd	r25, Y+2	; 0x02
     ca4:	2b 81       	ldd	r18, Y+3	; 0x03
     ca6:	3c 81       	ldd	r19, Y+4	; 0x04
     ca8:	b9 01       	movw	r22, r18
     caa:	0e 94 60 05 	call	0xac0	; 0xac0 <xEventGroupSetBits>
}
     cae:	26 96       	adiw	r28, 0x06	; 6
     cb0:	0f b6       	in	r0, 0x3f	; 63
     cb2:	f8 94       	cli
     cb4:	de bf       	out	0x3e, r29	; 62
     cb6:	0f be       	out	0x3f, r0	; 63
     cb8:	cd bf       	out	0x3d, r28	; 61
     cba:	cf 91       	pop	r28
     cbc:	df 91       	pop	r29
     cbe:	08 95       	ret

00000cc0 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
     cc0:	df 93       	push	r29
     cc2:	cf 93       	push	r28
     cc4:	00 d0       	rcall	.+0      	; 0xcc6 <vEventGroupClearBitsCallback+0x6>
     cc6:	00 d0       	rcall	.+0      	; 0xcc8 <vEventGroupClearBitsCallback+0x8>
     cc8:	00 d0       	rcall	.+0      	; 0xcca <vEventGroupClearBitsCallback+0xa>
     cca:	cd b7       	in	r28, 0x3d	; 61
     ccc:	de b7       	in	r29, 0x3e	; 62
     cce:	9a 83       	std	Y+2, r25	; 0x02
     cd0:	89 83       	std	Y+1, r24	; 0x01
     cd2:	4b 83       	std	Y+3, r20	; 0x03
     cd4:	5c 83       	std	Y+4, r21	; 0x04
     cd6:	6d 83       	std	Y+5, r22	; 0x05
     cd8:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     cda:	89 81       	ldd	r24, Y+1	; 0x01
     cdc:	9a 81       	ldd	r25, Y+2	; 0x02
     cde:	2b 81       	ldd	r18, Y+3	; 0x03
     ce0:	3c 81       	ldd	r19, Y+4	; 0x04
     ce2:	b9 01       	movw	r22, r18
     ce4:	0e 94 08 05 	call	0xa10	; 0xa10 <xEventGroupClearBits>
}
     ce8:	26 96       	adiw	r28, 0x06	; 6
     cea:	0f b6       	in	r0, 0x3f	; 63
     cec:	f8 94       	cli
     cee:	de bf       	out	0x3e, r29	; 62
     cf0:	0f be       	out	0x3f, r0	; 63
     cf2:	cd bf       	out	0x3d, r28	; 61
     cf4:	cf 91       	pop	r28
     cf6:	df 91       	pop	r29
     cf8:	08 95       	ret

00000cfa <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
     cfa:	df 93       	push	r29
     cfc:	cf 93       	push	r28
     cfe:	00 d0       	rcall	.+0      	; 0xd00 <prvTestWaitCondition+0x6>
     d00:	00 d0       	rcall	.+0      	; 0xd02 <prvTestWaitCondition+0x8>
     d02:	00 d0       	rcall	.+0      	; 0xd04 <prvTestWaitCondition+0xa>
     d04:	cd b7       	in	r28, 0x3d	; 61
     d06:	de b7       	in	r29, 0x3e	; 62
     d08:	9b 83       	std	Y+3, r25	; 0x03
     d0a:	8a 83       	std	Y+2, r24	; 0x02
     d0c:	7d 83       	std	Y+5, r23	; 0x05
     d0e:	6c 83       	std	Y+4, r22	; 0x04
     d10:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
     d12:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
     d14:	8e 81       	ldd	r24, Y+6	; 0x06
     d16:	88 23       	and	r24, r24
     d18:	59 f4       	brne	.+22     	; 0xd30 <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
     d1a:	8a 81       	ldd	r24, Y+2	; 0x02
     d1c:	9b 81       	ldd	r25, Y+3	; 0x03
     d1e:	2c 81       	ldd	r18, Y+4	; 0x04
     d20:	3d 81       	ldd	r19, Y+5	; 0x05
     d22:	82 23       	and	r24, r18
     d24:	93 23       	and	r25, r19
     d26:	00 97       	sbiw	r24, 0x00	; 0
     d28:	81 f0       	breq	.+32     	; 0xd4a <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
     d2a:	81 e0       	ldi	r24, 0x01	; 1
     d2c:	89 83       	std	Y+1, r24	; 0x01
     d2e:	0d c0       	rjmp	.+26     	; 0xd4a <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     d30:	2a 81       	ldd	r18, Y+2	; 0x02
     d32:	3b 81       	ldd	r19, Y+3	; 0x03
     d34:	8c 81       	ldd	r24, Y+4	; 0x04
     d36:	9d 81       	ldd	r25, Y+5	; 0x05
     d38:	28 23       	and	r18, r24
     d3a:	39 23       	and	r19, r25
     d3c:	8c 81       	ldd	r24, Y+4	; 0x04
     d3e:	9d 81       	ldd	r25, Y+5	; 0x05
     d40:	28 17       	cp	r18, r24
     d42:	39 07       	cpc	r19, r25
     d44:	11 f4       	brne	.+4      	; 0xd4a <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
     d46:	81 e0       	ldi	r24, 0x01	; 1
     d48:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
     d4a:	89 81       	ldd	r24, Y+1	; 0x01
}
     d4c:	26 96       	adiw	r28, 0x06	; 6
     d4e:	0f b6       	in	r0, 0x3f	; 63
     d50:	f8 94       	cli
     d52:	de bf       	out	0x3e, r29	; 62
     d54:	0f be       	out	0x3f, r0	; 63
     d56:	cd bf       	out	0x3d, r28	; 61
     d58:	cf 91       	pop	r28
     d5a:	df 91       	pop	r29
     d5c:	08 95       	ret

00000d5e <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     d5e:	df 93       	push	r29
     d60:	cf 93       	push	r28
     d62:	00 d0       	rcall	.+0      	; 0xd64 <pvPortMalloc+0x6>
     d64:	00 d0       	rcall	.+0      	; 0xd66 <pvPortMalloc+0x8>
     d66:	cd b7       	in	r28, 0x3d	; 61
     d68:	de b7       	in	r29, 0x3e	; 62
     d6a:	9c 83       	std	Y+4, r25	; 0x04
     d6c:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
     d6e:	1a 82       	std	Y+2, r1	; 0x02
     d70:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     d72:	0e 94 da 15 	call	0x2bb4	; 0x2bb4 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     d76:	80 91 6e 00 	lds	r24, 0x006E
     d7a:	90 91 6f 00 	lds	r25, 0x006F
     d7e:	00 97       	sbiw	r24, 0x00	; 0
     d80:	31 f4       	brne	.+12     	; 0xd8e <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     d82:	81 e7       	ldi	r24, 0x71	; 113
     d84:	90 e0       	ldi	r25, 0x00	; 0
     d86:	90 93 6f 00 	sts	0x006F, r25
     d8a:	80 93 6e 00 	sts	0x006E, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     d8e:	80 91 6c 00 	lds	r24, 0x006C
     d92:	90 91 6d 00 	lds	r25, 0x006D
     d96:	2b 81       	ldd	r18, Y+3	; 0x03
     d98:	3c 81       	ldd	r19, Y+4	; 0x04
     d9a:	82 0f       	add	r24, r18
     d9c:	93 1f       	adc	r25, r19
     d9e:	22 e0       	ldi	r18, 0x02	; 2
     da0:	87 35       	cpi	r24, 0x57	; 87
     da2:	92 07       	cpc	r25, r18
     da4:	38 f5       	brcc	.+78     	; 0xdf4 <pvPortMalloc+0x96>
     da6:	20 91 6c 00 	lds	r18, 0x006C
     daa:	30 91 6d 00 	lds	r19, 0x006D
     dae:	8b 81       	ldd	r24, Y+3	; 0x03
     db0:	9c 81       	ldd	r25, Y+4	; 0x04
     db2:	28 0f       	add	r18, r24
     db4:	39 1f       	adc	r19, r25
     db6:	80 91 6c 00 	lds	r24, 0x006C
     dba:	90 91 6d 00 	lds	r25, 0x006D
     dbe:	82 17       	cp	r24, r18
     dc0:	93 07       	cpc	r25, r19
     dc2:	c0 f4       	brcc	.+48     	; 0xdf4 <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     dc4:	20 91 6e 00 	lds	r18, 0x006E
     dc8:	30 91 6f 00 	lds	r19, 0x006F
     dcc:	80 91 6c 00 	lds	r24, 0x006C
     dd0:	90 91 6d 00 	lds	r25, 0x006D
     dd4:	82 0f       	add	r24, r18
     dd6:	93 1f       	adc	r25, r19
     dd8:	9a 83       	std	Y+2, r25	; 0x02
     dda:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
     ddc:	20 91 6c 00 	lds	r18, 0x006C
     de0:	30 91 6d 00 	lds	r19, 0x006D
     de4:	8b 81       	ldd	r24, Y+3	; 0x03
     de6:	9c 81       	ldd	r25, Y+4	; 0x04
     de8:	82 0f       	add	r24, r18
     dea:	93 1f       	adc	r25, r19
     dec:	90 93 6d 00 	sts	0x006D, r25
     df0:	80 93 6c 00 	sts	0x006C, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     df4:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
     df8:	89 81       	ldd	r24, Y+1	; 0x01
     dfa:	9a 81       	ldd	r25, Y+2	; 0x02
}
     dfc:	0f 90       	pop	r0
     dfe:	0f 90       	pop	r0
     e00:	0f 90       	pop	r0
     e02:	0f 90       	pop	r0
     e04:	cf 91       	pop	r28
     e06:	df 91       	pop	r29
     e08:	08 95       	ret

00000e0a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     e0a:	df 93       	push	r29
     e0c:	cf 93       	push	r28
     e0e:	00 d0       	rcall	.+0      	; 0xe10 <vPortFree+0x6>
     e10:	cd b7       	in	r28, 0x3d	; 61
     e12:	de b7       	in	r29, 0x3e	; 62
     e14:	9a 83       	std	Y+2, r25	; 0x02
     e16:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
     e18:	0f 90       	pop	r0
     e1a:	0f 90       	pop	r0
     e1c:	cf 91       	pop	r28
     e1e:	df 91       	pop	r29
     e20:	08 95       	ret

00000e22 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     e22:	df 93       	push	r29
     e24:	cf 93       	push	r28
     e26:	cd b7       	in	r28, 0x3d	; 61
     e28:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     e2a:	10 92 6d 00 	sts	0x006D, r1
     e2e:	10 92 6c 00 	sts	0x006C, r1
}
     e32:	cf 91       	pop	r28
     e34:	df 91       	pop	r29
     e36:	08 95       	ret

00000e38 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     e38:	df 93       	push	r29
     e3a:	cf 93       	push	r28
     e3c:	cd b7       	in	r28, 0x3d	; 61
     e3e:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     e40:	20 91 6c 00 	lds	r18, 0x006C
     e44:	30 91 6d 00 	lds	r19, 0x006D
     e48:	87 e5       	ldi	r24, 0x57	; 87
     e4a:	92 e0       	ldi	r25, 0x02	; 2
     e4c:	82 1b       	sub	r24, r18
     e4e:	93 0b       	sbc	r25, r19
}
     e50:	cf 91       	pop	r28
     e52:	df 91       	pop	r29
     e54:	08 95       	ret

00000e56 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     e56:	df 93       	push	r29
     e58:	cf 93       	push	r28
     e5a:	00 d0       	rcall	.+0      	; 0xe5c <vListInitialise+0x6>
     e5c:	cd b7       	in	r28, 0x3d	; 61
     e5e:	de b7       	in	r29, 0x3e	; 62
     e60:	9a 83       	std	Y+2, r25	; 0x02
     e62:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     e64:	89 81       	ldd	r24, Y+1	; 0x01
     e66:	9a 81       	ldd	r25, Y+2	; 0x02
     e68:	03 96       	adiw	r24, 0x03	; 3
     e6a:	e9 81       	ldd	r30, Y+1	; 0x01
     e6c:	fa 81       	ldd	r31, Y+2	; 0x02
     e6e:	92 83       	std	Z+2, r25	; 0x02
     e70:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     e72:	e9 81       	ldd	r30, Y+1	; 0x01
     e74:	fa 81       	ldd	r31, Y+2	; 0x02
     e76:	8f ef       	ldi	r24, 0xFF	; 255
     e78:	9f ef       	ldi	r25, 0xFF	; 255
     e7a:	94 83       	std	Z+4, r25	; 0x04
     e7c:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     e7e:	89 81       	ldd	r24, Y+1	; 0x01
     e80:	9a 81       	ldd	r25, Y+2	; 0x02
     e82:	03 96       	adiw	r24, 0x03	; 3
     e84:	e9 81       	ldd	r30, Y+1	; 0x01
     e86:	fa 81       	ldd	r31, Y+2	; 0x02
     e88:	96 83       	std	Z+6, r25	; 0x06
     e8a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     e8c:	89 81       	ldd	r24, Y+1	; 0x01
     e8e:	9a 81       	ldd	r25, Y+2	; 0x02
     e90:	03 96       	adiw	r24, 0x03	; 3
     e92:	e9 81       	ldd	r30, Y+1	; 0x01
     e94:	fa 81       	ldd	r31, Y+2	; 0x02
     e96:	90 87       	std	Z+8, r25	; 0x08
     e98:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     e9a:	e9 81       	ldd	r30, Y+1	; 0x01
     e9c:	fa 81       	ldd	r31, Y+2	; 0x02
     e9e:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     ea0:	0f 90       	pop	r0
     ea2:	0f 90       	pop	r0
     ea4:	cf 91       	pop	r28
     ea6:	df 91       	pop	r29
     ea8:	08 95       	ret

00000eaa <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
     eaa:	df 93       	push	r29
     eac:	cf 93       	push	r28
     eae:	00 d0       	rcall	.+0      	; 0xeb0 <vListInitialiseItem+0x6>
     eb0:	cd b7       	in	r28, 0x3d	; 61
     eb2:	de b7       	in	r29, 0x3e	; 62
     eb4:	9a 83       	std	Y+2, r25	; 0x02
     eb6:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
     eb8:	e9 81       	ldd	r30, Y+1	; 0x01
     eba:	fa 81       	ldd	r31, Y+2	; 0x02
     ebc:	11 86       	std	Z+9, r1	; 0x09
     ebe:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     ec0:	0f 90       	pop	r0
     ec2:	0f 90       	pop	r0
     ec4:	cf 91       	pop	r28
     ec6:	df 91       	pop	r29
     ec8:	08 95       	ret

00000eca <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     eca:	df 93       	push	r29
     ecc:	cf 93       	push	r28
     ece:	00 d0       	rcall	.+0      	; 0xed0 <vListInsertEnd+0x6>
     ed0:	00 d0       	rcall	.+0      	; 0xed2 <vListInsertEnd+0x8>
     ed2:	00 d0       	rcall	.+0      	; 0xed4 <vListInsertEnd+0xa>
     ed4:	cd b7       	in	r28, 0x3d	; 61
     ed6:	de b7       	in	r29, 0x3e	; 62
     ed8:	9c 83       	std	Y+4, r25	; 0x04
     eda:	8b 83       	std	Y+3, r24	; 0x03
     edc:	7e 83       	std	Y+6, r23	; 0x06
     ede:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
     ee0:	eb 81       	ldd	r30, Y+3	; 0x03
     ee2:	fc 81       	ldd	r31, Y+4	; 0x04
     ee4:	81 81       	ldd	r24, Z+1	; 0x01
     ee6:	92 81       	ldd	r25, Z+2	; 0x02
     ee8:	9a 83       	std	Y+2, r25	; 0x02
     eea:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     eec:	ed 81       	ldd	r30, Y+5	; 0x05
     eee:	fe 81       	ldd	r31, Y+6	; 0x06
     ef0:	89 81       	ldd	r24, Y+1	; 0x01
     ef2:	9a 81       	ldd	r25, Y+2	; 0x02
     ef4:	93 83       	std	Z+3, r25	; 0x03
     ef6:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     ef8:	e9 81       	ldd	r30, Y+1	; 0x01
     efa:	fa 81       	ldd	r31, Y+2	; 0x02
     efc:	84 81       	ldd	r24, Z+4	; 0x04
     efe:	95 81       	ldd	r25, Z+5	; 0x05
     f00:	ed 81       	ldd	r30, Y+5	; 0x05
     f02:	fe 81       	ldd	r31, Y+6	; 0x06
     f04:	95 83       	std	Z+5, r25	; 0x05
     f06:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     f08:	e9 81       	ldd	r30, Y+1	; 0x01
     f0a:	fa 81       	ldd	r31, Y+2	; 0x02
     f0c:	04 80       	ldd	r0, Z+4	; 0x04
     f0e:	f5 81       	ldd	r31, Z+5	; 0x05
     f10:	e0 2d       	mov	r30, r0
     f12:	8d 81       	ldd	r24, Y+5	; 0x05
     f14:	9e 81       	ldd	r25, Y+6	; 0x06
     f16:	93 83       	std	Z+3, r25	; 0x03
     f18:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
     f1a:	e9 81       	ldd	r30, Y+1	; 0x01
     f1c:	fa 81       	ldd	r31, Y+2	; 0x02
     f1e:	8d 81       	ldd	r24, Y+5	; 0x05
     f20:	9e 81       	ldd	r25, Y+6	; 0x06
     f22:	95 83       	std	Z+5, r25	; 0x05
     f24:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
     f26:	ed 81       	ldd	r30, Y+5	; 0x05
     f28:	fe 81       	ldd	r31, Y+6	; 0x06
     f2a:	8b 81       	ldd	r24, Y+3	; 0x03
     f2c:	9c 81       	ldd	r25, Y+4	; 0x04
     f2e:	91 87       	std	Z+9, r25	; 0x09
     f30:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     f32:	eb 81       	ldd	r30, Y+3	; 0x03
     f34:	fc 81       	ldd	r31, Y+4	; 0x04
     f36:	80 81       	ld	r24, Z
     f38:	8f 5f       	subi	r24, 0xFF	; 255
     f3a:	eb 81       	ldd	r30, Y+3	; 0x03
     f3c:	fc 81       	ldd	r31, Y+4	; 0x04
     f3e:	80 83       	st	Z, r24
}
     f40:	26 96       	adiw	r28, 0x06	; 6
     f42:	0f b6       	in	r0, 0x3f	; 63
     f44:	f8 94       	cli
     f46:	de bf       	out	0x3e, r29	; 62
     f48:	0f be       	out	0x3f, r0	; 63
     f4a:	cd bf       	out	0x3d, r28	; 61
     f4c:	cf 91       	pop	r28
     f4e:	df 91       	pop	r29
     f50:	08 95       	ret

00000f52 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     f52:	df 93       	push	r29
     f54:	cf 93       	push	r28
     f56:	cd b7       	in	r28, 0x3d	; 61
     f58:	de b7       	in	r29, 0x3e	; 62
     f5a:	28 97       	sbiw	r28, 0x08	; 8
     f5c:	0f b6       	in	r0, 0x3f	; 63
     f5e:	f8 94       	cli
     f60:	de bf       	out	0x3e, r29	; 62
     f62:	0f be       	out	0x3f, r0	; 63
     f64:	cd bf       	out	0x3d, r28	; 61
     f66:	9e 83       	std	Y+6, r25	; 0x06
     f68:	8d 83       	std	Y+5, r24	; 0x05
     f6a:	78 87       	std	Y+8, r23	; 0x08
     f6c:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     f6e:	ef 81       	ldd	r30, Y+7	; 0x07
     f70:	f8 85       	ldd	r31, Y+8	; 0x08
     f72:	80 81       	ld	r24, Z
     f74:	91 81       	ldd	r25, Z+1	; 0x01
     f76:	9a 83       	std	Y+2, r25	; 0x02
     f78:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     f7a:	89 81       	ldd	r24, Y+1	; 0x01
     f7c:	9a 81       	ldd	r25, Y+2	; 0x02
     f7e:	2f ef       	ldi	r18, 0xFF	; 255
     f80:	8f 3f       	cpi	r24, 0xFF	; 255
     f82:	92 07       	cpc	r25, r18
     f84:	39 f4       	brne	.+14     	; 0xf94 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     f86:	ed 81       	ldd	r30, Y+5	; 0x05
     f88:	fe 81       	ldd	r31, Y+6	; 0x06
     f8a:	87 81       	ldd	r24, Z+7	; 0x07
     f8c:	90 85       	ldd	r25, Z+8	; 0x08
     f8e:	9c 83       	std	Y+4, r25	; 0x04
     f90:	8b 83       	std	Y+3, r24	; 0x03
     f92:	18 c0       	rjmp	.+48     	; 0xfc4 <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     f94:	8d 81       	ldd	r24, Y+5	; 0x05
     f96:	9e 81       	ldd	r25, Y+6	; 0x06
     f98:	03 96       	adiw	r24, 0x03	; 3
     f9a:	9c 83       	std	Y+4, r25	; 0x04
     f9c:	8b 83       	std	Y+3, r24	; 0x03
     f9e:	06 c0       	rjmp	.+12     	; 0xfac <vListInsert+0x5a>
     fa0:	eb 81       	ldd	r30, Y+3	; 0x03
     fa2:	fc 81       	ldd	r31, Y+4	; 0x04
     fa4:	82 81       	ldd	r24, Z+2	; 0x02
     fa6:	93 81       	ldd	r25, Z+3	; 0x03
     fa8:	9c 83       	std	Y+4, r25	; 0x04
     faa:	8b 83       	std	Y+3, r24	; 0x03
     fac:	eb 81       	ldd	r30, Y+3	; 0x03
     fae:	fc 81       	ldd	r31, Y+4	; 0x04
     fb0:	02 80       	ldd	r0, Z+2	; 0x02
     fb2:	f3 81       	ldd	r31, Z+3	; 0x03
     fb4:	e0 2d       	mov	r30, r0
     fb6:	20 81       	ld	r18, Z
     fb8:	31 81       	ldd	r19, Z+1	; 0x01
     fba:	89 81       	ldd	r24, Y+1	; 0x01
     fbc:	9a 81       	ldd	r25, Y+2	; 0x02
     fbe:	82 17       	cp	r24, r18
     fc0:	93 07       	cpc	r25, r19
     fc2:	70 f7       	brcc	.-36     	; 0xfa0 <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     fc4:	eb 81       	ldd	r30, Y+3	; 0x03
     fc6:	fc 81       	ldd	r31, Y+4	; 0x04
     fc8:	82 81       	ldd	r24, Z+2	; 0x02
     fca:	93 81       	ldd	r25, Z+3	; 0x03
     fcc:	ef 81       	ldd	r30, Y+7	; 0x07
     fce:	f8 85       	ldd	r31, Y+8	; 0x08
     fd0:	93 83       	std	Z+3, r25	; 0x03
     fd2:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     fd4:	ef 81       	ldd	r30, Y+7	; 0x07
     fd6:	f8 85       	ldd	r31, Y+8	; 0x08
     fd8:	02 80       	ldd	r0, Z+2	; 0x02
     fda:	f3 81       	ldd	r31, Z+3	; 0x03
     fdc:	e0 2d       	mov	r30, r0
     fde:	8f 81       	ldd	r24, Y+7	; 0x07
     fe0:	98 85       	ldd	r25, Y+8	; 0x08
     fe2:	95 83       	std	Z+5, r25	; 0x05
     fe4:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     fe6:	ef 81       	ldd	r30, Y+7	; 0x07
     fe8:	f8 85       	ldd	r31, Y+8	; 0x08
     fea:	8b 81       	ldd	r24, Y+3	; 0x03
     fec:	9c 81       	ldd	r25, Y+4	; 0x04
     fee:	95 83       	std	Z+5, r25	; 0x05
     ff0:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
     ff2:	eb 81       	ldd	r30, Y+3	; 0x03
     ff4:	fc 81       	ldd	r31, Y+4	; 0x04
     ff6:	8f 81       	ldd	r24, Y+7	; 0x07
     ff8:	98 85       	ldd	r25, Y+8	; 0x08
     ffa:	93 83       	std	Z+3, r25	; 0x03
     ffc:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
     ffe:	ef 81       	ldd	r30, Y+7	; 0x07
    1000:	f8 85       	ldd	r31, Y+8	; 0x08
    1002:	8d 81       	ldd	r24, Y+5	; 0x05
    1004:	9e 81       	ldd	r25, Y+6	; 0x06
    1006:	91 87       	std	Z+9, r25	; 0x09
    1008:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    100a:	ed 81       	ldd	r30, Y+5	; 0x05
    100c:	fe 81       	ldd	r31, Y+6	; 0x06
    100e:	80 81       	ld	r24, Z
    1010:	8f 5f       	subi	r24, 0xFF	; 255
    1012:	ed 81       	ldd	r30, Y+5	; 0x05
    1014:	fe 81       	ldd	r31, Y+6	; 0x06
    1016:	80 83       	st	Z, r24
}
    1018:	28 96       	adiw	r28, 0x08	; 8
    101a:	0f b6       	in	r0, 0x3f	; 63
    101c:	f8 94       	cli
    101e:	de bf       	out	0x3e, r29	; 62
    1020:	0f be       	out	0x3f, r0	; 63
    1022:	cd bf       	out	0x3d, r28	; 61
    1024:	cf 91       	pop	r28
    1026:	df 91       	pop	r29
    1028:	08 95       	ret

0000102a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    102a:	df 93       	push	r29
    102c:	cf 93       	push	r28
    102e:	00 d0       	rcall	.+0      	; 0x1030 <uxListRemove+0x6>
    1030:	00 d0       	rcall	.+0      	; 0x1032 <uxListRemove+0x8>
    1032:	cd b7       	in	r28, 0x3d	; 61
    1034:	de b7       	in	r29, 0x3e	; 62
    1036:	9c 83       	std	Y+4, r25	; 0x04
    1038:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    103a:	eb 81       	ldd	r30, Y+3	; 0x03
    103c:	fc 81       	ldd	r31, Y+4	; 0x04
    103e:	80 85       	ldd	r24, Z+8	; 0x08
    1040:	91 85       	ldd	r25, Z+9	; 0x09
    1042:	9a 83       	std	Y+2, r25	; 0x02
    1044:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1046:	eb 81       	ldd	r30, Y+3	; 0x03
    1048:	fc 81       	ldd	r31, Y+4	; 0x04
    104a:	a2 81       	ldd	r26, Z+2	; 0x02
    104c:	b3 81       	ldd	r27, Z+3	; 0x03
    104e:	eb 81       	ldd	r30, Y+3	; 0x03
    1050:	fc 81       	ldd	r31, Y+4	; 0x04
    1052:	84 81       	ldd	r24, Z+4	; 0x04
    1054:	95 81       	ldd	r25, Z+5	; 0x05
    1056:	15 96       	adiw	r26, 0x05	; 5
    1058:	9c 93       	st	X, r25
    105a:	8e 93       	st	-X, r24
    105c:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    105e:	eb 81       	ldd	r30, Y+3	; 0x03
    1060:	fc 81       	ldd	r31, Y+4	; 0x04
    1062:	a4 81       	ldd	r26, Z+4	; 0x04
    1064:	b5 81       	ldd	r27, Z+5	; 0x05
    1066:	eb 81       	ldd	r30, Y+3	; 0x03
    1068:	fc 81       	ldd	r31, Y+4	; 0x04
    106a:	82 81       	ldd	r24, Z+2	; 0x02
    106c:	93 81       	ldd	r25, Z+3	; 0x03
    106e:	13 96       	adiw	r26, 0x03	; 3
    1070:	9c 93       	st	X, r25
    1072:	8e 93       	st	-X, r24
    1074:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1076:	e9 81       	ldd	r30, Y+1	; 0x01
    1078:	fa 81       	ldd	r31, Y+2	; 0x02
    107a:	21 81       	ldd	r18, Z+1	; 0x01
    107c:	32 81       	ldd	r19, Z+2	; 0x02
    107e:	8b 81       	ldd	r24, Y+3	; 0x03
    1080:	9c 81       	ldd	r25, Y+4	; 0x04
    1082:	28 17       	cp	r18, r24
    1084:	39 07       	cpc	r19, r25
    1086:	41 f4       	brne	.+16     	; 0x1098 <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1088:	eb 81       	ldd	r30, Y+3	; 0x03
    108a:	fc 81       	ldd	r31, Y+4	; 0x04
    108c:	84 81       	ldd	r24, Z+4	; 0x04
    108e:	95 81       	ldd	r25, Z+5	; 0x05
    1090:	e9 81       	ldd	r30, Y+1	; 0x01
    1092:	fa 81       	ldd	r31, Y+2	; 0x02
    1094:	92 83       	std	Z+2, r25	; 0x02
    1096:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    1098:	eb 81       	ldd	r30, Y+3	; 0x03
    109a:	fc 81       	ldd	r31, Y+4	; 0x04
    109c:	11 86       	std	Z+9, r1	; 0x09
    109e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    10a0:	e9 81       	ldd	r30, Y+1	; 0x01
    10a2:	fa 81       	ldd	r31, Y+2	; 0x02
    10a4:	80 81       	ld	r24, Z
    10a6:	81 50       	subi	r24, 0x01	; 1
    10a8:	e9 81       	ldd	r30, Y+1	; 0x01
    10aa:	fa 81       	ldd	r31, Y+2	; 0x02
    10ac:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    10ae:	e9 81       	ldd	r30, Y+1	; 0x01
    10b0:	fa 81       	ldd	r31, Y+2	; 0x02
    10b2:	80 81       	ld	r24, Z
}
    10b4:	0f 90       	pop	r0
    10b6:	0f 90       	pop	r0
    10b8:	0f 90       	pop	r0
    10ba:	0f 90       	pop	r0
    10bc:	cf 91       	pop	r28
    10be:	df 91       	pop	r29
    10c0:	08 95       	ret

000010c2 <LED_1>:
#include "DIO_Interface.h"

//#include"LCD_Interface.h"

void LED_1 (void *pvpesament)
{
    10c2:	df 93       	push	r29
    10c4:	cf 93       	push	r28
    10c6:	00 d0       	rcall	.+0      	; 0x10c8 <LED_1+0x6>
    10c8:	cd b7       	in	r28, 0x3d	; 61
    10ca:	de b7       	in	r29, 0x3e	; 62
    10cc:	9a 83       	std	Y+2, r25	; 0x02
    10ce:	89 83       	std	Y+1, r24	; 0x01
static u8 state_1=0;
	while(1)//عشان لما ييجي رجع للمكان الي كان فيه بعد الديلي يعمل لوب وينفذ الاكشن الي عاوز انفذه تاني
	{	DIO_SET_PIN_VALUE(GROUP_C,PIN0,toogle_bit(state_1,0));
    10d0:	90 91 c8 02 	lds	r25, 0x02C8
    10d4:	81 e0       	ldi	r24, 0x01	; 1
    10d6:	89 27       	eor	r24, r25
    10d8:	80 93 c8 02 	sts	0x02C8, r24
    10dc:	90 91 c8 02 	lds	r25, 0x02C8
    10e0:	82 e0       	ldi	r24, 0x02	; 2
    10e2:	60 e0       	ldi	r22, 0x00	; 0
    10e4:	49 2f       	mov	r20, r25
    10e6:	0e 94 49 00 	call	0x92	; 0x92 <DIO_SET_PIN_VALUE>
		vTaskDelay(1000);//دا الوقت الي عاوز كل تاسكايه تتنفذ بعديه (peredisty)
    10ea:	88 ee       	ldi	r24, 0xE8	; 232
    10ec:	93 e0       	ldi	r25, 0x03	; 3
    10ee:	0e 94 7a 15 	call	0x2af4	; 0x2af4 <vTaskDelay>
    10f2:	ee cf       	rjmp	.-36     	; 0x10d0 <LED_1+0xe>

000010f4 <LED_2>:
//ولو لما بودي التاسك ويتينج بعمل سيف للمكان الي كنت فيه ولما باجي انديها تاني هيرجع عند المكان الي سبته فيه
}
}
void LED_2 (void *pvpesament)
{
    10f4:	df 93       	push	r29
    10f6:	cf 93       	push	r28
    10f8:	00 d0       	rcall	.+0      	; 0x10fa <LED_2+0x6>
    10fa:	cd b7       	in	r28, 0x3d	; 61
    10fc:	de b7       	in	r29, 0x3e	; 62
    10fe:	9a 83       	std	Y+2, r25	; 0x02
    1100:	89 83       	std	Y+1, r24	; 0x01
static u8 state_2=0;
while(1)//عشان لما ييجي رجع للمكان الي كان فيه بعد الديلي يعمل لوب وينفذ الاكشن الي عاوز انفذه تاني
	{	DIO_SET_PIN_VALUE(GROUP_C,PIN1,toogle_bit(state_2,0));
    1102:	90 91 c9 02 	lds	r25, 0x02C9
    1106:	81 e0       	ldi	r24, 0x01	; 1
    1108:	89 27       	eor	r24, r25
    110a:	80 93 c9 02 	sts	0x02C9, r24
    110e:	90 91 c9 02 	lds	r25, 0x02C9
    1112:	82 e0       	ldi	r24, 0x02	; 2
    1114:	61 e0       	ldi	r22, 0x01	; 1
    1116:	49 2f       	mov	r20, r25
    1118:	0e 94 49 00 	call	0x92	; 0x92 <DIO_SET_PIN_VALUE>
		vTaskDelay(2000);//دا الوقت الي عاوز كل تاسكايه تتنفذ بعديه (peredisty)
    111c:	80 ed       	ldi	r24, 0xD0	; 208
    111e:	97 e0       	ldi	r25, 0x07	; 7
    1120:	0e 94 7a 15 	call	0x2af4	; 0x2af4 <vTaskDelay>
    1124:	ee cf       	rjmp	.-36     	; 0x1102 <LED_2+0xe>

00001126 <LED_3>:

}
}
void LED_3 (void *pvpesament)//لازم اكتب كده
{
    1126:	df 93       	push	r29
    1128:	cf 93       	push	r28
    112a:	00 d0       	rcall	.+0      	; 0x112c <LED_3+0x6>
    112c:	cd b7       	in	r28, 0x3d	; 61
    112e:	de b7       	in	r29, 0x3e	; 62
    1130:	9a 83       	std	Y+2, r25	; 0x02
    1132:	89 83       	std	Y+1, r24	; 0x01
static u8 state_3=0;
while(1)//عشان لما ييجي رجع للمكان الي كان فيه بعد الديلي يعمل لوب وينفذ الاكشن الي عاوز انفذه تاني
	{	DIO_SET_PIN_VALUE(GROUP_C,PIN2,toogle_bit(state_3,0));
    1134:	90 91 ca 02 	lds	r25, 0x02CA
    1138:	81 e0       	ldi	r24, 0x01	; 1
    113a:	89 27       	eor	r24, r25
    113c:	80 93 ca 02 	sts	0x02CA, r24
    1140:	90 91 ca 02 	lds	r25, 0x02CA
    1144:	82 e0       	ldi	r24, 0x02	; 2
    1146:	62 e0       	ldi	r22, 0x02	; 2
    1148:	49 2f       	mov	r20, r25
    114a:	0e 94 49 00 	call	0x92	; 0x92 <DIO_SET_PIN_VALUE>
		vTaskDelay(3000);//دا الوقت الي عاوز كل تاسكايه تتنفذ بعديه (peredisty)
    114e:	88 eb       	ldi	r24, 0xB8	; 184
    1150:	9b e0       	ldi	r25, 0x0B	; 11
    1152:	0e 94 7a 15 	call	0x2af4	; 0x2af4 <vTaskDelay>
    1156:	ee cf       	rjmp	.-36     	; 0x1134 <LED_3+0xe>

00001158 <main>:
}



void main (void)
{
    1158:	ef 92       	push	r14
    115a:	ff 92       	push	r15
    115c:	0f 93       	push	r16
    115e:	df 93       	push	r29
    1160:	cf 93       	push	r28
    1162:	cd b7       	in	r28, 0x3d	; 61
    1164:	de b7       	in	r29, 0x3e	; 62
	DIO_SET_PIN_DIRECTION(GROUP_C,PIN0,DIO_HIGH);
    1166:	82 e0       	ldi	r24, 0x02	; 2
    1168:	60 e0       	ldi	r22, 0x00	; 0
    116a:	41 e0       	ldi	r20, 0x01	; 1
    116c:	0e 94 44 01 	call	0x288	; 0x288 <DIO_SET_PIN_DIRECTION>
	DIO_SET_PIN_DIRECTION(GROUP_C,PIN1,DIO_HIGH);
    1170:	82 e0       	ldi	r24, 0x02	; 2
    1172:	61 e0       	ldi	r22, 0x01	; 1
    1174:	41 e0       	ldi	r20, 0x01	; 1
    1176:	0e 94 44 01 	call	0x288	; 0x288 <DIO_SET_PIN_DIRECTION>
	DIO_SET_PIN_DIRECTION(GROUP_C,PIN2,DIO_HIGH);
    117a:	82 e0       	ldi	r24, 0x02	; 2
    117c:	62 e0       	ldi	r22, 0x02	; 2
    117e:	41 e0       	ldi	r20, 0x01	; 1
    1180:	0e 94 44 01 	call	0x288	; 0x288 <DIO_SET_PIN_DIRECTION>

	xTaskCreate(LED_1,"TASK_1",85,NULL,1,NULL);//FRIST NAME FUNC , 2- NAME TASK (BETWEEN "") ,3- LENGH OF BYTE كام بايت هتاخدها التاسك دي , IF لو معنديش انبوت هبعت نال لو عندي اينبوت للفانكشن هبعت عنوان الفاريبول الي انيوت للفانكشن(ر&ي)
    1184:	81 e6       	ldi	r24, 0x61	; 97
    1186:	98 e0       	ldi	r25, 0x08	; 8
    1188:	20 e6       	ldi	r18, 0x60	; 96
    118a:	30 e0       	ldi	r19, 0x00	; 0
    118c:	b9 01       	movw	r22, r18
    118e:	45 e5       	ldi	r20, 0x55	; 85
    1190:	50 e0       	ldi	r21, 0x00	; 0
    1192:	20 e0       	ldi	r18, 0x00	; 0
    1194:	30 e0       	ldi	r19, 0x00	; 0
    1196:	01 e0       	ldi	r16, 0x01	; 1
    1198:	ee 24       	eor	r14, r14
    119a:	ff 24       	eor	r15, r15
    119c:	0e 94 ea 12 	call	0x25d4	; 0x25d4 <xTaskCreate>
//5-   البريورتي بتاعت التاسك (اعلي بريورتي أعلي رقم عندي ) ولو عندي 5 تاسك ف اعلي بريورتي هنا هزود واحد ويبقي 6
//6-بوينتر بيشاور علي التاسكايه الي كريتها لو مش عاوز هكتب NULL

	xTaskCreate(LED_2,"TASK_1",85,NULL,2,NULL);
    11a0:	8a e7       	ldi	r24, 0x7A	; 122
    11a2:	98 e0       	ldi	r25, 0x08	; 8
    11a4:	20 e6       	ldi	r18, 0x60	; 96
    11a6:	30 e0       	ldi	r19, 0x00	; 0
    11a8:	b9 01       	movw	r22, r18
    11aa:	45 e5       	ldi	r20, 0x55	; 85
    11ac:	50 e0       	ldi	r21, 0x00	; 0
    11ae:	20 e0       	ldi	r18, 0x00	; 0
    11b0:	30 e0       	ldi	r19, 0x00	; 0
    11b2:	02 e0       	ldi	r16, 0x02	; 2
    11b4:	ee 24       	eor	r14, r14
    11b6:	ff 24       	eor	r15, r15
    11b8:	0e 94 ea 12 	call	0x25d4	; 0x25d4 <xTaskCreate>

	xTaskCreate(LED_3,"TASK_1",85,NULL,3,NULL);
    11bc:	83 e9       	ldi	r24, 0x93	; 147
    11be:	98 e0       	ldi	r25, 0x08	; 8
    11c0:	20 e6       	ldi	r18, 0x60	; 96
    11c2:	30 e0       	ldi	r19, 0x00	; 0
    11c4:	b9 01       	movw	r22, r18
    11c6:	45 e5       	ldi	r20, 0x55	; 85
    11c8:	50 e0       	ldi	r21, 0x00	; 0
    11ca:	20 e0       	ldi	r18, 0x00	; 0
    11cc:	30 e0       	ldi	r19, 0x00	; 0
    11ce:	03 e0       	ldi	r16, 0x03	; 3
    11d0:	ee 24       	eor	r14, r14
    11d2:	ff 24       	eor	r15, r15
    11d4:	0e 94 ea 12 	call	0x25d4	; 0x25d4 <xTaskCreate>

	vTaskStartScheduler();//بقوله ابدا شغل
    11d8:	0e 94 9c 15 	call	0x2b38	; 0x2b38 <vTaskStartScheduler>
}
    11dc:	cf 91       	pop	r28
    11de:	df 91       	pop	r29
    11e0:	0f 91       	pop	r16
    11e2:	ff 90       	pop	r15
    11e4:	ef 90       	pop	r14
    11e6:	08 95       	ret

000011e8 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    11e8:	df 93       	push	r29
    11ea:	cf 93       	push	r28
    11ec:	cd b7       	in	r28, 0x3d	; 61
    11ee:	de b7       	in	r29, 0x3e	; 62
    11f0:	28 97       	sbiw	r28, 0x08	; 8
    11f2:	0f b6       	in	r0, 0x3f	; 63
    11f4:	f8 94       	cli
    11f6:	de bf       	out	0x3e, r29	; 62
    11f8:	0f be       	out	0x3f, r0	; 63
    11fa:	cd bf       	out	0x3d, r28	; 61
    11fc:	9c 83       	std	Y+4, r25	; 0x04
    11fe:	8b 83       	std	Y+3, r24	; 0x03
    1200:	7e 83       	std	Y+6, r23	; 0x06
    1202:	6d 83       	std	Y+5, r22	; 0x05
    1204:	58 87       	std	Y+8, r21	; 0x08
    1206:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1208:	eb 81       	ldd	r30, Y+3	; 0x03
    120a:	fc 81       	ldd	r31, Y+4	; 0x04
    120c:	81 e1       	ldi	r24, 0x11	; 17
    120e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1210:	8b 81       	ldd	r24, Y+3	; 0x03
    1212:	9c 81       	ldd	r25, Y+4	; 0x04
    1214:	01 97       	sbiw	r24, 0x01	; 1
    1216:	9c 83       	std	Y+4, r25	; 0x04
    1218:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    121a:	eb 81       	ldd	r30, Y+3	; 0x03
    121c:	fc 81       	ldd	r31, Y+4	; 0x04
    121e:	82 e2       	ldi	r24, 0x22	; 34
    1220:	80 83       	st	Z, r24
	pxTopOfStack--;
    1222:	8b 81       	ldd	r24, Y+3	; 0x03
    1224:	9c 81       	ldd	r25, Y+4	; 0x04
    1226:	01 97       	sbiw	r24, 0x01	; 1
    1228:	9c 83       	std	Y+4, r25	; 0x04
    122a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    122c:	eb 81       	ldd	r30, Y+3	; 0x03
    122e:	fc 81       	ldd	r31, Y+4	; 0x04
    1230:	83 e3       	ldi	r24, 0x33	; 51
    1232:	80 83       	st	Z, r24
	pxTopOfStack--;
    1234:	8b 81       	ldd	r24, Y+3	; 0x03
    1236:	9c 81       	ldd	r25, Y+4	; 0x04
    1238:	01 97       	sbiw	r24, 0x01	; 1
    123a:	9c 83       	std	Y+4, r25	; 0x04
    123c:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    123e:	8d 81       	ldd	r24, Y+5	; 0x05
    1240:	9e 81       	ldd	r25, Y+6	; 0x06
    1242:	9a 83       	std	Y+2, r25	; 0x02
    1244:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1246:	89 81       	ldd	r24, Y+1	; 0x01
    1248:	eb 81       	ldd	r30, Y+3	; 0x03
    124a:	fc 81       	ldd	r31, Y+4	; 0x04
    124c:	80 83       	st	Z, r24
	pxTopOfStack--;
    124e:	8b 81       	ldd	r24, Y+3	; 0x03
    1250:	9c 81       	ldd	r25, Y+4	; 0x04
    1252:	01 97       	sbiw	r24, 0x01	; 1
    1254:	9c 83       	std	Y+4, r25	; 0x04
    1256:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1258:	89 81       	ldd	r24, Y+1	; 0x01
    125a:	9a 81       	ldd	r25, Y+2	; 0x02
    125c:	89 2f       	mov	r24, r25
    125e:	99 27       	eor	r25, r25
    1260:	9a 83       	std	Y+2, r25	; 0x02
    1262:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1264:	89 81       	ldd	r24, Y+1	; 0x01
    1266:	eb 81       	ldd	r30, Y+3	; 0x03
    1268:	fc 81       	ldd	r31, Y+4	; 0x04
    126a:	80 83       	st	Z, r24
	pxTopOfStack--;
    126c:	8b 81       	ldd	r24, Y+3	; 0x03
    126e:	9c 81       	ldd	r25, Y+4	; 0x04
    1270:	01 97       	sbiw	r24, 0x01	; 1
    1272:	9c 83       	std	Y+4, r25	; 0x04
    1274:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    1276:	eb 81       	ldd	r30, Y+3	; 0x03
    1278:	fc 81       	ldd	r31, Y+4	; 0x04
    127a:	10 82       	st	Z, r1
	pxTopOfStack--;
    127c:	8b 81       	ldd	r24, Y+3	; 0x03
    127e:	9c 81       	ldd	r25, Y+4	; 0x04
    1280:	01 97       	sbiw	r24, 0x01	; 1
    1282:	9c 83       	std	Y+4, r25	; 0x04
    1284:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1286:	eb 81       	ldd	r30, Y+3	; 0x03
    1288:	fc 81       	ldd	r31, Y+4	; 0x04
    128a:	80 e8       	ldi	r24, 0x80	; 128
    128c:	80 83       	st	Z, r24
	pxTopOfStack--;
    128e:	8b 81       	ldd	r24, Y+3	; 0x03
    1290:	9c 81       	ldd	r25, Y+4	; 0x04
    1292:	01 97       	sbiw	r24, 0x01	; 1
    1294:	9c 83       	std	Y+4, r25	; 0x04
    1296:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    1298:	eb 81       	ldd	r30, Y+3	; 0x03
    129a:	fc 81       	ldd	r31, Y+4	; 0x04
    129c:	10 82       	st	Z, r1
	pxTopOfStack--;
    129e:	8b 81       	ldd	r24, Y+3	; 0x03
    12a0:	9c 81       	ldd	r25, Y+4	; 0x04
    12a2:	01 97       	sbiw	r24, 0x01	; 1
    12a4:	9c 83       	std	Y+4, r25	; 0x04
    12a6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    12a8:	eb 81       	ldd	r30, Y+3	; 0x03
    12aa:	fc 81       	ldd	r31, Y+4	; 0x04
    12ac:	82 e0       	ldi	r24, 0x02	; 2
    12ae:	80 83       	st	Z, r24
	pxTopOfStack--;
    12b0:	8b 81       	ldd	r24, Y+3	; 0x03
    12b2:	9c 81       	ldd	r25, Y+4	; 0x04
    12b4:	01 97       	sbiw	r24, 0x01	; 1
    12b6:	9c 83       	std	Y+4, r25	; 0x04
    12b8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    12ba:	eb 81       	ldd	r30, Y+3	; 0x03
    12bc:	fc 81       	ldd	r31, Y+4	; 0x04
    12be:	83 e0       	ldi	r24, 0x03	; 3
    12c0:	80 83       	st	Z, r24
	pxTopOfStack--;
    12c2:	8b 81       	ldd	r24, Y+3	; 0x03
    12c4:	9c 81       	ldd	r25, Y+4	; 0x04
    12c6:	01 97       	sbiw	r24, 0x01	; 1
    12c8:	9c 83       	std	Y+4, r25	; 0x04
    12ca:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    12cc:	eb 81       	ldd	r30, Y+3	; 0x03
    12ce:	fc 81       	ldd	r31, Y+4	; 0x04
    12d0:	84 e0       	ldi	r24, 0x04	; 4
    12d2:	80 83       	st	Z, r24
	pxTopOfStack--;
    12d4:	8b 81       	ldd	r24, Y+3	; 0x03
    12d6:	9c 81       	ldd	r25, Y+4	; 0x04
    12d8:	01 97       	sbiw	r24, 0x01	; 1
    12da:	9c 83       	std	Y+4, r25	; 0x04
    12dc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    12de:	eb 81       	ldd	r30, Y+3	; 0x03
    12e0:	fc 81       	ldd	r31, Y+4	; 0x04
    12e2:	85 e0       	ldi	r24, 0x05	; 5
    12e4:	80 83       	st	Z, r24
	pxTopOfStack--;
    12e6:	8b 81       	ldd	r24, Y+3	; 0x03
    12e8:	9c 81       	ldd	r25, Y+4	; 0x04
    12ea:	01 97       	sbiw	r24, 0x01	; 1
    12ec:	9c 83       	std	Y+4, r25	; 0x04
    12ee:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    12f0:	eb 81       	ldd	r30, Y+3	; 0x03
    12f2:	fc 81       	ldd	r31, Y+4	; 0x04
    12f4:	86 e0       	ldi	r24, 0x06	; 6
    12f6:	80 83       	st	Z, r24
	pxTopOfStack--;
    12f8:	8b 81       	ldd	r24, Y+3	; 0x03
    12fa:	9c 81       	ldd	r25, Y+4	; 0x04
    12fc:	01 97       	sbiw	r24, 0x01	; 1
    12fe:	9c 83       	std	Y+4, r25	; 0x04
    1300:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    1302:	eb 81       	ldd	r30, Y+3	; 0x03
    1304:	fc 81       	ldd	r31, Y+4	; 0x04
    1306:	87 e0       	ldi	r24, 0x07	; 7
    1308:	80 83       	st	Z, r24
	pxTopOfStack--;
    130a:	8b 81       	ldd	r24, Y+3	; 0x03
    130c:	9c 81       	ldd	r25, Y+4	; 0x04
    130e:	01 97       	sbiw	r24, 0x01	; 1
    1310:	9c 83       	std	Y+4, r25	; 0x04
    1312:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    1314:	eb 81       	ldd	r30, Y+3	; 0x03
    1316:	fc 81       	ldd	r31, Y+4	; 0x04
    1318:	88 e0       	ldi	r24, 0x08	; 8
    131a:	80 83       	st	Z, r24
	pxTopOfStack--;
    131c:	8b 81       	ldd	r24, Y+3	; 0x03
    131e:	9c 81       	ldd	r25, Y+4	; 0x04
    1320:	01 97       	sbiw	r24, 0x01	; 1
    1322:	9c 83       	std	Y+4, r25	; 0x04
    1324:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    1326:	eb 81       	ldd	r30, Y+3	; 0x03
    1328:	fc 81       	ldd	r31, Y+4	; 0x04
    132a:	89 e0       	ldi	r24, 0x09	; 9
    132c:	80 83       	st	Z, r24
	pxTopOfStack--;
    132e:	8b 81       	ldd	r24, Y+3	; 0x03
    1330:	9c 81       	ldd	r25, Y+4	; 0x04
    1332:	01 97       	sbiw	r24, 0x01	; 1
    1334:	9c 83       	std	Y+4, r25	; 0x04
    1336:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    1338:	eb 81       	ldd	r30, Y+3	; 0x03
    133a:	fc 81       	ldd	r31, Y+4	; 0x04
    133c:	80 e1       	ldi	r24, 0x10	; 16
    133e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1340:	8b 81       	ldd	r24, Y+3	; 0x03
    1342:	9c 81       	ldd	r25, Y+4	; 0x04
    1344:	01 97       	sbiw	r24, 0x01	; 1
    1346:	9c 83       	std	Y+4, r25	; 0x04
    1348:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    134a:	eb 81       	ldd	r30, Y+3	; 0x03
    134c:	fc 81       	ldd	r31, Y+4	; 0x04
    134e:	81 e1       	ldi	r24, 0x11	; 17
    1350:	80 83       	st	Z, r24
	pxTopOfStack--;
    1352:	8b 81       	ldd	r24, Y+3	; 0x03
    1354:	9c 81       	ldd	r25, Y+4	; 0x04
    1356:	01 97       	sbiw	r24, 0x01	; 1
    1358:	9c 83       	std	Y+4, r25	; 0x04
    135a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    135c:	eb 81       	ldd	r30, Y+3	; 0x03
    135e:	fc 81       	ldd	r31, Y+4	; 0x04
    1360:	82 e1       	ldi	r24, 0x12	; 18
    1362:	80 83       	st	Z, r24
	pxTopOfStack--;
    1364:	8b 81       	ldd	r24, Y+3	; 0x03
    1366:	9c 81       	ldd	r25, Y+4	; 0x04
    1368:	01 97       	sbiw	r24, 0x01	; 1
    136a:	9c 83       	std	Y+4, r25	; 0x04
    136c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    136e:	eb 81       	ldd	r30, Y+3	; 0x03
    1370:	fc 81       	ldd	r31, Y+4	; 0x04
    1372:	83 e1       	ldi	r24, 0x13	; 19
    1374:	80 83       	st	Z, r24
	pxTopOfStack--;
    1376:	8b 81       	ldd	r24, Y+3	; 0x03
    1378:	9c 81       	ldd	r25, Y+4	; 0x04
    137a:	01 97       	sbiw	r24, 0x01	; 1
    137c:	9c 83       	std	Y+4, r25	; 0x04
    137e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    1380:	eb 81       	ldd	r30, Y+3	; 0x03
    1382:	fc 81       	ldd	r31, Y+4	; 0x04
    1384:	84 e1       	ldi	r24, 0x14	; 20
    1386:	80 83       	st	Z, r24
	pxTopOfStack--;
    1388:	8b 81       	ldd	r24, Y+3	; 0x03
    138a:	9c 81       	ldd	r25, Y+4	; 0x04
    138c:	01 97       	sbiw	r24, 0x01	; 1
    138e:	9c 83       	std	Y+4, r25	; 0x04
    1390:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    1392:	eb 81       	ldd	r30, Y+3	; 0x03
    1394:	fc 81       	ldd	r31, Y+4	; 0x04
    1396:	85 e1       	ldi	r24, 0x15	; 21
    1398:	80 83       	st	Z, r24
	pxTopOfStack--;
    139a:	8b 81       	ldd	r24, Y+3	; 0x03
    139c:	9c 81       	ldd	r25, Y+4	; 0x04
    139e:	01 97       	sbiw	r24, 0x01	; 1
    13a0:	9c 83       	std	Y+4, r25	; 0x04
    13a2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    13a4:	eb 81       	ldd	r30, Y+3	; 0x03
    13a6:	fc 81       	ldd	r31, Y+4	; 0x04
    13a8:	86 e1       	ldi	r24, 0x16	; 22
    13aa:	80 83       	st	Z, r24
	pxTopOfStack--;
    13ac:	8b 81       	ldd	r24, Y+3	; 0x03
    13ae:	9c 81       	ldd	r25, Y+4	; 0x04
    13b0:	01 97       	sbiw	r24, 0x01	; 1
    13b2:	9c 83       	std	Y+4, r25	; 0x04
    13b4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    13b6:	eb 81       	ldd	r30, Y+3	; 0x03
    13b8:	fc 81       	ldd	r31, Y+4	; 0x04
    13ba:	87 e1       	ldi	r24, 0x17	; 23
    13bc:	80 83       	st	Z, r24
	pxTopOfStack--;
    13be:	8b 81       	ldd	r24, Y+3	; 0x03
    13c0:	9c 81       	ldd	r25, Y+4	; 0x04
    13c2:	01 97       	sbiw	r24, 0x01	; 1
    13c4:	9c 83       	std	Y+4, r25	; 0x04
    13c6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    13c8:	eb 81       	ldd	r30, Y+3	; 0x03
    13ca:	fc 81       	ldd	r31, Y+4	; 0x04
    13cc:	88 e1       	ldi	r24, 0x18	; 24
    13ce:	80 83       	st	Z, r24
	pxTopOfStack--;
    13d0:	8b 81       	ldd	r24, Y+3	; 0x03
    13d2:	9c 81       	ldd	r25, Y+4	; 0x04
    13d4:	01 97       	sbiw	r24, 0x01	; 1
    13d6:	9c 83       	std	Y+4, r25	; 0x04
    13d8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    13da:	eb 81       	ldd	r30, Y+3	; 0x03
    13dc:	fc 81       	ldd	r31, Y+4	; 0x04
    13de:	89 e1       	ldi	r24, 0x19	; 25
    13e0:	80 83       	st	Z, r24
	pxTopOfStack--;
    13e2:	8b 81       	ldd	r24, Y+3	; 0x03
    13e4:	9c 81       	ldd	r25, Y+4	; 0x04
    13e6:	01 97       	sbiw	r24, 0x01	; 1
    13e8:	9c 83       	std	Y+4, r25	; 0x04
    13ea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    13ec:	eb 81       	ldd	r30, Y+3	; 0x03
    13ee:	fc 81       	ldd	r31, Y+4	; 0x04
    13f0:	80 e2       	ldi	r24, 0x20	; 32
    13f2:	80 83       	st	Z, r24
	pxTopOfStack--;
    13f4:	8b 81       	ldd	r24, Y+3	; 0x03
    13f6:	9c 81       	ldd	r25, Y+4	; 0x04
    13f8:	01 97       	sbiw	r24, 0x01	; 1
    13fa:	9c 83       	std	Y+4, r25	; 0x04
    13fc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    13fe:	eb 81       	ldd	r30, Y+3	; 0x03
    1400:	fc 81       	ldd	r31, Y+4	; 0x04
    1402:	81 e2       	ldi	r24, 0x21	; 33
    1404:	80 83       	st	Z, r24
	pxTopOfStack--;
    1406:	8b 81       	ldd	r24, Y+3	; 0x03
    1408:	9c 81       	ldd	r25, Y+4	; 0x04
    140a:	01 97       	sbiw	r24, 0x01	; 1
    140c:	9c 83       	std	Y+4, r25	; 0x04
    140e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    1410:	eb 81       	ldd	r30, Y+3	; 0x03
    1412:	fc 81       	ldd	r31, Y+4	; 0x04
    1414:	82 e2       	ldi	r24, 0x22	; 34
    1416:	80 83       	st	Z, r24
	pxTopOfStack--;
    1418:	8b 81       	ldd	r24, Y+3	; 0x03
    141a:	9c 81       	ldd	r25, Y+4	; 0x04
    141c:	01 97       	sbiw	r24, 0x01	; 1
    141e:	9c 83       	std	Y+4, r25	; 0x04
    1420:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    1422:	eb 81       	ldd	r30, Y+3	; 0x03
    1424:	fc 81       	ldd	r31, Y+4	; 0x04
    1426:	83 e2       	ldi	r24, 0x23	; 35
    1428:	80 83       	st	Z, r24
	pxTopOfStack--;
    142a:	8b 81       	ldd	r24, Y+3	; 0x03
    142c:	9c 81       	ldd	r25, Y+4	; 0x04
    142e:	01 97       	sbiw	r24, 0x01	; 1
    1430:	9c 83       	std	Y+4, r25	; 0x04
    1432:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    1434:	8f 81       	ldd	r24, Y+7	; 0x07
    1436:	98 85       	ldd	r25, Y+8	; 0x08
    1438:	9a 83       	std	Y+2, r25	; 0x02
    143a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    143c:	89 81       	ldd	r24, Y+1	; 0x01
    143e:	eb 81       	ldd	r30, Y+3	; 0x03
    1440:	fc 81       	ldd	r31, Y+4	; 0x04
    1442:	80 83       	st	Z, r24
	pxTopOfStack--;
    1444:	8b 81       	ldd	r24, Y+3	; 0x03
    1446:	9c 81       	ldd	r25, Y+4	; 0x04
    1448:	01 97       	sbiw	r24, 0x01	; 1
    144a:	9c 83       	std	Y+4, r25	; 0x04
    144c:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    144e:	89 81       	ldd	r24, Y+1	; 0x01
    1450:	9a 81       	ldd	r25, Y+2	; 0x02
    1452:	89 2f       	mov	r24, r25
    1454:	99 27       	eor	r25, r25
    1456:	9a 83       	std	Y+2, r25	; 0x02
    1458:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    145a:	89 81       	ldd	r24, Y+1	; 0x01
    145c:	eb 81       	ldd	r30, Y+3	; 0x03
    145e:	fc 81       	ldd	r31, Y+4	; 0x04
    1460:	80 83       	st	Z, r24
	pxTopOfStack--;
    1462:	8b 81       	ldd	r24, Y+3	; 0x03
    1464:	9c 81       	ldd	r25, Y+4	; 0x04
    1466:	01 97       	sbiw	r24, 0x01	; 1
    1468:	9c 83       	std	Y+4, r25	; 0x04
    146a:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    146c:	eb 81       	ldd	r30, Y+3	; 0x03
    146e:	fc 81       	ldd	r31, Y+4	; 0x04
    1470:	86 e2       	ldi	r24, 0x26	; 38
    1472:	80 83       	st	Z, r24
	pxTopOfStack--;
    1474:	8b 81       	ldd	r24, Y+3	; 0x03
    1476:	9c 81       	ldd	r25, Y+4	; 0x04
    1478:	01 97       	sbiw	r24, 0x01	; 1
    147a:	9c 83       	std	Y+4, r25	; 0x04
    147c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    147e:	eb 81       	ldd	r30, Y+3	; 0x03
    1480:	fc 81       	ldd	r31, Y+4	; 0x04
    1482:	87 e2       	ldi	r24, 0x27	; 39
    1484:	80 83       	st	Z, r24
	pxTopOfStack--;
    1486:	8b 81       	ldd	r24, Y+3	; 0x03
    1488:	9c 81       	ldd	r25, Y+4	; 0x04
    148a:	01 97       	sbiw	r24, 0x01	; 1
    148c:	9c 83       	std	Y+4, r25	; 0x04
    148e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    1490:	eb 81       	ldd	r30, Y+3	; 0x03
    1492:	fc 81       	ldd	r31, Y+4	; 0x04
    1494:	88 e2       	ldi	r24, 0x28	; 40
    1496:	80 83       	st	Z, r24
	pxTopOfStack--;
    1498:	8b 81       	ldd	r24, Y+3	; 0x03
    149a:	9c 81       	ldd	r25, Y+4	; 0x04
    149c:	01 97       	sbiw	r24, 0x01	; 1
    149e:	9c 83       	std	Y+4, r25	; 0x04
    14a0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    14a2:	eb 81       	ldd	r30, Y+3	; 0x03
    14a4:	fc 81       	ldd	r31, Y+4	; 0x04
    14a6:	89 e2       	ldi	r24, 0x29	; 41
    14a8:	80 83       	st	Z, r24
	pxTopOfStack--;
    14aa:	8b 81       	ldd	r24, Y+3	; 0x03
    14ac:	9c 81       	ldd	r25, Y+4	; 0x04
    14ae:	01 97       	sbiw	r24, 0x01	; 1
    14b0:	9c 83       	std	Y+4, r25	; 0x04
    14b2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    14b4:	eb 81       	ldd	r30, Y+3	; 0x03
    14b6:	fc 81       	ldd	r31, Y+4	; 0x04
    14b8:	80 e3       	ldi	r24, 0x30	; 48
    14ba:	80 83       	st	Z, r24
	pxTopOfStack--;
    14bc:	8b 81       	ldd	r24, Y+3	; 0x03
    14be:	9c 81       	ldd	r25, Y+4	; 0x04
    14c0:	01 97       	sbiw	r24, 0x01	; 1
    14c2:	9c 83       	std	Y+4, r25	; 0x04
    14c4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    14c6:	eb 81       	ldd	r30, Y+3	; 0x03
    14c8:	fc 81       	ldd	r31, Y+4	; 0x04
    14ca:	81 e3       	ldi	r24, 0x31	; 49
    14cc:	80 83       	st	Z, r24
	pxTopOfStack--;
    14ce:	8b 81       	ldd	r24, Y+3	; 0x03
    14d0:	9c 81       	ldd	r25, Y+4	; 0x04
    14d2:	01 97       	sbiw	r24, 0x01	; 1
    14d4:	9c 83       	std	Y+4, r25	; 0x04
    14d6:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    14d8:	8b 81       	ldd	r24, Y+3	; 0x03
    14da:	9c 81       	ldd	r25, Y+4	; 0x04
}
    14dc:	28 96       	adiw	r28, 0x08	; 8
    14de:	0f b6       	in	r0, 0x3f	; 63
    14e0:	f8 94       	cli
    14e2:	de bf       	out	0x3e, r29	; 62
    14e4:	0f be       	out	0x3f, r0	; 63
    14e6:	cd bf       	out	0x3d, r28	; 61
    14e8:	cf 91       	pop	r28
    14ea:	df 91       	pop	r29
    14ec:	08 95       	ret

000014ee <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    14ee:	df 93       	push	r29
    14f0:	cf 93       	push	r28
    14f2:	cd b7       	in	r28, 0x3d	; 61
    14f4:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    14f6:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    14fa:	a0 91 cb 02 	lds	r26, 0x02CB
    14fe:	b0 91 cc 02 	lds	r27, 0x02CC
    1502:	cd 91       	ld	r28, X+
    1504:	cd bf       	out	0x3d, r28	; 61
    1506:	dd 91       	ld	r29, X+
    1508:	de bf       	out	0x3e, r29	; 62
    150a:	ff 91       	pop	r31
    150c:	ef 91       	pop	r30
    150e:	df 91       	pop	r29
    1510:	cf 91       	pop	r28
    1512:	bf 91       	pop	r27
    1514:	af 91       	pop	r26
    1516:	9f 91       	pop	r25
    1518:	8f 91       	pop	r24
    151a:	7f 91       	pop	r23
    151c:	6f 91       	pop	r22
    151e:	5f 91       	pop	r21
    1520:	4f 91       	pop	r20
    1522:	3f 91       	pop	r19
    1524:	2f 91       	pop	r18
    1526:	1f 91       	pop	r17
    1528:	0f 91       	pop	r16
    152a:	ff 90       	pop	r15
    152c:	ef 90       	pop	r14
    152e:	df 90       	pop	r13
    1530:	cf 90       	pop	r12
    1532:	bf 90       	pop	r11
    1534:	af 90       	pop	r10
    1536:	9f 90       	pop	r9
    1538:	8f 90       	pop	r8
    153a:	7f 90       	pop	r7
    153c:	6f 90       	pop	r6
    153e:	5f 90       	pop	r5
    1540:	4f 90       	pop	r4
    1542:	3f 90       	pop	r3
    1544:	2f 90       	pop	r2
    1546:	1f 90       	pop	r1
    1548:	0f 90       	pop	r0
    154a:	0f be       	out	0x3f, r0	; 63
    154c:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    154e:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    1550:	81 e0       	ldi	r24, 0x01	; 1
}
    1552:	cf 91       	pop	r28
    1554:	df 91       	pop	r29
    1556:	08 95       	ret

00001558 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1558:	df 93       	push	r29
    155a:	cf 93       	push	r28
    155c:	cd b7       	in	r28, 0x3d	; 61
    155e:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1560:	cf 91       	pop	r28
    1562:	df 91       	pop	r29
    1564:	08 95       	ret

00001566 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1566:	0f 92       	push	r0
    1568:	0f b6       	in	r0, 0x3f	; 63
    156a:	f8 94       	cli
    156c:	0f 92       	push	r0
    156e:	1f 92       	push	r1
    1570:	11 24       	eor	r1, r1
    1572:	2f 92       	push	r2
    1574:	3f 92       	push	r3
    1576:	4f 92       	push	r4
    1578:	5f 92       	push	r5
    157a:	6f 92       	push	r6
    157c:	7f 92       	push	r7
    157e:	8f 92       	push	r8
    1580:	9f 92       	push	r9
    1582:	af 92       	push	r10
    1584:	bf 92       	push	r11
    1586:	cf 92       	push	r12
    1588:	df 92       	push	r13
    158a:	ef 92       	push	r14
    158c:	ff 92       	push	r15
    158e:	0f 93       	push	r16
    1590:	1f 93       	push	r17
    1592:	2f 93       	push	r18
    1594:	3f 93       	push	r19
    1596:	4f 93       	push	r20
    1598:	5f 93       	push	r21
    159a:	6f 93       	push	r22
    159c:	7f 93       	push	r23
    159e:	8f 93       	push	r24
    15a0:	9f 93       	push	r25
    15a2:	af 93       	push	r26
    15a4:	bf 93       	push	r27
    15a6:	cf 93       	push	r28
    15a8:	df 93       	push	r29
    15aa:	ef 93       	push	r30
    15ac:	ff 93       	push	r31
    15ae:	a0 91 cb 02 	lds	r26, 0x02CB
    15b2:	b0 91 cc 02 	lds	r27, 0x02CC
    15b6:	0d b6       	in	r0, 0x3d	; 61
    15b8:	0d 92       	st	X+, r0
    15ba:	0e b6       	in	r0, 0x3e	; 62
    15bc:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    15be:	0e 94 bb 17 	call	0x2f76	; 0x2f76 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    15c2:	a0 91 cb 02 	lds	r26, 0x02CB
    15c6:	b0 91 cc 02 	lds	r27, 0x02CC
    15ca:	cd 91       	ld	r28, X+
    15cc:	cd bf       	out	0x3d, r28	; 61
    15ce:	dd 91       	ld	r29, X+
    15d0:	de bf       	out	0x3e, r29	; 62
    15d2:	ff 91       	pop	r31
    15d4:	ef 91       	pop	r30
    15d6:	df 91       	pop	r29
    15d8:	cf 91       	pop	r28
    15da:	bf 91       	pop	r27
    15dc:	af 91       	pop	r26
    15de:	9f 91       	pop	r25
    15e0:	8f 91       	pop	r24
    15e2:	7f 91       	pop	r23
    15e4:	6f 91       	pop	r22
    15e6:	5f 91       	pop	r21
    15e8:	4f 91       	pop	r20
    15ea:	3f 91       	pop	r19
    15ec:	2f 91       	pop	r18
    15ee:	1f 91       	pop	r17
    15f0:	0f 91       	pop	r16
    15f2:	ff 90       	pop	r15
    15f4:	ef 90       	pop	r14
    15f6:	df 90       	pop	r13
    15f8:	cf 90       	pop	r12
    15fa:	bf 90       	pop	r11
    15fc:	af 90       	pop	r10
    15fe:	9f 90       	pop	r9
    1600:	8f 90       	pop	r8
    1602:	7f 90       	pop	r7
    1604:	6f 90       	pop	r6
    1606:	5f 90       	pop	r5
    1608:	4f 90       	pop	r4
    160a:	3f 90       	pop	r3
    160c:	2f 90       	pop	r2
    160e:	1f 90       	pop	r1
    1610:	0f 90       	pop	r0
    1612:	0f be       	out	0x3f, r0	; 63
    1614:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1616:	08 95       	ret

00001618 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1618:	0f 92       	push	r0
    161a:	0f b6       	in	r0, 0x3f	; 63
    161c:	f8 94       	cli
    161e:	0f 92       	push	r0
    1620:	1f 92       	push	r1
    1622:	11 24       	eor	r1, r1
    1624:	2f 92       	push	r2
    1626:	3f 92       	push	r3
    1628:	4f 92       	push	r4
    162a:	5f 92       	push	r5
    162c:	6f 92       	push	r6
    162e:	7f 92       	push	r7
    1630:	8f 92       	push	r8
    1632:	9f 92       	push	r9
    1634:	af 92       	push	r10
    1636:	bf 92       	push	r11
    1638:	cf 92       	push	r12
    163a:	df 92       	push	r13
    163c:	ef 92       	push	r14
    163e:	ff 92       	push	r15
    1640:	0f 93       	push	r16
    1642:	1f 93       	push	r17
    1644:	2f 93       	push	r18
    1646:	3f 93       	push	r19
    1648:	4f 93       	push	r20
    164a:	5f 93       	push	r21
    164c:	6f 93       	push	r22
    164e:	7f 93       	push	r23
    1650:	8f 93       	push	r24
    1652:	9f 93       	push	r25
    1654:	af 93       	push	r26
    1656:	bf 93       	push	r27
    1658:	cf 93       	push	r28
    165a:	df 93       	push	r29
    165c:	ef 93       	push	r30
    165e:	ff 93       	push	r31
    1660:	a0 91 cb 02 	lds	r26, 0x02CB
    1664:	b0 91 cc 02 	lds	r27, 0x02CC
    1668:	0d b6       	in	r0, 0x3d	; 61
    166a:	0d 92       	st	X+, r0
    166c:	0e b6       	in	r0, 0x3e	; 62
    166e:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1670:	0e 94 d6 16 	call	0x2dac	; 0x2dac <xTaskIncrementTick>
    1674:	88 23       	and	r24, r24
    1676:	11 f0       	breq	.+4      	; 0x167c <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    1678:	0e 94 bb 17 	call	0x2f76	; 0x2f76 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    167c:	a0 91 cb 02 	lds	r26, 0x02CB
    1680:	b0 91 cc 02 	lds	r27, 0x02CC
    1684:	cd 91       	ld	r28, X+
    1686:	cd bf       	out	0x3d, r28	; 61
    1688:	dd 91       	ld	r29, X+
    168a:	de bf       	out	0x3e, r29	; 62
    168c:	ff 91       	pop	r31
    168e:	ef 91       	pop	r30
    1690:	df 91       	pop	r29
    1692:	cf 91       	pop	r28
    1694:	bf 91       	pop	r27
    1696:	af 91       	pop	r26
    1698:	9f 91       	pop	r25
    169a:	8f 91       	pop	r24
    169c:	7f 91       	pop	r23
    169e:	6f 91       	pop	r22
    16a0:	5f 91       	pop	r21
    16a2:	4f 91       	pop	r20
    16a4:	3f 91       	pop	r19
    16a6:	2f 91       	pop	r18
    16a8:	1f 91       	pop	r17
    16aa:	0f 91       	pop	r16
    16ac:	ff 90       	pop	r15
    16ae:	ef 90       	pop	r14
    16b0:	df 90       	pop	r13
    16b2:	cf 90       	pop	r12
    16b4:	bf 90       	pop	r11
    16b6:	af 90       	pop	r10
    16b8:	9f 90       	pop	r9
    16ba:	8f 90       	pop	r8
    16bc:	7f 90       	pop	r7
    16be:	6f 90       	pop	r6
    16c0:	5f 90       	pop	r5
    16c2:	4f 90       	pop	r4
    16c4:	3f 90       	pop	r3
    16c6:	2f 90       	pop	r2
    16c8:	1f 90       	pop	r1
    16ca:	0f 90       	pop	r0
    16cc:	0f be       	out	0x3f, r0	; 63
    16ce:	0f 90       	pop	r0

	asm volatile ( "ret" );
    16d0:	08 95       	ret

000016d2 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    16d2:	df 93       	push	r29
    16d4:	cf 93       	push	r28
    16d6:	00 d0       	rcall	.+0      	; 0x16d8 <prvSetupTimerInterrupt+0x6>
    16d8:	00 d0       	rcall	.+0      	; 0x16da <prvSetupTimerInterrupt+0x8>
    16da:	00 d0       	rcall	.+0      	; 0x16dc <prvSetupTimerInterrupt+0xa>
    16dc:	cd b7       	in	r28, 0x3d	; 61
    16de:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    16e0:	80 e4       	ldi	r24, 0x40	; 64
    16e2:	9f e1       	ldi	r25, 0x1F	; 31
    16e4:	a0 e0       	ldi	r26, 0x00	; 0
    16e6:	b0 e0       	ldi	r27, 0x00	; 0
    16e8:	8b 83       	std	Y+3, r24	; 0x03
    16ea:	9c 83       	std	Y+4, r25	; 0x04
    16ec:	ad 83       	std	Y+5, r26	; 0x05
    16ee:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    16f0:	8b 81       	ldd	r24, Y+3	; 0x03
    16f2:	9c 81       	ldd	r25, Y+4	; 0x04
    16f4:	ad 81       	ldd	r26, Y+5	; 0x05
    16f6:	be 81       	ldd	r27, Y+6	; 0x06
    16f8:	68 94       	set
    16fa:	15 f8       	bld	r1, 5
    16fc:	b6 95       	lsr	r27
    16fe:	a7 95       	ror	r26
    1700:	97 95       	ror	r25
    1702:	87 95       	ror	r24
    1704:	16 94       	lsr	r1
    1706:	d1 f7       	brne	.-12     	; 0x16fc <prvSetupTimerInterrupt+0x2a>
    1708:	8b 83       	std	Y+3, r24	; 0x03
    170a:	9c 83       	std	Y+4, r25	; 0x04
    170c:	ad 83       	std	Y+5, r26	; 0x05
    170e:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    1710:	8b 81       	ldd	r24, Y+3	; 0x03
    1712:	9c 81       	ldd	r25, Y+4	; 0x04
    1714:	ad 81       	ldd	r26, Y+5	; 0x05
    1716:	be 81       	ldd	r27, Y+6	; 0x06
    1718:	01 97       	sbiw	r24, 0x01	; 1
    171a:	a1 09       	sbc	r26, r1
    171c:	b1 09       	sbc	r27, r1
    171e:	8b 83       	std	Y+3, r24	; 0x03
    1720:	9c 83       	std	Y+4, r25	; 0x04
    1722:	ad 83       	std	Y+5, r26	; 0x05
    1724:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    1726:	8b 81       	ldd	r24, Y+3	; 0x03
    1728:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    172a:	8b 81       	ldd	r24, Y+3	; 0x03
    172c:	9c 81       	ldd	r25, Y+4	; 0x04
    172e:	ad 81       	ldd	r26, Y+5	; 0x05
    1730:	be 81       	ldd	r27, Y+6	; 0x06
    1732:	89 2f       	mov	r24, r25
    1734:	9a 2f       	mov	r25, r26
    1736:	ab 2f       	mov	r26, r27
    1738:	bb 27       	eor	r27, r27
    173a:	8b 83       	std	Y+3, r24	; 0x03
    173c:	9c 83       	std	Y+4, r25	; 0x04
    173e:	ad 83       	std	Y+5, r26	; 0x05
    1740:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    1742:	8b 81       	ldd	r24, Y+3	; 0x03
    1744:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    1746:	eb e4       	ldi	r30, 0x4B	; 75
    1748:	f0 e0       	ldi	r31, 0x00	; 0
    174a:	8a 81       	ldd	r24, Y+2	; 0x02
    174c:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    174e:	ea e4       	ldi	r30, 0x4A	; 74
    1750:	f0 e0       	ldi	r31, 0x00	; 0
    1752:	89 81       	ldd	r24, Y+1	; 0x01
    1754:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    1756:	8b e0       	ldi	r24, 0x0B	; 11
    1758:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    175a:	ee e4       	ldi	r30, 0x4E	; 78
    175c:	f0 e0       	ldi	r31, 0x00	; 0
    175e:	89 81       	ldd	r24, Y+1	; 0x01
    1760:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1762:	e9 e5       	ldi	r30, 0x59	; 89
    1764:	f0 e0       	ldi	r31, 0x00	; 0
    1766:	80 81       	ld	r24, Z
    1768:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    176a:	89 81       	ldd	r24, Y+1	; 0x01
    176c:	80 61       	ori	r24, 0x10	; 16
    176e:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    1770:	e9 e5       	ldi	r30, 0x59	; 89
    1772:	f0 e0       	ldi	r31, 0x00	; 0
    1774:	89 81       	ldd	r24, Y+1	; 0x01
    1776:	80 83       	st	Z, r24
}
    1778:	26 96       	adiw	r28, 0x06	; 6
    177a:	0f b6       	in	r0, 0x3f	; 63
    177c:	f8 94       	cli
    177e:	de bf       	out	0x3e, r29	; 62
    1780:	0f be       	out	0x3f, r0	; 63
    1782:	cd bf       	out	0x3d, r28	; 61
    1784:	cf 91       	pop	r28
    1786:	df 91       	pop	r29
    1788:	08 95       	ret

0000178a <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    178a:	0e 94 0c 0b 	call	0x1618	; 0x1618 <vPortYieldFromTick>
		asm volatile ( "reti" );
    178e:	18 95       	reti

00001790 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1790:	df 93       	push	r29
    1792:	cf 93       	push	r28
    1794:	00 d0       	rcall	.+0      	; 0x1796 <xQueueGenericReset+0x6>
    1796:	00 d0       	rcall	.+0      	; 0x1798 <xQueueGenericReset+0x8>
    1798:	0f 92       	push	r0
    179a:	cd b7       	in	r28, 0x3d	; 61
    179c:	de b7       	in	r29, 0x3e	; 62
    179e:	9c 83       	std	Y+4, r25	; 0x04
    17a0:	8b 83       	std	Y+3, r24	; 0x03
    17a2:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    17a4:	8b 81       	ldd	r24, Y+3	; 0x03
    17a6:	9c 81       	ldd	r25, Y+4	; 0x04
    17a8:	9a 83       	std	Y+2, r25	; 0x02
    17aa:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    17ac:	0f b6       	in	r0, 0x3f	; 63
    17ae:	f8 94       	cli
    17b0:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    17b2:	e9 81       	ldd	r30, Y+1	; 0x01
    17b4:	fa 81       	ldd	r31, Y+2	; 0x02
    17b6:	40 81       	ld	r20, Z
    17b8:	51 81       	ldd	r21, Z+1	; 0x01
    17ba:	e9 81       	ldd	r30, Y+1	; 0x01
    17bc:	fa 81       	ldd	r31, Y+2	; 0x02
    17be:	83 8d       	ldd	r24, Z+27	; 0x1b
    17c0:	28 2f       	mov	r18, r24
    17c2:	30 e0       	ldi	r19, 0x00	; 0
    17c4:	e9 81       	ldd	r30, Y+1	; 0x01
    17c6:	fa 81       	ldd	r31, Y+2	; 0x02
    17c8:	84 8d       	ldd	r24, Z+28	; 0x1c
    17ca:	88 2f       	mov	r24, r24
    17cc:	90 e0       	ldi	r25, 0x00	; 0
    17ce:	bc 01       	movw	r22, r24
    17d0:	26 9f       	mul	r18, r22
    17d2:	c0 01       	movw	r24, r0
    17d4:	27 9f       	mul	r18, r23
    17d6:	90 0d       	add	r25, r0
    17d8:	36 9f       	mul	r19, r22
    17da:	90 0d       	add	r25, r0
    17dc:	11 24       	eor	r1, r1
    17de:	84 0f       	add	r24, r20
    17e0:	95 1f       	adc	r25, r21
    17e2:	e9 81       	ldd	r30, Y+1	; 0x01
    17e4:	fa 81       	ldd	r31, Y+2	; 0x02
    17e6:	95 83       	std	Z+5, r25	; 0x05
    17e8:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    17ea:	e9 81       	ldd	r30, Y+1	; 0x01
    17ec:	fa 81       	ldd	r31, Y+2	; 0x02
    17ee:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    17f0:	e9 81       	ldd	r30, Y+1	; 0x01
    17f2:	fa 81       	ldd	r31, Y+2	; 0x02
    17f4:	80 81       	ld	r24, Z
    17f6:	91 81       	ldd	r25, Z+1	; 0x01
    17f8:	e9 81       	ldd	r30, Y+1	; 0x01
    17fa:	fa 81       	ldd	r31, Y+2	; 0x02
    17fc:	93 83       	std	Z+3, r25	; 0x03
    17fe:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1800:	e9 81       	ldd	r30, Y+1	; 0x01
    1802:	fa 81       	ldd	r31, Y+2	; 0x02
    1804:	40 81       	ld	r20, Z
    1806:	51 81       	ldd	r21, Z+1	; 0x01
    1808:	e9 81       	ldd	r30, Y+1	; 0x01
    180a:	fa 81       	ldd	r31, Y+2	; 0x02
    180c:	83 8d       	ldd	r24, Z+27	; 0x1b
    180e:	88 2f       	mov	r24, r24
    1810:	90 e0       	ldi	r25, 0x00	; 0
    1812:	9c 01       	movw	r18, r24
    1814:	21 50       	subi	r18, 0x01	; 1
    1816:	30 40       	sbci	r19, 0x00	; 0
    1818:	e9 81       	ldd	r30, Y+1	; 0x01
    181a:	fa 81       	ldd	r31, Y+2	; 0x02
    181c:	84 8d       	ldd	r24, Z+28	; 0x1c
    181e:	88 2f       	mov	r24, r24
    1820:	90 e0       	ldi	r25, 0x00	; 0
    1822:	bc 01       	movw	r22, r24
    1824:	26 9f       	mul	r18, r22
    1826:	c0 01       	movw	r24, r0
    1828:	27 9f       	mul	r18, r23
    182a:	90 0d       	add	r25, r0
    182c:	36 9f       	mul	r19, r22
    182e:	90 0d       	add	r25, r0
    1830:	11 24       	eor	r1, r1
    1832:	84 0f       	add	r24, r20
    1834:	95 1f       	adc	r25, r21
    1836:	e9 81       	ldd	r30, Y+1	; 0x01
    1838:	fa 81       	ldd	r31, Y+2	; 0x02
    183a:	97 83       	std	Z+7, r25	; 0x07
    183c:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    183e:	e9 81       	ldd	r30, Y+1	; 0x01
    1840:	fa 81       	ldd	r31, Y+2	; 0x02
    1842:	8f ef       	ldi	r24, 0xFF	; 255
    1844:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    1846:	e9 81       	ldd	r30, Y+1	; 0x01
    1848:	fa 81       	ldd	r31, Y+2	; 0x02
    184a:	8f ef       	ldi	r24, 0xFF	; 255
    184c:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    184e:	8d 81       	ldd	r24, Y+5	; 0x05
    1850:	88 23       	and	r24, r24
    1852:	79 f4       	brne	.+30     	; 0x1872 <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1854:	e9 81       	ldd	r30, Y+1	; 0x01
    1856:	fa 81       	ldd	r31, Y+2	; 0x02
    1858:	80 85       	ldd	r24, Z+8	; 0x08
    185a:	88 23       	and	r24, r24
    185c:	a1 f0       	breq	.+40     	; 0x1886 <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    185e:	89 81       	ldd	r24, Y+1	; 0x01
    1860:	9a 81       	ldd	r25, Y+2	; 0x02
    1862:	08 96       	adiw	r24, 0x08	; 8
    1864:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <xTaskRemoveFromEventList>
    1868:	88 23       	and	r24, r24
    186a:	69 f0       	breq	.+26     	; 0x1886 <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    186c:	0e 94 b3 0a 	call	0x1566	; 0x1566 <vPortYield>
    1870:	0a c0       	rjmp	.+20     	; 0x1886 <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1872:	89 81       	ldd	r24, Y+1	; 0x01
    1874:	9a 81       	ldd	r25, Y+2	; 0x02
    1876:	08 96       	adiw	r24, 0x08	; 8
    1878:	0e 94 2b 07 	call	0xe56	; 0xe56 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    187c:	89 81       	ldd	r24, Y+1	; 0x01
    187e:	9a 81       	ldd	r25, Y+2	; 0x02
    1880:	41 96       	adiw	r24, 0x11	; 17
    1882:	0e 94 2b 07 	call	0xe56	; 0xe56 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1886:	0f 90       	pop	r0
    1888:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    188a:	81 e0       	ldi	r24, 0x01	; 1
}
    188c:	0f 90       	pop	r0
    188e:	0f 90       	pop	r0
    1890:	0f 90       	pop	r0
    1892:	0f 90       	pop	r0
    1894:	0f 90       	pop	r0
    1896:	cf 91       	pop	r28
    1898:	df 91       	pop	r29
    189a:	08 95       	ret

0000189c <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    189c:	0f 93       	push	r16
    189e:	1f 93       	push	r17
    18a0:	df 93       	push	r29
    18a2:	cf 93       	push	r28
    18a4:	cd b7       	in	r28, 0x3d	; 61
    18a6:	de b7       	in	r29, 0x3e	; 62
    18a8:	29 97       	sbiw	r28, 0x09	; 9
    18aa:	0f b6       	in	r0, 0x3f	; 63
    18ac:	f8 94       	cli
    18ae:	de bf       	out	0x3e, r29	; 62
    18b0:	0f be       	out	0x3f, r0	; 63
    18b2:	cd bf       	out	0x3d, r28	; 61
    18b4:	8f 83       	std	Y+7, r24	; 0x07
    18b6:	68 87       	std	Y+8, r22	; 0x08
    18b8:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    18ba:	88 85       	ldd	r24, Y+8	; 0x08
    18bc:	88 23       	and	r24, r24
    18be:	19 f4       	brne	.+6      	; 0x18c6 <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    18c0:	1c 82       	std	Y+4, r1	; 0x04
    18c2:	1b 82       	std	Y+3, r1	; 0x03
    18c4:	10 c0       	rjmp	.+32     	; 0x18e6 <xQueueGenericCreate+0x4a>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    18c6:	8f 81       	ldd	r24, Y+7	; 0x07
    18c8:	28 2f       	mov	r18, r24
    18ca:	30 e0       	ldi	r19, 0x00	; 0
    18cc:	88 85       	ldd	r24, Y+8	; 0x08
    18ce:	88 2f       	mov	r24, r24
    18d0:	90 e0       	ldi	r25, 0x00	; 0
    18d2:	ac 01       	movw	r20, r24
    18d4:	24 9f       	mul	r18, r20
    18d6:	c0 01       	movw	r24, r0
    18d8:	25 9f       	mul	r18, r21
    18da:	90 0d       	add	r25, r0
    18dc:	34 9f       	mul	r19, r20
    18de:	90 0d       	add	r25, r0
    18e0:	11 24       	eor	r1, r1
    18e2:	9c 83       	std	Y+4, r25	; 0x04
    18e4:	8b 83       	std	Y+3, r24	; 0x03
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    18e6:	8b 81       	ldd	r24, Y+3	; 0x03
    18e8:	9c 81       	ldd	r25, Y+4	; 0x04
    18ea:	4f 96       	adiw	r24, 0x1f	; 31
    18ec:	0e 94 af 06 	call	0xd5e	; 0xd5e <pvPortMalloc>
    18f0:	9e 83       	std	Y+6, r25	; 0x06
    18f2:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    18f4:	8d 81       	ldd	r24, Y+5	; 0x05
    18f6:	9e 81       	ldd	r25, Y+6	; 0x06
    18f8:	00 97       	sbiw	r24, 0x00	; 0
    18fa:	a1 f0       	breq	.+40     	; 0x1924 <xQueueGenericCreate+0x88>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    18fc:	8d 81       	ldd	r24, Y+5	; 0x05
    18fe:	9e 81       	ldd	r25, Y+6	; 0x06
    1900:	9a 83       	std	Y+2, r25	; 0x02
    1902:	89 83       	std	Y+1, r24	; 0x01
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1904:	89 81       	ldd	r24, Y+1	; 0x01
    1906:	9a 81       	ldd	r25, Y+2	; 0x02
    1908:	4f 96       	adiw	r24, 0x1f	; 31
    190a:	9a 83       	std	Y+2, r25	; 0x02
    190c:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    190e:	29 81       	ldd	r18, Y+1	; 0x01
    1910:	3a 81       	ldd	r19, Y+2	; 0x02
    1912:	ed 81       	ldd	r30, Y+5	; 0x05
    1914:	fe 81       	ldd	r31, Y+6	; 0x06
    1916:	8f 81       	ldd	r24, Y+7	; 0x07
    1918:	68 85       	ldd	r22, Y+8	; 0x08
    191a:	a9 01       	movw	r20, r18
    191c:	29 85       	ldd	r18, Y+9	; 0x09
    191e:	8f 01       	movw	r16, r30
    1920:	0e 94 9f 0c 	call	0x193e	; 0x193e <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    1924:	8d 81       	ldd	r24, Y+5	; 0x05
    1926:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    1928:	29 96       	adiw	r28, 0x09	; 9
    192a:	0f b6       	in	r0, 0x3f	; 63
    192c:	f8 94       	cli
    192e:	de bf       	out	0x3e, r29	; 62
    1930:	0f be       	out	0x3f, r0	; 63
    1932:	cd bf       	out	0x3d, r28	; 61
    1934:	cf 91       	pop	r28
    1936:	df 91       	pop	r29
    1938:	1f 91       	pop	r17
    193a:	0f 91       	pop	r16
    193c:	08 95       	ret

0000193e <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    193e:	0f 93       	push	r16
    1940:	1f 93       	push	r17
    1942:	df 93       	push	r29
    1944:	cf 93       	push	r28
    1946:	cd b7       	in	r28, 0x3d	; 61
    1948:	de b7       	in	r29, 0x3e	; 62
    194a:	27 97       	sbiw	r28, 0x07	; 7
    194c:	0f b6       	in	r0, 0x3f	; 63
    194e:	f8 94       	cli
    1950:	de bf       	out	0x3e, r29	; 62
    1952:	0f be       	out	0x3f, r0	; 63
    1954:	cd bf       	out	0x3d, r28	; 61
    1956:	89 83       	std	Y+1, r24	; 0x01
    1958:	6a 83       	std	Y+2, r22	; 0x02
    195a:	5c 83       	std	Y+4, r21	; 0x04
    195c:	4b 83       	std	Y+3, r20	; 0x03
    195e:	2d 83       	std	Y+5, r18	; 0x05
    1960:	1f 83       	std	Y+7, r17	; 0x07
    1962:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    1964:	8a 81       	ldd	r24, Y+2	; 0x02
    1966:	88 23       	and	r24, r24
    1968:	39 f4       	brne	.+14     	; 0x1978 <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    196a:	8e 81       	ldd	r24, Y+6	; 0x06
    196c:	9f 81       	ldd	r25, Y+7	; 0x07
    196e:	ee 81       	ldd	r30, Y+6	; 0x06
    1970:	ff 81       	ldd	r31, Y+7	; 0x07
    1972:	91 83       	std	Z+1, r25	; 0x01
    1974:	80 83       	st	Z, r24
    1976:	06 c0       	rjmp	.+12     	; 0x1984 <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1978:	8b 81       	ldd	r24, Y+3	; 0x03
    197a:	9c 81       	ldd	r25, Y+4	; 0x04
    197c:	ee 81       	ldd	r30, Y+6	; 0x06
    197e:	ff 81       	ldd	r31, Y+7	; 0x07
    1980:	91 83       	std	Z+1, r25	; 0x01
    1982:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    1984:	ee 81       	ldd	r30, Y+6	; 0x06
    1986:	ff 81       	ldd	r31, Y+7	; 0x07
    1988:	89 81       	ldd	r24, Y+1	; 0x01
    198a:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    198c:	ee 81       	ldd	r30, Y+6	; 0x06
    198e:	ff 81       	ldd	r31, Y+7	; 0x07
    1990:	8a 81       	ldd	r24, Y+2	; 0x02
    1992:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1994:	8e 81       	ldd	r24, Y+6	; 0x06
    1996:	9f 81       	ldd	r25, Y+7	; 0x07
    1998:	61 e0       	ldi	r22, 0x01	; 1
    199a:	0e 94 c8 0b 	call	0x1790	; 0x1790 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    199e:	27 96       	adiw	r28, 0x07	; 7
    19a0:	0f b6       	in	r0, 0x3f	; 63
    19a2:	f8 94       	cli
    19a4:	de bf       	out	0x3e, r29	; 62
    19a6:	0f be       	out	0x3f, r0	; 63
    19a8:	cd bf       	out	0x3d, r28	; 61
    19aa:	cf 91       	pop	r28
    19ac:	df 91       	pop	r29
    19ae:	1f 91       	pop	r17
    19b0:	0f 91       	pop	r16
    19b2:	08 95       	ret

000019b4 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    19b4:	df 93       	push	r29
    19b6:	cf 93       	push	r28
    19b8:	cd b7       	in	r28, 0x3d	; 61
    19ba:	de b7       	in	r29, 0x3e	; 62
    19bc:	2f 97       	sbiw	r28, 0x0f	; 15
    19be:	0f b6       	in	r0, 0x3f	; 63
    19c0:	f8 94       	cli
    19c2:	de bf       	out	0x3e, r29	; 62
    19c4:	0f be       	out	0x3f, r0	; 63
    19c6:	cd bf       	out	0x3d, r28	; 61
    19c8:	99 87       	std	Y+9, r25	; 0x09
    19ca:	88 87       	std	Y+8, r24	; 0x08
    19cc:	7b 87       	std	Y+11, r23	; 0x0b
    19ce:	6a 87       	std	Y+10, r22	; 0x0a
    19d0:	5d 87       	std	Y+13, r21	; 0x0d
    19d2:	4c 87       	std	Y+12, r20	; 0x0c
    19d4:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    19d6:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    19d8:	88 85       	ldd	r24, Y+8	; 0x08
    19da:	99 85       	ldd	r25, Y+9	; 0x09
    19dc:	9a 83       	std	Y+2, r25	; 0x02
    19de:	89 83       	std	Y+1, r24	; 0x01
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    19e0:	0f b6       	in	r0, 0x3f	; 63
    19e2:	f8 94       	cli
    19e4:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    19e6:	e9 81       	ldd	r30, Y+1	; 0x01
    19e8:	fa 81       	ldd	r31, Y+2	; 0x02
    19ea:	92 8d       	ldd	r25, Z+26	; 0x1a
    19ec:	e9 81       	ldd	r30, Y+1	; 0x01
    19ee:	fa 81       	ldd	r31, Y+2	; 0x02
    19f0:	83 8d       	ldd	r24, Z+27	; 0x1b
    19f2:	98 17       	cp	r25, r24
    19f4:	18 f0       	brcs	.+6      	; 0x19fc <xQueueGenericSend+0x48>
    19f6:	8e 85       	ldd	r24, Y+14	; 0x0e
    19f8:	82 30       	cpi	r24, 0x02	; 2
    19fa:	11 f5       	brne	.+68     	; 0x1a40 <xQueueGenericSend+0x8c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    19fc:	89 81       	ldd	r24, Y+1	; 0x01
    19fe:	9a 81       	ldd	r25, Y+2	; 0x02
    1a00:	2a 85       	ldd	r18, Y+10	; 0x0a
    1a02:	3b 85       	ldd	r19, Y+11	; 0x0b
    1a04:	b9 01       	movw	r22, r18
    1a06:	4e 85       	ldd	r20, Y+14	; 0x0e
    1a08:	0e 94 2c 11 	call	0x2258	; 0x2258 <prvCopyDataToQueue>
    1a0c:	8b 83       	std	Y+3, r24	; 0x03

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a0e:	e9 81       	ldd	r30, Y+1	; 0x01
    1a10:	fa 81       	ldd	r31, Y+2	; 0x02
    1a12:	81 89       	ldd	r24, Z+17	; 0x11
    1a14:	88 23       	and	r24, r24
    1a16:	51 f0       	breq	.+20     	; 0x1a2c <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a18:	89 81       	ldd	r24, Y+1	; 0x01
    1a1a:	9a 81       	ldd	r25, Y+2	; 0x02
    1a1c:	41 96       	adiw	r24, 0x11	; 17
    1a1e:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <xTaskRemoveFromEventList>
    1a22:	88 23       	and	r24, r24
    1a24:	41 f0       	breq	.+16     	; 0x1a36 <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1a26:	0e 94 b3 0a 	call	0x1566	; 0x1566 <vPortYield>
    1a2a:	05 c0       	rjmp	.+10     	; 0x1a36 <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1a2c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a2e:	88 23       	and	r24, r24
    1a30:	11 f0       	breq	.+4      	; 0x1a36 <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1a32:	0e 94 b3 0a 	call	0x1566	; 0x1566 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1a36:	0f 90       	pop	r0
    1a38:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1a3a:	81 e0       	ldi	r24, 0x01	; 1
    1a3c:	8f 87       	std	Y+15, r24	; 0x0f
    1a3e:	5c c0       	rjmp	.+184    	; 0x1af8 <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1a40:	8c 85       	ldd	r24, Y+12	; 0x0c
    1a42:	9d 85       	ldd	r25, Y+13	; 0x0d
    1a44:	00 97       	sbiw	r24, 0x00	; 0
    1a46:	21 f4       	brne	.+8      	; 0x1a50 <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1a48:	0f 90       	pop	r0
    1a4a:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1a4c:	1f 86       	std	Y+15, r1	; 0x0f
    1a4e:	54 c0       	rjmp	.+168    	; 0x1af8 <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1a50:	8c 81       	ldd	r24, Y+4	; 0x04
    1a52:	88 23       	and	r24, r24
    1a54:	31 f4       	brne	.+12     	; 0x1a62 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1a56:	ce 01       	movw	r24, r28
    1a58:	05 96       	adiw	r24, 0x05	; 5
    1a5a:	0e 94 60 19 	call	0x32c0	; 0x32c0 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1a5e:	81 e0       	ldi	r24, 0x01	; 1
    1a60:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1a62:	0f 90       	pop	r0
    1a64:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1a66:	0e 94 da 15 	call	0x2bb4	; 0x2bb4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1a6a:	0f b6       	in	r0, 0x3f	; 63
    1a6c:	f8 94       	cli
    1a6e:	0f 92       	push	r0
    1a70:	e9 81       	ldd	r30, Y+1	; 0x01
    1a72:	fa 81       	ldd	r31, Y+2	; 0x02
    1a74:	85 8d       	ldd	r24, Z+29	; 0x1d
    1a76:	8f 3f       	cpi	r24, 0xFF	; 255
    1a78:	19 f4       	brne	.+6      	; 0x1a80 <xQueueGenericSend+0xcc>
    1a7a:	e9 81       	ldd	r30, Y+1	; 0x01
    1a7c:	fa 81       	ldd	r31, Y+2	; 0x02
    1a7e:	15 8e       	std	Z+29, r1	; 0x1d
    1a80:	e9 81       	ldd	r30, Y+1	; 0x01
    1a82:	fa 81       	ldd	r31, Y+2	; 0x02
    1a84:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a86:	8f 3f       	cpi	r24, 0xFF	; 255
    1a88:	19 f4       	brne	.+6      	; 0x1a90 <xQueueGenericSend+0xdc>
    1a8a:	e9 81       	ldd	r30, Y+1	; 0x01
    1a8c:	fa 81       	ldd	r31, Y+2	; 0x02
    1a8e:	16 8e       	std	Z+30, r1	; 0x1e
    1a90:	0f 90       	pop	r0
    1a92:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1a94:	ce 01       	movw	r24, r28
    1a96:	05 96       	adiw	r24, 0x05	; 5
    1a98:	9e 01       	movw	r18, r28
    1a9a:	24 5f       	subi	r18, 0xF4	; 244
    1a9c:	3f 4f       	sbci	r19, 0xFF	; 255
    1a9e:	b9 01       	movw	r22, r18
    1aa0:	0e 94 79 19 	call	0x32f2	; 0x32f2 <xTaskCheckForTimeOut>
    1aa4:	88 23       	and	r24, r24
    1aa6:	09 f5       	brne	.+66     	; 0x1aea <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1aa8:	89 81       	ldd	r24, Y+1	; 0x01
    1aaa:	9a 81       	ldd	r25, Y+2	; 0x02
    1aac:	0e 94 a8 12 	call	0x2550	; 0x2550 <prvIsQueueFull>
    1ab0:	88 23       	and	r24, r24
    1ab2:	a1 f0       	breq	.+40     	; 0x1adc <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1ab4:	89 81       	ldd	r24, Y+1	; 0x01
    1ab6:	9a 81       	ldd	r25, Y+2	; 0x02
    1ab8:	08 96       	adiw	r24, 0x08	; 8
    1aba:	2c 85       	ldd	r18, Y+12	; 0x0c
    1abc:	3d 85       	ldd	r19, Y+13	; 0x0d
    1abe:	b9 01       	movw	r22, r18
    1ac0:	0e 94 28 18 	call	0x3050	; 0x3050 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1ac4:	89 81       	ldd	r24, Y+1	; 0x01
    1ac6:	9a 81       	ldd	r25, Y+2	; 0x02
    1ac8:	0e 94 19 12 	call	0x2432	; 0x2432 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1acc:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <xTaskResumeAll>
    1ad0:	88 23       	and	r24, r24
    1ad2:	09 f0       	breq	.+2      	; 0x1ad6 <xQueueGenericSend+0x122>
    1ad4:	85 cf       	rjmp	.-246    	; 0x19e0 <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    1ad6:	0e 94 b3 0a 	call	0x1566	; 0x1566 <vPortYield>
    1ada:	82 cf       	rjmp	.-252    	; 0x19e0 <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1adc:	89 81       	ldd	r24, Y+1	; 0x01
    1ade:	9a 81       	ldd	r25, Y+2	; 0x02
    1ae0:	0e 94 19 12 	call	0x2432	; 0x2432 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1ae4:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <xTaskResumeAll>
    1ae8:	7b cf       	rjmp	.-266    	; 0x19e0 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1aea:	89 81       	ldd	r24, Y+1	; 0x01
    1aec:	9a 81       	ldd	r25, Y+2	; 0x02
    1aee:	0e 94 19 12 	call	0x2432	; 0x2432 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1af2:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1af6:	1f 86       	std	Y+15, r1	; 0x0f
    1af8:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	} /*lint -restore */
}
    1afa:	2f 96       	adiw	r28, 0x0f	; 15
    1afc:	0f b6       	in	r0, 0x3f	; 63
    1afe:	f8 94       	cli
    1b00:	de bf       	out	0x3e, r29	; 62
    1b02:	0f be       	out	0x3f, r0	; 63
    1b04:	cd bf       	out	0x3d, r28	; 61
    1b06:	cf 91       	pop	r28
    1b08:	df 91       	pop	r29
    1b0a:	08 95       	ret

00001b0c <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1b0c:	df 93       	push	r29
    1b0e:	cf 93       	push	r28
    1b10:	cd b7       	in	r28, 0x3d	; 61
    1b12:	de b7       	in	r29, 0x3e	; 62
    1b14:	2c 97       	sbiw	r28, 0x0c	; 12
    1b16:	0f b6       	in	r0, 0x3f	; 63
    1b18:	f8 94       	cli
    1b1a:	de bf       	out	0x3e, r29	; 62
    1b1c:	0f be       	out	0x3f, r0	; 63
    1b1e:	cd bf       	out	0x3d, r28	; 61
    1b20:	9f 83       	std	Y+7, r25	; 0x07
    1b22:	8e 83       	std	Y+6, r24	; 0x06
    1b24:	79 87       	std	Y+9, r23	; 0x09
    1b26:	68 87       	std	Y+8, r22	; 0x08
    1b28:	5b 87       	std	Y+11, r21	; 0x0b
    1b2a:	4a 87       	std	Y+10, r20	; 0x0a
    1b2c:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    1b2e:	8e 81       	ldd	r24, Y+6	; 0x06
    1b30:	9f 81       	ldd	r25, Y+7	; 0x07
    1b32:	9b 83       	std	Y+3, r25	; 0x03
    1b34:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1b36:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1b38:	ea 81       	ldd	r30, Y+2	; 0x02
    1b3a:	fb 81       	ldd	r31, Y+3	; 0x03
    1b3c:	92 8d       	ldd	r25, Z+26	; 0x1a
    1b3e:	ea 81       	ldd	r30, Y+2	; 0x02
    1b40:	fb 81       	ldd	r31, Y+3	; 0x03
    1b42:	83 8d       	ldd	r24, Z+27	; 0x1b
    1b44:	98 17       	cp	r25, r24
    1b46:	18 f0       	brcs	.+6      	; 0x1b4e <xQueueGenericSendFromISR+0x42>
    1b48:	8c 85       	ldd	r24, Y+12	; 0x0c
    1b4a:	82 30       	cpi	r24, 0x02	; 2
    1b4c:	61 f5       	brne	.+88     	; 0x1ba6 <xQueueGenericSendFromISR+0x9a>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1b4e:	ea 81       	ldd	r30, Y+2	; 0x02
    1b50:	fb 81       	ldd	r31, Y+3	; 0x03
    1b52:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b54:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1b56:	8a 81       	ldd	r24, Y+2	; 0x02
    1b58:	9b 81       	ldd	r25, Y+3	; 0x03
    1b5a:	28 85       	ldd	r18, Y+8	; 0x08
    1b5c:	39 85       	ldd	r19, Y+9	; 0x09
    1b5e:	b9 01       	movw	r22, r18
    1b60:	4c 85       	ldd	r20, Y+12	; 0x0c
    1b62:	0e 94 2c 11 	call	0x2258	; 0x2258 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1b66:	89 81       	ldd	r24, Y+1	; 0x01
    1b68:	8f 3f       	cpi	r24, 0xFF	; 255
    1b6a:	a9 f4       	brne	.+42     	; 0x1b96 <xQueueGenericSendFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b6c:	ea 81       	ldd	r30, Y+2	; 0x02
    1b6e:	fb 81       	ldd	r31, Y+3	; 0x03
    1b70:	81 89       	ldd	r24, Z+17	; 0x11
    1b72:	88 23       	and	r24, r24
    1b74:	a9 f0       	breq	.+42     	; 0x1ba0 <xQueueGenericSendFromISR+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b76:	8a 81       	ldd	r24, Y+2	; 0x02
    1b78:	9b 81       	ldd	r25, Y+3	; 0x03
    1b7a:	41 96       	adiw	r24, 0x11	; 17
    1b7c:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <xTaskRemoveFromEventList>
    1b80:	88 23       	and	r24, r24
    1b82:	71 f0       	breq	.+28     	; 0x1ba0 <xQueueGenericSendFromISR+0x94>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1b84:	8a 85       	ldd	r24, Y+10	; 0x0a
    1b86:	9b 85       	ldd	r25, Y+11	; 0x0b
    1b88:	00 97       	sbiw	r24, 0x00	; 0
    1b8a:	51 f0       	breq	.+20     	; 0x1ba0 <xQueueGenericSendFromISR+0x94>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1b8c:	ea 85       	ldd	r30, Y+10	; 0x0a
    1b8e:	fb 85       	ldd	r31, Y+11	; 0x0b
    1b90:	81 e0       	ldi	r24, 0x01	; 1
    1b92:	80 83       	st	Z, r24
    1b94:	05 c0       	rjmp	.+10     	; 0x1ba0 <xQueueGenericSendFromISR+0x94>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1b96:	89 81       	ldd	r24, Y+1	; 0x01
    1b98:	8f 5f       	subi	r24, 0xFF	; 255
    1b9a:	ea 81       	ldd	r30, Y+2	; 0x02
    1b9c:	fb 81       	ldd	r31, Y+3	; 0x03
    1b9e:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1ba0:	81 e0       	ldi	r24, 0x01	; 1
    1ba2:	8d 83       	std	Y+5, r24	; 0x05
    1ba4:	01 c0       	rjmp	.+2      	; 0x1ba8 <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1ba6:	1d 82       	std	Y+5, r1	; 0x05
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1ba8:	8d 81       	ldd	r24, Y+5	; 0x05
}
    1baa:	2c 96       	adiw	r28, 0x0c	; 12
    1bac:	0f b6       	in	r0, 0x3f	; 63
    1bae:	f8 94       	cli
    1bb0:	de bf       	out	0x3e, r29	; 62
    1bb2:	0f be       	out	0x3f, r0	; 63
    1bb4:	cd bf       	out	0x3d, r28	; 61
    1bb6:	cf 91       	pop	r28
    1bb8:	df 91       	pop	r29
    1bba:	08 95       	ret

00001bbc <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1bbc:	df 93       	push	r29
    1bbe:	cf 93       	push	r28
    1bc0:	cd b7       	in	r28, 0x3d	; 61
    1bc2:	de b7       	in	r29, 0x3e	; 62
    1bc4:	2a 97       	sbiw	r28, 0x0a	; 10
    1bc6:	0f b6       	in	r0, 0x3f	; 63
    1bc8:	f8 94       	cli
    1bca:	de bf       	out	0x3e, r29	; 62
    1bcc:	0f be       	out	0x3f, r0	; 63
    1bce:	cd bf       	out	0x3d, r28	; 61
    1bd0:	98 87       	std	Y+8, r25	; 0x08
    1bd2:	8f 83       	std	Y+7, r24	; 0x07
    1bd4:	7a 87       	std	Y+10, r23	; 0x0a
    1bd6:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    1bd8:	8f 81       	ldd	r24, Y+7	; 0x07
    1bda:	98 85       	ldd	r25, Y+8	; 0x08
    1bdc:	9c 83       	std	Y+4, r25	; 0x04
    1bde:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1be0:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1be2:	eb 81       	ldd	r30, Y+3	; 0x03
    1be4:	fc 81       	ldd	r31, Y+4	; 0x04
    1be6:	82 8d       	ldd	r24, Z+26	; 0x1a
    1be8:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    1bea:	eb 81       	ldd	r30, Y+3	; 0x03
    1bec:	fc 81       	ldd	r31, Y+4	; 0x04
    1bee:	93 8d       	ldd	r25, Z+27	; 0x1b
    1bf0:	8a 81       	ldd	r24, Y+2	; 0x02
    1bf2:	89 17       	cp	r24, r25
    1bf4:	48 f5       	brcc	.+82     	; 0x1c48 <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1bf6:	eb 81       	ldd	r30, Y+3	; 0x03
    1bf8:	fc 81       	ldd	r31, Y+4	; 0x04
    1bfa:	86 8d       	ldd	r24, Z+30	; 0x1e
    1bfc:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1bfe:	8a 81       	ldd	r24, Y+2	; 0x02
    1c00:	8f 5f       	subi	r24, 0xFF	; 255
    1c02:	eb 81       	ldd	r30, Y+3	; 0x03
    1c04:	fc 81       	ldd	r31, Y+4	; 0x04
    1c06:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1c08:	89 81       	ldd	r24, Y+1	; 0x01
    1c0a:	8f 3f       	cpi	r24, 0xFF	; 255
    1c0c:	a9 f4       	brne	.+42     	; 0x1c38 <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1c0e:	eb 81       	ldd	r30, Y+3	; 0x03
    1c10:	fc 81       	ldd	r31, Y+4	; 0x04
    1c12:	81 89       	ldd	r24, Z+17	; 0x11
    1c14:	88 23       	and	r24, r24
    1c16:	a9 f0       	breq	.+42     	; 0x1c42 <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1c18:	8b 81       	ldd	r24, Y+3	; 0x03
    1c1a:	9c 81       	ldd	r25, Y+4	; 0x04
    1c1c:	41 96       	adiw	r24, 0x11	; 17
    1c1e:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <xTaskRemoveFromEventList>
    1c22:	88 23       	and	r24, r24
    1c24:	71 f0       	breq	.+28     	; 0x1c42 <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1c26:	89 85       	ldd	r24, Y+9	; 0x09
    1c28:	9a 85       	ldd	r25, Y+10	; 0x0a
    1c2a:	00 97       	sbiw	r24, 0x00	; 0
    1c2c:	51 f0       	breq	.+20     	; 0x1c42 <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1c2e:	e9 85       	ldd	r30, Y+9	; 0x09
    1c30:	fa 85       	ldd	r31, Y+10	; 0x0a
    1c32:	81 e0       	ldi	r24, 0x01	; 1
    1c34:	80 83       	st	Z, r24
    1c36:	05 c0       	rjmp	.+10     	; 0x1c42 <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1c38:	89 81       	ldd	r24, Y+1	; 0x01
    1c3a:	8f 5f       	subi	r24, 0xFF	; 255
    1c3c:	eb 81       	ldd	r30, Y+3	; 0x03
    1c3e:	fc 81       	ldd	r31, Y+4	; 0x04
    1c40:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1c42:	81 e0       	ldi	r24, 0x01	; 1
    1c44:	8e 83       	std	Y+6, r24	; 0x06
    1c46:	01 c0       	rjmp	.+2      	; 0x1c4a <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1c48:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1c4a:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1c4c:	2a 96       	adiw	r28, 0x0a	; 10
    1c4e:	0f b6       	in	r0, 0x3f	; 63
    1c50:	f8 94       	cli
    1c52:	de bf       	out	0x3e, r29	; 62
    1c54:	0f be       	out	0x3f, r0	; 63
    1c56:	cd bf       	out	0x3d, r28	; 61
    1c58:	cf 91       	pop	r28
    1c5a:	df 91       	pop	r29
    1c5c:	08 95       	ret

00001c5e <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1c5e:	df 93       	push	r29
    1c60:	cf 93       	push	r28
    1c62:	cd b7       	in	r28, 0x3d	; 61
    1c64:	de b7       	in	r29, 0x3e	; 62
    1c66:	2e 97       	sbiw	r28, 0x0e	; 14
    1c68:	0f b6       	in	r0, 0x3f	; 63
    1c6a:	f8 94       	cli
    1c6c:	de bf       	out	0x3e, r29	; 62
    1c6e:	0f be       	out	0x3f, r0	; 63
    1c70:	cd bf       	out	0x3d, r28	; 61
    1c72:	99 87       	std	Y+9, r25	; 0x09
    1c74:	88 87       	std	Y+8, r24	; 0x08
    1c76:	7b 87       	std	Y+11, r23	; 0x0b
    1c78:	6a 87       	std	Y+10, r22	; 0x0a
    1c7a:	5d 87       	std	Y+13, r21	; 0x0d
    1c7c:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    1c7e:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    1c80:	88 85       	ldd	r24, Y+8	; 0x08
    1c82:	99 85       	ldd	r25, Y+9	; 0x09
    1c84:	9b 83       	std	Y+3, r25	; 0x03
    1c86:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1c88:	0f b6       	in	r0, 0x3f	; 63
    1c8a:	f8 94       	cli
    1c8c:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1c8e:	ea 81       	ldd	r30, Y+2	; 0x02
    1c90:	fb 81       	ldd	r31, Y+3	; 0x03
    1c92:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c94:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1c96:	89 81       	ldd	r24, Y+1	; 0x01
    1c98:	88 23       	and	r24, r24
    1c9a:	f9 f0       	breq	.+62     	; 0x1cda <xQueueReceive+0x7c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1c9c:	8a 81       	ldd	r24, Y+2	; 0x02
    1c9e:	9b 81       	ldd	r25, Y+3	; 0x03
    1ca0:	2a 85       	ldd	r18, Y+10	; 0x0a
    1ca2:	3b 85       	ldd	r19, Y+11	; 0x0b
    1ca4:	b9 01       	movw	r22, r18
    1ca6:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1caa:	89 81       	ldd	r24, Y+1	; 0x01
    1cac:	81 50       	subi	r24, 0x01	; 1
    1cae:	ea 81       	ldd	r30, Y+2	; 0x02
    1cb0:	fb 81       	ldd	r31, Y+3	; 0x03
    1cb2:	82 8f       	std	Z+26, r24	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1cb4:	ea 81       	ldd	r30, Y+2	; 0x02
    1cb6:	fb 81       	ldd	r31, Y+3	; 0x03
    1cb8:	80 85       	ldd	r24, Z+8	; 0x08
    1cba:	88 23       	and	r24, r24
    1cbc:	49 f0       	breq	.+18     	; 0x1cd0 <xQueueReceive+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1cbe:	8a 81       	ldd	r24, Y+2	; 0x02
    1cc0:	9b 81       	ldd	r25, Y+3	; 0x03
    1cc2:	08 96       	adiw	r24, 0x08	; 8
    1cc4:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <xTaskRemoveFromEventList>
    1cc8:	88 23       	and	r24, r24
    1cca:	11 f0       	breq	.+4      	; 0x1cd0 <xQueueReceive+0x72>
					{
						queueYIELD_IF_USING_PREEMPTION();
    1ccc:	0e 94 b3 0a 	call	0x1566	; 0x1566 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1cd0:	0f 90       	pop	r0
    1cd2:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1cd4:	81 e0       	ldi	r24, 0x01	; 1
    1cd6:	8e 87       	std	Y+14, r24	; 0x0e
    1cd8:	63 c0       	rjmp	.+198    	; 0x1da0 <xQueueReceive+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1cda:	8c 85       	ldd	r24, Y+12	; 0x0c
    1cdc:	9d 85       	ldd	r25, Y+13	; 0x0d
    1cde:	00 97       	sbiw	r24, 0x00	; 0
    1ce0:	21 f4       	brne	.+8      	; 0x1cea <xQueueReceive+0x8c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1ce2:	0f 90       	pop	r0
    1ce4:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1ce6:	1e 86       	std	Y+14, r1	; 0x0e
    1ce8:	5b c0       	rjmp	.+182    	; 0x1da0 <xQueueReceive+0x142>
				}
				else if( xEntryTimeSet == pdFALSE )
    1cea:	8c 81       	ldd	r24, Y+4	; 0x04
    1cec:	88 23       	and	r24, r24
    1cee:	31 f4       	brne	.+12     	; 0x1cfc <xQueueReceive+0x9e>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1cf0:	ce 01       	movw	r24, r28
    1cf2:	05 96       	adiw	r24, 0x05	; 5
    1cf4:	0e 94 60 19 	call	0x32c0	; 0x32c0 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1cf8:	81 e0       	ldi	r24, 0x01	; 1
    1cfa:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1cfc:	0f 90       	pop	r0
    1cfe:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1d00:	0e 94 da 15 	call	0x2bb4	; 0x2bb4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1d04:	0f b6       	in	r0, 0x3f	; 63
    1d06:	f8 94       	cli
    1d08:	0f 92       	push	r0
    1d0a:	ea 81       	ldd	r30, Y+2	; 0x02
    1d0c:	fb 81       	ldd	r31, Y+3	; 0x03
    1d0e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d10:	8f 3f       	cpi	r24, 0xFF	; 255
    1d12:	19 f4       	brne	.+6      	; 0x1d1a <xQueueReceive+0xbc>
    1d14:	ea 81       	ldd	r30, Y+2	; 0x02
    1d16:	fb 81       	ldd	r31, Y+3	; 0x03
    1d18:	15 8e       	std	Z+29, r1	; 0x1d
    1d1a:	ea 81       	ldd	r30, Y+2	; 0x02
    1d1c:	fb 81       	ldd	r31, Y+3	; 0x03
    1d1e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d20:	8f 3f       	cpi	r24, 0xFF	; 255
    1d22:	19 f4       	brne	.+6      	; 0x1d2a <xQueueReceive+0xcc>
    1d24:	ea 81       	ldd	r30, Y+2	; 0x02
    1d26:	fb 81       	ldd	r31, Y+3	; 0x03
    1d28:	16 8e       	std	Z+30, r1	; 0x1e
    1d2a:	0f 90       	pop	r0
    1d2c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1d2e:	ce 01       	movw	r24, r28
    1d30:	05 96       	adiw	r24, 0x05	; 5
    1d32:	9e 01       	movw	r18, r28
    1d34:	24 5f       	subi	r18, 0xF4	; 244
    1d36:	3f 4f       	sbci	r19, 0xFF	; 255
    1d38:	b9 01       	movw	r22, r18
    1d3a:	0e 94 79 19 	call	0x32f2	; 0x32f2 <xTaskCheckForTimeOut>
    1d3e:	88 23       	and	r24, r24
    1d40:	09 f5       	brne	.+66     	; 0x1d84 <xQueueReceive+0x126>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1d42:	8a 81       	ldd	r24, Y+2	; 0x02
    1d44:	9b 81       	ldd	r25, Y+3	; 0x03
    1d46:	0e 94 6c 12 	call	0x24d8	; 0x24d8 <prvIsQueueEmpty>
    1d4a:	88 23       	and	r24, r24
    1d4c:	a1 f0       	breq	.+40     	; 0x1d76 <xQueueReceive+0x118>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1d4e:	8a 81       	ldd	r24, Y+2	; 0x02
    1d50:	9b 81       	ldd	r25, Y+3	; 0x03
    1d52:	41 96       	adiw	r24, 0x11	; 17
    1d54:	2c 85       	ldd	r18, Y+12	; 0x0c
    1d56:	3d 85       	ldd	r19, Y+13	; 0x0d
    1d58:	b9 01       	movw	r22, r18
    1d5a:	0e 94 28 18 	call	0x3050	; 0x3050 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1d5e:	8a 81       	ldd	r24, Y+2	; 0x02
    1d60:	9b 81       	ldd	r25, Y+3	; 0x03
    1d62:	0e 94 19 12 	call	0x2432	; 0x2432 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1d66:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <xTaskResumeAll>
    1d6a:	88 23       	and	r24, r24
    1d6c:	09 f0       	breq	.+2      	; 0x1d70 <xQueueReceive+0x112>
    1d6e:	8c cf       	rjmp	.-232    	; 0x1c88 <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    1d70:	0e 94 b3 0a 	call	0x1566	; 0x1566 <vPortYield>
    1d74:	89 cf       	rjmp	.-238    	; 0x1c88 <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    1d76:	8a 81       	ldd	r24, Y+2	; 0x02
    1d78:	9b 81       	ldd	r25, Y+3	; 0x03
    1d7a:	0e 94 19 12 	call	0x2432	; 0x2432 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1d7e:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <xTaskResumeAll>
    1d82:	82 cf       	rjmp	.-252    	; 0x1c88 <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    1d84:	8a 81       	ldd	r24, Y+2	; 0x02
    1d86:	9b 81       	ldd	r25, Y+3	; 0x03
    1d88:	0e 94 19 12 	call	0x2432	; 0x2432 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1d8c:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1d90:	8a 81       	ldd	r24, Y+2	; 0x02
    1d92:	9b 81       	ldd	r25, Y+3	; 0x03
    1d94:	0e 94 6c 12 	call	0x24d8	; 0x24d8 <prvIsQueueEmpty>
    1d98:	88 23       	and	r24, r24
    1d9a:	09 f4       	brne	.+2      	; 0x1d9e <xQueueReceive+0x140>
    1d9c:	75 cf       	rjmp	.-278    	; 0x1c88 <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1d9e:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    1da0:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    1da2:	2e 96       	adiw	r28, 0x0e	; 14
    1da4:	0f b6       	in	r0, 0x3f	; 63
    1da6:	f8 94       	cli
    1da8:	de bf       	out	0x3e, r29	; 62
    1daa:	0f be       	out	0x3f, r0	; 63
    1dac:	cd bf       	out	0x3d, r28	; 61
    1dae:	cf 91       	pop	r28
    1db0:	df 91       	pop	r29
    1db2:	08 95       	ret

00001db4 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    1db4:	df 93       	push	r29
    1db6:	cf 93       	push	r28
    1db8:	cd b7       	in	r28, 0x3d	; 61
    1dba:	de b7       	in	r29, 0x3e	; 62
    1dbc:	2c 97       	sbiw	r28, 0x0c	; 12
    1dbe:	0f b6       	in	r0, 0x3f	; 63
    1dc0:	f8 94       	cli
    1dc2:	de bf       	out	0x3e, r29	; 62
    1dc4:	0f be       	out	0x3f, r0	; 63
    1dc6:	cd bf       	out	0x3d, r28	; 61
    1dc8:	99 87       	std	Y+9, r25	; 0x09
    1dca:	88 87       	std	Y+8, r24	; 0x08
    1dcc:	7b 87       	std	Y+11, r23	; 0x0b
    1dce:	6a 87       	std	Y+10, r22	; 0x0a
BaseType_t xEntryTimeSet = pdFALSE;
    1dd0:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    1dd2:	88 85       	ldd	r24, Y+8	; 0x08
    1dd4:	99 85       	ldd	r25, Y+9	; 0x09
    1dd6:	9b 83       	std	Y+3, r25	; 0x03
    1dd8:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1dda:	0f b6       	in	r0, 0x3f	; 63
    1ddc:	f8 94       	cli
    1dde:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    1de0:	ea 81       	ldd	r30, Y+2	; 0x02
    1de2:	fb 81       	ldd	r31, Y+3	; 0x03
    1de4:	82 8d       	ldd	r24, Z+26	; 0x1a
    1de6:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    1de8:	89 81       	ldd	r24, Y+1	; 0x01
    1dea:	88 23       	and	r24, r24
    1dec:	c1 f0       	breq	.+48     	; 0x1e1e <xQueueSemaphoreTake+0x6a>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    1dee:	89 81       	ldd	r24, Y+1	; 0x01
    1df0:	81 50       	subi	r24, 0x01	; 1
    1df2:	ea 81       	ldd	r30, Y+2	; 0x02
    1df4:	fb 81       	ldd	r31, Y+3	; 0x03
    1df6:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1df8:	ea 81       	ldd	r30, Y+2	; 0x02
    1dfa:	fb 81       	ldd	r31, Y+3	; 0x03
    1dfc:	80 85       	ldd	r24, Z+8	; 0x08
    1dfe:	88 23       	and	r24, r24
    1e00:	49 f0       	breq	.+18     	; 0x1e14 <xQueueSemaphoreTake+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1e02:	8a 81       	ldd	r24, Y+2	; 0x02
    1e04:	9b 81       	ldd	r25, Y+3	; 0x03
    1e06:	08 96       	adiw	r24, 0x08	; 8
    1e08:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <xTaskRemoveFromEventList>
    1e0c:	88 23       	and	r24, r24
    1e0e:	11 f0       	breq	.+4      	; 0x1e14 <xQueueSemaphoreTake+0x60>
					{
						queueYIELD_IF_USING_PREEMPTION();
    1e10:	0e 94 b3 0a 	call	0x1566	; 0x1566 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1e14:	0f 90       	pop	r0
    1e16:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1e18:	81 e0       	ldi	r24, 0x01	; 1
    1e1a:	8c 87       	std	Y+12, r24	; 0x0c
    1e1c:	63 c0       	rjmp	.+198    	; 0x1ee4 <xQueueSemaphoreTake+0x130>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1e1e:	8a 85       	ldd	r24, Y+10	; 0x0a
    1e20:	9b 85       	ldd	r25, Y+11	; 0x0b
    1e22:	00 97       	sbiw	r24, 0x00	; 0
    1e24:	21 f4       	brne	.+8      	; 0x1e2e <xQueueSemaphoreTake+0x7a>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    1e26:	0f 90       	pop	r0
    1e28:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1e2a:	1c 86       	std	Y+12, r1	; 0x0c
    1e2c:	5b c0       	rjmp	.+182    	; 0x1ee4 <xQueueSemaphoreTake+0x130>
				}
				else if( xEntryTimeSet == pdFALSE )
    1e2e:	8c 81       	ldd	r24, Y+4	; 0x04
    1e30:	88 23       	and	r24, r24
    1e32:	31 f4       	brne	.+12     	; 0x1e40 <xQueueSemaphoreTake+0x8c>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1e34:	ce 01       	movw	r24, r28
    1e36:	05 96       	adiw	r24, 0x05	; 5
    1e38:	0e 94 60 19 	call	0x32c0	; 0x32c0 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1e3c:	81 e0       	ldi	r24, 0x01	; 1
    1e3e:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1e40:	0f 90       	pop	r0
    1e42:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    1e44:	0e 94 da 15 	call	0x2bb4	; 0x2bb4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1e48:	0f b6       	in	r0, 0x3f	; 63
    1e4a:	f8 94       	cli
    1e4c:	0f 92       	push	r0
    1e4e:	ea 81       	ldd	r30, Y+2	; 0x02
    1e50:	fb 81       	ldd	r31, Y+3	; 0x03
    1e52:	85 8d       	ldd	r24, Z+29	; 0x1d
    1e54:	8f 3f       	cpi	r24, 0xFF	; 255
    1e56:	19 f4       	brne	.+6      	; 0x1e5e <xQueueSemaphoreTake+0xaa>
    1e58:	ea 81       	ldd	r30, Y+2	; 0x02
    1e5a:	fb 81       	ldd	r31, Y+3	; 0x03
    1e5c:	15 8e       	std	Z+29, r1	; 0x1d
    1e5e:	ea 81       	ldd	r30, Y+2	; 0x02
    1e60:	fb 81       	ldd	r31, Y+3	; 0x03
    1e62:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e64:	8f 3f       	cpi	r24, 0xFF	; 255
    1e66:	19 f4       	brne	.+6      	; 0x1e6e <xQueueSemaphoreTake+0xba>
    1e68:	ea 81       	ldd	r30, Y+2	; 0x02
    1e6a:	fb 81       	ldd	r31, Y+3	; 0x03
    1e6c:	16 8e       	std	Z+30, r1	; 0x1e
    1e6e:	0f 90       	pop	r0
    1e70:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1e72:	ce 01       	movw	r24, r28
    1e74:	05 96       	adiw	r24, 0x05	; 5
    1e76:	9e 01       	movw	r18, r28
    1e78:	26 5f       	subi	r18, 0xF6	; 246
    1e7a:	3f 4f       	sbci	r19, 0xFF	; 255
    1e7c:	b9 01       	movw	r22, r18
    1e7e:	0e 94 79 19 	call	0x32f2	; 0x32f2 <xTaskCheckForTimeOut>
    1e82:	88 23       	and	r24, r24
    1e84:	09 f5       	brne	.+66     	; 0x1ec8 <xQueueSemaphoreTake+0x114>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1e86:	8a 81       	ldd	r24, Y+2	; 0x02
    1e88:	9b 81       	ldd	r25, Y+3	; 0x03
    1e8a:	0e 94 6c 12 	call	0x24d8	; 0x24d8 <prvIsQueueEmpty>
    1e8e:	88 23       	and	r24, r24
    1e90:	a1 f0       	breq	.+40     	; 0x1eba <xQueueSemaphoreTake+0x106>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1e92:	8a 81       	ldd	r24, Y+2	; 0x02
    1e94:	9b 81       	ldd	r25, Y+3	; 0x03
    1e96:	41 96       	adiw	r24, 0x11	; 17
    1e98:	2a 85       	ldd	r18, Y+10	; 0x0a
    1e9a:	3b 85       	ldd	r19, Y+11	; 0x0b
    1e9c:	b9 01       	movw	r22, r18
    1e9e:	0e 94 28 18 	call	0x3050	; 0x3050 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1ea2:	8a 81       	ldd	r24, Y+2	; 0x02
    1ea4:	9b 81       	ldd	r25, Y+3	; 0x03
    1ea6:	0e 94 19 12 	call	0x2432	; 0x2432 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1eaa:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <xTaskResumeAll>
    1eae:	88 23       	and	r24, r24
    1eb0:	09 f0       	breq	.+2      	; 0x1eb4 <xQueueSemaphoreTake+0x100>
    1eb2:	93 cf       	rjmp	.-218    	; 0x1dda <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    1eb4:	0e 94 b3 0a 	call	0x1566	; 0x1566 <vPortYield>
    1eb8:	90 cf       	rjmp	.-224    	; 0x1dda <xQueueSemaphoreTake+0x26>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    1eba:	8a 81       	ldd	r24, Y+2	; 0x02
    1ebc:	9b 81       	ldd	r25, Y+3	; 0x03
    1ebe:	0e 94 19 12 	call	0x2432	; 0x2432 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1ec2:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <xTaskResumeAll>
    1ec6:	89 cf       	rjmp	.-238    	; 0x1dda <xQueueSemaphoreTake+0x26>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    1ec8:	8a 81       	ldd	r24, Y+2	; 0x02
    1eca:	9b 81       	ldd	r25, Y+3	; 0x03
    1ecc:	0e 94 19 12 	call	0x2432	; 0x2432 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1ed0:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1ed4:	8a 81       	ldd	r24, Y+2	; 0x02
    1ed6:	9b 81       	ldd	r25, Y+3	; 0x03
    1ed8:	0e 94 6c 12 	call	0x24d8	; 0x24d8 <prvIsQueueEmpty>
    1edc:	88 23       	and	r24, r24
    1ede:	09 f4       	brne	.+2      	; 0x1ee2 <xQueueSemaphoreTake+0x12e>
    1ee0:	7c cf       	rjmp	.-264    	; 0x1dda <xQueueSemaphoreTake+0x26>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1ee2:	1c 86       	std	Y+12, r1	; 0x0c
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    1ee4:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    1ee6:	2c 96       	adiw	r28, 0x0c	; 12
    1ee8:	0f b6       	in	r0, 0x3f	; 63
    1eea:	f8 94       	cli
    1eec:	de bf       	out	0x3e, r29	; 62
    1eee:	0f be       	out	0x3f, r0	; 63
    1ef0:	cd bf       	out	0x3d, r28	; 61
    1ef2:	cf 91       	pop	r28
    1ef4:	df 91       	pop	r29
    1ef6:	08 95       	ret

00001ef8 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1ef8:	df 93       	push	r29
    1efa:	cf 93       	push	r28
    1efc:	cd b7       	in	r28, 0x3d	; 61
    1efe:	de b7       	in	r29, 0x3e	; 62
    1f00:	60 97       	sbiw	r28, 0x10	; 16
    1f02:	0f b6       	in	r0, 0x3f	; 63
    1f04:	f8 94       	cli
    1f06:	de bf       	out	0x3e, r29	; 62
    1f08:	0f be       	out	0x3f, r0	; 63
    1f0a:	cd bf       	out	0x3d, r28	; 61
    1f0c:	9b 87       	std	Y+11, r25	; 0x0b
    1f0e:	8a 87       	std	Y+10, r24	; 0x0a
    1f10:	7d 87       	std	Y+13, r23	; 0x0d
    1f12:	6c 87       	std	Y+12, r22	; 0x0c
    1f14:	5f 87       	std	Y+15, r21	; 0x0f
    1f16:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    1f18:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    1f1a:	8a 85       	ldd	r24, Y+10	; 0x0a
    1f1c:	9b 85       	ldd	r25, Y+11	; 0x0b
    1f1e:	9b 83       	std	Y+3, r25	; 0x03
    1f20:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1f22:	0f b6       	in	r0, 0x3f	; 63
    1f24:	f8 94       	cli
    1f26:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1f28:	ea 81       	ldd	r30, Y+2	; 0x02
    1f2a:	fb 81       	ldd	r31, Y+3	; 0x03
    1f2c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f2e:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1f30:	89 81       	ldd	r24, Y+1	; 0x01
    1f32:	88 23       	and	r24, r24
    1f34:	31 f1       	breq	.+76     	; 0x1f82 <xQueuePeek+0x8a>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1f36:	ea 81       	ldd	r30, Y+2	; 0x02
    1f38:	fb 81       	ldd	r31, Y+3	; 0x03
    1f3a:	86 81       	ldd	r24, Z+6	; 0x06
    1f3c:	97 81       	ldd	r25, Z+7	; 0x07
    1f3e:	9d 83       	std	Y+5, r25	; 0x05
    1f40:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1f42:	8a 81       	ldd	r24, Y+2	; 0x02
    1f44:	9b 81       	ldd	r25, Y+3	; 0x03
    1f46:	2c 85       	ldd	r18, Y+12	; 0x0c
    1f48:	3d 85       	ldd	r19, Y+13	; 0x0d
    1f4a:	b9 01       	movw	r22, r18
    1f4c:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1f50:	ea 81       	ldd	r30, Y+2	; 0x02
    1f52:	fb 81       	ldd	r31, Y+3	; 0x03
    1f54:	8c 81       	ldd	r24, Y+4	; 0x04
    1f56:	9d 81       	ldd	r25, Y+5	; 0x05
    1f58:	97 83       	std	Z+7, r25	; 0x07
    1f5a:	86 83       	std	Z+6, r24	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1f5c:	ea 81       	ldd	r30, Y+2	; 0x02
    1f5e:	fb 81       	ldd	r31, Y+3	; 0x03
    1f60:	81 89       	ldd	r24, Z+17	; 0x11
    1f62:	88 23       	and	r24, r24
    1f64:	49 f0       	breq	.+18     	; 0x1f78 <xQueuePeek+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1f66:	8a 81       	ldd	r24, Y+2	; 0x02
    1f68:	9b 81       	ldd	r25, Y+3	; 0x03
    1f6a:	41 96       	adiw	r24, 0x11	; 17
    1f6c:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <xTaskRemoveFromEventList>
    1f70:	88 23       	and	r24, r24
    1f72:	11 f0       	breq	.+4      	; 0x1f78 <xQueuePeek+0x80>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    1f74:	0e 94 b3 0a 	call	0x1566	; 0x1566 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1f78:	0f 90       	pop	r0
    1f7a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1f7c:	81 e0       	ldi	r24, 0x01	; 1
    1f7e:	88 8b       	std	Y+16, r24	; 0x10
    1f80:	63 c0       	rjmp	.+198    	; 0x2048 <xQueuePeek+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1f82:	8e 85       	ldd	r24, Y+14	; 0x0e
    1f84:	9f 85       	ldd	r25, Y+15	; 0x0f
    1f86:	00 97       	sbiw	r24, 0x00	; 0
    1f88:	21 f4       	brne	.+8      	; 0x1f92 <xQueuePeek+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1f8a:	0f 90       	pop	r0
    1f8c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1f8e:	18 8a       	std	Y+16, r1	; 0x10
    1f90:	5b c0       	rjmp	.+182    	; 0x2048 <xQueuePeek+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    1f92:	8e 81       	ldd	r24, Y+6	; 0x06
    1f94:	88 23       	and	r24, r24
    1f96:	31 f4       	brne	.+12     	; 0x1fa4 <xQueuePeek+0xac>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1f98:	ce 01       	movw	r24, r28
    1f9a:	07 96       	adiw	r24, 0x07	; 7
    1f9c:	0e 94 60 19 	call	0x32c0	; 0x32c0 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1fa0:	81 e0       	ldi	r24, 0x01	; 1
    1fa2:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1fa4:	0f 90       	pop	r0
    1fa6:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1fa8:	0e 94 da 15 	call	0x2bb4	; 0x2bb4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1fac:	0f b6       	in	r0, 0x3f	; 63
    1fae:	f8 94       	cli
    1fb0:	0f 92       	push	r0
    1fb2:	ea 81       	ldd	r30, Y+2	; 0x02
    1fb4:	fb 81       	ldd	r31, Y+3	; 0x03
    1fb6:	85 8d       	ldd	r24, Z+29	; 0x1d
    1fb8:	8f 3f       	cpi	r24, 0xFF	; 255
    1fba:	19 f4       	brne	.+6      	; 0x1fc2 <xQueuePeek+0xca>
    1fbc:	ea 81       	ldd	r30, Y+2	; 0x02
    1fbe:	fb 81       	ldd	r31, Y+3	; 0x03
    1fc0:	15 8e       	std	Z+29, r1	; 0x1d
    1fc2:	ea 81       	ldd	r30, Y+2	; 0x02
    1fc4:	fb 81       	ldd	r31, Y+3	; 0x03
    1fc6:	86 8d       	ldd	r24, Z+30	; 0x1e
    1fc8:	8f 3f       	cpi	r24, 0xFF	; 255
    1fca:	19 f4       	brne	.+6      	; 0x1fd2 <xQueuePeek+0xda>
    1fcc:	ea 81       	ldd	r30, Y+2	; 0x02
    1fce:	fb 81       	ldd	r31, Y+3	; 0x03
    1fd0:	16 8e       	std	Z+30, r1	; 0x1e
    1fd2:	0f 90       	pop	r0
    1fd4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1fd6:	ce 01       	movw	r24, r28
    1fd8:	07 96       	adiw	r24, 0x07	; 7
    1fda:	9e 01       	movw	r18, r28
    1fdc:	22 5f       	subi	r18, 0xF2	; 242
    1fde:	3f 4f       	sbci	r19, 0xFF	; 255
    1fe0:	b9 01       	movw	r22, r18
    1fe2:	0e 94 79 19 	call	0x32f2	; 0x32f2 <xTaskCheckForTimeOut>
    1fe6:	88 23       	and	r24, r24
    1fe8:	09 f5       	brne	.+66     	; 0x202c <xQueuePeek+0x134>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1fea:	8a 81       	ldd	r24, Y+2	; 0x02
    1fec:	9b 81       	ldd	r25, Y+3	; 0x03
    1fee:	0e 94 6c 12 	call	0x24d8	; 0x24d8 <prvIsQueueEmpty>
    1ff2:	88 23       	and	r24, r24
    1ff4:	a1 f0       	breq	.+40     	; 0x201e <xQueuePeek+0x126>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1ff6:	8a 81       	ldd	r24, Y+2	; 0x02
    1ff8:	9b 81       	ldd	r25, Y+3	; 0x03
    1ffa:	41 96       	adiw	r24, 0x11	; 17
    1ffc:	2e 85       	ldd	r18, Y+14	; 0x0e
    1ffe:	3f 85       	ldd	r19, Y+15	; 0x0f
    2000:	b9 01       	movw	r22, r18
    2002:	0e 94 28 18 	call	0x3050	; 0x3050 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2006:	8a 81       	ldd	r24, Y+2	; 0x02
    2008:	9b 81       	ldd	r25, Y+3	; 0x03
    200a:	0e 94 19 12 	call	0x2432	; 0x2432 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    200e:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <xTaskResumeAll>
    2012:	88 23       	and	r24, r24
    2014:	09 f0       	breq	.+2      	; 0x2018 <xQueuePeek+0x120>
    2016:	85 cf       	rjmp	.-246    	; 0x1f22 <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    2018:	0e 94 b3 0a 	call	0x1566	; 0x1566 <vPortYield>
    201c:	82 cf       	rjmp	.-252    	; 0x1f22 <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    201e:	8a 81       	ldd	r24, Y+2	; 0x02
    2020:	9b 81       	ldd	r25, Y+3	; 0x03
    2022:	0e 94 19 12 	call	0x2432	; 0x2432 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2026:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <xTaskResumeAll>
    202a:	7b cf       	rjmp	.-266    	; 0x1f22 <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    202c:	8a 81       	ldd	r24, Y+2	; 0x02
    202e:	9b 81       	ldd	r25, Y+3	; 0x03
    2030:	0e 94 19 12 	call	0x2432	; 0x2432 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2034:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2038:	8a 81       	ldd	r24, Y+2	; 0x02
    203a:	9b 81       	ldd	r25, Y+3	; 0x03
    203c:	0e 94 6c 12 	call	0x24d8	; 0x24d8 <prvIsQueueEmpty>
    2040:	88 23       	and	r24, r24
    2042:	09 f4       	brne	.+2      	; 0x2046 <xQueuePeek+0x14e>
    2044:	6e cf       	rjmp	.-292    	; 0x1f22 <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    2046:	18 8a       	std	Y+16, r1	; 0x10
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    2048:	88 89       	ldd	r24, Y+16	; 0x10
}
    204a:	60 96       	adiw	r28, 0x10	; 16
    204c:	0f b6       	in	r0, 0x3f	; 63
    204e:	f8 94       	cli
    2050:	de bf       	out	0x3e, r29	; 62
    2052:	0f be       	out	0x3f, r0	; 63
    2054:	cd bf       	out	0x3d, r28	; 61
    2056:	cf 91       	pop	r28
    2058:	df 91       	pop	r29
    205a:	08 95       	ret

0000205c <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    205c:	df 93       	push	r29
    205e:	cf 93       	push	r28
    2060:	cd b7       	in	r28, 0x3d	; 61
    2062:	de b7       	in	r29, 0x3e	; 62
    2064:	2c 97       	sbiw	r28, 0x0c	; 12
    2066:	0f b6       	in	r0, 0x3f	; 63
    2068:	f8 94       	cli
    206a:	de bf       	out	0x3e, r29	; 62
    206c:	0f be       	out	0x3f, r0	; 63
    206e:	cd bf       	out	0x3d, r28	; 61
    2070:	98 87       	std	Y+8, r25	; 0x08
    2072:	8f 83       	std	Y+7, r24	; 0x07
    2074:	7a 87       	std	Y+10, r23	; 0x0a
    2076:	69 87       	std	Y+9, r22	; 0x09
    2078:	5c 87       	std	Y+12, r21	; 0x0c
    207a:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    207c:	8f 81       	ldd	r24, Y+7	; 0x07
    207e:	98 85       	ldd	r25, Y+8	; 0x08
    2080:	9c 83       	std	Y+4, r25	; 0x04
    2082:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2084:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2086:	eb 81       	ldd	r30, Y+3	; 0x03
    2088:	fc 81       	ldd	r31, Y+4	; 0x04
    208a:	82 8d       	ldd	r24, Z+26	; 0x1a
    208c:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    208e:	8a 81       	ldd	r24, Y+2	; 0x02
    2090:	88 23       	and	r24, r24
    2092:	81 f1       	breq	.+96     	; 0x20f4 <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    2094:	eb 81       	ldd	r30, Y+3	; 0x03
    2096:	fc 81       	ldd	r31, Y+4	; 0x04
    2098:	85 8d       	ldd	r24, Z+29	; 0x1d
    209a:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    209c:	8b 81       	ldd	r24, Y+3	; 0x03
    209e:	9c 81       	ldd	r25, Y+4	; 0x04
    20a0:	29 85       	ldd	r18, Y+9	; 0x09
    20a2:	3a 85       	ldd	r19, Y+10	; 0x0a
    20a4:	b9 01       	movw	r22, r18
    20a6:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    20aa:	8a 81       	ldd	r24, Y+2	; 0x02
    20ac:	81 50       	subi	r24, 0x01	; 1
    20ae:	eb 81       	ldd	r30, Y+3	; 0x03
    20b0:	fc 81       	ldd	r31, Y+4	; 0x04
    20b2:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    20b4:	89 81       	ldd	r24, Y+1	; 0x01
    20b6:	8f 3f       	cpi	r24, 0xFF	; 255
    20b8:	a9 f4       	brne	.+42     	; 0x20e4 <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    20ba:	eb 81       	ldd	r30, Y+3	; 0x03
    20bc:	fc 81       	ldd	r31, Y+4	; 0x04
    20be:	80 85       	ldd	r24, Z+8	; 0x08
    20c0:	88 23       	and	r24, r24
    20c2:	a9 f0       	breq	.+42     	; 0x20ee <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    20c4:	8b 81       	ldd	r24, Y+3	; 0x03
    20c6:	9c 81       	ldd	r25, Y+4	; 0x04
    20c8:	08 96       	adiw	r24, 0x08	; 8
    20ca:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <xTaskRemoveFromEventList>
    20ce:	88 23       	and	r24, r24
    20d0:	71 f0       	breq	.+28     	; 0x20ee <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    20d2:	8b 85       	ldd	r24, Y+11	; 0x0b
    20d4:	9c 85       	ldd	r25, Y+12	; 0x0c
    20d6:	00 97       	sbiw	r24, 0x00	; 0
    20d8:	51 f0       	breq	.+20     	; 0x20ee <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    20da:	eb 85       	ldd	r30, Y+11	; 0x0b
    20dc:	fc 85       	ldd	r31, Y+12	; 0x0c
    20de:	81 e0       	ldi	r24, 0x01	; 1
    20e0:	80 83       	st	Z, r24
    20e2:	05 c0       	rjmp	.+10     	; 0x20ee <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    20e4:	89 81       	ldd	r24, Y+1	; 0x01
    20e6:	8f 5f       	subi	r24, 0xFF	; 255
    20e8:	eb 81       	ldd	r30, Y+3	; 0x03
    20ea:	fc 81       	ldd	r31, Y+4	; 0x04
    20ec:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    20ee:	81 e0       	ldi	r24, 0x01	; 1
    20f0:	8e 83       	std	Y+6, r24	; 0x06
    20f2:	01 c0       	rjmp	.+2      	; 0x20f6 <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    20f4:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    20f6:	8e 81       	ldd	r24, Y+6	; 0x06
}
    20f8:	2c 96       	adiw	r28, 0x0c	; 12
    20fa:	0f b6       	in	r0, 0x3f	; 63
    20fc:	f8 94       	cli
    20fe:	de bf       	out	0x3e, r29	; 62
    2100:	0f be       	out	0x3f, r0	; 63
    2102:	cd bf       	out	0x3d, r28	; 61
    2104:	cf 91       	pop	r28
    2106:	df 91       	pop	r29
    2108:	08 95       	ret

0000210a <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    210a:	df 93       	push	r29
    210c:	cf 93       	push	r28
    210e:	cd b7       	in	r28, 0x3d	; 61
    2110:	de b7       	in	r29, 0x3e	; 62
    2112:	2a 97       	sbiw	r28, 0x0a	; 10
    2114:	0f b6       	in	r0, 0x3f	; 63
    2116:	f8 94       	cli
    2118:	de bf       	out	0x3e, r29	; 62
    211a:	0f be       	out	0x3f, r0	; 63
    211c:	cd bf       	out	0x3d, r28	; 61
    211e:	98 87       	std	Y+8, r25	; 0x08
    2120:	8f 83       	std	Y+7, r24	; 0x07
    2122:	7a 87       	std	Y+10, r23	; 0x0a
    2124:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    2126:	8f 81       	ldd	r24, Y+7	; 0x07
    2128:	98 85       	ldd	r25, Y+8	; 0x08
    212a:	9a 83       	std	Y+2, r25	; 0x02
    212c:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    212e:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2130:	e9 81       	ldd	r30, Y+1	; 0x01
    2132:	fa 81       	ldd	r31, Y+2	; 0x02
    2134:	82 8d       	ldd	r24, Z+26	; 0x1a
    2136:	88 23       	and	r24, r24
    2138:	b1 f0       	breq	.+44     	; 0x2166 <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    213a:	e9 81       	ldd	r30, Y+1	; 0x01
    213c:	fa 81       	ldd	r31, Y+2	; 0x02
    213e:	86 81       	ldd	r24, Z+6	; 0x06
    2140:	97 81       	ldd	r25, Z+7	; 0x07
    2142:	9c 83       	std	Y+4, r25	; 0x04
    2144:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2146:	89 81       	ldd	r24, Y+1	; 0x01
    2148:	9a 81       	ldd	r25, Y+2	; 0x02
    214a:	29 85       	ldd	r18, Y+9	; 0x09
    214c:	3a 85       	ldd	r19, Y+10	; 0x0a
    214e:	b9 01       	movw	r22, r18
    2150:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2154:	e9 81       	ldd	r30, Y+1	; 0x01
    2156:	fa 81       	ldd	r31, Y+2	; 0x02
    2158:	8b 81       	ldd	r24, Y+3	; 0x03
    215a:	9c 81       	ldd	r25, Y+4	; 0x04
    215c:	97 83       	std	Z+7, r25	; 0x07
    215e:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    2160:	81 e0       	ldi	r24, 0x01	; 1
    2162:	8e 83       	std	Y+6, r24	; 0x06
    2164:	01 c0       	rjmp	.+2      	; 0x2168 <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    2166:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2168:	8e 81       	ldd	r24, Y+6	; 0x06
}
    216a:	2a 96       	adiw	r28, 0x0a	; 10
    216c:	0f b6       	in	r0, 0x3f	; 63
    216e:	f8 94       	cli
    2170:	de bf       	out	0x3e, r29	; 62
    2172:	0f be       	out	0x3f, r0	; 63
    2174:	cd bf       	out	0x3d, r28	; 61
    2176:	cf 91       	pop	r28
    2178:	df 91       	pop	r29
    217a:	08 95       	ret

0000217c <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    217c:	df 93       	push	r29
    217e:	cf 93       	push	r28
    2180:	00 d0       	rcall	.+0      	; 0x2182 <uxQueueMessagesWaiting+0x6>
    2182:	0f 92       	push	r0
    2184:	cd b7       	in	r28, 0x3d	; 61
    2186:	de b7       	in	r29, 0x3e	; 62
    2188:	9b 83       	std	Y+3, r25	; 0x03
    218a:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    218c:	0f b6       	in	r0, 0x3f	; 63
    218e:	f8 94       	cli
    2190:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    2192:	ea 81       	ldd	r30, Y+2	; 0x02
    2194:	fb 81       	ldd	r31, Y+3	; 0x03
    2196:	82 8d       	ldd	r24, Z+26	; 0x1a
    2198:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    219a:	0f 90       	pop	r0
    219c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    219e:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    21a0:	0f 90       	pop	r0
    21a2:	0f 90       	pop	r0
    21a4:	0f 90       	pop	r0
    21a6:	cf 91       	pop	r28
    21a8:	df 91       	pop	r29
    21aa:	08 95       	ret

000021ac <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    21ac:	df 93       	push	r29
    21ae:	cf 93       	push	r28
    21b0:	00 d0       	rcall	.+0      	; 0x21b2 <uxQueueSpacesAvailable+0x6>
    21b2:	00 d0       	rcall	.+0      	; 0x21b4 <uxQueueSpacesAvailable+0x8>
    21b4:	0f 92       	push	r0
    21b6:	cd b7       	in	r28, 0x3d	; 61
    21b8:	de b7       	in	r29, 0x3e	; 62
    21ba:	9d 83       	std	Y+5, r25	; 0x05
    21bc:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    21be:	8c 81       	ldd	r24, Y+4	; 0x04
    21c0:	9d 81       	ldd	r25, Y+5	; 0x05
    21c2:	9a 83       	std	Y+2, r25	; 0x02
    21c4:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    21c6:	0f b6       	in	r0, 0x3f	; 63
    21c8:	f8 94       	cli
    21ca:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    21cc:	e9 81       	ldd	r30, Y+1	; 0x01
    21ce:	fa 81       	ldd	r31, Y+2	; 0x02
    21d0:	93 8d       	ldd	r25, Z+27	; 0x1b
    21d2:	e9 81       	ldd	r30, Y+1	; 0x01
    21d4:	fa 81       	ldd	r31, Y+2	; 0x02
    21d6:	82 8d       	ldd	r24, Z+26	; 0x1a
    21d8:	29 2f       	mov	r18, r25
    21da:	28 1b       	sub	r18, r24
    21dc:	82 2f       	mov	r24, r18
    21de:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    21e0:	0f 90       	pop	r0
    21e2:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    21e4:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    21e6:	0f 90       	pop	r0
    21e8:	0f 90       	pop	r0
    21ea:	0f 90       	pop	r0
    21ec:	0f 90       	pop	r0
    21ee:	0f 90       	pop	r0
    21f0:	cf 91       	pop	r28
    21f2:	df 91       	pop	r29
    21f4:	08 95       	ret

000021f6 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    21f6:	df 93       	push	r29
    21f8:	cf 93       	push	r28
    21fa:	00 d0       	rcall	.+0      	; 0x21fc <uxQueueMessagesWaitingFromISR+0x6>
    21fc:	00 d0       	rcall	.+0      	; 0x21fe <uxQueueMessagesWaitingFromISR+0x8>
    21fe:	0f 92       	push	r0
    2200:	cd b7       	in	r28, 0x3d	; 61
    2202:	de b7       	in	r29, 0x3e	; 62
    2204:	9d 83       	std	Y+5, r25	; 0x05
    2206:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    2208:	8c 81       	ldd	r24, Y+4	; 0x04
    220a:	9d 81       	ldd	r25, Y+5	; 0x05
    220c:	9a 83       	std	Y+2, r25	; 0x02
    220e:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    2210:	e9 81       	ldd	r30, Y+1	; 0x01
    2212:	fa 81       	ldd	r31, Y+2	; 0x02
    2214:	82 8d       	ldd	r24, Z+26	; 0x1a
    2216:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    2218:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    221a:	0f 90       	pop	r0
    221c:	0f 90       	pop	r0
    221e:	0f 90       	pop	r0
    2220:	0f 90       	pop	r0
    2222:	0f 90       	pop	r0
    2224:	cf 91       	pop	r28
    2226:	df 91       	pop	r29
    2228:	08 95       	ret

0000222a <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    222a:	df 93       	push	r29
    222c:	cf 93       	push	r28
    222e:	00 d0       	rcall	.+0      	; 0x2230 <vQueueDelete+0x6>
    2230:	00 d0       	rcall	.+0      	; 0x2232 <vQueueDelete+0x8>
    2232:	cd b7       	in	r28, 0x3d	; 61
    2234:	de b7       	in	r29, 0x3e	; 62
    2236:	9c 83       	std	Y+4, r25	; 0x04
    2238:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    223a:	8b 81       	ldd	r24, Y+3	; 0x03
    223c:	9c 81       	ldd	r25, Y+4	; 0x04
    223e:	9a 83       	std	Y+2, r25	; 0x02
    2240:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    2242:	89 81       	ldd	r24, Y+1	; 0x01
    2244:	9a 81       	ldd	r25, Y+2	; 0x02
    2246:	0e 94 05 07 	call	0xe0a	; 0xe0a <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    224a:	0f 90       	pop	r0
    224c:	0f 90       	pop	r0
    224e:	0f 90       	pop	r0
    2250:	0f 90       	pop	r0
    2252:	cf 91       	pop	r28
    2254:	df 91       	pop	r29
    2256:	08 95       	ret

00002258 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    2258:	df 93       	push	r29
    225a:	cf 93       	push	r28
    225c:	cd b7       	in	r28, 0x3d	; 61
    225e:	de b7       	in	r29, 0x3e	; 62
    2260:	27 97       	sbiw	r28, 0x07	; 7
    2262:	0f b6       	in	r0, 0x3f	; 63
    2264:	f8 94       	cli
    2266:	de bf       	out	0x3e, r29	; 62
    2268:	0f be       	out	0x3f, r0	; 63
    226a:	cd bf       	out	0x3d, r28	; 61
    226c:	9c 83       	std	Y+4, r25	; 0x04
    226e:	8b 83       	std	Y+3, r24	; 0x03
    2270:	7e 83       	std	Y+6, r23	; 0x06
    2272:	6d 83       	std	Y+5, r22	; 0x05
    2274:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    2276:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2278:	eb 81       	ldd	r30, Y+3	; 0x03
    227a:	fc 81       	ldd	r31, Y+4	; 0x04
    227c:	82 8d       	ldd	r24, Z+26	; 0x1a
    227e:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    2280:	eb 81       	ldd	r30, Y+3	; 0x03
    2282:	fc 81       	ldd	r31, Y+4	; 0x04
    2284:	84 8d       	ldd	r24, Z+28	; 0x1c
    2286:	88 23       	and	r24, r24
    2288:	09 f4       	brne	.+2      	; 0x228c <prvCopyDataToQueue+0x34>
    228a:	7d c0       	rjmp	.+250    	; 0x2386 <prvCopyDataToQueue+0x12e>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    228c:	8f 81       	ldd	r24, Y+7	; 0x07
    228e:	88 23       	and	r24, r24
    2290:	99 f5       	brne	.+102    	; 0x22f8 <prvCopyDataToQueue+0xa0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2292:	eb 81       	ldd	r30, Y+3	; 0x03
    2294:	fc 81       	ldd	r31, Y+4	; 0x04
    2296:	62 81       	ldd	r22, Z+2	; 0x02
    2298:	73 81       	ldd	r23, Z+3	; 0x03
    229a:	eb 81       	ldd	r30, Y+3	; 0x03
    229c:	fc 81       	ldd	r31, Y+4	; 0x04
    229e:	84 8d       	ldd	r24, Z+28	; 0x1c
    22a0:	48 2f       	mov	r20, r24
    22a2:	50 e0       	ldi	r21, 0x00	; 0
    22a4:	2d 81       	ldd	r18, Y+5	; 0x05
    22a6:	3e 81       	ldd	r19, Y+6	; 0x06
    22a8:	cb 01       	movw	r24, r22
    22aa:	b9 01       	movw	r22, r18
    22ac:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    22b0:	eb 81       	ldd	r30, Y+3	; 0x03
    22b2:	fc 81       	ldd	r31, Y+4	; 0x04
    22b4:	22 81       	ldd	r18, Z+2	; 0x02
    22b6:	33 81       	ldd	r19, Z+3	; 0x03
    22b8:	eb 81       	ldd	r30, Y+3	; 0x03
    22ba:	fc 81       	ldd	r31, Y+4	; 0x04
    22bc:	84 8d       	ldd	r24, Z+28	; 0x1c
    22be:	88 2f       	mov	r24, r24
    22c0:	90 e0       	ldi	r25, 0x00	; 0
    22c2:	82 0f       	add	r24, r18
    22c4:	93 1f       	adc	r25, r19
    22c6:	eb 81       	ldd	r30, Y+3	; 0x03
    22c8:	fc 81       	ldd	r31, Y+4	; 0x04
    22ca:	93 83       	std	Z+3, r25	; 0x03
    22cc:	82 83       	std	Z+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    22ce:	eb 81       	ldd	r30, Y+3	; 0x03
    22d0:	fc 81       	ldd	r31, Y+4	; 0x04
    22d2:	22 81       	ldd	r18, Z+2	; 0x02
    22d4:	33 81       	ldd	r19, Z+3	; 0x03
    22d6:	eb 81       	ldd	r30, Y+3	; 0x03
    22d8:	fc 81       	ldd	r31, Y+4	; 0x04
    22da:	84 81       	ldd	r24, Z+4	; 0x04
    22dc:	95 81       	ldd	r25, Z+5	; 0x05
    22de:	28 17       	cp	r18, r24
    22e0:	39 07       	cpc	r19, r25
    22e2:	08 f4       	brcc	.+2      	; 0x22e6 <prvCopyDataToQueue+0x8e>
    22e4:	50 c0       	rjmp	.+160    	; 0x2386 <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    22e6:	eb 81       	ldd	r30, Y+3	; 0x03
    22e8:	fc 81       	ldd	r31, Y+4	; 0x04
    22ea:	80 81       	ld	r24, Z
    22ec:	91 81       	ldd	r25, Z+1	; 0x01
    22ee:	eb 81       	ldd	r30, Y+3	; 0x03
    22f0:	fc 81       	ldd	r31, Y+4	; 0x04
    22f2:	93 83       	std	Z+3, r25	; 0x03
    22f4:	82 83       	std	Z+2, r24	; 0x02
    22f6:	47 c0       	rjmp	.+142    	; 0x2386 <prvCopyDataToQueue+0x12e>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    22f8:	eb 81       	ldd	r30, Y+3	; 0x03
    22fa:	fc 81       	ldd	r31, Y+4	; 0x04
    22fc:	66 81       	ldd	r22, Z+6	; 0x06
    22fe:	77 81       	ldd	r23, Z+7	; 0x07
    2300:	eb 81       	ldd	r30, Y+3	; 0x03
    2302:	fc 81       	ldd	r31, Y+4	; 0x04
    2304:	84 8d       	ldd	r24, Z+28	; 0x1c
    2306:	48 2f       	mov	r20, r24
    2308:	50 e0       	ldi	r21, 0x00	; 0
    230a:	2d 81       	ldd	r18, Y+5	; 0x05
    230c:	3e 81       	ldd	r19, Y+6	; 0x06
    230e:	cb 01       	movw	r24, r22
    2310:	b9 01       	movw	r22, r18
    2312:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    2316:	eb 81       	ldd	r30, Y+3	; 0x03
    2318:	fc 81       	ldd	r31, Y+4	; 0x04
    231a:	26 81       	ldd	r18, Z+6	; 0x06
    231c:	37 81       	ldd	r19, Z+7	; 0x07
    231e:	eb 81       	ldd	r30, Y+3	; 0x03
    2320:	fc 81       	ldd	r31, Y+4	; 0x04
    2322:	84 8d       	ldd	r24, Z+28	; 0x1c
    2324:	88 2f       	mov	r24, r24
    2326:	90 e0       	ldi	r25, 0x00	; 0
    2328:	90 95       	com	r25
    232a:	81 95       	neg	r24
    232c:	9f 4f       	sbci	r25, 0xFF	; 255
    232e:	82 0f       	add	r24, r18
    2330:	93 1f       	adc	r25, r19
    2332:	eb 81       	ldd	r30, Y+3	; 0x03
    2334:	fc 81       	ldd	r31, Y+4	; 0x04
    2336:	97 83       	std	Z+7, r25	; 0x07
    2338:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    233a:	eb 81       	ldd	r30, Y+3	; 0x03
    233c:	fc 81       	ldd	r31, Y+4	; 0x04
    233e:	26 81       	ldd	r18, Z+6	; 0x06
    2340:	37 81       	ldd	r19, Z+7	; 0x07
    2342:	eb 81       	ldd	r30, Y+3	; 0x03
    2344:	fc 81       	ldd	r31, Y+4	; 0x04
    2346:	80 81       	ld	r24, Z
    2348:	91 81       	ldd	r25, Z+1	; 0x01
    234a:	28 17       	cp	r18, r24
    234c:	39 07       	cpc	r19, r25
    234e:	90 f4       	brcc	.+36     	; 0x2374 <prvCopyDataToQueue+0x11c>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    2350:	eb 81       	ldd	r30, Y+3	; 0x03
    2352:	fc 81       	ldd	r31, Y+4	; 0x04
    2354:	24 81       	ldd	r18, Z+4	; 0x04
    2356:	35 81       	ldd	r19, Z+5	; 0x05
    2358:	eb 81       	ldd	r30, Y+3	; 0x03
    235a:	fc 81       	ldd	r31, Y+4	; 0x04
    235c:	84 8d       	ldd	r24, Z+28	; 0x1c
    235e:	88 2f       	mov	r24, r24
    2360:	90 e0       	ldi	r25, 0x00	; 0
    2362:	90 95       	com	r25
    2364:	81 95       	neg	r24
    2366:	9f 4f       	sbci	r25, 0xFF	; 255
    2368:	82 0f       	add	r24, r18
    236a:	93 1f       	adc	r25, r19
    236c:	eb 81       	ldd	r30, Y+3	; 0x03
    236e:	fc 81       	ldd	r31, Y+4	; 0x04
    2370:	97 83       	std	Z+7, r25	; 0x07
    2372:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    2374:	8f 81       	ldd	r24, Y+7	; 0x07
    2376:	82 30       	cpi	r24, 0x02	; 2
    2378:	31 f4       	brne	.+12     	; 0x2386 <prvCopyDataToQueue+0x12e>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    237a:	89 81       	ldd	r24, Y+1	; 0x01
    237c:	88 23       	and	r24, r24
    237e:	19 f0       	breq	.+6      	; 0x2386 <prvCopyDataToQueue+0x12e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    2380:	89 81       	ldd	r24, Y+1	; 0x01
    2382:	81 50       	subi	r24, 0x01	; 1
    2384:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    2386:	89 81       	ldd	r24, Y+1	; 0x01
    2388:	8f 5f       	subi	r24, 0xFF	; 255
    238a:	eb 81       	ldd	r30, Y+3	; 0x03
    238c:	fc 81       	ldd	r31, Y+4	; 0x04
    238e:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    2390:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2392:	27 96       	adiw	r28, 0x07	; 7
    2394:	0f b6       	in	r0, 0x3f	; 63
    2396:	f8 94       	cli
    2398:	de bf       	out	0x3e, r29	; 62
    239a:	0f be       	out	0x3f, r0	; 63
    239c:	cd bf       	out	0x3d, r28	; 61
    239e:	cf 91       	pop	r28
    23a0:	df 91       	pop	r29
    23a2:	08 95       	ret

000023a4 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    23a4:	df 93       	push	r29
    23a6:	cf 93       	push	r28
    23a8:	00 d0       	rcall	.+0      	; 0x23aa <prvCopyDataFromQueue+0x6>
    23aa:	00 d0       	rcall	.+0      	; 0x23ac <prvCopyDataFromQueue+0x8>
    23ac:	cd b7       	in	r28, 0x3d	; 61
    23ae:	de b7       	in	r29, 0x3e	; 62
    23b0:	9a 83       	std	Y+2, r25	; 0x02
    23b2:	89 83       	std	Y+1, r24	; 0x01
    23b4:	7c 83       	std	Y+4, r23	; 0x04
    23b6:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    23b8:	e9 81       	ldd	r30, Y+1	; 0x01
    23ba:	fa 81       	ldd	r31, Y+2	; 0x02
    23bc:	84 8d       	ldd	r24, Z+28	; 0x1c
    23be:	88 23       	and	r24, r24
    23c0:	89 f1       	breq	.+98     	; 0x2424 <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    23c2:	e9 81       	ldd	r30, Y+1	; 0x01
    23c4:	fa 81       	ldd	r31, Y+2	; 0x02
    23c6:	26 81       	ldd	r18, Z+6	; 0x06
    23c8:	37 81       	ldd	r19, Z+7	; 0x07
    23ca:	e9 81       	ldd	r30, Y+1	; 0x01
    23cc:	fa 81       	ldd	r31, Y+2	; 0x02
    23ce:	84 8d       	ldd	r24, Z+28	; 0x1c
    23d0:	88 2f       	mov	r24, r24
    23d2:	90 e0       	ldi	r25, 0x00	; 0
    23d4:	82 0f       	add	r24, r18
    23d6:	93 1f       	adc	r25, r19
    23d8:	e9 81       	ldd	r30, Y+1	; 0x01
    23da:	fa 81       	ldd	r31, Y+2	; 0x02
    23dc:	97 83       	std	Z+7, r25	; 0x07
    23de:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    23e0:	e9 81       	ldd	r30, Y+1	; 0x01
    23e2:	fa 81       	ldd	r31, Y+2	; 0x02
    23e4:	26 81       	ldd	r18, Z+6	; 0x06
    23e6:	37 81       	ldd	r19, Z+7	; 0x07
    23e8:	e9 81       	ldd	r30, Y+1	; 0x01
    23ea:	fa 81       	ldd	r31, Y+2	; 0x02
    23ec:	84 81       	ldd	r24, Z+4	; 0x04
    23ee:	95 81       	ldd	r25, Z+5	; 0x05
    23f0:	28 17       	cp	r18, r24
    23f2:	39 07       	cpc	r19, r25
    23f4:	40 f0       	brcs	.+16     	; 0x2406 <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    23f6:	e9 81       	ldd	r30, Y+1	; 0x01
    23f8:	fa 81       	ldd	r31, Y+2	; 0x02
    23fa:	80 81       	ld	r24, Z
    23fc:	91 81       	ldd	r25, Z+1	; 0x01
    23fe:	e9 81       	ldd	r30, Y+1	; 0x01
    2400:	fa 81       	ldd	r31, Y+2	; 0x02
    2402:	97 83       	std	Z+7, r25	; 0x07
    2404:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2406:	e9 81       	ldd	r30, Y+1	; 0x01
    2408:	fa 81       	ldd	r31, Y+2	; 0x02
    240a:	46 81       	ldd	r20, Z+6	; 0x06
    240c:	57 81       	ldd	r21, Z+7	; 0x07
    240e:	e9 81       	ldd	r30, Y+1	; 0x01
    2410:	fa 81       	ldd	r31, Y+2	; 0x02
    2412:	84 8d       	ldd	r24, Z+28	; 0x1c
    2414:	28 2f       	mov	r18, r24
    2416:	30 e0       	ldi	r19, 0x00	; 0
    2418:	8b 81       	ldd	r24, Y+3	; 0x03
    241a:	9c 81       	ldd	r25, Y+4	; 0x04
    241c:	ba 01       	movw	r22, r20
    241e:	a9 01       	movw	r20, r18
    2420:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <memcpy>
	}
}
    2424:	0f 90       	pop	r0
    2426:	0f 90       	pop	r0
    2428:	0f 90       	pop	r0
    242a:	0f 90       	pop	r0
    242c:	cf 91       	pop	r28
    242e:	df 91       	pop	r29
    2430:	08 95       	ret

00002432 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    2432:	df 93       	push	r29
    2434:	cf 93       	push	r28
    2436:	00 d0       	rcall	.+0      	; 0x2438 <prvUnlockQueue+0x6>
    2438:	00 d0       	rcall	.+0      	; 0x243a <prvUnlockQueue+0x8>
    243a:	cd b7       	in	r28, 0x3d	; 61
    243c:	de b7       	in	r29, 0x3e	; 62
    243e:	9c 83       	std	Y+4, r25	; 0x04
    2440:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    2442:	0f b6       	in	r0, 0x3f	; 63
    2444:	f8 94       	cli
    2446:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    2448:	eb 81       	ldd	r30, Y+3	; 0x03
    244a:	fc 81       	ldd	r31, Y+4	; 0x04
    244c:	86 8d       	ldd	r24, Z+30	; 0x1e
    244e:	8a 83       	std	Y+2, r24	; 0x02
    2450:	11 c0       	rjmp	.+34     	; 0x2474 <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2452:	eb 81       	ldd	r30, Y+3	; 0x03
    2454:	fc 81       	ldd	r31, Y+4	; 0x04
    2456:	81 89       	ldd	r24, Z+17	; 0x11
    2458:	88 23       	and	r24, r24
    245a:	79 f0       	breq	.+30     	; 0x247a <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    245c:	8b 81       	ldd	r24, Y+3	; 0x03
    245e:	9c 81       	ldd	r25, Y+4	; 0x04
    2460:	41 96       	adiw	r24, 0x11	; 17
    2462:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <xTaskRemoveFromEventList>
    2466:	88 23       	and	r24, r24
    2468:	11 f0       	breq	.+4      	; 0x246e <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    246a:	0e 94 dc 19 	call	0x33b8	; 0x33b8 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    246e:	8a 81       	ldd	r24, Y+2	; 0x02
    2470:	81 50       	subi	r24, 0x01	; 1
    2472:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    2474:	8a 81       	ldd	r24, Y+2	; 0x02
    2476:	18 16       	cp	r1, r24
    2478:	64 f3       	brlt	.-40     	; 0x2452 <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    247a:	eb 81       	ldd	r30, Y+3	; 0x03
    247c:	fc 81       	ldd	r31, Y+4	; 0x04
    247e:	8f ef       	ldi	r24, 0xFF	; 255
    2480:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    2482:	0f 90       	pop	r0
    2484:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2486:	0f b6       	in	r0, 0x3f	; 63
    2488:	f8 94       	cli
    248a:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    248c:	eb 81       	ldd	r30, Y+3	; 0x03
    248e:	fc 81       	ldd	r31, Y+4	; 0x04
    2490:	85 8d       	ldd	r24, Z+29	; 0x1d
    2492:	89 83       	std	Y+1, r24	; 0x01
    2494:	11 c0       	rjmp	.+34     	; 0x24b8 <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2496:	eb 81       	ldd	r30, Y+3	; 0x03
    2498:	fc 81       	ldd	r31, Y+4	; 0x04
    249a:	80 85       	ldd	r24, Z+8	; 0x08
    249c:	88 23       	and	r24, r24
    249e:	79 f0       	breq	.+30     	; 0x24be <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    24a0:	8b 81       	ldd	r24, Y+3	; 0x03
    24a2:	9c 81       	ldd	r25, Y+4	; 0x04
    24a4:	08 96       	adiw	r24, 0x08	; 8
    24a6:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <xTaskRemoveFromEventList>
    24aa:	88 23       	and	r24, r24
    24ac:	11 f0       	breq	.+4      	; 0x24b2 <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    24ae:	0e 94 dc 19 	call	0x33b8	; 0x33b8 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    24b2:	89 81       	ldd	r24, Y+1	; 0x01
    24b4:	81 50       	subi	r24, 0x01	; 1
    24b6:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    24b8:	89 81       	ldd	r24, Y+1	; 0x01
    24ba:	18 16       	cp	r1, r24
    24bc:	64 f3       	brlt	.-40     	; 0x2496 <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    24be:	eb 81       	ldd	r30, Y+3	; 0x03
    24c0:	fc 81       	ldd	r31, Y+4	; 0x04
    24c2:	8f ef       	ldi	r24, 0xFF	; 255
    24c4:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    24c6:	0f 90       	pop	r0
    24c8:	0f be       	out	0x3f, r0	; 63
}
    24ca:	0f 90       	pop	r0
    24cc:	0f 90       	pop	r0
    24ce:	0f 90       	pop	r0
    24d0:	0f 90       	pop	r0
    24d2:	cf 91       	pop	r28
    24d4:	df 91       	pop	r29
    24d6:	08 95       	ret

000024d8 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    24d8:	df 93       	push	r29
    24da:	cf 93       	push	r28
    24dc:	00 d0       	rcall	.+0      	; 0x24de <prvIsQueueEmpty+0x6>
    24de:	0f 92       	push	r0
    24e0:	cd b7       	in	r28, 0x3d	; 61
    24e2:	de b7       	in	r29, 0x3e	; 62
    24e4:	9b 83       	std	Y+3, r25	; 0x03
    24e6:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    24e8:	0f b6       	in	r0, 0x3f	; 63
    24ea:	f8 94       	cli
    24ec:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    24ee:	ea 81       	ldd	r30, Y+2	; 0x02
    24f0:	fb 81       	ldd	r31, Y+3	; 0x03
    24f2:	82 8d       	ldd	r24, Z+26	; 0x1a
    24f4:	88 23       	and	r24, r24
    24f6:	19 f4       	brne	.+6      	; 0x24fe <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    24f8:	81 e0       	ldi	r24, 0x01	; 1
    24fa:	89 83       	std	Y+1, r24	; 0x01
    24fc:	01 c0       	rjmp	.+2      	; 0x2500 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    24fe:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2500:	0f 90       	pop	r0
    2502:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2504:	89 81       	ldd	r24, Y+1	; 0x01
}
    2506:	0f 90       	pop	r0
    2508:	0f 90       	pop	r0
    250a:	0f 90       	pop	r0
    250c:	cf 91       	pop	r28
    250e:	df 91       	pop	r29
    2510:	08 95       	ret

00002512 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    2512:	df 93       	push	r29
    2514:	cf 93       	push	r28
    2516:	00 d0       	rcall	.+0      	; 0x2518 <xQueueIsQueueEmptyFromISR+0x6>
    2518:	00 d0       	rcall	.+0      	; 0x251a <xQueueIsQueueEmptyFromISR+0x8>
    251a:	0f 92       	push	r0
    251c:	cd b7       	in	r28, 0x3d	; 61
    251e:	de b7       	in	r29, 0x3e	; 62
    2520:	9d 83       	std	Y+5, r25	; 0x05
    2522:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    2524:	8c 81       	ldd	r24, Y+4	; 0x04
    2526:	9d 81       	ldd	r25, Y+5	; 0x05
    2528:	9a 83       	std	Y+2, r25	; 0x02
    252a:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    252c:	e9 81       	ldd	r30, Y+1	; 0x01
    252e:	fa 81       	ldd	r31, Y+2	; 0x02
    2530:	82 8d       	ldd	r24, Z+26	; 0x1a
    2532:	88 23       	and	r24, r24
    2534:	19 f4       	brne	.+6      	; 0x253c <xQueueIsQueueEmptyFromISR+0x2a>
	{
		xReturn = pdTRUE;
    2536:	81 e0       	ldi	r24, 0x01	; 1
    2538:	8b 83       	std	Y+3, r24	; 0x03
    253a:	01 c0       	rjmp	.+2      	; 0x253e <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    253c:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    253e:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2540:	0f 90       	pop	r0
    2542:	0f 90       	pop	r0
    2544:	0f 90       	pop	r0
    2546:	0f 90       	pop	r0
    2548:	0f 90       	pop	r0
    254a:	cf 91       	pop	r28
    254c:	df 91       	pop	r29
    254e:	08 95       	ret

00002550 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    2550:	df 93       	push	r29
    2552:	cf 93       	push	r28
    2554:	00 d0       	rcall	.+0      	; 0x2556 <prvIsQueueFull+0x6>
    2556:	0f 92       	push	r0
    2558:	cd b7       	in	r28, 0x3d	; 61
    255a:	de b7       	in	r29, 0x3e	; 62
    255c:	9b 83       	std	Y+3, r25	; 0x03
    255e:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2560:	0f b6       	in	r0, 0x3f	; 63
    2562:	f8 94       	cli
    2564:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2566:	ea 81       	ldd	r30, Y+2	; 0x02
    2568:	fb 81       	ldd	r31, Y+3	; 0x03
    256a:	92 8d       	ldd	r25, Z+26	; 0x1a
    256c:	ea 81       	ldd	r30, Y+2	; 0x02
    256e:	fb 81       	ldd	r31, Y+3	; 0x03
    2570:	83 8d       	ldd	r24, Z+27	; 0x1b
    2572:	98 17       	cp	r25, r24
    2574:	19 f4       	brne	.+6      	; 0x257c <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    2576:	81 e0       	ldi	r24, 0x01	; 1
    2578:	89 83       	std	Y+1, r24	; 0x01
    257a:	01 c0       	rjmp	.+2      	; 0x257e <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    257c:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    257e:	0f 90       	pop	r0
    2580:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2582:	89 81       	ldd	r24, Y+1	; 0x01
}
    2584:	0f 90       	pop	r0
    2586:	0f 90       	pop	r0
    2588:	0f 90       	pop	r0
    258a:	cf 91       	pop	r28
    258c:	df 91       	pop	r29
    258e:	08 95       	ret

00002590 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    2590:	df 93       	push	r29
    2592:	cf 93       	push	r28
    2594:	00 d0       	rcall	.+0      	; 0x2596 <xQueueIsQueueFullFromISR+0x6>
    2596:	00 d0       	rcall	.+0      	; 0x2598 <xQueueIsQueueFullFromISR+0x8>
    2598:	0f 92       	push	r0
    259a:	cd b7       	in	r28, 0x3d	; 61
    259c:	de b7       	in	r29, 0x3e	; 62
    259e:	9d 83       	std	Y+5, r25	; 0x05
    25a0:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    25a2:	8c 81       	ldd	r24, Y+4	; 0x04
    25a4:	9d 81       	ldd	r25, Y+5	; 0x05
    25a6:	9a 83       	std	Y+2, r25	; 0x02
    25a8:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    25aa:	e9 81       	ldd	r30, Y+1	; 0x01
    25ac:	fa 81       	ldd	r31, Y+2	; 0x02
    25ae:	92 8d       	ldd	r25, Z+26	; 0x1a
    25b0:	e9 81       	ldd	r30, Y+1	; 0x01
    25b2:	fa 81       	ldd	r31, Y+2	; 0x02
    25b4:	83 8d       	ldd	r24, Z+27	; 0x1b
    25b6:	98 17       	cp	r25, r24
    25b8:	19 f4       	brne	.+6      	; 0x25c0 <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
    25ba:	81 e0       	ldi	r24, 0x01	; 1
    25bc:	8b 83       	std	Y+3, r24	; 0x03
    25be:	01 c0       	rjmp	.+2      	; 0x25c2 <xQueueIsQueueFullFromISR+0x32>
	}
	else
	{
		xReturn = pdFALSE;
    25c0:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    25c2:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    25c4:	0f 90       	pop	r0
    25c6:	0f 90       	pop	r0
    25c8:	0f 90       	pop	r0
    25ca:	0f 90       	pop	r0
    25cc:	0f 90       	pop	r0
    25ce:	cf 91       	pop	r28
    25d0:	df 91       	pop	r29
    25d2:	08 95       	ret

000025d4 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    25d4:	8f 92       	push	r8
    25d6:	9f 92       	push	r9
    25d8:	af 92       	push	r10
    25da:	bf 92       	push	r11
    25dc:	cf 92       	push	r12
    25de:	df 92       	push	r13
    25e0:	ef 92       	push	r14
    25e2:	ff 92       	push	r15
    25e4:	0f 93       	push	r16
    25e6:	1f 93       	push	r17
    25e8:	df 93       	push	r29
    25ea:	cf 93       	push	r28
    25ec:	cd b7       	in	r28, 0x3d	; 61
    25ee:	de b7       	in	r29, 0x3e	; 62
    25f0:	60 97       	sbiw	r28, 0x10	; 16
    25f2:	0f b6       	in	r0, 0x3f	; 63
    25f4:	f8 94       	cli
    25f6:	de bf       	out	0x3e, r29	; 62
    25f8:	0f be       	out	0x3f, r0	; 63
    25fa:	cd bf       	out	0x3d, r28	; 61
    25fc:	9f 83       	std	Y+7, r25	; 0x07
    25fe:	8e 83       	std	Y+6, r24	; 0x06
    2600:	79 87       	std	Y+9, r23	; 0x09
    2602:	68 87       	std	Y+8, r22	; 0x08
    2604:	5b 87       	std	Y+11, r21	; 0x0b
    2606:	4a 87       	std	Y+10, r20	; 0x0a
    2608:	3d 87       	std	Y+13, r19	; 0x0d
    260a:	2c 87       	std	Y+12, r18	; 0x0c
    260c:	0e 87       	std	Y+14, r16	; 0x0e
    260e:	f8 8a       	std	Y+16, r15	; 0x10
    2610:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    2612:	8a 85       	ldd	r24, Y+10	; 0x0a
    2614:	9b 85       	ldd	r25, Y+11	; 0x0b
    2616:	0e 94 af 06 	call	0xd5e	; 0xd5e <pvPortMalloc>
    261a:	9a 83       	std	Y+2, r25	; 0x02
    261c:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    261e:	89 81       	ldd	r24, Y+1	; 0x01
    2620:	9a 81       	ldd	r25, Y+2	; 0x02
    2622:	00 97       	sbiw	r24, 0x00	; 0
    2624:	b1 f0       	breq	.+44     	; 0x2652 <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    2626:	86 e2       	ldi	r24, 0x26	; 38
    2628:	90 e0       	ldi	r25, 0x00	; 0
    262a:	0e 94 af 06 	call	0xd5e	; 0xd5e <pvPortMalloc>
    262e:	9d 83       	std	Y+5, r25	; 0x05
    2630:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    2632:	8c 81       	ldd	r24, Y+4	; 0x04
    2634:	9d 81       	ldd	r25, Y+5	; 0x05
    2636:	00 97       	sbiw	r24, 0x00	; 0
    2638:	39 f0       	breq	.+14     	; 0x2648 <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    263a:	ec 81       	ldd	r30, Y+4	; 0x04
    263c:	fd 81       	ldd	r31, Y+5	; 0x05
    263e:	89 81       	ldd	r24, Y+1	; 0x01
    2640:	9a 81       	ldd	r25, Y+2	; 0x02
    2642:	90 8f       	std	Z+24, r25	; 0x18
    2644:	87 8b       	std	Z+23, r24	; 0x17
    2646:	07 c0       	rjmp	.+14     	; 0x2656 <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    2648:	89 81       	ldd	r24, Y+1	; 0x01
    264a:	9a 81       	ldd	r25, Y+2	; 0x02
    264c:	0e 94 05 07 	call	0xe0a	; 0xe0a <vPortFree>
    2650:	02 c0       	rjmp	.+4      	; 0x2656 <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    2652:	1d 82       	std	Y+5, r1	; 0x05
    2654:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    2656:	8c 81       	ldd	r24, Y+4	; 0x04
    2658:	9d 81       	ldd	r25, Y+5	; 0x05
    265a:	00 97       	sbiw	r24, 0x00	; 0
    265c:	e9 f0       	breq	.+58     	; 0x2698 <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    265e:	8a 85       	ldd	r24, Y+10	; 0x0a
    2660:	9b 85       	ldd	r25, Y+11	; 0x0b
    2662:	9c 01       	movw	r18, r24
    2664:	40 e0       	ldi	r20, 0x00	; 0
    2666:	50 e0       	ldi	r21, 0x00	; 0
    2668:	8e 81       	ldd	r24, Y+6	; 0x06
    266a:	9f 81       	ldd	r25, Y+7	; 0x07
    266c:	68 85       	ldd	r22, Y+8	; 0x08
    266e:	79 85       	ldd	r23, Y+9	; 0x09
    2670:	ec 85       	ldd	r30, Y+12	; 0x0c
    2672:	fd 85       	ldd	r31, Y+13	; 0x0d
    2674:	af 85       	ldd	r26, Y+15	; 0x0f
    2676:	b8 89       	ldd	r27, Y+16	; 0x10
    2678:	ac 80       	ldd	r10, Y+4	; 0x04
    267a:	bd 80       	ldd	r11, Y+5	; 0x05
    267c:	8f 01       	movw	r16, r30
    267e:	ee 84       	ldd	r14, Y+14	; 0x0e
    2680:	6d 01       	movw	r12, r26
    2682:	88 24       	eor	r8, r8
    2684:	99 24       	eor	r9, r9
    2686:	0e 94 62 13 	call	0x26c4	; 0x26c4 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    268a:	8c 81       	ldd	r24, Y+4	; 0x04
    268c:	9d 81       	ldd	r25, Y+5	; 0x05
    268e:	0e 94 1e 14 	call	0x283c	; 0x283c <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    2692:	81 e0       	ldi	r24, 0x01	; 1
    2694:	8b 83       	std	Y+3, r24	; 0x03
    2696:	02 c0       	rjmp	.+4      	; 0x269c <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2698:	8f ef       	ldi	r24, 0xFF	; 255
    269a:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    269c:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    269e:	60 96       	adiw	r28, 0x10	; 16
    26a0:	0f b6       	in	r0, 0x3f	; 63
    26a2:	f8 94       	cli
    26a4:	de bf       	out	0x3e, r29	; 62
    26a6:	0f be       	out	0x3f, r0	; 63
    26a8:	cd bf       	out	0x3d, r28	; 61
    26aa:	cf 91       	pop	r28
    26ac:	df 91       	pop	r29
    26ae:	1f 91       	pop	r17
    26b0:	0f 91       	pop	r16
    26b2:	ff 90       	pop	r15
    26b4:	ef 90       	pop	r14
    26b6:	df 90       	pop	r13
    26b8:	cf 90       	pop	r12
    26ba:	bf 90       	pop	r11
    26bc:	af 90       	pop	r10
    26be:	9f 90       	pop	r9
    26c0:	8f 90       	pop	r8
    26c2:	08 95       	ret

000026c4 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    26c4:	8f 92       	push	r8
    26c6:	9f 92       	push	r9
    26c8:	af 92       	push	r10
    26ca:	bf 92       	push	r11
    26cc:	cf 92       	push	r12
    26ce:	df 92       	push	r13
    26d0:	ef 92       	push	r14
    26d2:	0f 93       	push	r16
    26d4:	1f 93       	push	r17
    26d6:	df 93       	push	r29
    26d8:	cf 93       	push	r28
    26da:	cd b7       	in	r28, 0x3d	; 61
    26dc:	de b7       	in	r29, 0x3e	; 62
    26de:	64 97       	sbiw	r28, 0x14	; 20
    26e0:	0f b6       	in	r0, 0x3f	; 63
    26e2:	f8 94       	cli
    26e4:	de bf       	out	0x3e, r29	; 62
    26e6:	0f be       	out	0x3f, r0	; 63
    26e8:	cd bf       	out	0x3d, r28	; 61
    26ea:	9d 83       	std	Y+5, r25	; 0x05
    26ec:	8c 83       	std	Y+4, r24	; 0x04
    26ee:	7f 83       	std	Y+7, r23	; 0x07
    26f0:	6e 83       	std	Y+6, r22	; 0x06
    26f2:	28 87       	std	Y+8, r18	; 0x08
    26f4:	39 87       	std	Y+9, r19	; 0x09
    26f6:	4a 87       	std	Y+10, r20	; 0x0a
    26f8:	5b 87       	std	Y+11, r21	; 0x0b
    26fa:	1d 87       	std	Y+13, r17	; 0x0d
    26fc:	0c 87       	std	Y+12, r16	; 0x0c
    26fe:	ee 86       	std	Y+14, r14	; 0x0e
    2700:	d8 8a       	std	Y+16, r13	; 0x10
    2702:	cf 86       	std	Y+15, r12	; 0x0f
    2704:	ba 8a       	std	Y+18, r11	; 0x12
    2706:	a9 8a       	std	Y+17, r10	; 0x11
    2708:	9c 8a       	std	Y+20, r9	; 0x14
    270a:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    270c:	e9 89       	ldd	r30, Y+17	; 0x11
    270e:	fa 89       	ldd	r31, Y+18	; 0x12
    2710:	27 89       	ldd	r18, Z+23	; 0x17
    2712:	30 8d       	ldd	r19, Z+24	; 0x18
    2714:	88 85       	ldd	r24, Y+8	; 0x08
    2716:	99 85       	ldd	r25, Y+9	; 0x09
    2718:	01 97       	sbiw	r24, 0x01	; 1
    271a:	82 0f       	add	r24, r18
    271c:	93 1f       	adc	r25, r19
    271e:	9b 83       	std	Y+3, r25	; 0x03
    2720:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    2722:	8e 81       	ldd	r24, Y+6	; 0x06
    2724:	9f 81       	ldd	r25, Y+7	; 0x07
    2726:	00 97       	sbiw	r24, 0x00	; 0
    2728:	51 f1       	breq	.+84     	; 0x277e <prvInitialiseNewTask+0xba>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    272a:	19 82       	std	Y+1, r1	; 0x01
    272c:	21 c0       	rjmp	.+66     	; 0x2770 <prvInitialiseNewTask+0xac>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    272e:	89 81       	ldd	r24, Y+1	; 0x01
    2730:	48 2f       	mov	r20, r24
    2732:	50 e0       	ldi	r21, 0x00	; 0
    2734:	89 81       	ldd	r24, Y+1	; 0x01
    2736:	28 2f       	mov	r18, r24
    2738:	30 e0       	ldi	r19, 0x00	; 0
    273a:	8e 81       	ldd	r24, Y+6	; 0x06
    273c:	9f 81       	ldd	r25, Y+7	; 0x07
    273e:	fc 01       	movw	r30, r24
    2740:	e2 0f       	add	r30, r18
    2742:	f3 1f       	adc	r31, r19
    2744:	20 81       	ld	r18, Z
    2746:	89 89       	ldd	r24, Y+17	; 0x11
    2748:	9a 89       	ldd	r25, Y+18	; 0x12
    274a:	84 0f       	add	r24, r20
    274c:	95 1f       	adc	r25, r21
    274e:	fc 01       	movw	r30, r24
    2750:	79 96       	adiw	r30, 0x19	; 25
    2752:	20 83       	st	Z, r18

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    2754:	89 81       	ldd	r24, Y+1	; 0x01
    2756:	28 2f       	mov	r18, r24
    2758:	30 e0       	ldi	r19, 0x00	; 0
    275a:	8e 81       	ldd	r24, Y+6	; 0x06
    275c:	9f 81       	ldd	r25, Y+7	; 0x07
    275e:	fc 01       	movw	r30, r24
    2760:	e2 0f       	add	r30, r18
    2762:	f3 1f       	adc	r31, r19
    2764:	80 81       	ld	r24, Z
    2766:	88 23       	and	r24, r24
    2768:	31 f0       	breq	.+12     	; 0x2776 <prvInitialiseNewTask+0xb2>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    276a:	89 81       	ldd	r24, Y+1	; 0x01
    276c:	8f 5f       	subi	r24, 0xFF	; 255
    276e:	89 83       	std	Y+1, r24	; 0x01
    2770:	89 81       	ldd	r24, Y+1	; 0x01
    2772:	88 30       	cpi	r24, 0x08	; 8
    2774:	e0 f2       	brcs	.-72     	; 0x272e <prvInitialiseNewTask+0x6a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    2776:	e9 89       	ldd	r30, Y+17	; 0x11
    2778:	fa 89       	ldd	r31, Y+18	; 0x12
    277a:	10 a2       	std	Z+32, r1	; 0x20
    277c:	03 c0       	rjmp	.+6      	; 0x2784 <prvInitialiseNewTask+0xc0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    277e:	e9 89       	ldd	r30, Y+17	; 0x11
    2780:	fa 89       	ldd	r31, Y+18	; 0x12
    2782:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    2784:	8e 85       	ldd	r24, Y+14	; 0x0e
    2786:	84 30       	cpi	r24, 0x04	; 4
    2788:	10 f0       	brcs	.+4      	; 0x278e <prvInitialiseNewTask+0xca>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    278a:	83 e0       	ldi	r24, 0x03	; 3
    278c:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    278e:	e9 89       	ldd	r30, Y+17	; 0x11
    2790:	fa 89       	ldd	r31, Y+18	; 0x12
    2792:	8e 85       	ldd	r24, Y+14	; 0x0e
    2794:	86 8b       	std	Z+22, r24	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    2796:	89 89       	ldd	r24, Y+17	; 0x11
    2798:	9a 89       	ldd	r25, Y+18	; 0x12
    279a:	02 96       	adiw	r24, 0x02	; 2
    279c:	0e 94 55 07 	call	0xeaa	; 0xeaa <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    27a0:	89 89       	ldd	r24, Y+17	; 0x11
    27a2:	9a 89       	ldd	r25, Y+18	; 0x12
    27a4:	0c 96       	adiw	r24, 0x0c	; 12
    27a6:	0e 94 55 07 	call	0xeaa	; 0xeaa <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    27aa:	e9 89       	ldd	r30, Y+17	; 0x11
    27ac:	fa 89       	ldd	r31, Y+18	; 0x12
    27ae:	89 89       	ldd	r24, Y+17	; 0x11
    27b0:	9a 89       	ldd	r25, Y+18	; 0x12
    27b2:	91 87       	std	Z+9, r25	; 0x09
    27b4:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    27b6:	8e 85       	ldd	r24, Y+14	; 0x0e
    27b8:	28 2f       	mov	r18, r24
    27ba:	30 e0       	ldi	r19, 0x00	; 0
    27bc:	84 e0       	ldi	r24, 0x04	; 4
    27be:	90 e0       	ldi	r25, 0x00	; 0
    27c0:	82 1b       	sub	r24, r18
    27c2:	93 0b       	sbc	r25, r19
    27c4:	e9 89       	ldd	r30, Y+17	; 0x11
    27c6:	fa 89       	ldd	r31, Y+18	; 0x12
    27c8:	95 87       	std	Z+13, r25	; 0x0d
    27ca:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    27cc:	e9 89       	ldd	r30, Y+17	; 0x11
    27ce:	fa 89       	ldd	r31, Y+18	; 0x12
    27d0:	89 89       	ldd	r24, Y+17	; 0x11
    27d2:	9a 89       	ldd	r25, Y+18	; 0x12
    27d4:	93 8b       	std	Z+19, r25	; 0x13
    27d6:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    27d8:	e9 89       	ldd	r30, Y+17	; 0x11
    27da:	fa 89       	ldd	r31, Y+18	; 0x12
    27dc:	11 a2       	std	Z+33, r1	; 0x21
    27de:	12 a2       	std	Z+34, r1	; 0x22
    27e0:	13 a2       	std	Z+35, r1	; 0x23
    27e2:	14 a2       	std	Z+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    27e4:	e9 89       	ldd	r30, Y+17	; 0x11
    27e6:	fa 89       	ldd	r31, Y+18	; 0x12
    27e8:	15 a2       	std	Z+37, r1	; 0x25
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    27ea:	8a 81       	ldd	r24, Y+2	; 0x02
    27ec:	9b 81       	ldd	r25, Y+3	; 0x03
    27ee:	2c 81       	ldd	r18, Y+4	; 0x04
    27f0:	3d 81       	ldd	r19, Y+5	; 0x05
    27f2:	4c 85       	ldd	r20, Y+12	; 0x0c
    27f4:	5d 85       	ldd	r21, Y+13	; 0x0d
    27f6:	b9 01       	movw	r22, r18
    27f8:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <pxPortInitialiseStack>
    27fc:	e9 89       	ldd	r30, Y+17	; 0x11
    27fe:	fa 89       	ldd	r31, Y+18	; 0x12
    2800:	91 83       	std	Z+1, r25	; 0x01
    2802:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    2804:	8f 85       	ldd	r24, Y+15	; 0x0f
    2806:	98 89       	ldd	r25, Y+16	; 0x10
    2808:	00 97       	sbiw	r24, 0x00	; 0
    280a:	31 f0       	breq	.+12     	; 0x2818 <prvInitialiseNewTask+0x154>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    280c:	ef 85       	ldd	r30, Y+15	; 0x0f
    280e:	f8 89       	ldd	r31, Y+16	; 0x10
    2810:	89 89       	ldd	r24, Y+17	; 0x11
    2812:	9a 89       	ldd	r25, Y+18	; 0x12
    2814:	91 83       	std	Z+1, r25	; 0x01
    2816:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    2818:	64 96       	adiw	r28, 0x14	; 20
    281a:	0f b6       	in	r0, 0x3f	; 63
    281c:	f8 94       	cli
    281e:	de bf       	out	0x3e, r29	; 62
    2820:	0f be       	out	0x3f, r0	; 63
    2822:	cd bf       	out	0x3d, r28	; 61
    2824:	cf 91       	pop	r28
    2826:	df 91       	pop	r29
    2828:	1f 91       	pop	r17
    282a:	0f 91       	pop	r16
    282c:	ef 90       	pop	r14
    282e:	df 90       	pop	r13
    2830:	cf 90       	pop	r12
    2832:	bf 90       	pop	r11
    2834:	af 90       	pop	r10
    2836:	9f 90       	pop	r9
    2838:	8f 90       	pop	r8
    283a:	08 95       	ret

0000283c <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    283c:	df 93       	push	r29
    283e:	cf 93       	push	r28
    2840:	00 d0       	rcall	.+0      	; 0x2842 <prvAddNewTaskToReadyList+0x6>
    2842:	cd b7       	in	r28, 0x3d	; 61
    2844:	de b7       	in	r29, 0x3e	; 62
    2846:	9a 83       	std	Y+2, r25	; 0x02
    2848:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    284a:	0f b6       	in	r0, 0x3f	; 63
    284c:	f8 94       	cli
    284e:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    2850:	80 91 ce 02 	lds	r24, 0x02CE
    2854:	8f 5f       	subi	r24, 0xFF	; 255
    2856:	80 93 ce 02 	sts	0x02CE, r24
		if( pxCurrentTCB == NULL )
    285a:	80 91 cb 02 	lds	r24, 0x02CB
    285e:	90 91 cc 02 	lds	r25, 0x02CC
    2862:	00 97       	sbiw	r24, 0x00	; 0
    2864:	69 f4       	brne	.+26     	; 0x2880 <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    2866:	89 81       	ldd	r24, Y+1	; 0x01
    2868:	9a 81       	ldd	r25, Y+2	; 0x02
    286a:	90 93 cc 02 	sts	0x02CC, r25
    286e:	80 93 cb 02 	sts	0x02CB, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    2872:	80 91 ce 02 	lds	r24, 0x02CE
    2876:	81 30       	cpi	r24, 0x01	; 1
    2878:	b9 f4       	brne	.+46     	; 0x28a8 <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    287a:	0e 94 f0 19 	call	0x33e0	; 0x33e0 <prvInitialiseTaskLists>
    287e:	14 c0       	rjmp	.+40     	; 0x28a8 <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    2880:	80 91 d2 02 	lds	r24, 0x02D2
    2884:	88 23       	and	r24, r24
    2886:	81 f4       	brne	.+32     	; 0x28a8 <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    2888:	e0 91 cb 02 	lds	r30, 0x02CB
    288c:	f0 91 cc 02 	lds	r31, 0x02CC
    2890:	96 89       	ldd	r25, Z+22	; 0x16
    2892:	e9 81       	ldd	r30, Y+1	; 0x01
    2894:	fa 81       	ldd	r31, Y+2	; 0x02
    2896:	86 89       	ldd	r24, Z+22	; 0x16
    2898:	89 17       	cp	r24, r25
    289a:	30 f0       	brcs	.+12     	; 0x28a8 <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    289c:	89 81       	ldd	r24, Y+1	; 0x01
    289e:	9a 81       	ldd	r25, Y+2	; 0x02
    28a0:	90 93 cc 02 	sts	0x02CC, r25
    28a4:	80 93 cb 02 	sts	0x02CB, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    28a8:	80 91 d6 02 	lds	r24, 0x02D6
    28ac:	8f 5f       	subi	r24, 0xFF	; 255
    28ae:	80 93 d6 02 	sts	0x02D6, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    28b2:	e9 81       	ldd	r30, Y+1	; 0x01
    28b4:	fa 81       	ldd	r31, Y+2	; 0x02
    28b6:	96 89       	ldd	r25, Z+22	; 0x16
    28b8:	80 91 d1 02 	lds	r24, 0x02D1
    28bc:	89 17       	cp	r24, r25
    28be:	28 f4       	brcc	.+10     	; 0x28ca <prvAddNewTaskToReadyList+0x8e>
    28c0:	e9 81       	ldd	r30, Y+1	; 0x01
    28c2:	fa 81       	ldd	r31, Y+2	; 0x02
    28c4:	86 89       	ldd	r24, Z+22	; 0x16
    28c6:	80 93 d1 02 	sts	0x02D1, r24
    28ca:	e9 81       	ldd	r30, Y+1	; 0x01
    28cc:	fa 81       	ldd	r31, Y+2	; 0x02
    28ce:	86 89       	ldd	r24, Z+22	; 0x16
    28d0:	28 2f       	mov	r18, r24
    28d2:	30 e0       	ldi	r19, 0x00	; 0
    28d4:	c9 01       	movw	r24, r18
    28d6:	88 0f       	add	r24, r24
    28d8:	99 1f       	adc	r25, r25
    28da:	88 0f       	add	r24, r24
    28dc:	99 1f       	adc	r25, r25
    28de:	88 0f       	add	r24, r24
    28e0:	99 1f       	adc	r25, r25
    28e2:	82 0f       	add	r24, r18
    28e4:	93 1f       	adc	r25, r19
    28e6:	ac 01       	movw	r20, r24
    28e8:	44 52       	subi	r20, 0x24	; 36
    28ea:	5d 4f       	sbci	r21, 0xFD	; 253
    28ec:	89 81       	ldd	r24, Y+1	; 0x01
    28ee:	9a 81       	ldd	r25, Y+2	; 0x02
    28f0:	9c 01       	movw	r18, r24
    28f2:	2e 5f       	subi	r18, 0xFE	; 254
    28f4:	3f 4f       	sbci	r19, 0xFF	; 255
    28f6:	ca 01       	movw	r24, r20
    28f8:	b9 01       	movw	r22, r18
    28fa:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    28fe:	0f 90       	pop	r0
    2900:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    2902:	80 91 d2 02 	lds	r24, 0x02D2
    2906:	88 23       	and	r24, r24
    2908:	61 f0       	breq	.+24     	; 0x2922 <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    290a:	e0 91 cb 02 	lds	r30, 0x02CB
    290e:	f0 91 cc 02 	lds	r31, 0x02CC
    2912:	96 89       	ldd	r25, Z+22	; 0x16
    2914:	e9 81       	ldd	r30, Y+1	; 0x01
    2916:	fa 81       	ldd	r31, Y+2	; 0x02
    2918:	86 89       	ldd	r24, Z+22	; 0x16
    291a:	98 17       	cp	r25, r24
    291c:	10 f4       	brcc	.+4      	; 0x2922 <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    291e:	0e 94 b3 0a 	call	0x1566	; 0x1566 <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    2922:	0f 90       	pop	r0
    2924:	0f 90       	pop	r0
    2926:	cf 91       	pop	r28
    2928:	df 91       	pop	r29
    292a:	08 95       	ret

0000292c <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    292c:	df 93       	push	r29
    292e:	cf 93       	push	r28
    2930:	00 d0       	rcall	.+0      	; 0x2932 <vTaskDelete+0x6>
    2932:	00 d0       	rcall	.+0      	; 0x2934 <vTaskDelete+0x8>
    2934:	00 d0       	rcall	.+0      	; 0x2936 <vTaskDelete+0xa>
    2936:	cd b7       	in	r28, 0x3d	; 61
    2938:	de b7       	in	r29, 0x3e	; 62
    293a:	9c 83       	std	Y+4, r25	; 0x04
    293c:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    293e:	0f b6       	in	r0, 0x3f	; 63
    2940:	f8 94       	cli
    2942:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    2944:	8b 81       	ldd	r24, Y+3	; 0x03
    2946:	9c 81       	ldd	r25, Y+4	; 0x04
    2948:	00 97       	sbiw	r24, 0x00	; 0
    294a:	39 f4       	brne	.+14     	; 0x295a <vTaskDelete+0x2e>
    294c:	80 91 cb 02 	lds	r24, 0x02CB
    2950:	90 91 cc 02 	lds	r25, 0x02CC
    2954:	9e 83       	std	Y+6, r25	; 0x06
    2956:	8d 83       	std	Y+5, r24	; 0x05
    2958:	04 c0       	rjmp	.+8      	; 0x2962 <vTaskDelete+0x36>
    295a:	8b 81       	ldd	r24, Y+3	; 0x03
    295c:	9c 81       	ldd	r25, Y+4	; 0x04
    295e:	9e 83       	std	Y+6, r25	; 0x06
    2960:	8d 83       	std	Y+5, r24	; 0x05
    2962:	8d 81       	ldd	r24, Y+5	; 0x05
    2964:	9e 81       	ldd	r25, Y+6	; 0x06
    2966:	9a 83       	std	Y+2, r25	; 0x02
    2968:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    296a:	89 81       	ldd	r24, Y+1	; 0x01
    296c:	9a 81       	ldd	r25, Y+2	; 0x02
    296e:	02 96       	adiw	r24, 0x02	; 2
    2970:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    2974:	e9 81       	ldd	r30, Y+1	; 0x01
    2976:	fa 81       	ldd	r31, Y+2	; 0x02
    2978:	84 89       	ldd	r24, Z+20	; 0x14
    297a:	95 89       	ldd	r25, Z+21	; 0x15
    297c:	00 97       	sbiw	r24, 0x00	; 0
    297e:	29 f0       	breq	.+10     	; 0x298a <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2980:	89 81       	ldd	r24, Y+1	; 0x01
    2982:	9a 81       	ldd	r25, Y+2	; 0x02
    2984:	0c 96       	adiw	r24, 0x0c	; 12
    2986:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    298a:	80 91 d6 02 	lds	r24, 0x02D6
    298e:	8f 5f       	subi	r24, 0xFF	; 255
    2990:	80 93 d6 02 	sts	0x02D6, r24

			if( pxTCB == pxCurrentTCB )
    2994:	20 91 cb 02 	lds	r18, 0x02CB
    2998:	30 91 cc 02 	lds	r19, 0x02CC
    299c:	89 81       	ldd	r24, Y+1	; 0x01
    299e:	9a 81       	ldd	r25, Y+2	; 0x02
    29a0:	82 17       	cp	r24, r18
    29a2:	93 07       	cpc	r25, r19
    29a4:	81 f4       	brne	.+32     	; 0x29c6 <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    29a6:	89 81       	ldd	r24, Y+1	; 0x01
    29a8:	9a 81       	ldd	r25, Y+2	; 0x02
    29aa:	9c 01       	movw	r18, r24
    29ac:	2e 5f       	subi	r18, 0xFE	; 254
    29ae:	3f 4f       	sbci	r19, 0xFF	; 255
    29b0:	8f e1       	ldi	r24, 0x1F	; 31
    29b2:	93 e0       	ldi	r25, 0x03	; 3
    29b4:	b9 01       	movw	r22, r18
    29b6:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    29ba:	80 91 cd 02 	lds	r24, 0x02CD
    29be:	8f 5f       	subi	r24, 0xFF	; 255
    29c0:	80 93 cd 02 	sts	0x02CD, r24
    29c4:	0b c0       	rjmp	.+22     	; 0x29dc <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    29c6:	80 91 ce 02 	lds	r24, 0x02CE
    29ca:	81 50       	subi	r24, 0x01	; 1
    29cc:	80 93 ce 02 	sts	0x02CE, r24
				prvDeleteTCB( pxTCB );
    29d0:	89 81       	ldd	r24, Y+1	; 0x01
    29d2:	9a 81       	ldd	r25, Y+2	; 0x02
    29d4:	0e 94 5c 1a 	call	0x34b8	; 0x34b8 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    29d8:	0e 94 72 1a 	call	0x34e4	; 0x34e4 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    29dc:	0f 90       	pop	r0
    29de:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    29e0:	80 91 d2 02 	lds	r24, 0x02D2
    29e4:	88 23       	and	r24, r24
    29e6:	59 f0       	breq	.+22     	; 0x29fe <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    29e8:	20 91 cb 02 	lds	r18, 0x02CB
    29ec:	30 91 cc 02 	lds	r19, 0x02CC
    29f0:	89 81       	ldd	r24, Y+1	; 0x01
    29f2:	9a 81       	ldd	r25, Y+2	; 0x02
    29f4:	82 17       	cp	r24, r18
    29f6:	93 07       	cpc	r25, r19
    29f8:	11 f4       	brne	.+4      	; 0x29fe <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    29fa:	0e 94 b3 0a 	call	0x1566	; 0x1566 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    29fe:	26 96       	adiw	r28, 0x06	; 6
    2a00:	0f b6       	in	r0, 0x3f	; 63
    2a02:	f8 94       	cli
    2a04:	de bf       	out	0x3e, r29	; 62
    2a06:	0f be       	out	0x3f, r0	; 63
    2a08:	cd bf       	out	0x3d, r28	; 61
    2a0a:	cf 91       	pop	r28
    2a0c:	df 91       	pop	r29
    2a0e:	08 95       	ret

00002a10 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    2a10:	df 93       	push	r29
    2a12:	cf 93       	push	r28
    2a14:	cd b7       	in	r28, 0x3d	; 61
    2a16:	de b7       	in	r29, 0x3e	; 62
    2a18:	2a 97       	sbiw	r28, 0x0a	; 10
    2a1a:	0f b6       	in	r0, 0x3f	; 63
    2a1c:	f8 94       	cli
    2a1e:	de bf       	out	0x3e, r29	; 62
    2a20:	0f be       	out	0x3f, r0	; 63
    2a22:	cd bf       	out	0x3d, r28	; 61
    2a24:	98 87       	std	Y+8, r25	; 0x08
    2a26:	8f 83       	std	Y+7, r24	; 0x07
    2a28:	7a 87       	std	Y+10, r23	; 0x0a
    2a2a:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    2a2c:	1b 82       	std	Y+3, r1	; 0x03

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    2a2e:	0e 94 da 15 	call	0x2bb4	; 0x2bb4 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    2a32:	80 91 cf 02 	lds	r24, 0x02CF
    2a36:	90 91 d0 02 	lds	r25, 0x02D0
    2a3a:	9a 83       	std	Y+2, r25	; 0x02
    2a3c:	89 83       	std	Y+1, r24	; 0x01

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2a3e:	ef 81       	ldd	r30, Y+7	; 0x07
    2a40:	f8 85       	ldd	r31, Y+8	; 0x08
    2a42:	20 81       	ld	r18, Z
    2a44:	31 81       	ldd	r19, Z+1	; 0x01
    2a46:	89 85       	ldd	r24, Y+9	; 0x09
    2a48:	9a 85       	ldd	r25, Y+10	; 0x0a
    2a4a:	82 0f       	add	r24, r18
    2a4c:	93 1f       	adc	r25, r19
    2a4e:	9e 83       	std	Y+6, r25	; 0x06
    2a50:	8d 83       	std	Y+5, r24	; 0x05

			if( xConstTickCount < *pxPreviousWakeTime )
    2a52:	ef 81       	ldd	r30, Y+7	; 0x07
    2a54:	f8 85       	ldd	r31, Y+8	; 0x08
    2a56:	20 81       	ld	r18, Z
    2a58:	31 81       	ldd	r19, Z+1	; 0x01
    2a5a:	89 81       	ldd	r24, Y+1	; 0x01
    2a5c:	9a 81       	ldd	r25, Y+2	; 0x02
    2a5e:	82 17       	cp	r24, r18
    2a60:	93 07       	cpc	r25, r19
    2a62:	98 f4       	brcc	.+38     	; 0x2a8a <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    2a64:	ef 81       	ldd	r30, Y+7	; 0x07
    2a66:	f8 85       	ldd	r31, Y+8	; 0x08
    2a68:	20 81       	ld	r18, Z
    2a6a:	31 81       	ldd	r19, Z+1	; 0x01
    2a6c:	8d 81       	ldd	r24, Y+5	; 0x05
    2a6e:	9e 81       	ldd	r25, Y+6	; 0x06
    2a70:	82 17       	cp	r24, r18
    2a72:	93 07       	cpc	r25, r19
    2a74:	e0 f4       	brcc	.+56     	; 0x2aae <vTaskDelayUntil+0x9e>
    2a76:	2d 81       	ldd	r18, Y+5	; 0x05
    2a78:	3e 81       	ldd	r19, Y+6	; 0x06
    2a7a:	89 81       	ldd	r24, Y+1	; 0x01
    2a7c:	9a 81       	ldd	r25, Y+2	; 0x02
    2a7e:	82 17       	cp	r24, r18
    2a80:	93 07       	cpc	r25, r19
    2a82:	a8 f4       	brcc	.+42     	; 0x2aae <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    2a84:	81 e0       	ldi	r24, 0x01	; 1
    2a86:	8b 83       	std	Y+3, r24	; 0x03
    2a88:	12 c0       	rjmp	.+36     	; 0x2aae <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    2a8a:	ef 81       	ldd	r30, Y+7	; 0x07
    2a8c:	f8 85       	ldd	r31, Y+8	; 0x08
    2a8e:	20 81       	ld	r18, Z
    2a90:	31 81       	ldd	r19, Z+1	; 0x01
    2a92:	8d 81       	ldd	r24, Y+5	; 0x05
    2a94:	9e 81       	ldd	r25, Y+6	; 0x06
    2a96:	82 17       	cp	r24, r18
    2a98:	93 07       	cpc	r25, r19
    2a9a:	38 f0       	brcs	.+14     	; 0x2aaa <vTaskDelayUntil+0x9a>
    2a9c:	2d 81       	ldd	r18, Y+5	; 0x05
    2a9e:	3e 81       	ldd	r19, Y+6	; 0x06
    2aa0:	89 81       	ldd	r24, Y+1	; 0x01
    2aa2:	9a 81       	ldd	r25, Y+2	; 0x02
    2aa4:	82 17       	cp	r24, r18
    2aa6:	93 07       	cpc	r25, r19
    2aa8:	10 f4       	brcc	.+4      	; 0x2aae <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    2aaa:	81 e0       	ldi	r24, 0x01	; 1
    2aac:	8b 83       	std	Y+3, r24	; 0x03
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2aae:	ef 81       	ldd	r30, Y+7	; 0x07
    2ab0:	f8 85       	ldd	r31, Y+8	; 0x08
    2ab2:	8d 81       	ldd	r24, Y+5	; 0x05
    2ab4:	9e 81       	ldd	r25, Y+6	; 0x06
    2ab6:	91 83       	std	Z+1, r25	; 0x01
    2ab8:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    2aba:	8b 81       	ldd	r24, Y+3	; 0x03
    2abc:	88 23       	and	r24, r24
    2abe:	49 f0       	breq	.+18     	; 0x2ad2 <vTaskDelayUntil+0xc2>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    2ac0:	8d 81       	ldd	r24, Y+5	; 0x05
    2ac2:	9e 81       	ldd	r25, Y+6	; 0x06
    2ac4:	29 81       	ldd	r18, Y+1	; 0x01
    2ac6:	3a 81       	ldd	r19, Y+2	; 0x02
    2ac8:	82 1b       	sub	r24, r18
    2aca:	93 0b       	sbc	r25, r19
    2acc:	60 e0       	ldi	r22, 0x00	; 0
    2ace:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2ad2:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <xTaskResumeAll>
    2ad6:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2ad8:	8c 81       	ldd	r24, Y+4	; 0x04
    2ada:	88 23       	and	r24, r24
    2adc:	11 f4       	brne	.+4      	; 0x2ae2 <vTaskDelayUntil+0xd2>
		{
			portYIELD_WITHIN_API();
    2ade:	0e 94 b3 0a 	call	0x1566	; 0x1566 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2ae2:	2a 96       	adiw	r28, 0x0a	; 10
    2ae4:	0f b6       	in	r0, 0x3f	; 63
    2ae6:	f8 94       	cli
    2ae8:	de bf       	out	0x3e, r29	; 62
    2aea:	0f be       	out	0x3f, r0	; 63
    2aec:	cd bf       	out	0x3d, r28	; 61
    2aee:	cf 91       	pop	r28
    2af0:	df 91       	pop	r29
    2af2:	08 95       	ret

00002af4 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    2af4:	df 93       	push	r29
    2af6:	cf 93       	push	r28
    2af8:	00 d0       	rcall	.+0      	; 0x2afa <vTaskDelay+0x6>
    2afa:	0f 92       	push	r0
    2afc:	cd b7       	in	r28, 0x3d	; 61
    2afe:	de b7       	in	r29, 0x3e	; 62
    2b00:	9b 83       	std	Y+3, r25	; 0x03
    2b02:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    2b04:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    2b06:	8a 81       	ldd	r24, Y+2	; 0x02
    2b08:	9b 81       	ldd	r25, Y+3	; 0x03
    2b0a:	00 97       	sbiw	r24, 0x00	; 0
    2b0c:	51 f0       	breq	.+20     	; 0x2b22 <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    2b0e:	0e 94 da 15 	call	0x2bb4	; 0x2bb4 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    2b12:	8a 81       	ldd	r24, Y+2	; 0x02
    2b14:	9b 81       	ldd	r25, Y+3	; 0x03
    2b16:	60 e0       	ldi	r22, 0x00	; 0
    2b18:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2b1c:	0e 94 e6 15 	call	0x2bcc	; 0x2bcc <xTaskResumeAll>
    2b20:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2b22:	89 81       	ldd	r24, Y+1	; 0x01
    2b24:	88 23       	and	r24, r24
    2b26:	11 f4       	brne	.+4      	; 0x2b2c <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    2b28:	0e 94 b3 0a 	call	0x1566	; 0x1566 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2b2c:	0f 90       	pop	r0
    2b2e:	0f 90       	pop	r0
    2b30:	0f 90       	pop	r0
    2b32:	cf 91       	pop	r28
    2b34:	df 91       	pop	r29
    2b36:	08 95       	ret

00002b38 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    2b38:	ef 92       	push	r14
    2b3a:	ff 92       	push	r15
    2b3c:	0f 93       	push	r16
    2b3e:	df 93       	push	r29
    2b40:	cf 93       	push	r28
    2b42:	0f 92       	push	r0
    2b44:	cd b7       	in	r28, 0x3d	; 61
    2b46:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    2b48:	86 ee       	ldi	r24, 0xE6	; 230
    2b4a:	99 e1       	ldi	r25, 0x19	; 25
    2b4c:	27 e6       	ldi	r18, 0x67	; 103
    2b4e:	30 e0       	ldi	r19, 0x00	; 0
    2b50:	e9 ed       	ldi	r30, 0xD9	; 217
    2b52:	f2 e0       	ldi	r31, 0x02	; 2
    2b54:	b9 01       	movw	r22, r18
    2b56:	45 e5       	ldi	r20, 0x55	; 85
    2b58:	50 e0       	ldi	r21, 0x00	; 0
    2b5a:	20 e0       	ldi	r18, 0x00	; 0
    2b5c:	30 e0       	ldi	r19, 0x00	; 0
    2b5e:	00 e0       	ldi	r16, 0x00	; 0
    2b60:	7f 01       	movw	r14, r30
    2b62:	0e 94 ea 12 	call	0x25d4	; 0x25d4 <xTaskCreate>
    2b66:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    2b68:	89 81       	ldd	r24, Y+1	; 0x01
    2b6a:	81 30       	cpi	r24, 0x01	; 1
    2b6c:	81 f4       	brne	.+32     	; 0x2b8e <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    2b6e:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    2b70:	8f ef       	ldi	r24, 0xFF	; 255
    2b72:	9f ef       	ldi	r25, 0xFF	; 255
    2b74:	90 93 d8 02 	sts	0x02D8, r25
    2b78:	80 93 d7 02 	sts	0x02D7, r24
		xSchedulerRunning = pdTRUE;
    2b7c:	81 e0       	ldi	r24, 0x01	; 1
    2b7e:	80 93 d2 02 	sts	0x02D2, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    2b82:	10 92 d0 02 	sts	0x02D0, r1
    2b86:	10 92 cf 02 	sts	0x02CF, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    2b8a:	0e 94 77 0a 	call	0x14ee	; 0x14ee <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    2b8e:	0f 90       	pop	r0
    2b90:	cf 91       	pop	r28
    2b92:	df 91       	pop	r29
    2b94:	0f 91       	pop	r16
    2b96:	ff 90       	pop	r15
    2b98:	ef 90       	pop	r14
    2b9a:	08 95       	ret

00002b9c <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    2b9c:	df 93       	push	r29
    2b9e:	cf 93       	push	r28
    2ba0:	cd b7       	in	r28, 0x3d	; 61
    2ba2:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    2ba4:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    2ba6:	10 92 d2 02 	sts	0x02D2, r1
	vPortEndScheduler();
    2baa:	0e 94 ac 0a 	call	0x1558	; 0x1558 <vPortEndScheduler>
}
    2bae:	cf 91       	pop	r28
    2bb0:	df 91       	pop	r29
    2bb2:	08 95       	ret

00002bb4 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    2bb4:	df 93       	push	r29
    2bb6:	cf 93       	push	r28
    2bb8:	cd b7       	in	r28, 0x3d	; 61
    2bba:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    2bbc:	80 91 db 02 	lds	r24, 0x02DB
    2bc0:	8f 5f       	subi	r24, 0xFF	; 255
    2bc2:	80 93 db 02 	sts	0x02DB, r24
	portMEMORY_BARRIER();
}
    2bc6:	cf 91       	pop	r28
    2bc8:	df 91       	pop	r29
    2bca:	08 95       	ret

00002bcc <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    2bcc:	df 93       	push	r29
    2bce:	cf 93       	push	r28
    2bd0:	00 d0       	rcall	.+0      	; 0x2bd2 <xTaskResumeAll+0x6>
    2bd2:	00 d0       	rcall	.+0      	; 0x2bd4 <xTaskResumeAll+0x8>
    2bd4:	cd b7       	in	r28, 0x3d	; 61
    2bd6:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    2bd8:	1c 82       	std	Y+4, r1	; 0x04
    2bda:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xAlreadyYielded = pdFALSE;
    2bdc:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2bde:	0f b6       	in	r0, 0x3f	; 63
    2be0:	f8 94       	cli
    2be2:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2be4:	80 91 db 02 	lds	r24, 0x02DB
    2be8:	81 50       	subi	r24, 0x01	; 1
    2bea:	80 93 db 02 	sts	0x02DB, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2bee:	80 91 db 02 	lds	r24, 0x02DB
    2bf2:	88 23       	and	r24, r24
    2bf4:	09 f0       	breq	.+2      	; 0x2bf8 <xTaskResumeAll+0x2c>
    2bf6:	73 c0       	rjmp	.+230    	; 0x2cde <xTaskResumeAll+0x112>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    2bf8:	80 91 ce 02 	lds	r24, 0x02CE
    2bfc:	88 23       	and	r24, r24
    2bfe:	09 f4       	brne	.+2      	; 0x2c02 <xTaskResumeAll+0x36>
    2c00:	6e c0       	rjmp	.+220    	; 0x2cde <xTaskResumeAll+0x112>
    2c02:	45 c0       	rjmp	.+138    	; 0x2c8e <xTaskResumeAll+0xc2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2c04:	e0 91 1b 03 	lds	r30, 0x031B
    2c08:	f0 91 1c 03 	lds	r31, 0x031C
    2c0c:	86 81       	ldd	r24, Z+6	; 0x06
    2c0e:	97 81       	ldd	r25, Z+7	; 0x07
    2c10:	9c 83       	std	Y+4, r25	; 0x04
    2c12:	8b 83       	std	Y+3, r24	; 0x03
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2c14:	8b 81       	ldd	r24, Y+3	; 0x03
    2c16:	9c 81       	ldd	r25, Y+4	; 0x04
    2c18:	0c 96       	adiw	r24, 0x0c	; 12
    2c1a:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2c1e:	8b 81       	ldd	r24, Y+3	; 0x03
    2c20:	9c 81       	ldd	r25, Y+4	; 0x04
    2c22:	02 96       	adiw	r24, 0x02	; 2
    2c24:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2c28:	eb 81       	ldd	r30, Y+3	; 0x03
    2c2a:	fc 81       	ldd	r31, Y+4	; 0x04
    2c2c:	96 89       	ldd	r25, Z+22	; 0x16
    2c2e:	80 91 d1 02 	lds	r24, 0x02D1
    2c32:	89 17       	cp	r24, r25
    2c34:	28 f4       	brcc	.+10     	; 0x2c40 <xTaskResumeAll+0x74>
    2c36:	eb 81       	ldd	r30, Y+3	; 0x03
    2c38:	fc 81       	ldd	r31, Y+4	; 0x04
    2c3a:	86 89       	ldd	r24, Z+22	; 0x16
    2c3c:	80 93 d1 02 	sts	0x02D1, r24
    2c40:	eb 81       	ldd	r30, Y+3	; 0x03
    2c42:	fc 81       	ldd	r31, Y+4	; 0x04
    2c44:	86 89       	ldd	r24, Z+22	; 0x16
    2c46:	28 2f       	mov	r18, r24
    2c48:	30 e0       	ldi	r19, 0x00	; 0
    2c4a:	c9 01       	movw	r24, r18
    2c4c:	88 0f       	add	r24, r24
    2c4e:	99 1f       	adc	r25, r25
    2c50:	88 0f       	add	r24, r24
    2c52:	99 1f       	adc	r25, r25
    2c54:	88 0f       	add	r24, r24
    2c56:	99 1f       	adc	r25, r25
    2c58:	82 0f       	add	r24, r18
    2c5a:	93 1f       	adc	r25, r19
    2c5c:	ac 01       	movw	r20, r24
    2c5e:	44 52       	subi	r20, 0x24	; 36
    2c60:	5d 4f       	sbci	r21, 0xFD	; 253
    2c62:	8b 81       	ldd	r24, Y+3	; 0x03
    2c64:	9c 81       	ldd	r25, Y+4	; 0x04
    2c66:	9c 01       	movw	r18, r24
    2c68:	2e 5f       	subi	r18, 0xFE	; 254
    2c6a:	3f 4f       	sbci	r19, 0xFF	; 255
    2c6c:	ca 01       	movw	r24, r20
    2c6e:	b9 01       	movw	r22, r18
    2c70:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2c74:	eb 81       	ldd	r30, Y+3	; 0x03
    2c76:	fc 81       	ldd	r31, Y+4	; 0x04
    2c78:	96 89       	ldd	r25, Z+22	; 0x16
    2c7a:	e0 91 cb 02 	lds	r30, 0x02CB
    2c7e:	f0 91 cc 02 	lds	r31, 0x02CC
    2c82:	86 89       	ldd	r24, Z+22	; 0x16
    2c84:	98 17       	cp	r25, r24
    2c86:	18 f0       	brcs	.+6      	; 0x2c8e <xTaskResumeAll+0xc2>
					{
						xYieldPending = pdTRUE;
    2c88:	81 e0       	ldi	r24, 0x01	; 1
    2c8a:	80 93 d4 02 	sts	0x02D4, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    2c8e:	80 91 16 03 	lds	r24, 0x0316
    2c92:	88 23       	and	r24, r24
    2c94:	09 f0       	breq	.+2      	; 0x2c98 <xTaskResumeAll+0xcc>
    2c96:	b6 cf       	rjmp	.-148    	; 0x2c04 <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    2c98:	8b 81       	ldd	r24, Y+3	; 0x03
    2c9a:	9c 81       	ldd	r25, Y+4	; 0x04
    2c9c:	00 97       	sbiw	r24, 0x00	; 0
    2c9e:	11 f0       	breq	.+4      	; 0x2ca4 <xTaskResumeAll+0xd8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    2ca0:	0e 94 72 1a 	call	0x34e4	; 0x34e4 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    2ca4:	80 91 d3 02 	lds	r24, 0x02D3
    2ca8:	89 83       	std	Y+1, r24	; 0x01

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    2caa:	89 81       	ldd	r24, Y+1	; 0x01
    2cac:	88 23       	and	r24, r24
    2cae:	79 f0       	breq	.+30     	; 0x2cce <xTaskResumeAll+0x102>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    2cb0:	0e 94 d6 16 	call	0x2dac	; 0x2dac <xTaskIncrementTick>
    2cb4:	88 23       	and	r24, r24
    2cb6:	19 f0       	breq	.+6      	; 0x2cbe <xTaskResumeAll+0xf2>
							{
								xYieldPending = pdTRUE;
    2cb8:	81 e0       	ldi	r24, 0x01	; 1
    2cba:	80 93 d4 02 	sts	0x02D4, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    2cbe:	89 81       	ldd	r24, Y+1	; 0x01
    2cc0:	81 50       	subi	r24, 0x01	; 1
    2cc2:	89 83       	std	Y+1, r24	; 0x01
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    2cc4:	89 81       	ldd	r24, Y+1	; 0x01
    2cc6:	88 23       	and	r24, r24
    2cc8:	99 f7       	brne	.-26     	; 0x2cb0 <xTaskResumeAll+0xe4>

						uxPendedTicks = 0;
    2cca:	10 92 d3 02 	sts	0x02D3, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    2cce:	80 91 d4 02 	lds	r24, 0x02D4
    2cd2:	88 23       	and	r24, r24
    2cd4:	21 f0       	breq	.+8      	; 0x2cde <xTaskResumeAll+0x112>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    2cd6:	81 e0       	ldi	r24, 0x01	; 1
    2cd8:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    2cda:	0e 94 b3 0a 	call	0x1566	; 0x1566 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    2cde:	0f 90       	pop	r0
    2ce0:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    2ce2:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2ce4:	0f 90       	pop	r0
    2ce6:	0f 90       	pop	r0
    2ce8:	0f 90       	pop	r0
    2cea:	0f 90       	pop	r0
    2cec:	cf 91       	pop	r28
    2cee:	df 91       	pop	r29
    2cf0:	08 95       	ret

00002cf2 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    2cf2:	df 93       	push	r29
    2cf4:	cf 93       	push	r28
    2cf6:	00 d0       	rcall	.+0      	; 0x2cf8 <xTaskGetTickCount+0x6>
    2cf8:	cd b7       	in	r28, 0x3d	; 61
    2cfa:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    2cfc:	0f b6       	in	r0, 0x3f	; 63
    2cfe:	f8 94       	cli
    2d00:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    2d02:	80 91 cf 02 	lds	r24, 0x02CF
    2d06:	90 91 d0 02 	lds	r25, 0x02D0
    2d0a:	9a 83       	std	Y+2, r25	; 0x02
    2d0c:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    2d0e:	0f 90       	pop	r0
    2d10:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    2d12:	89 81       	ldd	r24, Y+1	; 0x01
    2d14:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2d16:	0f 90       	pop	r0
    2d18:	0f 90       	pop	r0
    2d1a:	cf 91       	pop	r28
    2d1c:	df 91       	pop	r29
    2d1e:	08 95       	ret

00002d20 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    2d20:	df 93       	push	r29
    2d22:	cf 93       	push	r28
    2d24:	00 d0       	rcall	.+0      	; 0x2d26 <xTaskGetTickCountFromISR+0x6>
    2d26:	0f 92       	push	r0
    2d28:	cd b7       	in	r28, 0x3d	; 61
    2d2a:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    2d2c:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    2d2e:	80 91 cf 02 	lds	r24, 0x02CF
    2d32:	90 91 d0 02 	lds	r25, 0x02D0
    2d36:	9b 83       	std	Y+3, r25	; 0x03
    2d38:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2d3a:	8a 81       	ldd	r24, Y+2	; 0x02
    2d3c:	9b 81       	ldd	r25, Y+3	; 0x03
}
    2d3e:	0f 90       	pop	r0
    2d40:	0f 90       	pop	r0
    2d42:	0f 90       	pop	r0
    2d44:	cf 91       	pop	r28
    2d46:	df 91       	pop	r29
    2d48:	08 95       	ret

00002d4a <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    2d4a:	df 93       	push	r29
    2d4c:	cf 93       	push	r28
    2d4e:	cd b7       	in	r28, 0x3d	; 61
    2d50:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    2d52:	80 91 ce 02 	lds	r24, 0x02CE
}
    2d56:	cf 91       	pop	r28
    2d58:	df 91       	pop	r29
    2d5a:	08 95       	ret

00002d5c <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    2d5c:	df 93       	push	r29
    2d5e:	cf 93       	push	r28
    2d60:	00 d0       	rcall	.+0      	; 0x2d62 <pcTaskGetName+0x6>
    2d62:	00 d0       	rcall	.+0      	; 0x2d64 <pcTaskGetName+0x8>
    2d64:	00 d0       	rcall	.+0      	; 0x2d66 <pcTaskGetName+0xa>
    2d66:	cd b7       	in	r28, 0x3d	; 61
    2d68:	de b7       	in	r29, 0x3e	; 62
    2d6a:	9c 83       	std	Y+4, r25	; 0x04
    2d6c:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    2d6e:	8b 81       	ldd	r24, Y+3	; 0x03
    2d70:	9c 81       	ldd	r25, Y+4	; 0x04
    2d72:	00 97       	sbiw	r24, 0x00	; 0
    2d74:	39 f4       	brne	.+14     	; 0x2d84 <pcTaskGetName+0x28>
    2d76:	80 91 cb 02 	lds	r24, 0x02CB
    2d7a:	90 91 cc 02 	lds	r25, 0x02CC
    2d7e:	9e 83       	std	Y+6, r25	; 0x06
    2d80:	8d 83       	std	Y+5, r24	; 0x05
    2d82:	04 c0       	rjmp	.+8      	; 0x2d8c <pcTaskGetName+0x30>
    2d84:	8b 81       	ldd	r24, Y+3	; 0x03
    2d86:	9c 81       	ldd	r25, Y+4	; 0x04
    2d88:	9e 83       	std	Y+6, r25	; 0x06
    2d8a:	8d 83       	std	Y+5, r24	; 0x05
    2d8c:	8d 81       	ldd	r24, Y+5	; 0x05
    2d8e:	9e 81       	ldd	r25, Y+6	; 0x06
    2d90:	9a 83       	std	Y+2, r25	; 0x02
    2d92:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    2d94:	89 81       	ldd	r24, Y+1	; 0x01
    2d96:	9a 81       	ldd	r25, Y+2	; 0x02
    2d98:	49 96       	adiw	r24, 0x19	; 25
}
    2d9a:	26 96       	adiw	r28, 0x06	; 6
    2d9c:	0f b6       	in	r0, 0x3f	; 63
    2d9e:	f8 94       	cli
    2da0:	de bf       	out	0x3e, r29	; 62
    2da2:	0f be       	out	0x3f, r0	; 63
    2da4:	cd bf       	out	0x3d, r28	; 61
    2da6:	cf 91       	pop	r28
    2da8:	df 91       	pop	r29
    2daa:	08 95       	ret

00002dac <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    2dac:	df 93       	push	r29
    2dae:	cf 93       	push	r28
    2db0:	cd b7       	in	r28, 0x3d	; 61
    2db2:	de b7       	in	r29, 0x3e	; 62
    2db4:	29 97       	sbiw	r28, 0x09	; 9
    2db6:	0f b6       	in	r0, 0x3f	; 63
    2db8:	f8 94       	cli
    2dba:	de bf       	out	0x3e, r29	; 62
    2dbc:	0f be       	out	0x3f, r0	; 63
    2dbe:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    2dc0:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2dc2:	80 91 db 02 	lds	r24, 0x02DB
    2dc6:	88 23       	and	r24, r24
    2dc8:	09 f0       	breq	.+2      	; 0x2dcc <xTaskIncrementTick+0x20>
    2dca:	c0 c0       	rjmp	.+384    	; 0x2f4c <xTaskIncrementTick+0x1a0>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    2dcc:	80 91 cf 02 	lds	r24, 0x02CF
    2dd0:	90 91 d0 02 	lds	r25, 0x02D0
    2dd4:	01 96       	adiw	r24, 0x01	; 1
    2dd6:	9c 83       	std	Y+4, r25	; 0x04
    2dd8:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    2dda:	8b 81       	ldd	r24, Y+3	; 0x03
    2ddc:	9c 81       	ldd	r25, Y+4	; 0x04
    2dde:	90 93 d0 02 	sts	0x02D0, r25
    2de2:	80 93 cf 02 	sts	0x02CF, r24

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    2de6:	8b 81       	ldd	r24, Y+3	; 0x03
    2de8:	9c 81       	ldd	r25, Y+4	; 0x04
    2dea:	00 97       	sbiw	r24, 0x00	; 0
    2dec:	d9 f4       	brne	.+54     	; 0x2e24 <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    2dee:	80 91 12 03 	lds	r24, 0x0312
    2df2:	90 91 13 03 	lds	r25, 0x0313
    2df6:	9a 83       	std	Y+2, r25	; 0x02
    2df8:	89 83       	std	Y+1, r24	; 0x01
    2dfa:	80 91 14 03 	lds	r24, 0x0314
    2dfe:	90 91 15 03 	lds	r25, 0x0315
    2e02:	90 93 13 03 	sts	0x0313, r25
    2e06:	80 93 12 03 	sts	0x0312, r24
    2e0a:	89 81       	ldd	r24, Y+1	; 0x01
    2e0c:	9a 81       	ldd	r25, Y+2	; 0x02
    2e0e:	90 93 15 03 	sts	0x0315, r25
    2e12:	80 93 14 03 	sts	0x0314, r24
    2e16:	80 91 d5 02 	lds	r24, 0x02D5
    2e1a:	8f 5f       	subi	r24, 0xFF	; 255
    2e1c:	80 93 d5 02 	sts	0x02D5, r24
    2e20:	0e 94 72 1a 	call	0x34e4	; 0x34e4 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    2e24:	20 91 d7 02 	lds	r18, 0x02D7
    2e28:	30 91 d8 02 	lds	r19, 0x02D8
    2e2c:	8b 81       	ldd	r24, Y+3	; 0x03
    2e2e:	9c 81       	ldd	r25, Y+4	; 0x04
    2e30:	82 17       	cp	r24, r18
    2e32:	93 07       	cpc	r25, r19
    2e34:	08 f4       	brcc	.+2      	; 0x2e38 <xTaskIncrementTick+0x8c>
    2e36:	71 c0       	rjmp	.+226    	; 0x2f1a <xTaskIncrementTick+0x16e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2e38:	e0 91 12 03 	lds	r30, 0x0312
    2e3c:	f0 91 13 03 	lds	r31, 0x0313
    2e40:	80 81       	ld	r24, Z
    2e42:	88 23       	and	r24, r24
    2e44:	39 f4       	brne	.+14     	; 0x2e54 <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2e46:	8f ef       	ldi	r24, 0xFF	; 255
    2e48:	9f ef       	ldi	r25, 0xFF	; 255
    2e4a:	90 93 d8 02 	sts	0x02D8, r25
    2e4e:	80 93 d7 02 	sts	0x02D7, r24
    2e52:	63 c0       	rjmp	.+198    	; 0x2f1a <xTaskIncrementTick+0x16e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2e54:	e0 91 12 03 	lds	r30, 0x0312
    2e58:	f0 91 13 03 	lds	r31, 0x0313
    2e5c:	05 80       	ldd	r0, Z+5	; 0x05
    2e5e:	f6 81       	ldd	r31, Z+6	; 0x06
    2e60:	e0 2d       	mov	r30, r0
    2e62:	86 81       	ldd	r24, Z+6	; 0x06
    2e64:	97 81       	ldd	r25, Z+7	; 0x07
    2e66:	99 87       	std	Y+9, r25	; 0x09
    2e68:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    2e6a:	e8 85       	ldd	r30, Y+8	; 0x08
    2e6c:	f9 85       	ldd	r31, Y+9	; 0x09
    2e6e:	82 81       	ldd	r24, Z+2	; 0x02
    2e70:	93 81       	ldd	r25, Z+3	; 0x03
    2e72:	9f 83       	std	Y+7, r25	; 0x07
    2e74:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    2e76:	2b 81       	ldd	r18, Y+3	; 0x03
    2e78:	3c 81       	ldd	r19, Y+4	; 0x04
    2e7a:	8e 81       	ldd	r24, Y+6	; 0x06
    2e7c:	9f 81       	ldd	r25, Y+7	; 0x07
    2e7e:	28 17       	cp	r18, r24
    2e80:	39 07       	cpc	r19, r25
    2e82:	38 f4       	brcc	.+14     	; 0x2e92 <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    2e84:	8e 81       	ldd	r24, Y+6	; 0x06
    2e86:	9f 81       	ldd	r25, Y+7	; 0x07
    2e88:	90 93 d8 02 	sts	0x02D8, r25
    2e8c:	80 93 d7 02 	sts	0x02D7, r24
    2e90:	44 c0       	rjmp	.+136    	; 0x2f1a <xTaskIncrementTick+0x16e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2e92:	88 85       	ldd	r24, Y+8	; 0x08
    2e94:	99 85       	ldd	r25, Y+9	; 0x09
    2e96:	02 96       	adiw	r24, 0x02	; 2
    2e98:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    2e9c:	e8 85       	ldd	r30, Y+8	; 0x08
    2e9e:	f9 85       	ldd	r31, Y+9	; 0x09
    2ea0:	84 89       	ldd	r24, Z+20	; 0x14
    2ea2:	95 89       	ldd	r25, Z+21	; 0x15
    2ea4:	00 97       	sbiw	r24, 0x00	; 0
    2ea6:	29 f0       	breq	.+10     	; 0x2eb2 <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2ea8:	88 85       	ldd	r24, Y+8	; 0x08
    2eaa:	99 85       	ldd	r25, Y+9	; 0x09
    2eac:	0c 96       	adiw	r24, 0x0c	; 12
    2eae:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    2eb2:	e8 85       	ldd	r30, Y+8	; 0x08
    2eb4:	f9 85       	ldd	r31, Y+9	; 0x09
    2eb6:	96 89       	ldd	r25, Z+22	; 0x16
    2eb8:	80 91 d1 02 	lds	r24, 0x02D1
    2ebc:	89 17       	cp	r24, r25
    2ebe:	28 f4       	brcc	.+10     	; 0x2eca <xTaskIncrementTick+0x11e>
    2ec0:	e8 85       	ldd	r30, Y+8	; 0x08
    2ec2:	f9 85       	ldd	r31, Y+9	; 0x09
    2ec4:	86 89       	ldd	r24, Z+22	; 0x16
    2ec6:	80 93 d1 02 	sts	0x02D1, r24
    2eca:	e8 85       	ldd	r30, Y+8	; 0x08
    2ecc:	f9 85       	ldd	r31, Y+9	; 0x09
    2ece:	86 89       	ldd	r24, Z+22	; 0x16
    2ed0:	28 2f       	mov	r18, r24
    2ed2:	30 e0       	ldi	r19, 0x00	; 0
    2ed4:	c9 01       	movw	r24, r18
    2ed6:	88 0f       	add	r24, r24
    2ed8:	99 1f       	adc	r25, r25
    2eda:	88 0f       	add	r24, r24
    2edc:	99 1f       	adc	r25, r25
    2ede:	88 0f       	add	r24, r24
    2ee0:	99 1f       	adc	r25, r25
    2ee2:	82 0f       	add	r24, r18
    2ee4:	93 1f       	adc	r25, r19
    2ee6:	ac 01       	movw	r20, r24
    2ee8:	44 52       	subi	r20, 0x24	; 36
    2eea:	5d 4f       	sbci	r21, 0xFD	; 253
    2eec:	88 85       	ldd	r24, Y+8	; 0x08
    2eee:	99 85       	ldd	r25, Y+9	; 0x09
    2ef0:	9c 01       	movw	r18, r24
    2ef2:	2e 5f       	subi	r18, 0xFE	; 254
    2ef4:	3f 4f       	sbci	r19, 0xFF	; 255
    2ef6:	ca 01       	movw	r24, r20
    2ef8:	b9 01       	movw	r22, r18
    2efa:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2efe:	e8 85       	ldd	r30, Y+8	; 0x08
    2f00:	f9 85       	ldd	r31, Y+9	; 0x09
    2f02:	96 89       	ldd	r25, Z+22	; 0x16
    2f04:	e0 91 cb 02 	lds	r30, 0x02CB
    2f08:	f0 91 cc 02 	lds	r31, 0x02CC
    2f0c:	86 89       	ldd	r24, Z+22	; 0x16
    2f0e:	98 17       	cp	r25, r24
    2f10:	08 f4       	brcc	.+2      	; 0x2f14 <xTaskIncrementTick+0x168>
    2f12:	92 cf       	rjmp	.-220    	; 0x2e38 <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    2f14:	81 e0       	ldi	r24, 0x01	; 1
    2f16:	8d 83       	std	Y+5, r24	; 0x05
    2f18:	8f cf       	rjmp	.-226    	; 0x2e38 <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    2f1a:	e0 91 cb 02 	lds	r30, 0x02CB
    2f1e:	f0 91 cc 02 	lds	r31, 0x02CC
    2f22:	86 89       	ldd	r24, Z+22	; 0x16
    2f24:	28 2f       	mov	r18, r24
    2f26:	30 e0       	ldi	r19, 0x00	; 0
    2f28:	c9 01       	movw	r24, r18
    2f2a:	88 0f       	add	r24, r24
    2f2c:	99 1f       	adc	r25, r25
    2f2e:	88 0f       	add	r24, r24
    2f30:	99 1f       	adc	r25, r25
    2f32:	88 0f       	add	r24, r24
    2f34:	99 1f       	adc	r25, r25
    2f36:	82 0f       	add	r24, r18
    2f38:	93 1f       	adc	r25, r19
    2f3a:	fc 01       	movw	r30, r24
    2f3c:	e4 52       	subi	r30, 0x24	; 36
    2f3e:	fd 4f       	sbci	r31, 0xFD	; 253
    2f40:	80 81       	ld	r24, Z
    2f42:	82 30       	cpi	r24, 0x02	; 2
    2f44:	40 f0       	brcs	.+16     	; 0x2f56 <xTaskIncrementTick+0x1aa>
			{
				xSwitchRequired = pdTRUE;
    2f46:	81 e0       	ldi	r24, 0x01	; 1
    2f48:	8d 83       	std	Y+5, r24	; 0x05
    2f4a:	05 c0       	rjmp	.+10     	; 0x2f56 <xTaskIncrementTick+0x1aa>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    2f4c:	80 91 d3 02 	lds	r24, 0x02D3
    2f50:	8f 5f       	subi	r24, 0xFF	; 255
    2f52:	80 93 d3 02 	sts	0x02D3, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    2f56:	80 91 d4 02 	lds	r24, 0x02D4
    2f5a:	88 23       	and	r24, r24
    2f5c:	11 f0       	breq	.+4      	; 0x2f62 <xTaskIncrementTick+0x1b6>
		{
			xSwitchRequired = pdTRUE;
    2f5e:	81 e0       	ldi	r24, 0x01	; 1
    2f60:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    2f62:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2f64:	29 96       	adiw	r28, 0x09	; 9
    2f66:	0f b6       	in	r0, 0x3f	; 63
    2f68:	f8 94       	cli
    2f6a:	de bf       	out	0x3e, r29	; 62
    2f6c:	0f be       	out	0x3f, r0	; 63
    2f6e:	cd bf       	out	0x3d, r28	; 61
    2f70:	cf 91       	pop	r28
    2f72:	df 91       	pop	r29
    2f74:	08 95       	ret

00002f76 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    2f76:	df 93       	push	r29
    2f78:	cf 93       	push	r28
    2f7a:	00 d0       	rcall	.+0      	; 0x2f7c <vTaskSwitchContext+0x6>
    2f7c:	0f 92       	push	r0
    2f7e:	cd b7       	in	r28, 0x3d	; 61
    2f80:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    2f82:	80 91 db 02 	lds	r24, 0x02DB
    2f86:	88 23       	and	r24, r24
    2f88:	21 f0       	breq	.+8      	; 0x2f92 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    2f8a:	81 e0       	ldi	r24, 0x01	; 1
    2f8c:	80 93 d4 02 	sts	0x02D4, r24
    2f90:	59 c0       	rjmp	.+178    	; 0x3044 <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    2f92:	10 92 d4 02 	sts	0x02D4, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2f96:	80 91 d1 02 	lds	r24, 0x02D1
    2f9a:	8b 83       	std	Y+3, r24	; 0x03
    2f9c:	03 c0       	rjmp	.+6      	; 0x2fa4 <vTaskSwitchContext+0x2e>
    2f9e:	8b 81       	ldd	r24, Y+3	; 0x03
    2fa0:	81 50       	subi	r24, 0x01	; 1
    2fa2:	8b 83       	std	Y+3, r24	; 0x03
    2fa4:	8b 81       	ldd	r24, Y+3	; 0x03
    2fa6:	28 2f       	mov	r18, r24
    2fa8:	30 e0       	ldi	r19, 0x00	; 0
    2faa:	c9 01       	movw	r24, r18
    2fac:	88 0f       	add	r24, r24
    2fae:	99 1f       	adc	r25, r25
    2fb0:	88 0f       	add	r24, r24
    2fb2:	99 1f       	adc	r25, r25
    2fb4:	88 0f       	add	r24, r24
    2fb6:	99 1f       	adc	r25, r25
    2fb8:	82 0f       	add	r24, r18
    2fba:	93 1f       	adc	r25, r19
    2fbc:	fc 01       	movw	r30, r24
    2fbe:	e4 52       	subi	r30, 0x24	; 36
    2fc0:	fd 4f       	sbci	r31, 0xFD	; 253
    2fc2:	80 81       	ld	r24, Z
    2fc4:	88 23       	and	r24, r24
    2fc6:	59 f3       	breq	.-42     	; 0x2f9e <vTaskSwitchContext+0x28>
    2fc8:	8b 81       	ldd	r24, Y+3	; 0x03
    2fca:	28 2f       	mov	r18, r24
    2fcc:	30 e0       	ldi	r19, 0x00	; 0
    2fce:	c9 01       	movw	r24, r18
    2fd0:	88 0f       	add	r24, r24
    2fd2:	99 1f       	adc	r25, r25
    2fd4:	88 0f       	add	r24, r24
    2fd6:	99 1f       	adc	r25, r25
    2fd8:	88 0f       	add	r24, r24
    2fda:	99 1f       	adc	r25, r25
    2fdc:	82 0f       	add	r24, r18
    2fde:	93 1f       	adc	r25, r19
    2fe0:	84 52       	subi	r24, 0x24	; 36
    2fe2:	9d 4f       	sbci	r25, 0xFD	; 253
    2fe4:	9a 83       	std	Y+2, r25	; 0x02
    2fe6:	89 83       	std	Y+1, r24	; 0x01
    2fe8:	e9 81       	ldd	r30, Y+1	; 0x01
    2fea:	fa 81       	ldd	r31, Y+2	; 0x02
    2fec:	01 80       	ldd	r0, Z+1	; 0x01
    2fee:	f2 81       	ldd	r31, Z+2	; 0x02
    2ff0:	e0 2d       	mov	r30, r0
    2ff2:	82 81       	ldd	r24, Z+2	; 0x02
    2ff4:	93 81       	ldd	r25, Z+3	; 0x03
    2ff6:	e9 81       	ldd	r30, Y+1	; 0x01
    2ff8:	fa 81       	ldd	r31, Y+2	; 0x02
    2ffa:	92 83       	std	Z+2, r25	; 0x02
    2ffc:	81 83       	std	Z+1, r24	; 0x01
    2ffe:	e9 81       	ldd	r30, Y+1	; 0x01
    3000:	fa 81       	ldd	r31, Y+2	; 0x02
    3002:	21 81       	ldd	r18, Z+1	; 0x01
    3004:	32 81       	ldd	r19, Z+2	; 0x02
    3006:	89 81       	ldd	r24, Y+1	; 0x01
    3008:	9a 81       	ldd	r25, Y+2	; 0x02
    300a:	03 96       	adiw	r24, 0x03	; 3
    300c:	28 17       	cp	r18, r24
    300e:	39 07       	cpc	r19, r25
    3010:	59 f4       	brne	.+22     	; 0x3028 <vTaskSwitchContext+0xb2>
    3012:	e9 81       	ldd	r30, Y+1	; 0x01
    3014:	fa 81       	ldd	r31, Y+2	; 0x02
    3016:	01 80       	ldd	r0, Z+1	; 0x01
    3018:	f2 81       	ldd	r31, Z+2	; 0x02
    301a:	e0 2d       	mov	r30, r0
    301c:	82 81       	ldd	r24, Z+2	; 0x02
    301e:	93 81       	ldd	r25, Z+3	; 0x03
    3020:	e9 81       	ldd	r30, Y+1	; 0x01
    3022:	fa 81       	ldd	r31, Y+2	; 0x02
    3024:	92 83       	std	Z+2, r25	; 0x02
    3026:	81 83       	std	Z+1, r24	; 0x01
    3028:	e9 81       	ldd	r30, Y+1	; 0x01
    302a:	fa 81       	ldd	r31, Y+2	; 0x02
    302c:	01 80       	ldd	r0, Z+1	; 0x01
    302e:	f2 81       	ldd	r31, Z+2	; 0x02
    3030:	e0 2d       	mov	r30, r0
    3032:	86 81       	ldd	r24, Z+6	; 0x06
    3034:	97 81       	ldd	r25, Z+7	; 0x07
    3036:	90 93 cc 02 	sts	0x02CC, r25
    303a:	80 93 cb 02 	sts	0x02CB, r24
    303e:	8b 81       	ldd	r24, Y+3	; 0x03
    3040:	80 93 d1 02 	sts	0x02D1, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    3044:	0f 90       	pop	r0
    3046:	0f 90       	pop	r0
    3048:	0f 90       	pop	r0
    304a:	cf 91       	pop	r28
    304c:	df 91       	pop	r29
    304e:	08 95       	ret

00003050 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    3050:	df 93       	push	r29
    3052:	cf 93       	push	r28
    3054:	00 d0       	rcall	.+0      	; 0x3056 <vTaskPlaceOnEventList+0x6>
    3056:	00 d0       	rcall	.+0      	; 0x3058 <vTaskPlaceOnEventList+0x8>
    3058:	cd b7       	in	r28, 0x3d	; 61
    305a:	de b7       	in	r29, 0x3e	; 62
    305c:	9a 83       	std	Y+2, r25	; 0x02
    305e:	89 83       	std	Y+1, r24	; 0x01
    3060:	7c 83       	std	Y+4, r23	; 0x04
    3062:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3064:	80 91 cb 02 	lds	r24, 0x02CB
    3068:	90 91 cc 02 	lds	r25, 0x02CC
    306c:	9c 01       	movw	r18, r24
    306e:	24 5f       	subi	r18, 0xF4	; 244
    3070:	3f 4f       	sbci	r19, 0xFF	; 255
    3072:	89 81       	ldd	r24, Y+1	; 0x01
    3074:	9a 81       	ldd	r25, Y+2	; 0x02
    3076:	b9 01       	movw	r22, r18
    3078:	0e 94 a9 07 	call	0xf52	; 0xf52 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    307c:	8b 81       	ldd	r24, Y+3	; 0x03
    307e:	9c 81       	ldd	r25, Y+4	; 0x04
    3080:	61 e0       	ldi	r22, 0x01	; 1
    3082:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <prvAddCurrentTaskToDelayedList>
}
    3086:	0f 90       	pop	r0
    3088:	0f 90       	pop	r0
    308a:	0f 90       	pop	r0
    308c:	0f 90       	pop	r0
    308e:	cf 91       	pop	r28
    3090:	df 91       	pop	r29
    3092:	08 95       	ret

00003094 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    3094:	df 93       	push	r29
    3096:	cf 93       	push	r28
    3098:	00 d0       	rcall	.+0      	; 0x309a <vTaskPlaceOnUnorderedEventList+0x6>
    309a:	00 d0       	rcall	.+0      	; 0x309c <vTaskPlaceOnUnorderedEventList+0x8>
    309c:	00 d0       	rcall	.+0      	; 0x309e <vTaskPlaceOnUnorderedEventList+0xa>
    309e:	cd b7       	in	r28, 0x3d	; 61
    30a0:	de b7       	in	r29, 0x3e	; 62
    30a2:	9a 83       	std	Y+2, r25	; 0x02
    30a4:	89 83       	std	Y+1, r24	; 0x01
    30a6:	7c 83       	std	Y+4, r23	; 0x04
    30a8:	6b 83       	std	Y+3, r22	; 0x03
    30aa:	5e 83       	std	Y+6, r21	; 0x06
    30ac:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    30ae:	e0 91 cb 02 	lds	r30, 0x02CB
    30b2:	f0 91 cc 02 	lds	r31, 0x02CC
    30b6:	8b 81       	ldd	r24, Y+3	; 0x03
    30b8:	9c 81       	ldd	r25, Y+4	; 0x04
    30ba:	90 68       	ori	r25, 0x80	; 128
    30bc:	95 87       	std	Z+13, r25	; 0x0d
    30be:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    30c0:	80 91 cb 02 	lds	r24, 0x02CB
    30c4:	90 91 cc 02 	lds	r25, 0x02CC
    30c8:	9c 01       	movw	r18, r24
    30ca:	24 5f       	subi	r18, 0xF4	; 244
    30cc:	3f 4f       	sbci	r19, 0xFF	; 255
    30ce:	89 81       	ldd	r24, Y+1	; 0x01
    30d0:	9a 81       	ldd	r25, Y+2	; 0x02
    30d2:	b9 01       	movw	r22, r18
    30d4:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    30d8:	8d 81       	ldd	r24, Y+5	; 0x05
    30da:	9e 81       	ldd	r25, Y+6	; 0x06
    30dc:	61 e0       	ldi	r22, 0x01	; 1
    30de:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <prvAddCurrentTaskToDelayedList>
}
    30e2:	26 96       	adiw	r28, 0x06	; 6
    30e4:	0f b6       	in	r0, 0x3f	; 63
    30e6:	f8 94       	cli
    30e8:	de bf       	out	0x3e, r29	; 62
    30ea:	0f be       	out	0x3f, r0	; 63
    30ec:	cd bf       	out	0x3d, r28	; 61
    30ee:	cf 91       	pop	r28
    30f0:	df 91       	pop	r29
    30f2:	08 95       	ret

000030f4 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    30f4:	df 93       	push	r29
    30f6:	cf 93       	push	r28
    30f8:	00 d0       	rcall	.+0      	; 0x30fa <xTaskRemoveFromEventList+0x6>
    30fa:	00 d0       	rcall	.+0      	; 0x30fc <xTaskRemoveFromEventList+0x8>
    30fc:	0f 92       	push	r0
    30fe:	cd b7       	in	r28, 0x3d	; 61
    3100:	de b7       	in	r29, 0x3e	; 62
    3102:	9d 83       	std	Y+5, r25	; 0x05
    3104:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3106:	ec 81       	ldd	r30, Y+4	; 0x04
    3108:	fd 81       	ldd	r31, Y+5	; 0x05
    310a:	05 80       	ldd	r0, Z+5	; 0x05
    310c:	f6 81       	ldd	r31, Z+6	; 0x06
    310e:	e0 2d       	mov	r30, r0
    3110:	86 81       	ldd	r24, Z+6	; 0x06
    3112:	97 81       	ldd	r25, Z+7	; 0x07
    3114:	9b 83       	std	Y+3, r25	; 0x03
    3116:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    3118:	8a 81       	ldd	r24, Y+2	; 0x02
    311a:	9b 81       	ldd	r25, Y+3	; 0x03
    311c:	0c 96       	adiw	r24, 0x0c	; 12
    311e:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3122:	80 91 db 02 	lds	r24, 0x02DB
    3126:	88 23       	and	r24, r24
    3128:	61 f5       	brne	.+88     	; 0x3182 <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    312a:	8a 81       	ldd	r24, Y+2	; 0x02
    312c:	9b 81       	ldd	r25, Y+3	; 0x03
    312e:	02 96       	adiw	r24, 0x02	; 2
    3130:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    3134:	ea 81       	ldd	r30, Y+2	; 0x02
    3136:	fb 81       	ldd	r31, Y+3	; 0x03
    3138:	96 89       	ldd	r25, Z+22	; 0x16
    313a:	80 91 d1 02 	lds	r24, 0x02D1
    313e:	89 17       	cp	r24, r25
    3140:	28 f4       	brcc	.+10     	; 0x314c <xTaskRemoveFromEventList+0x58>
    3142:	ea 81       	ldd	r30, Y+2	; 0x02
    3144:	fb 81       	ldd	r31, Y+3	; 0x03
    3146:	86 89       	ldd	r24, Z+22	; 0x16
    3148:	80 93 d1 02 	sts	0x02D1, r24
    314c:	ea 81       	ldd	r30, Y+2	; 0x02
    314e:	fb 81       	ldd	r31, Y+3	; 0x03
    3150:	86 89       	ldd	r24, Z+22	; 0x16
    3152:	28 2f       	mov	r18, r24
    3154:	30 e0       	ldi	r19, 0x00	; 0
    3156:	c9 01       	movw	r24, r18
    3158:	88 0f       	add	r24, r24
    315a:	99 1f       	adc	r25, r25
    315c:	88 0f       	add	r24, r24
    315e:	99 1f       	adc	r25, r25
    3160:	88 0f       	add	r24, r24
    3162:	99 1f       	adc	r25, r25
    3164:	82 0f       	add	r24, r18
    3166:	93 1f       	adc	r25, r19
    3168:	ac 01       	movw	r20, r24
    316a:	44 52       	subi	r20, 0x24	; 36
    316c:	5d 4f       	sbci	r21, 0xFD	; 253
    316e:	8a 81       	ldd	r24, Y+2	; 0x02
    3170:	9b 81       	ldd	r25, Y+3	; 0x03
    3172:	9c 01       	movw	r18, r24
    3174:	2e 5f       	subi	r18, 0xFE	; 254
    3176:	3f 4f       	sbci	r19, 0xFF	; 255
    3178:	ca 01       	movw	r24, r20
    317a:	b9 01       	movw	r22, r18
    317c:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>
    3180:	0a c0       	rjmp	.+20     	; 0x3196 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    3182:	8a 81       	ldd	r24, Y+2	; 0x02
    3184:	9b 81       	ldd	r25, Y+3	; 0x03
    3186:	9c 01       	movw	r18, r24
    3188:	24 5f       	subi	r18, 0xF4	; 244
    318a:	3f 4f       	sbci	r19, 0xFF	; 255
    318c:	86 e1       	ldi	r24, 0x16	; 22
    318e:	93 e0       	ldi	r25, 0x03	; 3
    3190:	b9 01       	movw	r22, r18
    3192:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3196:	ea 81       	ldd	r30, Y+2	; 0x02
    3198:	fb 81       	ldd	r31, Y+3	; 0x03
    319a:	96 89       	ldd	r25, Z+22	; 0x16
    319c:	e0 91 cb 02 	lds	r30, 0x02CB
    31a0:	f0 91 cc 02 	lds	r31, 0x02CC
    31a4:	86 89       	ldd	r24, Z+22	; 0x16
    31a6:	89 17       	cp	r24, r25
    31a8:	30 f4       	brcc	.+12     	; 0x31b6 <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    31aa:	81 e0       	ldi	r24, 0x01	; 1
    31ac:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    31ae:	81 e0       	ldi	r24, 0x01	; 1
    31b0:	80 93 d4 02 	sts	0x02D4, r24
    31b4:	01 c0       	rjmp	.+2      	; 0x31b8 <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    31b6:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    31b8:	89 81       	ldd	r24, Y+1	; 0x01
}
    31ba:	0f 90       	pop	r0
    31bc:	0f 90       	pop	r0
    31be:	0f 90       	pop	r0
    31c0:	0f 90       	pop	r0
    31c2:	0f 90       	pop	r0
    31c4:	cf 91       	pop	r28
    31c6:	df 91       	pop	r29
    31c8:	08 95       	ret

000031ca <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    31ca:	df 93       	push	r29
    31cc:	cf 93       	push	r28
    31ce:	00 d0       	rcall	.+0      	; 0x31d0 <vTaskRemoveFromUnorderedEventList+0x6>
    31d0:	00 d0       	rcall	.+0      	; 0x31d2 <vTaskRemoveFromUnorderedEventList+0x8>
    31d2:	00 d0       	rcall	.+0      	; 0x31d4 <vTaskRemoveFromUnorderedEventList+0xa>
    31d4:	cd b7       	in	r28, 0x3d	; 61
    31d6:	de b7       	in	r29, 0x3e	; 62
    31d8:	9c 83       	std	Y+4, r25	; 0x04
    31da:	8b 83       	std	Y+3, r24	; 0x03
    31dc:	7e 83       	std	Y+6, r23	; 0x06
    31de:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    31e0:	8d 81       	ldd	r24, Y+5	; 0x05
    31e2:	9e 81       	ldd	r25, Y+6	; 0x06
    31e4:	90 68       	ori	r25, 0x80	; 128
    31e6:	eb 81       	ldd	r30, Y+3	; 0x03
    31e8:	fc 81       	ldd	r31, Y+4	; 0x04
    31ea:	91 83       	std	Z+1, r25	; 0x01
    31ec:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    31ee:	eb 81       	ldd	r30, Y+3	; 0x03
    31f0:	fc 81       	ldd	r31, Y+4	; 0x04
    31f2:	86 81       	ldd	r24, Z+6	; 0x06
    31f4:	97 81       	ldd	r25, Z+7	; 0x07
    31f6:	9a 83       	std	Y+2, r25	; 0x02
    31f8:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    31fa:	8b 81       	ldd	r24, Y+3	; 0x03
    31fc:	9c 81       	ldd	r25, Y+4	; 0x04
    31fe:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    3202:	89 81       	ldd	r24, Y+1	; 0x01
    3204:	9a 81       	ldd	r25, Y+2	; 0x02
    3206:	02 96       	adiw	r24, 0x02	; 2
    3208:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    320c:	e9 81       	ldd	r30, Y+1	; 0x01
    320e:	fa 81       	ldd	r31, Y+2	; 0x02
    3210:	96 89       	ldd	r25, Z+22	; 0x16
    3212:	80 91 d1 02 	lds	r24, 0x02D1
    3216:	89 17       	cp	r24, r25
    3218:	28 f4       	brcc	.+10     	; 0x3224 <vTaskRemoveFromUnorderedEventList+0x5a>
    321a:	e9 81       	ldd	r30, Y+1	; 0x01
    321c:	fa 81       	ldd	r31, Y+2	; 0x02
    321e:	86 89       	ldd	r24, Z+22	; 0x16
    3220:	80 93 d1 02 	sts	0x02D1, r24
    3224:	e9 81       	ldd	r30, Y+1	; 0x01
    3226:	fa 81       	ldd	r31, Y+2	; 0x02
    3228:	86 89       	ldd	r24, Z+22	; 0x16
    322a:	28 2f       	mov	r18, r24
    322c:	30 e0       	ldi	r19, 0x00	; 0
    322e:	c9 01       	movw	r24, r18
    3230:	88 0f       	add	r24, r24
    3232:	99 1f       	adc	r25, r25
    3234:	88 0f       	add	r24, r24
    3236:	99 1f       	adc	r25, r25
    3238:	88 0f       	add	r24, r24
    323a:	99 1f       	adc	r25, r25
    323c:	82 0f       	add	r24, r18
    323e:	93 1f       	adc	r25, r19
    3240:	ac 01       	movw	r20, r24
    3242:	44 52       	subi	r20, 0x24	; 36
    3244:	5d 4f       	sbci	r21, 0xFD	; 253
    3246:	89 81       	ldd	r24, Y+1	; 0x01
    3248:	9a 81       	ldd	r25, Y+2	; 0x02
    324a:	9c 01       	movw	r18, r24
    324c:	2e 5f       	subi	r18, 0xFE	; 254
    324e:	3f 4f       	sbci	r19, 0xFF	; 255
    3250:	ca 01       	movw	r24, r20
    3252:	b9 01       	movw	r22, r18
    3254:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3258:	e9 81       	ldd	r30, Y+1	; 0x01
    325a:	fa 81       	ldd	r31, Y+2	; 0x02
    325c:	96 89       	ldd	r25, Z+22	; 0x16
    325e:	e0 91 cb 02 	lds	r30, 0x02CB
    3262:	f0 91 cc 02 	lds	r31, 0x02CC
    3266:	86 89       	ldd	r24, Z+22	; 0x16
    3268:	89 17       	cp	r24, r25
    326a:	18 f4       	brcc	.+6      	; 0x3272 <vTaskRemoveFromUnorderedEventList+0xa8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    326c:	81 e0       	ldi	r24, 0x01	; 1
    326e:	80 93 d4 02 	sts	0x02D4, r24
	}
}
    3272:	26 96       	adiw	r28, 0x06	; 6
    3274:	0f b6       	in	r0, 0x3f	; 63
    3276:	f8 94       	cli
    3278:	de bf       	out	0x3e, r29	; 62
    327a:	0f be       	out	0x3f, r0	; 63
    327c:	cd bf       	out	0x3d, r28	; 61
    327e:	cf 91       	pop	r28
    3280:	df 91       	pop	r29
    3282:	08 95       	ret

00003284 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    3284:	df 93       	push	r29
    3286:	cf 93       	push	r28
    3288:	00 d0       	rcall	.+0      	; 0x328a <vTaskSetTimeOutState+0x6>
    328a:	cd b7       	in	r28, 0x3d	; 61
    328c:	de b7       	in	r29, 0x3e	; 62
    328e:	9a 83       	std	Y+2, r25	; 0x02
    3290:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    3292:	0f b6       	in	r0, 0x3f	; 63
    3294:	f8 94       	cli
    3296:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    3298:	80 91 d5 02 	lds	r24, 0x02D5
    329c:	e9 81       	ldd	r30, Y+1	; 0x01
    329e:	fa 81       	ldd	r31, Y+2	; 0x02
    32a0:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    32a2:	80 91 cf 02 	lds	r24, 0x02CF
    32a6:	90 91 d0 02 	lds	r25, 0x02D0
    32aa:	e9 81       	ldd	r30, Y+1	; 0x01
    32ac:	fa 81       	ldd	r31, Y+2	; 0x02
    32ae:	92 83       	std	Z+2, r25	; 0x02
    32b0:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    32b2:	0f 90       	pop	r0
    32b4:	0f be       	out	0x3f, r0	; 63
}
    32b6:	0f 90       	pop	r0
    32b8:	0f 90       	pop	r0
    32ba:	cf 91       	pop	r28
    32bc:	df 91       	pop	r29
    32be:	08 95       	ret

000032c0 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    32c0:	df 93       	push	r29
    32c2:	cf 93       	push	r28
    32c4:	00 d0       	rcall	.+0      	; 0x32c6 <vTaskInternalSetTimeOutState+0x6>
    32c6:	cd b7       	in	r28, 0x3d	; 61
    32c8:	de b7       	in	r29, 0x3e	; 62
    32ca:	9a 83       	std	Y+2, r25	; 0x02
    32cc:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    32ce:	80 91 d5 02 	lds	r24, 0x02D5
    32d2:	e9 81       	ldd	r30, Y+1	; 0x01
    32d4:	fa 81       	ldd	r31, Y+2	; 0x02
    32d6:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    32d8:	80 91 cf 02 	lds	r24, 0x02CF
    32dc:	90 91 d0 02 	lds	r25, 0x02D0
    32e0:	e9 81       	ldd	r30, Y+1	; 0x01
    32e2:	fa 81       	ldd	r31, Y+2	; 0x02
    32e4:	92 83       	std	Z+2, r25	; 0x02
    32e6:	81 83       	std	Z+1, r24	; 0x01
}
    32e8:	0f 90       	pop	r0
    32ea:	0f 90       	pop	r0
    32ec:	cf 91       	pop	r28
    32ee:	df 91       	pop	r29
    32f0:	08 95       	ret

000032f2 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    32f2:	df 93       	push	r29
    32f4:	cf 93       	push	r28
    32f6:	cd b7       	in	r28, 0x3d	; 61
    32f8:	de b7       	in	r29, 0x3e	; 62
    32fa:	29 97       	sbiw	r28, 0x09	; 9
    32fc:	0f b6       	in	r0, 0x3f	; 63
    32fe:	f8 94       	cli
    3300:	de bf       	out	0x3e, r29	; 62
    3302:	0f be       	out	0x3f, r0	; 63
    3304:	cd bf       	out	0x3d, r28	; 61
    3306:	9f 83       	std	Y+7, r25	; 0x07
    3308:	8e 83       	std	Y+6, r24	; 0x06
    330a:	79 87       	std	Y+9, r23	; 0x09
    330c:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    330e:	0f b6       	in	r0, 0x3f	; 63
    3310:	f8 94       	cli
    3312:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    3314:	80 91 cf 02 	lds	r24, 0x02CF
    3318:	90 91 d0 02 	lds	r25, 0x02D0
    331c:	9c 83       	std	Y+4, r25	; 0x04
    331e:	8b 83       	std	Y+3, r24	; 0x03
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    3320:	ee 81       	ldd	r30, Y+6	; 0x06
    3322:	ff 81       	ldd	r31, Y+7	; 0x07
    3324:	21 81       	ldd	r18, Z+1	; 0x01
    3326:	32 81       	ldd	r19, Z+2	; 0x02
    3328:	8b 81       	ldd	r24, Y+3	; 0x03
    332a:	9c 81       	ldd	r25, Y+4	; 0x04
    332c:	82 1b       	sub	r24, r18
    332e:	93 0b       	sbc	r25, r19
    3330:	9a 83       	std	Y+2, r25	; 0x02
    3332:	89 83       	std	Y+1, r24	; 0x01
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    3334:	ee 81       	ldd	r30, Y+6	; 0x06
    3336:	ff 81       	ldd	r31, Y+7	; 0x07
    3338:	90 81       	ld	r25, Z
    333a:	80 91 d5 02 	lds	r24, 0x02D5
    333e:	98 17       	cp	r25, r24
    3340:	61 f0       	breq	.+24     	; 0x335a <xTaskCheckForTimeOut+0x68>
    3342:	ee 81       	ldd	r30, Y+6	; 0x06
    3344:	ff 81       	ldd	r31, Y+7	; 0x07
    3346:	21 81       	ldd	r18, Z+1	; 0x01
    3348:	32 81       	ldd	r19, Z+2	; 0x02
    334a:	8b 81       	ldd	r24, Y+3	; 0x03
    334c:	9c 81       	ldd	r25, Y+4	; 0x04
    334e:	82 17       	cp	r24, r18
    3350:	93 07       	cpc	r25, r19
    3352:	18 f0       	brcs	.+6      	; 0x335a <xTaskCheckForTimeOut+0x68>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    3354:	81 e0       	ldi	r24, 0x01	; 1
    3356:	8d 83       	std	Y+5, r24	; 0x05
    3358:	23 c0       	rjmp	.+70     	; 0x33a0 <xTaskCheckForTimeOut+0xae>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    335a:	e8 85       	ldd	r30, Y+8	; 0x08
    335c:	f9 85       	ldd	r31, Y+9	; 0x09
    335e:	20 81       	ld	r18, Z
    3360:	31 81       	ldd	r19, Z+1	; 0x01
    3362:	89 81       	ldd	r24, Y+1	; 0x01
    3364:	9a 81       	ldd	r25, Y+2	; 0x02
    3366:	82 17       	cp	r24, r18
    3368:	93 07       	cpc	r25, r19
    336a:	a0 f4       	brcc	.+40     	; 0x3394 <xTaskCheckForTimeOut+0xa2>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    336c:	e8 85       	ldd	r30, Y+8	; 0x08
    336e:	f9 85       	ldd	r31, Y+9	; 0x09
    3370:	20 81       	ld	r18, Z
    3372:	31 81       	ldd	r19, Z+1	; 0x01
    3374:	89 81       	ldd	r24, Y+1	; 0x01
    3376:	9a 81       	ldd	r25, Y+2	; 0x02
    3378:	a9 01       	movw	r20, r18
    337a:	48 1b       	sub	r20, r24
    337c:	59 0b       	sbc	r21, r25
    337e:	ca 01       	movw	r24, r20
    3380:	e8 85       	ldd	r30, Y+8	; 0x08
    3382:	f9 85       	ldd	r31, Y+9	; 0x09
    3384:	91 83       	std	Z+1, r25	; 0x01
    3386:	80 83       	st	Z, r24
			vTaskInternalSetTimeOutState( pxTimeOut );
    3388:	8e 81       	ldd	r24, Y+6	; 0x06
    338a:	9f 81       	ldd	r25, Y+7	; 0x07
    338c:	0e 94 60 19 	call	0x32c0	; 0x32c0 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    3390:	1d 82       	std	Y+5, r1	; 0x05
    3392:	06 c0       	rjmp	.+12     	; 0x33a0 <xTaskCheckForTimeOut+0xae>
		}
		else
		{
			*pxTicksToWait = 0;
    3394:	e8 85       	ldd	r30, Y+8	; 0x08
    3396:	f9 85       	ldd	r31, Y+9	; 0x09
    3398:	11 82       	std	Z+1, r1	; 0x01
    339a:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    339c:	81 e0       	ldi	r24, 0x01	; 1
    339e:	8d 83       	std	Y+5, r24	; 0x05
		}
	}
	taskEXIT_CRITICAL();
    33a0:	0f 90       	pop	r0
    33a2:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    33a4:	8d 81       	ldd	r24, Y+5	; 0x05
}
    33a6:	29 96       	adiw	r28, 0x09	; 9
    33a8:	0f b6       	in	r0, 0x3f	; 63
    33aa:	f8 94       	cli
    33ac:	de bf       	out	0x3e, r29	; 62
    33ae:	0f be       	out	0x3f, r0	; 63
    33b0:	cd bf       	out	0x3d, r28	; 61
    33b2:	cf 91       	pop	r28
    33b4:	df 91       	pop	r29
    33b6:	08 95       	ret

000033b8 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    33b8:	df 93       	push	r29
    33ba:	cf 93       	push	r28
    33bc:	cd b7       	in	r28, 0x3d	; 61
    33be:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    33c0:	81 e0       	ldi	r24, 0x01	; 1
    33c2:	80 93 d4 02 	sts	0x02D4, r24
}
    33c6:	cf 91       	pop	r28
    33c8:	df 91       	pop	r29
    33ca:	08 95       	ret

000033cc <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    33cc:	df 93       	push	r29
    33ce:	cf 93       	push	r28
    33d0:	00 d0       	rcall	.+0      	; 0x33d2 <prvIdleTask+0x6>
    33d2:	cd b7       	in	r28, 0x3d	; 61
    33d4:	de b7       	in	r29, 0x3e	; 62
    33d6:	9a 83       	std	Y+2, r25	; 0x02
    33d8:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    33da:	0e 94 2d 1a 	call	0x345a	; 0x345a <prvCheckTasksWaitingTermination>
    33de:	fd cf       	rjmp	.-6      	; 0x33da <prvIdleTask+0xe>

000033e0 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    33e0:	df 93       	push	r29
    33e2:	cf 93       	push	r28
    33e4:	0f 92       	push	r0
    33e6:	cd b7       	in	r28, 0x3d	; 61
    33e8:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    33ea:	19 82       	std	Y+1, r1	; 0x01
    33ec:	13 c0       	rjmp	.+38     	; 0x3414 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    33ee:	89 81       	ldd	r24, Y+1	; 0x01
    33f0:	28 2f       	mov	r18, r24
    33f2:	30 e0       	ldi	r19, 0x00	; 0
    33f4:	c9 01       	movw	r24, r18
    33f6:	88 0f       	add	r24, r24
    33f8:	99 1f       	adc	r25, r25
    33fa:	88 0f       	add	r24, r24
    33fc:	99 1f       	adc	r25, r25
    33fe:	88 0f       	add	r24, r24
    3400:	99 1f       	adc	r25, r25
    3402:	82 0f       	add	r24, r18
    3404:	93 1f       	adc	r25, r19
    3406:	84 52       	subi	r24, 0x24	; 36
    3408:	9d 4f       	sbci	r25, 0xFD	; 253
    340a:	0e 94 2b 07 	call	0xe56	; 0xe56 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    340e:	89 81       	ldd	r24, Y+1	; 0x01
    3410:	8f 5f       	subi	r24, 0xFF	; 255
    3412:	89 83       	std	Y+1, r24	; 0x01
    3414:	89 81       	ldd	r24, Y+1	; 0x01
    3416:	84 30       	cpi	r24, 0x04	; 4
    3418:	50 f3       	brcs	.-44     	; 0x33ee <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    341a:	80 e0       	ldi	r24, 0x00	; 0
    341c:	93 e0       	ldi	r25, 0x03	; 3
    341e:	0e 94 2b 07 	call	0xe56	; 0xe56 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    3422:	89 e0       	ldi	r24, 0x09	; 9
    3424:	93 e0       	ldi	r25, 0x03	; 3
    3426:	0e 94 2b 07 	call	0xe56	; 0xe56 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    342a:	86 e1       	ldi	r24, 0x16	; 22
    342c:	93 e0       	ldi	r25, 0x03	; 3
    342e:	0e 94 2b 07 	call	0xe56	; 0xe56 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    3432:	8f e1       	ldi	r24, 0x1F	; 31
    3434:	93 e0       	ldi	r25, 0x03	; 3
    3436:	0e 94 2b 07 	call	0xe56	; 0xe56 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    343a:	80 e0       	ldi	r24, 0x00	; 0
    343c:	93 e0       	ldi	r25, 0x03	; 3
    343e:	90 93 13 03 	sts	0x0313, r25
    3442:	80 93 12 03 	sts	0x0312, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    3446:	89 e0       	ldi	r24, 0x09	; 9
    3448:	93 e0       	ldi	r25, 0x03	; 3
    344a:	90 93 15 03 	sts	0x0315, r25
    344e:	80 93 14 03 	sts	0x0314, r24
}
    3452:	0f 90       	pop	r0
    3454:	cf 91       	pop	r28
    3456:	df 91       	pop	r29
    3458:	08 95       	ret

0000345a <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    345a:	df 93       	push	r29
    345c:	cf 93       	push	r28
    345e:	00 d0       	rcall	.+0      	; 0x3460 <prvCheckTasksWaitingTermination+0x6>
    3460:	cd b7       	in	r28, 0x3d	; 61
    3462:	de b7       	in	r29, 0x3e	; 62
    3464:	20 c0       	rjmp	.+64     	; 0x34a6 <prvCheckTasksWaitingTermination+0x4c>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
    3466:	0f b6       	in	r0, 0x3f	; 63
    3468:	f8 94       	cli
    346a:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    346c:	e0 91 24 03 	lds	r30, 0x0324
    3470:	f0 91 25 03 	lds	r31, 0x0325
    3474:	86 81       	ldd	r24, Z+6	; 0x06
    3476:	97 81       	ldd	r25, Z+7	; 0x07
    3478:	9a 83       	std	Y+2, r25	; 0x02
    347a:	89 83       	std	Y+1, r24	; 0x01
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    347c:	89 81       	ldd	r24, Y+1	; 0x01
    347e:	9a 81       	ldd	r25, Y+2	; 0x02
    3480:	02 96       	adiw	r24, 0x02	; 2
    3482:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>
				--uxCurrentNumberOfTasks;
    3486:	80 91 ce 02 	lds	r24, 0x02CE
    348a:	81 50       	subi	r24, 0x01	; 1
    348c:	80 93 ce 02 	sts	0x02CE, r24
				--uxDeletedTasksWaitingCleanUp;
    3490:	80 91 cd 02 	lds	r24, 0x02CD
    3494:	81 50       	subi	r24, 0x01	; 1
    3496:	80 93 cd 02 	sts	0x02CD, r24
			}
			taskEXIT_CRITICAL();
    349a:	0f 90       	pop	r0
    349c:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    349e:	89 81       	ldd	r24, Y+1	; 0x01
    34a0:	9a 81       	ldd	r25, Y+2	; 0x02
    34a2:	0e 94 5c 1a 	call	0x34b8	; 0x34b8 <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    34a6:	80 91 cd 02 	lds	r24, 0x02CD
    34aa:	88 23       	and	r24, r24
    34ac:	e1 f6       	brne	.-72     	; 0x3466 <prvCheckTasksWaitingTermination+0xc>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    34ae:	0f 90       	pop	r0
    34b0:	0f 90       	pop	r0
    34b2:	cf 91       	pop	r28
    34b4:	df 91       	pop	r29
    34b6:	08 95       	ret

000034b8 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    34b8:	df 93       	push	r29
    34ba:	cf 93       	push	r28
    34bc:	00 d0       	rcall	.+0      	; 0x34be <prvDeleteTCB+0x6>
    34be:	cd b7       	in	r28, 0x3d	; 61
    34c0:	de b7       	in	r29, 0x3e	; 62
    34c2:	9a 83       	std	Y+2, r25	; 0x02
    34c4:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    34c6:	e9 81       	ldd	r30, Y+1	; 0x01
    34c8:	fa 81       	ldd	r31, Y+2	; 0x02
    34ca:	87 89       	ldd	r24, Z+23	; 0x17
    34cc:	90 8d       	ldd	r25, Z+24	; 0x18
    34ce:	0e 94 05 07 	call	0xe0a	; 0xe0a <vPortFree>
			vPortFree( pxTCB );
    34d2:	89 81       	ldd	r24, Y+1	; 0x01
    34d4:	9a 81       	ldd	r25, Y+2	; 0x02
    34d6:	0e 94 05 07 	call	0xe0a	; 0xe0a <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    34da:	0f 90       	pop	r0
    34dc:	0f 90       	pop	r0
    34de:	cf 91       	pop	r28
    34e0:	df 91       	pop	r29
    34e2:	08 95       	ret

000034e4 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    34e4:	df 93       	push	r29
    34e6:	cf 93       	push	r28
    34e8:	00 d0       	rcall	.+0      	; 0x34ea <prvResetNextTaskUnblockTime+0x6>
    34ea:	cd b7       	in	r28, 0x3d	; 61
    34ec:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    34ee:	e0 91 12 03 	lds	r30, 0x0312
    34f2:	f0 91 13 03 	lds	r31, 0x0313
    34f6:	80 81       	ld	r24, Z
    34f8:	88 23       	and	r24, r24
    34fa:	39 f4       	brne	.+14     	; 0x350a <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    34fc:	8f ef       	ldi	r24, 0xFF	; 255
    34fe:	9f ef       	ldi	r25, 0xFF	; 255
    3500:	90 93 d8 02 	sts	0x02D8, r25
    3504:	80 93 d7 02 	sts	0x02D7, r24
    3508:	13 c0       	rjmp	.+38     	; 0x3530 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    350a:	e0 91 12 03 	lds	r30, 0x0312
    350e:	f0 91 13 03 	lds	r31, 0x0313
    3512:	05 80       	ldd	r0, Z+5	; 0x05
    3514:	f6 81       	ldd	r31, Z+6	; 0x06
    3516:	e0 2d       	mov	r30, r0
    3518:	86 81       	ldd	r24, Z+6	; 0x06
    351a:	97 81       	ldd	r25, Z+7	; 0x07
    351c:	9a 83       	std	Y+2, r25	; 0x02
    351e:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    3520:	e9 81       	ldd	r30, Y+1	; 0x01
    3522:	fa 81       	ldd	r31, Y+2	; 0x02
    3524:	82 81       	ldd	r24, Z+2	; 0x02
    3526:	93 81       	ldd	r25, Z+3	; 0x03
    3528:	90 93 d8 02 	sts	0x02D8, r25
    352c:	80 93 d7 02 	sts	0x02D7, r24
	}
}
    3530:	0f 90       	pop	r0
    3532:	0f 90       	pop	r0
    3534:	cf 91       	pop	r28
    3536:	df 91       	pop	r29
    3538:	08 95       	ret

0000353a <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    353a:	df 93       	push	r29
    353c:	cf 93       	push	r28
    353e:	00 d0       	rcall	.+0      	; 0x3540 <uxTaskResetEventItemValue+0x6>
    3540:	cd b7       	in	r28, 0x3d	; 61
    3542:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    3544:	e0 91 cb 02 	lds	r30, 0x02CB
    3548:	f0 91 cc 02 	lds	r31, 0x02CC
    354c:	84 85       	ldd	r24, Z+12	; 0x0c
    354e:	95 85       	ldd	r25, Z+13	; 0x0d
    3550:	9a 83       	std	Y+2, r25	; 0x02
    3552:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3554:	a0 91 cb 02 	lds	r26, 0x02CB
    3558:	b0 91 cc 02 	lds	r27, 0x02CC
    355c:	e0 91 cb 02 	lds	r30, 0x02CB
    3560:	f0 91 cc 02 	lds	r31, 0x02CC
    3564:	86 89       	ldd	r24, Z+22	; 0x16
    3566:	28 2f       	mov	r18, r24
    3568:	30 e0       	ldi	r19, 0x00	; 0
    356a:	84 e0       	ldi	r24, 0x04	; 4
    356c:	90 e0       	ldi	r25, 0x00	; 0
    356e:	82 1b       	sub	r24, r18
    3570:	93 0b       	sbc	r25, r19
    3572:	1d 96       	adiw	r26, 0x0d	; 13
    3574:	9c 93       	st	X, r25
    3576:	8e 93       	st	-X, r24
    3578:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    357a:	89 81       	ldd	r24, Y+1	; 0x01
    357c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    357e:	0f 90       	pop	r0
    3580:	0f 90       	pop	r0
    3582:	cf 91       	pop	r28
    3584:	df 91       	pop	r29
    3586:	08 95       	ret

00003588 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    3588:	df 93       	push	r29
    358a:	cf 93       	push	r28
    358c:	cd b7       	in	r28, 0x3d	; 61
    358e:	de b7       	in	r29, 0x3e	; 62
    3590:	27 97       	sbiw	r28, 0x07	; 7
    3592:	0f b6       	in	r0, 0x3f	; 63
    3594:	f8 94       	cli
    3596:	de bf       	out	0x3e, r29	; 62
    3598:	0f be       	out	0x3f, r0	; 63
    359a:	cd bf       	out	0x3d, r28	; 61
    359c:	8d 83       	std	Y+5, r24	; 0x05
    359e:	7f 83       	std	Y+7, r23	; 0x07
    35a0:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    35a2:	0f b6       	in	r0, 0x3f	; 63
    35a4:	f8 94       	cli
    35a6:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    35a8:	e0 91 cb 02 	lds	r30, 0x02CB
    35ac:	f0 91 cc 02 	lds	r31, 0x02CC
    35b0:	81 a1       	ldd	r24, Z+33	; 0x21
    35b2:	92 a1       	ldd	r25, Z+34	; 0x22
    35b4:	a3 a1       	ldd	r26, Z+35	; 0x23
    35b6:	b4 a1       	ldd	r27, Z+36	; 0x24
    35b8:	00 97       	sbiw	r24, 0x00	; 0
    35ba:	a1 05       	cpc	r26, r1
    35bc:	b1 05       	cpc	r27, r1
    35be:	89 f4       	brne	.+34     	; 0x35e2 <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    35c0:	e0 91 cb 02 	lds	r30, 0x02CB
    35c4:	f0 91 cc 02 	lds	r31, 0x02CC
    35c8:	81 e0       	ldi	r24, 0x01	; 1
    35ca:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    35cc:	8e 81       	ldd	r24, Y+6	; 0x06
    35ce:	9f 81       	ldd	r25, Y+7	; 0x07
    35d0:	00 97       	sbiw	r24, 0x00	; 0
    35d2:	39 f0       	breq	.+14     	; 0x35e2 <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    35d4:	8e 81       	ldd	r24, Y+6	; 0x06
    35d6:	9f 81       	ldd	r25, Y+7	; 0x07
    35d8:	61 e0       	ldi	r22, 0x01	; 1
    35da:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    35de:	0e 94 b3 0a 	call	0x1566	; 0x1566 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    35e2:	0f 90       	pop	r0
    35e4:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    35e6:	0f b6       	in	r0, 0x3f	; 63
    35e8:	f8 94       	cli
    35ea:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    35ec:	e0 91 cb 02 	lds	r30, 0x02CB
    35f0:	f0 91 cc 02 	lds	r31, 0x02CC
    35f4:	81 a1       	ldd	r24, Z+33	; 0x21
    35f6:	92 a1       	ldd	r25, Z+34	; 0x22
    35f8:	a3 a1       	ldd	r26, Z+35	; 0x23
    35fa:	b4 a1       	ldd	r27, Z+36	; 0x24
    35fc:	89 83       	std	Y+1, r24	; 0x01
    35fe:	9a 83       	std	Y+2, r25	; 0x02
    3600:	ab 83       	std	Y+3, r26	; 0x03
    3602:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    3604:	89 81       	ldd	r24, Y+1	; 0x01
    3606:	9a 81       	ldd	r25, Y+2	; 0x02
    3608:	ab 81       	ldd	r26, Y+3	; 0x03
    360a:	bc 81       	ldd	r27, Y+4	; 0x04
    360c:	00 97       	sbiw	r24, 0x00	; 0
    360e:	a1 05       	cpc	r26, r1
    3610:	b1 05       	cpc	r27, r1
    3612:	d9 f0       	breq	.+54     	; 0x364a <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    3614:	8d 81       	ldd	r24, Y+5	; 0x05
    3616:	88 23       	and	r24, r24
    3618:	49 f0       	breq	.+18     	; 0x362c <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    361a:	e0 91 cb 02 	lds	r30, 0x02CB
    361e:	f0 91 cc 02 	lds	r31, 0x02CC
    3622:	11 a2       	std	Z+33, r1	; 0x21
    3624:	12 a2       	std	Z+34, r1	; 0x22
    3626:	13 a2       	std	Z+35, r1	; 0x23
    3628:	14 a2       	std	Z+36, r1	; 0x24
    362a:	0f c0       	rjmp	.+30     	; 0x364a <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    362c:	e0 91 cb 02 	lds	r30, 0x02CB
    3630:	f0 91 cc 02 	lds	r31, 0x02CC
    3634:	89 81       	ldd	r24, Y+1	; 0x01
    3636:	9a 81       	ldd	r25, Y+2	; 0x02
    3638:	ab 81       	ldd	r26, Y+3	; 0x03
    363a:	bc 81       	ldd	r27, Y+4	; 0x04
    363c:	01 97       	sbiw	r24, 0x01	; 1
    363e:	a1 09       	sbc	r26, r1
    3640:	b1 09       	sbc	r27, r1
    3642:	81 a3       	std	Z+33, r24	; 0x21
    3644:	92 a3       	std	Z+34, r25	; 0x22
    3646:	a3 a3       	std	Z+35, r26	; 0x23
    3648:	b4 a3       	std	Z+36, r27	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    364a:	e0 91 cb 02 	lds	r30, 0x02CB
    364e:	f0 91 cc 02 	lds	r31, 0x02CC
    3652:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    3654:	0f 90       	pop	r0
    3656:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    3658:	89 81       	ldd	r24, Y+1	; 0x01
    365a:	9a 81       	ldd	r25, Y+2	; 0x02
    365c:	ab 81       	ldd	r26, Y+3	; 0x03
    365e:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    3660:	bc 01       	movw	r22, r24
    3662:	cd 01       	movw	r24, r26
    3664:	27 96       	adiw	r28, 0x07	; 7
    3666:	0f b6       	in	r0, 0x3f	; 63
    3668:	f8 94       	cli
    366a:	de bf       	out	0x3e, r29	; 62
    366c:	0f be       	out	0x3f, r0	; 63
    366e:	cd bf       	out	0x3d, r28	; 61
    3670:	cf 91       	pop	r28
    3672:	df 91       	pop	r29
    3674:	08 95       	ret

00003676 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    3676:	ef 92       	push	r14
    3678:	ff 92       	push	r15
    367a:	0f 93       	push	r16
    367c:	1f 93       	push	r17
    367e:	df 93       	push	r29
    3680:	cf 93       	push	r28
    3682:	cd b7       	in	r28, 0x3d	; 61
    3684:	de b7       	in	r29, 0x3e	; 62
    3686:	2d 97       	sbiw	r28, 0x0d	; 13
    3688:	0f b6       	in	r0, 0x3f	; 63
    368a:	f8 94       	cli
    368c:	de bf       	out	0x3e, r29	; 62
    368e:	0f be       	out	0x3f, r0	; 63
    3690:	cd bf       	out	0x3d, r28	; 61
    3692:	6a 83       	std	Y+2, r22	; 0x02
    3694:	7b 83       	std	Y+3, r23	; 0x03
    3696:	8c 83       	std	Y+4, r24	; 0x04
    3698:	9d 83       	std	Y+5, r25	; 0x05
    369a:	2e 83       	std	Y+6, r18	; 0x06
    369c:	3f 83       	std	Y+7, r19	; 0x07
    369e:	48 87       	std	Y+8, r20	; 0x08
    36a0:	59 87       	std	Y+9, r21	; 0x09
    36a2:	1b 87       	std	Y+11, r17	; 0x0b
    36a4:	0a 87       	std	Y+10, r16	; 0x0a
    36a6:	fd 86       	std	Y+13, r15	; 0x0d
    36a8:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    36aa:	0f b6       	in	r0, 0x3f	; 63
    36ac:	f8 94       	cli
    36ae:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    36b0:	e0 91 cb 02 	lds	r30, 0x02CB
    36b4:	f0 91 cc 02 	lds	r31, 0x02CC
    36b8:	85 a1       	ldd	r24, Z+37	; 0x25
    36ba:	82 30       	cpi	r24, 0x02	; 2
    36bc:	49 f1       	breq	.+82     	; 0x3710 <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    36be:	e0 91 cb 02 	lds	r30, 0x02CB
    36c2:	f0 91 cc 02 	lds	r31, 0x02CC
    36c6:	21 a1       	ldd	r18, Z+33	; 0x21
    36c8:	32 a1       	ldd	r19, Z+34	; 0x22
    36ca:	43 a1       	ldd	r20, Z+35	; 0x23
    36cc:	54 a1       	ldd	r21, Z+36	; 0x24
    36ce:	8a 81       	ldd	r24, Y+2	; 0x02
    36d0:	9b 81       	ldd	r25, Y+3	; 0x03
    36d2:	ac 81       	ldd	r26, Y+4	; 0x04
    36d4:	bd 81       	ldd	r27, Y+5	; 0x05
    36d6:	80 95       	com	r24
    36d8:	90 95       	com	r25
    36da:	a0 95       	com	r26
    36dc:	b0 95       	com	r27
    36de:	82 23       	and	r24, r18
    36e0:	93 23       	and	r25, r19
    36e2:	a4 23       	and	r26, r20
    36e4:	b5 23       	and	r27, r21
    36e6:	81 a3       	std	Z+33, r24	; 0x21
    36e8:	92 a3       	std	Z+34, r25	; 0x22
    36ea:	a3 a3       	std	Z+35, r26	; 0x23
    36ec:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    36ee:	e0 91 cb 02 	lds	r30, 0x02CB
    36f2:	f0 91 cc 02 	lds	r31, 0x02CC
    36f6:	81 e0       	ldi	r24, 0x01	; 1
    36f8:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    36fa:	8c 85       	ldd	r24, Y+12	; 0x0c
    36fc:	9d 85       	ldd	r25, Y+13	; 0x0d
    36fe:	00 97       	sbiw	r24, 0x00	; 0
    3700:	39 f0       	breq	.+14     	; 0x3710 <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3702:	8c 85       	ldd	r24, Y+12	; 0x0c
    3704:	9d 85       	ldd	r25, Y+13	; 0x0d
    3706:	61 e0       	ldi	r22, 0x01	; 1
    3708:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    370c:	0e 94 b3 0a 	call	0x1566	; 0x1566 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    3710:	0f 90       	pop	r0
    3712:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    3714:	0f b6       	in	r0, 0x3f	; 63
    3716:	f8 94       	cli
    3718:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    371a:	8a 85       	ldd	r24, Y+10	; 0x0a
    371c:	9b 85       	ldd	r25, Y+11	; 0x0b
    371e:	00 97       	sbiw	r24, 0x00	; 0
    3720:	71 f0       	breq	.+28     	; 0x373e <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    3722:	e0 91 cb 02 	lds	r30, 0x02CB
    3726:	f0 91 cc 02 	lds	r31, 0x02CC
    372a:	81 a1       	ldd	r24, Z+33	; 0x21
    372c:	92 a1       	ldd	r25, Z+34	; 0x22
    372e:	a3 a1       	ldd	r26, Z+35	; 0x23
    3730:	b4 a1       	ldd	r27, Z+36	; 0x24
    3732:	ea 85       	ldd	r30, Y+10	; 0x0a
    3734:	fb 85       	ldd	r31, Y+11	; 0x0b
    3736:	80 83       	st	Z, r24
    3738:	91 83       	std	Z+1, r25	; 0x01
    373a:	a2 83       	std	Z+2, r26	; 0x02
    373c:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    373e:	e0 91 cb 02 	lds	r30, 0x02CB
    3742:	f0 91 cc 02 	lds	r31, 0x02CC
    3746:	85 a1       	ldd	r24, Z+37	; 0x25
    3748:	82 30       	cpi	r24, 0x02	; 2
    374a:	11 f0       	breq	.+4      	; 0x3750 <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    374c:	19 82       	std	Y+1, r1	; 0x01
    374e:	1a c0       	rjmp	.+52     	; 0x3784 <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    3750:	e0 91 cb 02 	lds	r30, 0x02CB
    3754:	f0 91 cc 02 	lds	r31, 0x02CC
    3758:	21 a1       	ldd	r18, Z+33	; 0x21
    375a:	32 a1       	ldd	r19, Z+34	; 0x22
    375c:	43 a1       	ldd	r20, Z+35	; 0x23
    375e:	54 a1       	ldd	r21, Z+36	; 0x24
    3760:	8e 81       	ldd	r24, Y+6	; 0x06
    3762:	9f 81       	ldd	r25, Y+7	; 0x07
    3764:	a8 85       	ldd	r26, Y+8	; 0x08
    3766:	b9 85       	ldd	r27, Y+9	; 0x09
    3768:	80 95       	com	r24
    376a:	90 95       	com	r25
    376c:	a0 95       	com	r26
    376e:	b0 95       	com	r27
    3770:	82 23       	and	r24, r18
    3772:	93 23       	and	r25, r19
    3774:	a4 23       	and	r26, r20
    3776:	b5 23       	and	r27, r21
    3778:	81 a3       	std	Z+33, r24	; 0x21
    377a:	92 a3       	std	Z+34, r25	; 0x22
    377c:	a3 a3       	std	Z+35, r26	; 0x23
    377e:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
    3780:	81 e0       	ldi	r24, 0x01	; 1
    3782:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3784:	e0 91 cb 02 	lds	r30, 0x02CB
    3788:	f0 91 cc 02 	lds	r31, 0x02CC
    378c:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    378e:	0f 90       	pop	r0
    3790:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    3792:	89 81       	ldd	r24, Y+1	; 0x01
	}
    3794:	2d 96       	adiw	r28, 0x0d	; 13
    3796:	0f b6       	in	r0, 0x3f	; 63
    3798:	f8 94       	cli
    379a:	de bf       	out	0x3e, r29	; 62
    379c:	0f be       	out	0x3f, r0	; 63
    379e:	cd bf       	out	0x3d, r28	; 61
    37a0:	cf 91       	pop	r28
    37a2:	df 91       	pop	r29
    37a4:	1f 91       	pop	r17
    37a6:	0f 91       	pop	r16
    37a8:	ff 90       	pop	r15
    37aa:	ef 90       	pop	r14
    37ac:	08 95       	ret

000037ae <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    37ae:	0f 93       	push	r16
    37b0:	1f 93       	push	r17
    37b2:	df 93       	push	r29
    37b4:	cf 93       	push	r28
    37b6:	cd b7       	in	r28, 0x3d	; 61
    37b8:	de b7       	in	r29, 0x3e	; 62
    37ba:	2f 97       	sbiw	r28, 0x0f	; 15
    37bc:	0f b6       	in	r0, 0x3f	; 63
    37be:	f8 94       	cli
    37c0:	de bf       	out	0x3e, r29	; 62
    37c2:	0f be       	out	0x3f, r0	; 63
    37c4:	cd bf       	out	0x3d, r28	; 61
    37c6:	9e 83       	std	Y+6, r25	; 0x06
    37c8:	8d 83       	std	Y+5, r24	; 0x05
    37ca:	4f 83       	std	Y+7, r20	; 0x07
    37cc:	58 87       	std	Y+8, r21	; 0x08
    37ce:	69 87       	std	Y+9, r22	; 0x09
    37d0:	7a 87       	std	Y+10, r23	; 0x0a
    37d2:	2b 87       	std	Y+11, r18	; 0x0b
    37d4:	1d 87       	std	Y+13, r17	; 0x0d
    37d6:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    37d8:	81 e0       	ldi	r24, 0x01	; 1
    37da:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    37dc:	8d 81       	ldd	r24, Y+5	; 0x05
    37de:	9e 81       	ldd	r25, Y+6	; 0x06
    37e0:	9c 83       	std	Y+4, r25	; 0x04
    37e2:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    37e4:	0f b6       	in	r0, 0x3f	; 63
    37e6:	f8 94       	cli
    37e8:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    37ea:	8c 85       	ldd	r24, Y+12	; 0x0c
    37ec:	9d 85       	ldd	r25, Y+13	; 0x0d
    37ee:	00 97       	sbiw	r24, 0x00	; 0
    37f0:	61 f0       	breq	.+24     	; 0x380a <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    37f2:	eb 81       	ldd	r30, Y+3	; 0x03
    37f4:	fc 81       	ldd	r31, Y+4	; 0x04
    37f6:	81 a1       	ldd	r24, Z+33	; 0x21
    37f8:	92 a1       	ldd	r25, Z+34	; 0x22
    37fa:	a3 a1       	ldd	r26, Z+35	; 0x23
    37fc:	b4 a1       	ldd	r27, Z+36	; 0x24
    37fe:	ec 85       	ldd	r30, Y+12	; 0x0c
    3800:	fd 85       	ldd	r31, Y+13	; 0x0d
    3802:	80 83       	st	Z, r24
    3804:	91 83       	std	Z+1, r25	; 0x01
    3806:	a2 83       	std	Z+2, r26	; 0x02
    3808:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    380a:	eb 81       	ldd	r30, Y+3	; 0x03
    380c:	fc 81       	ldd	r31, Y+4	; 0x04
    380e:	85 a1       	ldd	r24, Z+37	; 0x25
    3810:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    3812:	eb 81       	ldd	r30, Y+3	; 0x03
    3814:	fc 81       	ldd	r31, Y+4	; 0x04
    3816:	82 e0       	ldi	r24, 0x02	; 2
    3818:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    381a:	8b 85       	ldd	r24, Y+11	; 0x0b
    381c:	28 2f       	mov	r18, r24
    381e:	30 e0       	ldi	r19, 0x00	; 0
    3820:	3f 87       	std	Y+15, r19	; 0x0f
    3822:	2e 87       	std	Y+14, r18	; 0x0e
    3824:	8e 85       	ldd	r24, Y+14	; 0x0e
    3826:	9f 85       	ldd	r25, Y+15	; 0x0f
    3828:	82 30       	cpi	r24, 0x02	; 2
    382a:	91 05       	cpc	r25, r1
    382c:	59 f1       	breq	.+86     	; 0x3884 <xTaskGenericNotify+0xd6>
    382e:	2e 85       	ldd	r18, Y+14	; 0x0e
    3830:	3f 85       	ldd	r19, Y+15	; 0x0f
    3832:	23 30       	cpi	r18, 0x03	; 3
    3834:	31 05       	cpc	r19, r1
    3836:	34 f4       	brge	.+12     	; 0x3844 <xTaskGenericNotify+0x96>
    3838:	8e 85       	ldd	r24, Y+14	; 0x0e
    383a:	9f 85       	ldd	r25, Y+15	; 0x0f
    383c:	81 30       	cpi	r24, 0x01	; 1
    383e:	91 05       	cpc	r25, r1
    3840:	61 f0       	breq	.+24     	; 0x385a <xTaskGenericNotify+0xac>
    3842:	4a c0       	rjmp	.+148    	; 0x38d8 <xTaskGenericNotify+0x12a>
    3844:	2e 85       	ldd	r18, Y+14	; 0x0e
    3846:	3f 85       	ldd	r19, Y+15	; 0x0f
    3848:	23 30       	cpi	r18, 0x03	; 3
    384a:	31 05       	cpc	r19, r1
    384c:	59 f1       	breq	.+86     	; 0x38a4 <xTaskGenericNotify+0xf6>
    384e:	8e 85       	ldd	r24, Y+14	; 0x0e
    3850:	9f 85       	ldd	r25, Y+15	; 0x0f
    3852:	84 30       	cpi	r24, 0x04	; 4
    3854:	91 05       	cpc	r25, r1
    3856:	89 f1       	breq	.+98     	; 0x38ba <xTaskGenericNotify+0x10c>
    3858:	3f c0       	rjmp	.+126    	; 0x38d8 <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    385a:	eb 81       	ldd	r30, Y+3	; 0x03
    385c:	fc 81       	ldd	r31, Y+4	; 0x04
    385e:	21 a1       	ldd	r18, Z+33	; 0x21
    3860:	32 a1       	ldd	r19, Z+34	; 0x22
    3862:	43 a1       	ldd	r20, Z+35	; 0x23
    3864:	54 a1       	ldd	r21, Z+36	; 0x24
    3866:	8f 81       	ldd	r24, Y+7	; 0x07
    3868:	98 85       	ldd	r25, Y+8	; 0x08
    386a:	a9 85       	ldd	r26, Y+9	; 0x09
    386c:	ba 85       	ldd	r27, Y+10	; 0x0a
    386e:	82 2b       	or	r24, r18
    3870:	93 2b       	or	r25, r19
    3872:	a4 2b       	or	r26, r20
    3874:	b5 2b       	or	r27, r21
    3876:	eb 81       	ldd	r30, Y+3	; 0x03
    3878:	fc 81       	ldd	r31, Y+4	; 0x04
    387a:	81 a3       	std	Z+33, r24	; 0x21
    387c:	92 a3       	std	Z+34, r25	; 0x22
    387e:	a3 a3       	std	Z+35, r26	; 0x23
    3880:	b4 a3       	std	Z+36, r27	; 0x24
    3882:	2a c0       	rjmp	.+84     	; 0x38d8 <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    3884:	eb 81       	ldd	r30, Y+3	; 0x03
    3886:	fc 81       	ldd	r31, Y+4	; 0x04
    3888:	81 a1       	ldd	r24, Z+33	; 0x21
    388a:	92 a1       	ldd	r25, Z+34	; 0x22
    388c:	a3 a1       	ldd	r26, Z+35	; 0x23
    388e:	b4 a1       	ldd	r27, Z+36	; 0x24
    3890:	01 96       	adiw	r24, 0x01	; 1
    3892:	a1 1d       	adc	r26, r1
    3894:	b1 1d       	adc	r27, r1
    3896:	eb 81       	ldd	r30, Y+3	; 0x03
    3898:	fc 81       	ldd	r31, Y+4	; 0x04
    389a:	81 a3       	std	Z+33, r24	; 0x21
    389c:	92 a3       	std	Z+34, r25	; 0x22
    389e:	a3 a3       	std	Z+35, r26	; 0x23
    38a0:	b4 a3       	std	Z+36, r27	; 0x24
    38a2:	1a c0       	rjmp	.+52     	; 0x38d8 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    38a4:	eb 81       	ldd	r30, Y+3	; 0x03
    38a6:	fc 81       	ldd	r31, Y+4	; 0x04
    38a8:	8f 81       	ldd	r24, Y+7	; 0x07
    38aa:	98 85       	ldd	r25, Y+8	; 0x08
    38ac:	a9 85       	ldd	r26, Y+9	; 0x09
    38ae:	ba 85       	ldd	r27, Y+10	; 0x0a
    38b0:	81 a3       	std	Z+33, r24	; 0x21
    38b2:	92 a3       	std	Z+34, r25	; 0x22
    38b4:	a3 a3       	std	Z+35, r26	; 0x23
    38b6:	b4 a3       	std	Z+36, r27	; 0x24
    38b8:	0f c0       	rjmp	.+30     	; 0x38d8 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    38ba:	89 81       	ldd	r24, Y+1	; 0x01
    38bc:	82 30       	cpi	r24, 0x02	; 2
    38be:	59 f0       	breq	.+22     	; 0x38d6 <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    38c0:	eb 81       	ldd	r30, Y+3	; 0x03
    38c2:	fc 81       	ldd	r31, Y+4	; 0x04
    38c4:	8f 81       	ldd	r24, Y+7	; 0x07
    38c6:	98 85       	ldd	r25, Y+8	; 0x08
    38c8:	a9 85       	ldd	r26, Y+9	; 0x09
    38ca:	ba 85       	ldd	r27, Y+10	; 0x0a
    38cc:	81 a3       	std	Z+33, r24	; 0x21
    38ce:	92 a3       	std	Z+34, r25	; 0x22
    38d0:	a3 a3       	std	Z+35, r26	; 0x23
    38d2:	b4 a3       	std	Z+36, r27	; 0x24
    38d4:	01 c0       	rjmp	.+2      	; 0x38d8 <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    38d6:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    38d8:	89 81       	ldd	r24, Y+1	; 0x01
    38da:	81 30       	cpi	r24, 0x01	; 1
    38dc:	b9 f5       	brne	.+110    	; 0x394c <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    38de:	8b 81       	ldd	r24, Y+3	; 0x03
    38e0:	9c 81       	ldd	r25, Y+4	; 0x04
    38e2:	02 96       	adiw	r24, 0x02	; 2
    38e4:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    38e8:	eb 81       	ldd	r30, Y+3	; 0x03
    38ea:	fc 81       	ldd	r31, Y+4	; 0x04
    38ec:	96 89       	ldd	r25, Z+22	; 0x16
    38ee:	80 91 d1 02 	lds	r24, 0x02D1
    38f2:	89 17       	cp	r24, r25
    38f4:	28 f4       	brcc	.+10     	; 0x3900 <xTaskGenericNotify+0x152>
    38f6:	eb 81       	ldd	r30, Y+3	; 0x03
    38f8:	fc 81       	ldd	r31, Y+4	; 0x04
    38fa:	86 89       	ldd	r24, Z+22	; 0x16
    38fc:	80 93 d1 02 	sts	0x02D1, r24
    3900:	eb 81       	ldd	r30, Y+3	; 0x03
    3902:	fc 81       	ldd	r31, Y+4	; 0x04
    3904:	86 89       	ldd	r24, Z+22	; 0x16
    3906:	28 2f       	mov	r18, r24
    3908:	30 e0       	ldi	r19, 0x00	; 0
    390a:	c9 01       	movw	r24, r18
    390c:	88 0f       	add	r24, r24
    390e:	99 1f       	adc	r25, r25
    3910:	88 0f       	add	r24, r24
    3912:	99 1f       	adc	r25, r25
    3914:	88 0f       	add	r24, r24
    3916:	99 1f       	adc	r25, r25
    3918:	82 0f       	add	r24, r18
    391a:	93 1f       	adc	r25, r19
    391c:	ac 01       	movw	r20, r24
    391e:	44 52       	subi	r20, 0x24	; 36
    3920:	5d 4f       	sbci	r21, 0xFD	; 253
    3922:	8b 81       	ldd	r24, Y+3	; 0x03
    3924:	9c 81       	ldd	r25, Y+4	; 0x04
    3926:	9c 01       	movw	r18, r24
    3928:	2e 5f       	subi	r18, 0xFE	; 254
    392a:	3f 4f       	sbci	r19, 0xFF	; 255
    392c:	ca 01       	movw	r24, r20
    392e:	b9 01       	movw	r22, r18
    3930:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    3934:	eb 81       	ldd	r30, Y+3	; 0x03
    3936:	fc 81       	ldd	r31, Y+4	; 0x04
    3938:	96 89       	ldd	r25, Z+22	; 0x16
    393a:	e0 91 cb 02 	lds	r30, 0x02CB
    393e:	f0 91 cc 02 	lds	r31, 0x02CC
    3942:	86 89       	ldd	r24, Z+22	; 0x16
    3944:	89 17       	cp	r24, r25
    3946:	10 f4       	brcc	.+4      	; 0x394c <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    3948:	0e 94 b3 0a 	call	0x1566	; 0x1566 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    394c:	0f 90       	pop	r0
    394e:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    3950:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    3952:	2f 96       	adiw	r28, 0x0f	; 15
    3954:	0f b6       	in	r0, 0x3f	; 63
    3956:	f8 94       	cli
    3958:	de bf       	out	0x3e, r29	; 62
    395a:	0f be       	out	0x3f, r0	; 63
    395c:	cd bf       	out	0x3d, r28	; 61
    395e:	cf 91       	pop	r28
    3960:	df 91       	pop	r29
    3962:	1f 91       	pop	r17
    3964:	0f 91       	pop	r16
    3966:	08 95       	ret

00003968 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    3968:	ef 92       	push	r14
    396a:	ff 92       	push	r15
    396c:	0f 93       	push	r16
    396e:	1f 93       	push	r17
    3970:	df 93       	push	r29
    3972:	cf 93       	push	r28
    3974:	cd b7       	in	r28, 0x3d	; 61
    3976:	de b7       	in	r29, 0x3e	; 62
    3978:	62 97       	sbiw	r28, 0x12	; 18
    397a:	0f b6       	in	r0, 0x3f	; 63
    397c:	f8 94       	cli
    397e:	de bf       	out	0x3e, r29	; 62
    3980:	0f be       	out	0x3f, r0	; 63
    3982:	cd bf       	out	0x3d, r28	; 61
    3984:	9f 83       	std	Y+7, r25	; 0x07
    3986:	8e 83       	std	Y+6, r24	; 0x06
    3988:	48 87       	std	Y+8, r20	; 0x08
    398a:	59 87       	std	Y+9, r21	; 0x09
    398c:	6a 87       	std	Y+10, r22	; 0x0a
    398e:	7b 87       	std	Y+11, r23	; 0x0b
    3990:	2c 87       	std	Y+12, r18	; 0x0c
    3992:	1e 87       	std	Y+14, r17	; 0x0e
    3994:	0d 87       	std	Y+13, r16	; 0x0d
    3996:	f8 8a       	std	Y+16, r15	; 0x10
    3998:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    399a:	81 e0       	ldi	r24, 0x01	; 1
    399c:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    399e:	8e 81       	ldd	r24, Y+6	; 0x06
    39a0:	9f 81       	ldd	r25, Y+7	; 0x07
    39a2:	9d 83       	std	Y+5, r25	; 0x05
    39a4:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    39a6:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    39a8:	8d 85       	ldd	r24, Y+13	; 0x0d
    39aa:	9e 85       	ldd	r25, Y+14	; 0x0e
    39ac:	00 97       	sbiw	r24, 0x00	; 0
    39ae:	61 f0       	breq	.+24     	; 0x39c8 <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    39b0:	ec 81       	ldd	r30, Y+4	; 0x04
    39b2:	fd 81       	ldd	r31, Y+5	; 0x05
    39b4:	81 a1       	ldd	r24, Z+33	; 0x21
    39b6:	92 a1       	ldd	r25, Z+34	; 0x22
    39b8:	a3 a1       	ldd	r26, Z+35	; 0x23
    39ba:	b4 a1       	ldd	r27, Z+36	; 0x24
    39bc:	ed 85       	ldd	r30, Y+13	; 0x0d
    39be:	fe 85       	ldd	r31, Y+14	; 0x0e
    39c0:	80 83       	st	Z, r24
    39c2:	91 83       	std	Z+1, r25	; 0x01
    39c4:	a2 83       	std	Z+2, r26	; 0x02
    39c6:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    39c8:	ec 81       	ldd	r30, Y+4	; 0x04
    39ca:	fd 81       	ldd	r31, Y+5	; 0x05
    39cc:	85 a1       	ldd	r24, Z+37	; 0x25
    39ce:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    39d0:	ec 81       	ldd	r30, Y+4	; 0x04
    39d2:	fd 81       	ldd	r31, Y+5	; 0x05
    39d4:	82 e0       	ldi	r24, 0x02	; 2
    39d6:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    39d8:	8c 85       	ldd	r24, Y+12	; 0x0c
    39da:	28 2f       	mov	r18, r24
    39dc:	30 e0       	ldi	r19, 0x00	; 0
    39de:	3a 8b       	std	Y+18, r19	; 0x12
    39e0:	29 8b       	std	Y+17, r18	; 0x11
    39e2:	89 89       	ldd	r24, Y+17	; 0x11
    39e4:	9a 89       	ldd	r25, Y+18	; 0x12
    39e6:	82 30       	cpi	r24, 0x02	; 2
    39e8:	91 05       	cpc	r25, r1
    39ea:	59 f1       	breq	.+86     	; 0x3a42 <xTaskGenericNotifyFromISR+0xda>
    39ec:	29 89       	ldd	r18, Y+17	; 0x11
    39ee:	3a 89       	ldd	r19, Y+18	; 0x12
    39f0:	23 30       	cpi	r18, 0x03	; 3
    39f2:	31 05       	cpc	r19, r1
    39f4:	34 f4       	brge	.+12     	; 0x3a02 <xTaskGenericNotifyFromISR+0x9a>
    39f6:	89 89       	ldd	r24, Y+17	; 0x11
    39f8:	9a 89       	ldd	r25, Y+18	; 0x12
    39fa:	81 30       	cpi	r24, 0x01	; 1
    39fc:	91 05       	cpc	r25, r1
    39fe:	61 f0       	breq	.+24     	; 0x3a18 <xTaskGenericNotifyFromISR+0xb0>
    3a00:	4a c0       	rjmp	.+148    	; 0x3a96 <xTaskGenericNotifyFromISR+0x12e>
    3a02:	29 89       	ldd	r18, Y+17	; 0x11
    3a04:	3a 89       	ldd	r19, Y+18	; 0x12
    3a06:	23 30       	cpi	r18, 0x03	; 3
    3a08:	31 05       	cpc	r19, r1
    3a0a:	59 f1       	breq	.+86     	; 0x3a62 <xTaskGenericNotifyFromISR+0xfa>
    3a0c:	89 89       	ldd	r24, Y+17	; 0x11
    3a0e:	9a 89       	ldd	r25, Y+18	; 0x12
    3a10:	84 30       	cpi	r24, 0x04	; 4
    3a12:	91 05       	cpc	r25, r1
    3a14:	89 f1       	breq	.+98     	; 0x3a78 <xTaskGenericNotifyFromISR+0x110>
    3a16:	3f c0       	rjmp	.+126    	; 0x3a96 <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    3a18:	ec 81       	ldd	r30, Y+4	; 0x04
    3a1a:	fd 81       	ldd	r31, Y+5	; 0x05
    3a1c:	21 a1       	ldd	r18, Z+33	; 0x21
    3a1e:	32 a1       	ldd	r19, Z+34	; 0x22
    3a20:	43 a1       	ldd	r20, Z+35	; 0x23
    3a22:	54 a1       	ldd	r21, Z+36	; 0x24
    3a24:	88 85       	ldd	r24, Y+8	; 0x08
    3a26:	99 85       	ldd	r25, Y+9	; 0x09
    3a28:	aa 85       	ldd	r26, Y+10	; 0x0a
    3a2a:	bb 85       	ldd	r27, Y+11	; 0x0b
    3a2c:	82 2b       	or	r24, r18
    3a2e:	93 2b       	or	r25, r19
    3a30:	a4 2b       	or	r26, r20
    3a32:	b5 2b       	or	r27, r21
    3a34:	ec 81       	ldd	r30, Y+4	; 0x04
    3a36:	fd 81       	ldd	r31, Y+5	; 0x05
    3a38:	81 a3       	std	Z+33, r24	; 0x21
    3a3a:	92 a3       	std	Z+34, r25	; 0x22
    3a3c:	a3 a3       	std	Z+35, r26	; 0x23
    3a3e:	b4 a3       	std	Z+36, r27	; 0x24
    3a40:	2a c0       	rjmp	.+84     	; 0x3a96 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    3a42:	ec 81       	ldd	r30, Y+4	; 0x04
    3a44:	fd 81       	ldd	r31, Y+5	; 0x05
    3a46:	81 a1       	ldd	r24, Z+33	; 0x21
    3a48:	92 a1       	ldd	r25, Z+34	; 0x22
    3a4a:	a3 a1       	ldd	r26, Z+35	; 0x23
    3a4c:	b4 a1       	ldd	r27, Z+36	; 0x24
    3a4e:	01 96       	adiw	r24, 0x01	; 1
    3a50:	a1 1d       	adc	r26, r1
    3a52:	b1 1d       	adc	r27, r1
    3a54:	ec 81       	ldd	r30, Y+4	; 0x04
    3a56:	fd 81       	ldd	r31, Y+5	; 0x05
    3a58:	81 a3       	std	Z+33, r24	; 0x21
    3a5a:	92 a3       	std	Z+34, r25	; 0x22
    3a5c:	a3 a3       	std	Z+35, r26	; 0x23
    3a5e:	b4 a3       	std	Z+36, r27	; 0x24
    3a60:	1a c0       	rjmp	.+52     	; 0x3a96 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    3a62:	ec 81       	ldd	r30, Y+4	; 0x04
    3a64:	fd 81       	ldd	r31, Y+5	; 0x05
    3a66:	88 85       	ldd	r24, Y+8	; 0x08
    3a68:	99 85       	ldd	r25, Y+9	; 0x09
    3a6a:	aa 85       	ldd	r26, Y+10	; 0x0a
    3a6c:	bb 85       	ldd	r27, Y+11	; 0x0b
    3a6e:	81 a3       	std	Z+33, r24	; 0x21
    3a70:	92 a3       	std	Z+34, r25	; 0x22
    3a72:	a3 a3       	std	Z+35, r26	; 0x23
    3a74:	b4 a3       	std	Z+36, r27	; 0x24
    3a76:	0f c0       	rjmp	.+30     	; 0x3a96 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    3a78:	8b 81       	ldd	r24, Y+3	; 0x03
    3a7a:	82 30       	cpi	r24, 0x02	; 2
    3a7c:	59 f0       	breq	.+22     	; 0x3a94 <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    3a7e:	ec 81       	ldd	r30, Y+4	; 0x04
    3a80:	fd 81       	ldd	r31, Y+5	; 0x05
    3a82:	88 85       	ldd	r24, Y+8	; 0x08
    3a84:	99 85       	ldd	r25, Y+9	; 0x09
    3a86:	aa 85       	ldd	r26, Y+10	; 0x0a
    3a88:	bb 85       	ldd	r27, Y+11	; 0x0b
    3a8a:	81 a3       	std	Z+33, r24	; 0x21
    3a8c:	92 a3       	std	Z+34, r25	; 0x22
    3a8e:	a3 a3       	std	Z+35, r26	; 0x23
    3a90:	b4 a3       	std	Z+36, r27	; 0x24
    3a92:	01 c0       	rjmp	.+2      	; 0x3a96 <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    3a94:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    3a96:	8b 81       	ldd	r24, Y+3	; 0x03
    3a98:	81 30       	cpi	r24, 0x01	; 1
    3a9a:	09 f0       	breq	.+2      	; 0x3a9e <xTaskGenericNotifyFromISR+0x136>
    3a9c:	4f c0       	rjmp	.+158    	; 0x3b3c <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3a9e:	80 91 db 02 	lds	r24, 0x02DB
    3aa2:	88 23       	and	r24, r24
    3aa4:	61 f5       	brne	.+88     	; 0x3afe <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3aa6:	8c 81       	ldd	r24, Y+4	; 0x04
    3aa8:	9d 81       	ldd	r25, Y+5	; 0x05
    3aaa:	02 96       	adiw	r24, 0x02	; 2
    3aac:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3ab0:	ec 81       	ldd	r30, Y+4	; 0x04
    3ab2:	fd 81       	ldd	r31, Y+5	; 0x05
    3ab4:	96 89       	ldd	r25, Z+22	; 0x16
    3ab6:	80 91 d1 02 	lds	r24, 0x02D1
    3aba:	89 17       	cp	r24, r25
    3abc:	28 f4       	brcc	.+10     	; 0x3ac8 <xTaskGenericNotifyFromISR+0x160>
    3abe:	ec 81       	ldd	r30, Y+4	; 0x04
    3ac0:	fd 81       	ldd	r31, Y+5	; 0x05
    3ac2:	86 89       	ldd	r24, Z+22	; 0x16
    3ac4:	80 93 d1 02 	sts	0x02D1, r24
    3ac8:	ec 81       	ldd	r30, Y+4	; 0x04
    3aca:	fd 81       	ldd	r31, Y+5	; 0x05
    3acc:	86 89       	ldd	r24, Z+22	; 0x16
    3ace:	28 2f       	mov	r18, r24
    3ad0:	30 e0       	ldi	r19, 0x00	; 0
    3ad2:	c9 01       	movw	r24, r18
    3ad4:	88 0f       	add	r24, r24
    3ad6:	99 1f       	adc	r25, r25
    3ad8:	88 0f       	add	r24, r24
    3ada:	99 1f       	adc	r25, r25
    3adc:	88 0f       	add	r24, r24
    3ade:	99 1f       	adc	r25, r25
    3ae0:	82 0f       	add	r24, r18
    3ae2:	93 1f       	adc	r25, r19
    3ae4:	ac 01       	movw	r20, r24
    3ae6:	44 52       	subi	r20, 0x24	; 36
    3ae8:	5d 4f       	sbci	r21, 0xFD	; 253
    3aea:	8c 81       	ldd	r24, Y+4	; 0x04
    3aec:	9d 81       	ldd	r25, Y+5	; 0x05
    3aee:	9c 01       	movw	r18, r24
    3af0:	2e 5f       	subi	r18, 0xFE	; 254
    3af2:	3f 4f       	sbci	r19, 0xFF	; 255
    3af4:	ca 01       	movw	r24, r20
    3af6:	b9 01       	movw	r22, r18
    3af8:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>
    3afc:	0a c0       	rjmp	.+20     	; 0x3b12 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    3afe:	8c 81       	ldd	r24, Y+4	; 0x04
    3b00:	9d 81       	ldd	r25, Y+5	; 0x05
    3b02:	9c 01       	movw	r18, r24
    3b04:	24 5f       	subi	r18, 0xF4	; 244
    3b06:	3f 4f       	sbci	r19, 0xFF	; 255
    3b08:	86 e1       	ldi	r24, 0x16	; 22
    3b0a:	93 e0       	ldi	r25, 0x03	; 3
    3b0c:	b9 01       	movw	r22, r18
    3b0e:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    3b12:	ec 81       	ldd	r30, Y+4	; 0x04
    3b14:	fd 81       	ldd	r31, Y+5	; 0x05
    3b16:	96 89       	ldd	r25, Z+22	; 0x16
    3b18:	e0 91 cb 02 	lds	r30, 0x02CB
    3b1c:	f0 91 cc 02 	lds	r31, 0x02CC
    3b20:	86 89       	ldd	r24, Z+22	; 0x16
    3b22:	89 17       	cp	r24, r25
    3b24:	58 f4       	brcc	.+22     	; 0x3b3c <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    3b26:	8f 85       	ldd	r24, Y+15	; 0x0f
    3b28:	98 89       	ldd	r25, Y+16	; 0x10
    3b2a:	00 97       	sbiw	r24, 0x00	; 0
    3b2c:	21 f0       	breq	.+8      	; 0x3b36 <xTaskGenericNotifyFromISR+0x1ce>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    3b2e:	ef 85       	ldd	r30, Y+15	; 0x0f
    3b30:	f8 89       	ldd	r31, Y+16	; 0x10
    3b32:	81 e0       	ldi	r24, 0x01	; 1
    3b34:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    3b36:	81 e0       	ldi	r24, 0x01	; 1
    3b38:	80 93 d4 02 	sts	0x02D4, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    3b3c:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    3b3e:	62 96       	adiw	r28, 0x12	; 18
    3b40:	0f b6       	in	r0, 0x3f	; 63
    3b42:	f8 94       	cli
    3b44:	de bf       	out	0x3e, r29	; 62
    3b46:	0f be       	out	0x3f, r0	; 63
    3b48:	cd bf       	out	0x3d, r28	; 61
    3b4a:	cf 91       	pop	r28
    3b4c:	df 91       	pop	r29
    3b4e:	1f 91       	pop	r17
    3b50:	0f 91       	pop	r16
    3b52:	ff 90       	pop	r15
    3b54:	ef 90       	pop	r14
    3b56:	08 95       	ret

00003b58 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    3b58:	df 93       	push	r29
    3b5a:	cf 93       	push	r28
    3b5c:	cd b7       	in	r28, 0x3d	; 61
    3b5e:	de b7       	in	r29, 0x3e	; 62
    3b60:	28 97       	sbiw	r28, 0x08	; 8
    3b62:	0f b6       	in	r0, 0x3f	; 63
    3b64:	f8 94       	cli
    3b66:	de bf       	out	0x3e, r29	; 62
    3b68:	0f be       	out	0x3f, r0	; 63
    3b6a:	cd bf       	out	0x3d, r28	; 61
    3b6c:	9e 83       	std	Y+6, r25	; 0x06
    3b6e:	8d 83       	std	Y+5, r24	; 0x05
    3b70:	78 87       	std	Y+8, r23	; 0x08
    3b72:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    3b74:	8d 81       	ldd	r24, Y+5	; 0x05
    3b76:	9e 81       	ldd	r25, Y+6	; 0x06
    3b78:	9c 83       	std	Y+4, r25	; 0x04
    3b7a:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3b7c:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    3b7e:	eb 81       	ldd	r30, Y+3	; 0x03
    3b80:	fc 81       	ldd	r31, Y+4	; 0x04
    3b82:	85 a1       	ldd	r24, Z+37	; 0x25
    3b84:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    3b86:	eb 81       	ldd	r30, Y+3	; 0x03
    3b88:	fc 81       	ldd	r31, Y+4	; 0x04
    3b8a:	82 e0       	ldi	r24, 0x02	; 2
    3b8c:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    3b8e:	eb 81       	ldd	r30, Y+3	; 0x03
    3b90:	fc 81       	ldd	r31, Y+4	; 0x04
    3b92:	81 a1       	ldd	r24, Z+33	; 0x21
    3b94:	92 a1       	ldd	r25, Z+34	; 0x22
    3b96:	a3 a1       	ldd	r26, Z+35	; 0x23
    3b98:	b4 a1       	ldd	r27, Z+36	; 0x24
    3b9a:	01 96       	adiw	r24, 0x01	; 1
    3b9c:	a1 1d       	adc	r26, r1
    3b9e:	b1 1d       	adc	r27, r1
    3ba0:	eb 81       	ldd	r30, Y+3	; 0x03
    3ba2:	fc 81       	ldd	r31, Y+4	; 0x04
    3ba4:	81 a3       	std	Z+33, r24	; 0x21
    3ba6:	92 a3       	std	Z+34, r25	; 0x22
    3ba8:	a3 a3       	std	Z+35, r26	; 0x23
    3baa:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    3bac:	8a 81       	ldd	r24, Y+2	; 0x02
    3bae:	81 30       	cpi	r24, 0x01	; 1
    3bb0:	09 f0       	breq	.+2      	; 0x3bb4 <vTaskNotifyGiveFromISR+0x5c>
    3bb2:	4f c0       	rjmp	.+158    	; 0x3c52 <vTaskNotifyGiveFromISR+0xfa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3bb4:	80 91 db 02 	lds	r24, 0x02DB
    3bb8:	88 23       	and	r24, r24
    3bba:	61 f5       	brne	.+88     	; 0x3c14 <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3bbc:	8b 81       	ldd	r24, Y+3	; 0x03
    3bbe:	9c 81       	ldd	r25, Y+4	; 0x04
    3bc0:	02 96       	adiw	r24, 0x02	; 2
    3bc2:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3bc6:	eb 81       	ldd	r30, Y+3	; 0x03
    3bc8:	fc 81       	ldd	r31, Y+4	; 0x04
    3bca:	96 89       	ldd	r25, Z+22	; 0x16
    3bcc:	80 91 d1 02 	lds	r24, 0x02D1
    3bd0:	89 17       	cp	r24, r25
    3bd2:	28 f4       	brcc	.+10     	; 0x3bde <vTaskNotifyGiveFromISR+0x86>
    3bd4:	eb 81       	ldd	r30, Y+3	; 0x03
    3bd6:	fc 81       	ldd	r31, Y+4	; 0x04
    3bd8:	86 89       	ldd	r24, Z+22	; 0x16
    3bda:	80 93 d1 02 	sts	0x02D1, r24
    3bde:	eb 81       	ldd	r30, Y+3	; 0x03
    3be0:	fc 81       	ldd	r31, Y+4	; 0x04
    3be2:	86 89       	ldd	r24, Z+22	; 0x16
    3be4:	28 2f       	mov	r18, r24
    3be6:	30 e0       	ldi	r19, 0x00	; 0
    3be8:	c9 01       	movw	r24, r18
    3bea:	88 0f       	add	r24, r24
    3bec:	99 1f       	adc	r25, r25
    3bee:	88 0f       	add	r24, r24
    3bf0:	99 1f       	adc	r25, r25
    3bf2:	88 0f       	add	r24, r24
    3bf4:	99 1f       	adc	r25, r25
    3bf6:	82 0f       	add	r24, r18
    3bf8:	93 1f       	adc	r25, r19
    3bfa:	ac 01       	movw	r20, r24
    3bfc:	44 52       	subi	r20, 0x24	; 36
    3bfe:	5d 4f       	sbci	r21, 0xFD	; 253
    3c00:	8b 81       	ldd	r24, Y+3	; 0x03
    3c02:	9c 81       	ldd	r25, Y+4	; 0x04
    3c04:	9c 01       	movw	r18, r24
    3c06:	2e 5f       	subi	r18, 0xFE	; 254
    3c08:	3f 4f       	sbci	r19, 0xFF	; 255
    3c0a:	ca 01       	movw	r24, r20
    3c0c:	b9 01       	movw	r22, r18
    3c0e:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>
    3c12:	0a c0       	rjmp	.+20     	; 0x3c28 <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    3c14:	8b 81       	ldd	r24, Y+3	; 0x03
    3c16:	9c 81       	ldd	r25, Y+4	; 0x04
    3c18:	9c 01       	movw	r18, r24
    3c1a:	24 5f       	subi	r18, 0xF4	; 244
    3c1c:	3f 4f       	sbci	r19, 0xFF	; 255
    3c1e:	86 e1       	ldi	r24, 0x16	; 22
    3c20:	93 e0       	ldi	r25, 0x03	; 3
    3c22:	b9 01       	movw	r22, r18
    3c24:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    3c28:	eb 81       	ldd	r30, Y+3	; 0x03
    3c2a:	fc 81       	ldd	r31, Y+4	; 0x04
    3c2c:	96 89       	ldd	r25, Z+22	; 0x16
    3c2e:	e0 91 cb 02 	lds	r30, 0x02CB
    3c32:	f0 91 cc 02 	lds	r31, 0x02CC
    3c36:	86 89       	ldd	r24, Z+22	; 0x16
    3c38:	89 17       	cp	r24, r25
    3c3a:	58 f4       	brcc	.+22     	; 0x3c52 <vTaskNotifyGiveFromISR+0xfa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    3c3c:	8f 81       	ldd	r24, Y+7	; 0x07
    3c3e:	98 85       	ldd	r25, Y+8	; 0x08
    3c40:	00 97       	sbiw	r24, 0x00	; 0
    3c42:	21 f0       	breq	.+8      	; 0x3c4c <vTaskNotifyGiveFromISR+0xf4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    3c44:	ef 81       	ldd	r30, Y+7	; 0x07
    3c46:	f8 85       	ldd	r31, Y+8	; 0x08
    3c48:	81 e0       	ldi	r24, 0x01	; 1
    3c4a:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    3c4c:	81 e0       	ldi	r24, 0x01	; 1
    3c4e:	80 93 d4 02 	sts	0x02D4, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    3c52:	28 96       	adiw	r28, 0x08	; 8
    3c54:	0f b6       	in	r0, 0x3f	; 63
    3c56:	f8 94       	cli
    3c58:	de bf       	out	0x3e, r29	; 62
    3c5a:	0f be       	out	0x3f, r0	; 63
    3c5c:	cd bf       	out	0x3d, r28	; 61
    3c5e:	cf 91       	pop	r28
    3c60:	df 91       	pop	r29
    3c62:	08 95       	ret

00003c64 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    3c64:	df 93       	push	r29
    3c66:	cf 93       	push	r28
    3c68:	cd b7       	in	r28, 0x3d	; 61
    3c6a:	de b7       	in	r29, 0x3e	; 62
    3c6c:	27 97       	sbiw	r28, 0x07	; 7
    3c6e:	0f b6       	in	r0, 0x3f	; 63
    3c70:	f8 94       	cli
    3c72:	de bf       	out	0x3e, r29	; 62
    3c74:	0f be       	out	0x3f, r0	; 63
    3c76:	cd bf       	out	0x3d, r28	; 61
    3c78:	9d 83       	std	Y+5, r25	; 0x05
    3c7a:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    3c7c:	8c 81       	ldd	r24, Y+4	; 0x04
    3c7e:	9d 81       	ldd	r25, Y+5	; 0x05
    3c80:	00 97       	sbiw	r24, 0x00	; 0
    3c82:	39 f4       	brne	.+14     	; 0x3c92 <xTaskNotifyStateClear+0x2e>
    3c84:	80 91 cb 02 	lds	r24, 0x02CB
    3c88:	90 91 cc 02 	lds	r25, 0x02CC
    3c8c:	9f 83       	std	Y+7, r25	; 0x07
    3c8e:	8e 83       	std	Y+6, r24	; 0x06
    3c90:	04 c0       	rjmp	.+8      	; 0x3c9a <xTaskNotifyStateClear+0x36>
    3c92:	8c 81       	ldd	r24, Y+4	; 0x04
    3c94:	9d 81       	ldd	r25, Y+5	; 0x05
    3c96:	9f 83       	std	Y+7, r25	; 0x07
    3c98:	8e 83       	std	Y+6, r24	; 0x06
    3c9a:	8e 81       	ldd	r24, Y+6	; 0x06
    3c9c:	9f 81       	ldd	r25, Y+7	; 0x07
    3c9e:	9b 83       	std	Y+3, r25	; 0x03
    3ca0:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    3ca2:	0f b6       	in	r0, 0x3f	; 63
    3ca4:	f8 94       	cli
    3ca6:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    3ca8:	ea 81       	ldd	r30, Y+2	; 0x02
    3caa:	fb 81       	ldd	r31, Y+3	; 0x03
    3cac:	85 a1       	ldd	r24, Z+37	; 0x25
    3cae:	82 30       	cpi	r24, 0x02	; 2
    3cb0:	31 f4       	brne	.+12     	; 0x3cbe <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3cb2:	ea 81       	ldd	r30, Y+2	; 0x02
    3cb4:	fb 81       	ldd	r31, Y+3	; 0x03
    3cb6:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    3cb8:	81 e0       	ldi	r24, 0x01	; 1
    3cba:	89 83       	std	Y+1, r24	; 0x01
    3cbc:	01 c0       	rjmp	.+2      	; 0x3cc0 <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    3cbe:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    3cc0:	0f 90       	pop	r0
    3cc2:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    3cc4:	89 81       	ldd	r24, Y+1	; 0x01
	}
    3cc6:	27 96       	adiw	r28, 0x07	; 7
    3cc8:	0f b6       	in	r0, 0x3f	; 63
    3cca:	f8 94       	cli
    3ccc:	de bf       	out	0x3e, r29	; 62
    3cce:	0f be       	out	0x3f, r0	; 63
    3cd0:	cd bf       	out	0x3d, r28	; 61
    3cd2:	cf 91       	pop	r28
    3cd4:	df 91       	pop	r29
    3cd6:	08 95       	ret

00003cd8 <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    3cd8:	df 93       	push	r29
    3cda:	cf 93       	push	r28
    3cdc:	cd b7       	in	r28, 0x3d	; 61
    3cde:	de b7       	in	r29, 0x3e	; 62
    3ce0:	27 97       	sbiw	r28, 0x07	; 7
    3ce2:	0f b6       	in	r0, 0x3f	; 63
    3ce4:	f8 94       	cli
    3ce6:	de bf       	out	0x3e, r29	; 62
    3ce8:	0f be       	out	0x3f, r0	; 63
    3cea:	cd bf       	out	0x3d, r28	; 61
    3cec:	9e 83       	std	Y+6, r25	; 0x06
    3cee:	8d 83       	std	Y+5, r24	; 0x05
    3cf0:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    3cf2:	80 91 cf 02 	lds	r24, 0x02CF
    3cf6:	90 91 d0 02 	lds	r25, 0x02D0
    3cfa:	9a 83       	std	Y+2, r25	; 0x02
    3cfc:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3cfe:	80 91 cb 02 	lds	r24, 0x02CB
    3d02:	90 91 cc 02 	lds	r25, 0x02CC
    3d06:	02 96       	adiw	r24, 0x02	; 2
    3d08:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
		/* Calculate the time at which the task should be woken if the event
		does not occur.  This may overflow but this doesn't matter, the kernel
		will manage it correctly. */
		xTimeToWake = xConstTickCount + xTicksToWait;
    3d0c:	29 81       	ldd	r18, Y+1	; 0x01
    3d0e:	3a 81       	ldd	r19, Y+2	; 0x02
    3d10:	8d 81       	ldd	r24, Y+5	; 0x05
    3d12:	9e 81       	ldd	r25, Y+6	; 0x06
    3d14:	82 0f       	add	r24, r18
    3d16:	93 1f       	adc	r25, r19
    3d18:	9c 83       	std	Y+4, r25	; 0x04
    3d1a:	8b 83       	std	Y+3, r24	; 0x03

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    3d1c:	e0 91 cb 02 	lds	r30, 0x02CB
    3d20:	f0 91 cc 02 	lds	r31, 0x02CC
    3d24:	8b 81       	ldd	r24, Y+3	; 0x03
    3d26:	9c 81       	ldd	r25, Y+4	; 0x04
    3d28:	93 83       	std	Z+3, r25	; 0x03
    3d2a:	82 83       	std	Z+2, r24	; 0x02

		if( xTimeToWake < xConstTickCount )
    3d2c:	2b 81       	ldd	r18, Y+3	; 0x03
    3d2e:	3c 81       	ldd	r19, Y+4	; 0x04
    3d30:	89 81       	ldd	r24, Y+1	; 0x01
    3d32:	9a 81       	ldd	r25, Y+2	; 0x02
    3d34:	28 17       	cp	r18, r24
    3d36:	39 07       	cpc	r19, r25
    3d38:	70 f4       	brcc	.+28     	; 0x3d56 <prvAddCurrentTaskToDelayedList+0x7e>
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    3d3a:	80 91 14 03 	lds	r24, 0x0314
    3d3e:	90 91 15 03 	lds	r25, 0x0315
    3d42:	20 91 cb 02 	lds	r18, 0x02CB
    3d46:	30 91 cc 02 	lds	r19, 0x02CC
    3d4a:	2e 5f       	subi	r18, 0xFE	; 254
    3d4c:	3f 4f       	sbci	r19, 0xFF	; 255
    3d4e:	b9 01       	movw	r22, r18
    3d50:	0e 94 a9 07 	call	0xf52	; 0xf52 <vListInsert>
    3d54:	1e c0       	rjmp	.+60     	; 0x3d92 <prvAddCurrentTaskToDelayedList+0xba>
		}
		else
		{
			/* The wake time has not overflowed, so the current block list is used. */
			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    3d56:	40 91 12 03 	lds	r20, 0x0312
    3d5a:	50 91 13 03 	lds	r21, 0x0313
    3d5e:	80 91 cb 02 	lds	r24, 0x02CB
    3d62:	90 91 cc 02 	lds	r25, 0x02CC
    3d66:	9c 01       	movw	r18, r24
    3d68:	2e 5f       	subi	r18, 0xFE	; 254
    3d6a:	3f 4f       	sbci	r19, 0xFF	; 255
    3d6c:	ca 01       	movw	r24, r20
    3d6e:	b9 01       	movw	r22, r18
    3d70:	0e 94 a9 07 	call	0xf52	; 0xf52 <vListInsert>

			/* If the task entering the blocked state was placed at the head of the
			list of blocked tasks then xNextTaskUnblockTime needs to be updated
			too. */
			if( xTimeToWake < xNextTaskUnblockTime )
    3d74:	20 91 d7 02 	lds	r18, 0x02D7
    3d78:	30 91 d8 02 	lds	r19, 0x02D8
    3d7c:	8b 81       	ldd	r24, Y+3	; 0x03
    3d7e:	9c 81       	ldd	r25, Y+4	; 0x04
    3d80:	82 17       	cp	r24, r18
    3d82:	93 07       	cpc	r25, r19
    3d84:	30 f4       	brcc	.+12     	; 0x3d92 <prvAddCurrentTaskToDelayedList+0xba>
			{
				xNextTaskUnblockTime = xTimeToWake;
    3d86:	8b 81       	ldd	r24, Y+3	; 0x03
    3d88:	9c 81       	ldd	r25, Y+4	; 0x04
    3d8a:	90 93 d8 02 	sts	0x02D8, r25
    3d8e:	80 93 d7 02 	sts	0x02D7, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    3d92:	27 96       	adiw	r28, 0x07	; 7
    3d94:	0f b6       	in	r0, 0x3f	; 63
    3d96:	f8 94       	cli
    3d98:	de bf       	out	0x3e, r29	; 62
    3d9a:	0f be       	out	0x3f, r0	; 63
    3d9c:	cd bf       	out	0x3d, r28	; 61
    3d9e:	cf 91       	pop	r28
    3da0:	df 91       	pop	r29
    3da2:	08 95       	ret

00003da4 <memcpy>:
    3da4:	fb 01       	movw	r30, r22
    3da6:	dc 01       	movw	r26, r24
    3da8:	02 c0       	rjmp	.+4      	; 0x3dae <memcpy+0xa>
    3daa:	01 90       	ld	r0, Z+
    3dac:	0d 92       	st	X+, r0
    3dae:	41 50       	subi	r20, 0x01	; 1
    3db0:	50 40       	sbci	r21, 0x00	; 0
    3db2:	d8 f7       	brcc	.-10     	; 0x3daa <memcpy+0x6>
    3db4:	08 95       	ret

00003db6 <_exit>:
    3db6:	f8 94       	cli

00003db8 <__stop_program>:
    3db8:	ff cf       	rjmp	.-2      	; 0x3db8 <__stop_program>
