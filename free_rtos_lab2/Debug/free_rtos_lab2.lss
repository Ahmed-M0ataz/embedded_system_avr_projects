
free_rtos_lab2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003da8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000014  00800060  00003da8  00003e3c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002bc  00800074  00800074  00003e50  2**0
                  ALLOC
  3 .stab         0000690c  00000000  00000000  00003e50  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003e21  00000000  00000000  0000a75c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 bc 0b 	jmp	0x1778	; 0x1778 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 ea       	ldi	r30, 0xA8	; 168
      68:	fd e3       	ldi	r31, 0x3D	; 61
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a4 37       	cpi	r26, 0x74	; 116
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	13 e0       	ldi	r17, 0x03	; 3
      78:	a4 e7       	ldi	r26, 0x74	; 116
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a0 33       	cpi	r26, 0x30	; 48
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 ad 08 	call	0x115a	; 0x115a <main>
      8a:	0c 94 d2 1e 	jmp	0x3da4	; 0x3da4 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DIO_SET_PIN_VALUE>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	00 d0       	rcall	.+0      	; 0x98 <DIO_SET_PIN_VALUE+0x6>
      98:	00 d0       	rcall	.+0      	; 0x9a <DIO_SET_PIN_VALUE+0x8>
      9a:	00 d0       	rcall	.+0      	; 0x9c <DIO_SET_PIN_VALUE+0xa>
      9c:	cd b7       	in	r28, 0x3d	; 61
      9e:	de b7       	in	r29, 0x3e	; 62
      a0:	8a 83       	std	Y+2, r24	; 0x02
      a2:	6b 83       	std	Y+3, r22	; 0x03
      a4:	4c 83       	std	Y+4, r20	; 0x04
      a6:	19 82       	std	Y+1, r1	; 0x01
      a8:	8a 81       	ldd	r24, Y+2	; 0x02
      aa:	84 30       	cpi	r24, 0x04	; 4
      ac:	18 f0       	brcs	.+6      	; 0xb4 <DIO_SET_PIN_VALUE+0x22>
      ae:	81 e0       	ldi	r24, 0x01	; 1
      b0:	89 83       	std	Y+1, r24	; 0x01
      b2:	e0 c0       	rjmp	.+448    	; 0x274 <DIO_SET_PIN_VALUE+0x1e2>
      b4:	8b 81       	ldd	r24, Y+3	; 0x03
      b6:	88 30       	cpi	r24, 0x08	; 8
      b8:	18 f0       	brcs	.+6      	; 0xc0 <DIO_SET_PIN_VALUE+0x2e>
      ba:	82 e0       	ldi	r24, 0x02	; 2
      bc:	89 83       	std	Y+1, r24	; 0x01
      be:	da c0       	rjmp	.+436    	; 0x274 <DIO_SET_PIN_VALUE+0x1e2>
      c0:	8c 81       	ldd	r24, Y+4	; 0x04
      c2:	88 23       	and	r24, r24
      c4:	31 f0       	breq	.+12     	; 0xd2 <DIO_SET_PIN_VALUE+0x40>
      c6:	8c 81       	ldd	r24, Y+4	; 0x04
      c8:	81 30       	cpi	r24, 0x01	; 1
      ca:	19 f0       	breq	.+6      	; 0xd2 <DIO_SET_PIN_VALUE+0x40>
      cc:	83 e0       	ldi	r24, 0x03	; 3
      ce:	89 83       	std	Y+1, r24	; 0x01
      d0:	d1 c0       	rjmp	.+418    	; 0x274 <DIO_SET_PIN_VALUE+0x1e2>
      d2:	8a 81       	ldd	r24, Y+2	; 0x02
      d4:	28 2f       	mov	r18, r24
      d6:	30 e0       	ldi	r19, 0x00	; 0
      d8:	3e 83       	std	Y+6, r19	; 0x06
      da:	2d 83       	std	Y+5, r18	; 0x05
      dc:	8d 81       	ldd	r24, Y+5	; 0x05
      de:	9e 81       	ldd	r25, Y+6	; 0x06
      e0:	81 30       	cpi	r24, 0x01	; 1
      e2:	91 05       	cpc	r25, r1
      e4:	09 f4       	brne	.+2      	; 0xe8 <DIO_SET_PIN_VALUE+0x56>
      e6:	43 c0       	rjmp	.+134    	; 0x16e <DIO_SET_PIN_VALUE+0xdc>
      e8:	2d 81       	ldd	r18, Y+5	; 0x05
      ea:	3e 81       	ldd	r19, Y+6	; 0x06
      ec:	22 30       	cpi	r18, 0x02	; 2
      ee:	31 05       	cpc	r19, r1
      f0:	2c f4       	brge	.+10     	; 0xfc <DIO_SET_PIN_VALUE+0x6a>
      f2:	8d 81       	ldd	r24, Y+5	; 0x05
      f4:	9e 81       	ldd	r25, Y+6	; 0x06
      f6:	00 97       	sbiw	r24, 0x00	; 0
      f8:	71 f0       	breq	.+28     	; 0x116 <DIO_SET_PIN_VALUE+0x84>
      fa:	bc c0       	rjmp	.+376    	; 0x274 <DIO_SET_PIN_VALUE+0x1e2>
      fc:	2d 81       	ldd	r18, Y+5	; 0x05
      fe:	3e 81       	ldd	r19, Y+6	; 0x06
     100:	22 30       	cpi	r18, 0x02	; 2
     102:	31 05       	cpc	r19, r1
     104:	09 f4       	brne	.+2      	; 0x108 <DIO_SET_PIN_VALUE+0x76>
     106:	5f c0       	rjmp	.+190    	; 0x1c6 <DIO_SET_PIN_VALUE+0x134>
     108:	8d 81       	ldd	r24, Y+5	; 0x05
     10a:	9e 81       	ldd	r25, Y+6	; 0x06
     10c:	83 30       	cpi	r24, 0x03	; 3
     10e:	91 05       	cpc	r25, r1
     110:	09 f4       	brne	.+2      	; 0x114 <DIO_SET_PIN_VALUE+0x82>
     112:	85 c0       	rjmp	.+266    	; 0x21e <DIO_SET_PIN_VALUE+0x18c>
     114:	af c0       	rjmp	.+350    	; 0x274 <DIO_SET_PIN_VALUE+0x1e2>
     116:	8c 81       	ldd	r24, Y+4	; 0x04
     118:	81 30       	cpi	r24, 0x01	; 1
     11a:	a1 f4       	brne	.+40     	; 0x144 <DIO_SET_PIN_VALUE+0xb2>
     11c:	ab e3       	ldi	r26, 0x3B	; 59
     11e:	b0 e0       	ldi	r27, 0x00	; 0
     120:	eb e3       	ldi	r30, 0x3B	; 59
     122:	f0 e0       	ldi	r31, 0x00	; 0
     124:	80 81       	ld	r24, Z
     126:	48 2f       	mov	r20, r24
     128:	8b 81       	ldd	r24, Y+3	; 0x03
     12a:	28 2f       	mov	r18, r24
     12c:	30 e0       	ldi	r19, 0x00	; 0
     12e:	81 e0       	ldi	r24, 0x01	; 1
     130:	90 e0       	ldi	r25, 0x00	; 0
     132:	02 2e       	mov	r0, r18
     134:	02 c0       	rjmp	.+4      	; 0x13a <DIO_SET_PIN_VALUE+0xa8>
     136:	88 0f       	add	r24, r24
     138:	99 1f       	adc	r25, r25
     13a:	0a 94       	dec	r0
     13c:	e2 f7       	brpl	.-8      	; 0x136 <DIO_SET_PIN_VALUE+0xa4>
     13e:	84 2b       	or	r24, r20
     140:	8c 93       	st	X, r24
     142:	98 c0       	rjmp	.+304    	; 0x274 <DIO_SET_PIN_VALUE+0x1e2>
     144:	ab e3       	ldi	r26, 0x3B	; 59
     146:	b0 e0       	ldi	r27, 0x00	; 0
     148:	eb e3       	ldi	r30, 0x3B	; 59
     14a:	f0 e0       	ldi	r31, 0x00	; 0
     14c:	80 81       	ld	r24, Z
     14e:	48 2f       	mov	r20, r24
     150:	8b 81       	ldd	r24, Y+3	; 0x03
     152:	28 2f       	mov	r18, r24
     154:	30 e0       	ldi	r19, 0x00	; 0
     156:	81 e0       	ldi	r24, 0x01	; 1
     158:	90 e0       	ldi	r25, 0x00	; 0
     15a:	02 2e       	mov	r0, r18
     15c:	02 c0       	rjmp	.+4      	; 0x162 <DIO_SET_PIN_VALUE+0xd0>
     15e:	88 0f       	add	r24, r24
     160:	99 1f       	adc	r25, r25
     162:	0a 94       	dec	r0
     164:	e2 f7       	brpl	.-8      	; 0x15e <DIO_SET_PIN_VALUE+0xcc>
     166:	80 95       	com	r24
     168:	84 23       	and	r24, r20
     16a:	8c 93       	st	X, r24
     16c:	83 c0       	rjmp	.+262    	; 0x274 <DIO_SET_PIN_VALUE+0x1e2>
     16e:	8c 81       	ldd	r24, Y+4	; 0x04
     170:	81 30       	cpi	r24, 0x01	; 1
     172:	a1 f4       	brne	.+40     	; 0x19c <DIO_SET_PIN_VALUE+0x10a>
     174:	a8 e3       	ldi	r26, 0x38	; 56
     176:	b0 e0       	ldi	r27, 0x00	; 0
     178:	e8 e3       	ldi	r30, 0x38	; 56
     17a:	f0 e0       	ldi	r31, 0x00	; 0
     17c:	80 81       	ld	r24, Z
     17e:	48 2f       	mov	r20, r24
     180:	8b 81       	ldd	r24, Y+3	; 0x03
     182:	28 2f       	mov	r18, r24
     184:	30 e0       	ldi	r19, 0x00	; 0
     186:	81 e0       	ldi	r24, 0x01	; 1
     188:	90 e0       	ldi	r25, 0x00	; 0
     18a:	02 2e       	mov	r0, r18
     18c:	02 c0       	rjmp	.+4      	; 0x192 <DIO_SET_PIN_VALUE+0x100>
     18e:	88 0f       	add	r24, r24
     190:	99 1f       	adc	r25, r25
     192:	0a 94       	dec	r0
     194:	e2 f7       	brpl	.-8      	; 0x18e <DIO_SET_PIN_VALUE+0xfc>
     196:	84 2b       	or	r24, r20
     198:	8c 93       	st	X, r24
     19a:	6c c0       	rjmp	.+216    	; 0x274 <DIO_SET_PIN_VALUE+0x1e2>
     19c:	a8 e3       	ldi	r26, 0x38	; 56
     19e:	b0 e0       	ldi	r27, 0x00	; 0
     1a0:	e8 e3       	ldi	r30, 0x38	; 56
     1a2:	f0 e0       	ldi	r31, 0x00	; 0
     1a4:	80 81       	ld	r24, Z
     1a6:	48 2f       	mov	r20, r24
     1a8:	8b 81       	ldd	r24, Y+3	; 0x03
     1aa:	28 2f       	mov	r18, r24
     1ac:	30 e0       	ldi	r19, 0x00	; 0
     1ae:	81 e0       	ldi	r24, 0x01	; 1
     1b0:	90 e0       	ldi	r25, 0x00	; 0
     1b2:	02 2e       	mov	r0, r18
     1b4:	02 c0       	rjmp	.+4      	; 0x1ba <DIO_SET_PIN_VALUE+0x128>
     1b6:	88 0f       	add	r24, r24
     1b8:	99 1f       	adc	r25, r25
     1ba:	0a 94       	dec	r0
     1bc:	e2 f7       	brpl	.-8      	; 0x1b6 <DIO_SET_PIN_VALUE+0x124>
     1be:	80 95       	com	r24
     1c0:	84 23       	and	r24, r20
     1c2:	8c 93       	st	X, r24
     1c4:	57 c0       	rjmp	.+174    	; 0x274 <DIO_SET_PIN_VALUE+0x1e2>
     1c6:	8c 81       	ldd	r24, Y+4	; 0x04
     1c8:	81 30       	cpi	r24, 0x01	; 1
     1ca:	a1 f4       	brne	.+40     	; 0x1f4 <DIO_SET_PIN_VALUE+0x162>
     1cc:	a5 e3       	ldi	r26, 0x35	; 53
     1ce:	b0 e0       	ldi	r27, 0x00	; 0
     1d0:	e5 e3       	ldi	r30, 0x35	; 53
     1d2:	f0 e0       	ldi	r31, 0x00	; 0
     1d4:	80 81       	ld	r24, Z
     1d6:	48 2f       	mov	r20, r24
     1d8:	8b 81       	ldd	r24, Y+3	; 0x03
     1da:	28 2f       	mov	r18, r24
     1dc:	30 e0       	ldi	r19, 0x00	; 0
     1de:	81 e0       	ldi	r24, 0x01	; 1
     1e0:	90 e0       	ldi	r25, 0x00	; 0
     1e2:	02 2e       	mov	r0, r18
     1e4:	02 c0       	rjmp	.+4      	; 0x1ea <DIO_SET_PIN_VALUE+0x158>
     1e6:	88 0f       	add	r24, r24
     1e8:	99 1f       	adc	r25, r25
     1ea:	0a 94       	dec	r0
     1ec:	e2 f7       	brpl	.-8      	; 0x1e6 <DIO_SET_PIN_VALUE+0x154>
     1ee:	84 2b       	or	r24, r20
     1f0:	8c 93       	st	X, r24
     1f2:	40 c0       	rjmp	.+128    	; 0x274 <DIO_SET_PIN_VALUE+0x1e2>
     1f4:	a5 e3       	ldi	r26, 0x35	; 53
     1f6:	b0 e0       	ldi	r27, 0x00	; 0
     1f8:	e5 e3       	ldi	r30, 0x35	; 53
     1fa:	f0 e0       	ldi	r31, 0x00	; 0
     1fc:	80 81       	ld	r24, Z
     1fe:	48 2f       	mov	r20, r24
     200:	8b 81       	ldd	r24, Y+3	; 0x03
     202:	28 2f       	mov	r18, r24
     204:	30 e0       	ldi	r19, 0x00	; 0
     206:	81 e0       	ldi	r24, 0x01	; 1
     208:	90 e0       	ldi	r25, 0x00	; 0
     20a:	02 2e       	mov	r0, r18
     20c:	02 c0       	rjmp	.+4      	; 0x212 <DIO_SET_PIN_VALUE+0x180>
     20e:	88 0f       	add	r24, r24
     210:	99 1f       	adc	r25, r25
     212:	0a 94       	dec	r0
     214:	e2 f7       	brpl	.-8      	; 0x20e <DIO_SET_PIN_VALUE+0x17c>
     216:	80 95       	com	r24
     218:	84 23       	and	r24, r20
     21a:	8c 93       	st	X, r24
     21c:	2b c0       	rjmp	.+86     	; 0x274 <DIO_SET_PIN_VALUE+0x1e2>
     21e:	8c 81       	ldd	r24, Y+4	; 0x04
     220:	81 30       	cpi	r24, 0x01	; 1
     222:	a1 f4       	brne	.+40     	; 0x24c <DIO_SET_PIN_VALUE+0x1ba>
     224:	a2 e3       	ldi	r26, 0x32	; 50
     226:	b0 e0       	ldi	r27, 0x00	; 0
     228:	e2 e3       	ldi	r30, 0x32	; 50
     22a:	f0 e0       	ldi	r31, 0x00	; 0
     22c:	80 81       	ld	r24, Z
     22e:	48 2f       	mov	r20, r24
     230:	8b 81       	ldd	r24, Y+3	; 0x03
     232:	28 2f       	mov	r18, r24
     234:	30 e0       	ldi	r19, 0x00	; 0
     236:	81 e0       	ldi	r24, 0x01	; 1
     238:	90 e0       	ldi	r25, 0x00	; 0
     23a:	02 2e       	mov	r0, r18
     23c:	02 c0       	rjmp	.+4      	; 0x242 <DIO_SET_PIN_VALUE+0x1b0>
     23e:	88 0f       	add	r24, r24
     240:	99 1f       	adc	r25, r25
     242:	0a 94       	dec	r0
     244:	e2 f7       	brpl	.-8      	; 0x23e <DIO_SET_PIN_VALUE+0x1ac>
     246:	84 2b       	or	r24, r20
     248:	8c 93       	st	X, r24
     24a:	14 c0       	rjmp	.+40     	; 0x274 <DIO_SET_PIN_VALUE+0x1e2>
     24c:	a2 e3       	ldi	r26, 0x32	; 50
     24e:	b0 e0       	ldi	r27, 0x00	; 0
     250:	e2 e3       	ldi	r30, 0x32	; 50
     252:	f0 e0       	ldi	r31, 0x00	; 0
     254:	80 81       	ld	r24, Z
     256:	48 2f       	mov	r20, r24
     258:	8b 81       	ldd	r24, Y+3	; 0x03
     25a:	28 2f       	mov	r18, r24
     25c:	30 e0       	ldi	r19, 0x00	; 0
     25e:	81 e0       	ldi	r24, 0x01	; 1
     260:	90 e0       	ldi	r25, 0x00	; 0
     262:	02 2e       	mov	r0, r18
     264:	02 c0       	rjmp	.+4      	; 0x26a <DIO_SET_PIN_VALUE+0x1d8>
     266:	88 0f       	add	r24, r24
     268:	99 1f       	adc	r25, r25
     26a:	0a 94       	dec	r0
     26c:	e2 f7       	brpl	.-8      	; 0x266 <DIO_SET_PIN_VALUE+0x1d4>
     26e:	80 95       	com	r24
     270:	84 23       	and	r24, r20
     272:	8c 93       	st	X, r24
     274:	89 81       	ldd	r24, Y+1	; 0x01
     276:	26 96       	adiw	r28, 0x06	; 6
     278:	0f b6       	in	r0, 0x3f	; 63
     27a:	f8 94       	cli
     27c:	de bf       	out	0x3e, r29	; 62
     27e:	0f be       	out	0x3f, r0	; 63
     280:	cd bf       	out	0x3d, r28	; 61
     282:	cf 91       	pop	r28
     284:	df 91       	pop	r29
     286:	08 95       	ret

00000288 <DIO_SET_PIN_DIRECTION>:

//FUNCTION FOR DIRECTION (REG DDR) FOR 1 PIN **************


u8 DIO_SET_PIN_DIRECTION(u8 PORT_NB,u8 PIN_NB,u8 PIN_DIRECTION)//RIGESTER PORT PIN PIN....
{u8 ERROR_STATE=0;
     288:	df 93       	push	r29
     28a:	cf 93       	push	r28
     28c:	00 d0       	rcall	.+0      	; 0x28e <DIO_SET_PIN_DIRECTION+0x6>
     28e:	00 d0       	rcall	.+0      	; 0x290 <DIO_SET_PIN_DIRECTION+0x8>
     290:	00 d0       	rcall	.+0      	; 0x292 <DIO_SET_PIN_DIRECTION+0xa>
     292:	cd b7       	in	r28, 0x3d	; 61
     294:	de b7       	in	r29, 0x3e	; 62
     296:	8a 83       	std	Y+2, r24	; 0x02
     298:	6b 83       	std	Y+3, r22	; 0x03
     29a:	4c 83       	std	Y+4, r20	; 0x04
     29c:	19 82       	std	Y+1, r1	; 0x01
	if (PORT_NB>=DIO_MAX_PORT_NB)
     29e:	8a 81       	ldd	r24, Y+2	; 0x02
     2a0:	84 30       	cpi	r24, 0x04	; 4
     2a2:	18 f0       	brcs	.+6      	; 0x2aa <DIO_SET_PIN_DIRECTION+0x22>
	{
		ERROR_STATE=1;//PORT ERROR
     2a4:	81 e0       	ldi	r24, 0x01	; 1
     2a6:	89 83       	std	Y+1, r24	; 0x01
     2a8:	e0 c0       	rjmp	.+448    	; 0x46a <DIO_SET_PIN_DIRECTION+0x1e2>

	}else if (PIN_NB >= DIO_MAX_PIN_NB)
     2aa:	8b 81       	ldd	r24, Y+3	; 0x03
     2ac:	88 30       	cpi	r24, 0x08	; 8
     2ae:	18 f0       	brcs	.+6      	; 0x2b6 <DIO_SET_PIN_DIRECTION+0x2e>

	{
		ERROR_STATE=2;//PIN ERROR
     2b0:	82 e0       	ldi	r24, 0x02	; 2
     2b2:	89 83       	std	Y+1, r24	; 0x01
     2b4:	da c0       	rjmp	.+436    	; 0x46a <DIO_SET_PIN_DIRECTION+0x1e2>

	}else if((PIN_DIRECTION !=DIO_INPUT)&&(PIN_DIRECTION!=DIO_OUTPUT))
     2b6:	8c 81       	ldd	r24, Y+4	; 0x04
     2b8:	88 23       	and	r24, r24
     2ba:	31 f0       	breq	.+12     	; 0x2c8 <DIO_SET_PIN_DIRECTION+0x40>
     2bc:	8c 81       	ldd	r24, Y+4	; 0x04
     2be:	81 30       	cpi	r24, 0x01	; 1
     2c0:	19 f0       	breq	.+6      	; 0x2c8 <DIO_SET_PIN_DIRECTION+0x40>
	{

		ERROR_STATE=3;//VALUE ERROR
     2c2:	83 e0       	ldi	r24, 0x03	; 3
     2c4:	89 83       	std	Y+1, r24	; 0x01
     2c6:	d1 c0       	rjmp	.+418    	; 0x46a <DIO_SET_PIN_DIRECTION+0x1e2>
	}
	else
	{

		switch (PORT_NB)
     2c8:	8a 81       	ldd	r24, Y+2	; 0x02
     2ca:	28 2f       	mov	r18, r24
     2cc:	30 e0       	ldi	r19, 0x00	; 0
     2ce:	3e 83       	std	Y+6, r19	; 0x06
     2d0:	2d 83       	std	Y+5, r18	; 0x05
     2d2:	8d 81       	ldd	r24, Y+5	; 0x05
     2d4:	9e 81       	ldd	r25, Y+6	; 0x06
     2d6:	81 30       	cpi	r24, 0x01	; 1
     2d8:	91 05       	cpc	r25, r1
     2da:	09 f4       	brne	.+2      	; 0x2de <DIO_SET_PIN_DIRECTION+0x56>
     2dc:	43 c0       	rjmp	.+134    	; 0x364 <DIO_SET_PIN_DIRECTION+0xdc>
     2de:	2d 81       	ldd	r18, Y+5	; 0x05
     2e0:	3e 81       	ldd	r19, Y+6	; 0x06
     2e2:	22 30       	cpi	r18, 0x02	; 2
     2e4:	31 05       	cpc	r19, r1
     2e6:	2c f4       	brge	.+10     	; 0x2f2 <DIO_SET_PIN_DIRECTION+0x6a>
     2e8:	8d 81       	ldd	r24, Y+5	; 0x05
     2ea:	9e 81       	ldd	r25, Y+6	; 0x06
     2ec:	00 97       	sbiw	r24, 0x00	; 0
     2ee:	71 f0       	breq	.+28     	; 0x30c <DIO_SET_PIN_DIRECTION+0x84>
     2f0:	bc c0       	rjmp	.+376    	; 0x46a <DIO_SET_PIN_DIRECTION+0x1e2>
     2f2:	2d 81       	ldd	r18, Y+5	; 0x05
     2f4:	3e 81       	ldd	r19, Y+6	; 0x06
     2f6:	22 30       	cpi	r18, 0x02	; 2
     2f8:	31 05       	cpc	r19, r1
     2fa:	09 f4       	brne	.+2      	; 0x2fe <DIO_SET_PIN_DIRECTION+0x76>
     2fc:	5f c0       	rjmp	.+190    	; 0x3bc <DIO_SET_PIN_DIRECTION+0x134>
     2fe:	8d 81       	ldd	r24, Y+5	; 0x05
     300:	9e 81       	ldd	r25, Y+6	; 0x06
     302:	83 30       	cpi	r24, 0x03	; 3
     304:	91 05       	cpc	r25, r1
     306:	09 f4       	brne	.+2      	; 0x30a <DIO_SET_PIN_DIRECTION+0x82>
     308:	85 c0       	rjmp	.+266    	; 0x414 <DIO_SET_PIN_DIRECTION+0x18c>
     30a:	af c0       	rjmp	.+350    	; 0x46a <DIO_SET_PIN_DIRECTION+0x1e2>
		{
		case GROUP_A:
					assign_bit(DIO_U8_DDRA,PIN_NB,PIN_DIRECTION);
     30c:	8c 81       	ldd	r24, Y+4	; 0x04
     30e:	81 30       	cpi	r24, 0x01	; 1
     310:	a1 f4       	brne	.+40     	; 0x33a <DIO_SET_PIN_DIRECTION+0xb2>
     312:	aa e3       	ldi	r26, 0x3A	; 58
     314:	b0 e0       	ldi	r27, 0x00	; 0
     316:	ea e3       	ldi	r30, 0x3A	; 58
     318:	f0 e0       	ldi	r31, 0x00	; 0
     31a:	80 81       	ld	r24, Z
     31c:	48 2f       	mov	r20, r24
     31e:	8b 81       	ldd	r24, Y+3	; 0x03
     320:	28 2f       	mov	r18, r24
     322:	30 e0       	ldi	r19, 0x00	; 0
     324:	81 e0       	ldi	r24, 0x01	; 1
     326:	90 e0       	ldi	r25, 0x00	; 0
     328:	02 2e       	mov	r0, r18
     32a:	02 c0       	rjmp	.+4      	; 0x330 <DIO_SET_PIN_DIRECTION+0xa8>
     32c:	88 0f       	add	r24, r24
     32e:	99 1f       	adc	r25, r25
     330:	0a 94       	dec	r0
     332:	e2 f7       	brpl	.-8      	; 0x32c <DIO_SET_PIN_DIRECTION+0xa4>
     334:	84 2b       	or	r24, r20
     336:	8c 93       	st	X, r24
     338:	98 c0       	rjmp	.+304    	; 0x46a <DIO_SET_PIN_DIRECTION+0x1e2>
     33a:	aa e3       	ldi	r26, 0x3A	; 58
     33c:	b0 e0       	ldi	r27, 0x00	; 0
     33e:	ea e3       	ldi	r30, 0x3A	; 58
     340:	f0 e0       	ldi	r31, 0x00	; 0
     342:	80 81       	ld	r24, Z
     344:	48 2f       	mov	r20, r24
     346:	8b 81       	ldd	r24, Y+3	; 0x03
     348:	28 2f       	mov	r18, r24
     34a:	30 e0       	ldi	r19, 0x00	; 0
     34c:	81 e0       	ldi	r24, 0x01	; 1
     34e:	90 e0       	ldi	r25, 0x00	; 0
     350:	02 2e       	mov	r0, r18
     352:	02 c0       	rjmp	.+4      	; 0x358 <DIO_SET_PIN_DIRECTION+0xd0>
     354:	88 0f       	add	r24, r24
     356:	99 1f       	adc	r25, r25
     358:	0a 94       	dec	r0
     35a:	e2 f7       	brpl	.-8      	; 0x354 <DIO_SET_PIN_DIRECTION+0xcc>
     35c:	80 95       	com	r24
     35e:	84 23       	and	r24, r20
     360:	8c 93       	st	X, r24
     362:	83 c0       	rjmp	.+262    	; 0x46a <DIO_SET_PIN_DIRECTION+0x1e2>
			break;
		case GROUP_B:
					assign_bit(DIO_U8_DDRB,PIN_NB,PIN_DIRECTION);
     364:	8c 81       	ldd	r24, Y+4	; 0x04
     366:	81 30       	cpi	r24, 0x01	; 1
     368:	a1 f4       	brne	.+40     	; 0x392 <DIO_SET_PIN_DIRECTION+0x10a>
     36a:	a7 e3       	ldi	r26, 0x37	; 55
     36c:	b0 e0       	ldi	r27, 0x00	; 0
     36e:	e7 e3       	ldi	r30, 0x37	; 55
     370:	f0 e0       	ldi	r31, 0x00	; 0
     372:	80 81       	ld	r24, Z
     374:	48 2f       	mov	r20, r24
     376:	8b 81       	ldd	r24, Y+3	; 0x03
     378:	28 2f       	mov	r18, r24
     37a:	30 e0       	ldi	r19, 0x00	; 0
     37c:	81 e0       	ldi	r24, 0x01	; 1
     37e:	90 e0       	ldi	r25, 0x00	; 0
     380:	02 2e       	mov	r0, r18
     382:	02 c0       	rjmp	.+4      	; 0x388 <DIO_SET_PIN_DIRECTION+0x100>
     384:	88 0f       	add	r24, r24
     386:	99 1f       	adc	r25, r25
     388:	0a 94       	dec	r0
     38a:	e2 f7       	brpl	.-8      	; 0x384 <DIO_SET_PIN_DIRECTION+0xfc>
     38c:	84 2b       	or	r24, r20
     38e:	8c 93       	st	X, r24
     390:	6c c0       	rjmp	.+216    	; 0x46a <DIO_SET_PIN_DIRECTION+0x1e2>
     392:	a7 e3       	ldi	r26, 0x37	; 55
     394:	b0 e0       	ldi	r27, 0x00	; 0
     396:	e7 e3       	ldi	r30, 0x37	; 55
     398:	f0 e0       	ldi	r31, 0x00	; 0
     39a:	80 81       	ld	r24, Z
     39c:	48 2f       	mov	r20, r24
     39e:	8b 81       	ldd	r24, Y+3	; 0x03
     3a0:	28 2f       	mov	r18, r24
     3a2:	30 e0       	ldi	r19, 0x00	; 0
     3a4:	81 e0       	ldi	r24, 0x01	; 1
     3a6:	90 e0       	ldi	r25, 0x00	; 0
     3a8:	02 2e       	mov	r0, r18
     3aa:	02 c0       	rjmp	.+4      	; 0x3b0 <DIO_SET_PIN_DIRECTION+0x128>
     3ac:	88 0f       	add	r24, r24
     3ae:	99 1f       	adc	r25, r25
     3b0:	0a 94       	dec	r0
     3b2:	e2 f7       	brpl	.-8      	; 0x3ac <DIO_SET_PIN_DIRECTION+0x124>
     3b4:	80 95       	com	r24
     3b6:	84 23       	and	r24, r20
     3b8:	8c 93       	st	X, r24
     3ba:	57 c0       	rjmp	.+174    	; 0x46a <DIO_SET_PIN_DIRECTION+0x1e2>
			break;
		case GROUP_C:
					assign_bit(DIO_U8_DDRC,PIN_NB,PIN_DIRECTION);
     3bc:	8c 81       	ldd	r24, Y+4	; 0x04
     3be:	81 30       	cpi	r24, 0x01	; 1
     3c0:	a1 f4       	brne	.+40     	; 0x3ea <DIO_SET_PIN_DIRECTION+0x162>
     3c2:	a4 e3       	ldi	r26, 0x34	; 52
     3c4:	b0 e0       	ldi	r27, 0x00	; 0
     3c6:	e4 e3       	ldi	r30, 0x34	; 52
     3c8:	f0 e0       	ldi	r31, 0x00	; 0
     3ca:	80 81       	ld	r24, Z
     3cc:	48 2f       	mov	r20, r24
     3ce:	8b 81       	ldd	r24, Y+3	; 0x03
     3d0:	28 2f       	mov	r18, r24
     3d2:	30 e0       	ldi	r19, 0x00	; 0
     3d4:	81 e0       	ldi	r24, 0x01	; 1
     3d6:	90 e0       	ldi	r25, 0x00	; 0
     3d8:	02 2e       	mov	r0, r18
     3da:	02 c0       	rjmp	.+4      	; 0x3e0 <DIO_SET_PIN_DIRECTION+0x158>
     3dc:	88 0f       	add	r24, r24
     3de:	99 1f       	adc	r25, r25
     3e0:	0a 94       	dec	r0
     3e2:	e2 f7       	brpl	.-8      	; 0x3dc <DIO_SET_PIN_DIRECTION+0x154>
     3e4:	84 2b       	or	r24, r20
     3e6:	8c 93       	st	X, r24
     3e8:	40 c0       	rjmp	.+128    	; 0x46a <DIO_SET_PIN_DIRECTION+0x1e2>
     3ea:	a4 e3       	ldi	r26, 0x34	; 52
     3ec:	b0 e0       	ldi	r27, 0x00	; 0
     3ee:	e4 e3       	ldi	r30, 0x34	; 52
     3f0:	f0 e0       	ldi	r31, 0x00	; 0
     3f2:	80 81       	ld	r24, Z
     3f4:	48 2f       	mov	r20, r24
     3f6:	8b 81       	ldd	r24, Y+3	; 0x03
     3f8:	28 2f       	mov	r18, r24
     3fa:	30 e0       	ldi	r19, 0x00	; 0
     3fc:	81 e0       	ldi	r24, 0x01	; 1
     3fe:	90 e0       	ldi	r25, 0x00	; 0
     400:	02 2e       	mov	r0, r18
     402:	02 c0       	rjmp	.+4      	; 0x408 <DIO_SET_PIN_DIRECTION+0x180>
     404:	88 0f       	add	r24, r24
     406:	99 1f       	adc	r25, r25
     408:	0a 94       	dec	r0
     40a:	e2 f7       	brpl	.-8      	; 0x404 <DIO_SET_PIN_DIRECTION+0x17c>
     40c:	80 95       	com	r24
     40e:	84 23       	and	r24, r20
     410:	8c 93       	st	X, r24
     412:	2b c0       	rjmp	.+86     	; 0x46a <DIO_SET_PIN_DIRECTION+0x1e2>
			break;
		case GROUP_D:
					assign_bit(DIO_U8_DDRD,PIN_NB,PIN_DIRECTION);
     414:	8c 81       	ldd	r24, Y+4	; 0x04
     416:	81 30       	cpi	r24, 0x01	; 1
     418:	a1 f4       	brne	.+40     	; 0x442 <DIO_SET_PIN_DIRECTION+0x1ba>
     41a:	a1 e3       	ldi	r26, 0x31	; 49
     41c:	b0 e0       	ldi	r27, 0x00	; 0
     41e:	e1 e3       	ldi	r30, 0x31	; 49
     420:	f0 e0       	ldi	r31, 0x00	; 0
     422:	80 81       	ld	r24, Z
     424:	48 2f       	mov	r20, r24
     426:	8b 81       	ldd	r24, Y+3	; 0x03
     428:	28 2f       	mov	r18, r24
     42a:	30 e0       	ldi	r19, 0x00	; 0
     42c:	81 e0       	ldi	r24, 0x01	; 1
     42e:	90 e0       	ldi	r25, 0x00	; 0
     430:	02 2e       	mov	r0, r18
     432:	02 c0       	rjmp	.+4      	; 0x438 <DIO_SET_PIN_DIRECTION+0x1b0>
     434:	88 0f       	add	r24, r24
     436:	99 1f       	adc	r25, r25
     438:	0a 94       	dec	r0
     43a:	e2 f7       	brpl	.-8      	; 0x434 <DIO_SET_PIN_DIRECTION+0x1ac>
     43c:	84 2b       	or	r24, r20
     43e:	8c 93       	st	X, r24
     440:	14 c0       	rjmp	.+40     	; 0x46a <DIO_SET_PIN_DIRECTION+0x1e2>
     442:	a1 e3       	ldi	r26, 0x31	; 49
     444:	b0 e0       	ldi	r27, 0x00	; 0
     446:	e1 e3       	ldi	r30, 0x31	; 49
     448:	f0 e0       	ldi	r31, 0x00	; 0
     44a:	80 81       	ld	r24, Z
     44c:	48 2f       	mov	r20, r24
     44e:	8b 81       	ldd	r24, Y+3	; 0x03
     450:	28 2f       	mov	r18, r24
     452:	30 e0       	ldi	r19, 0x00	; 0
     454:	81 e0       	ldi	r24, 0x01	; 1
     456:	90 e0       	ldi	r25, 0x00	; 0
     458:	02 2e       	mov	r0, r18
     45a:	02 c0       	rjmp	.+4      	; 0x460 <DIO_SET_PIN_DIRECTION+0x1d8>
     45c:	88 0f       	add	r24, r24
     45e:	99 1f       	adc	r25, r25
     460:	0a 94       	dec	r0
     462:	e2 f7       	brpl	.-8      	; 0x45c <DIO_SET_PIN_DIRECTION+0x1d4>
     464:	80 95       	com	r24
     466:	84 23       	and	r24, r20
     468:	8c 93       	st	X, r24

	}



return ERROR_STATE;
     46a:	89 81       	ldd	r24, Y+1	; 0x01
}
     46c:	26 96       	adiw	r28, 0x06	; 6
     46e:	0f b6       	in	r0, 0x3f	; 63
     470:	f8 94       	cli
     472:	de bf       	out	0x3e, r29	; 62
     474:	0f be       	out	0x3f, r0	; 63
     476:	cd bf       	out	0x3d, r28	; 61
     478:	cf 91       	pop	r28
     47a:	df 91       	pop	r29
     47c:	08 95       	ret

0000047e <DIO_GET_PIN_VALUE>:

//FUNCTION FOR GET VALUE (REG PIN) FOR 1 PIN **************


u8 DIO_GET_PIN_VALUE(u8 PORT_NB,u8 PIN_NB,u8 *PIN_VALUE)//RIGESTER PORT PIN PIN....
{u8 ERROR_STATE=0;
     47e:	df 93       	push	r29
     480:	cf 93       	push	r28
     482:	cd b7       	in	r28, 0x3d	; 61
     484:	de b7       	in	r29, 0x3e	; 62
     486:	27 97       	sbiw	r28, 0x07	; 7
     488:	0f b6       	in	r0, 0x3f	; 63
     48a:	f8 94       	cli
     48c:	de bf       	out	0x3e, r29	; 62
     48e:	0f be       	out	0x3f, r0	; 63
     490:	cd bf       	out	0x3d, r28	; 61
     492:	8a 83       	std	Y+2, r24	; 0x02
     494:	6b 83       	std	Y+3, r22	; 0x03
     496:	5d 83       	std	Y+5, r21	; 0x05
     498:	4c 83       	std	Y+4, r20	; 0x04
     49a:	19 82       	std	Y+1, r1	; 0x01
	if (PORT_NB>=DIO_MAX_PORT_NB)
     49c:	8a 81       	ldd	r24, Y+2	; 0x02
     49e:	84 30       	cpi	r24, 0x04	; 4
     4a0:	18 f0       	brcs	.+6      	; 0x4a8 <DIO_GET_PIN_VALUE+0x2a>
	{
		ERROR_STATE=1;//PORT ERROR
     4a2:	81 e0       	ldi	r24, 0x01	; 1
     4a4:	89 83       	std	Y+1, r24	; 0x01
     4a6:	76 c0       	rjmp	.+236    	; 0x594 <DIO_GET_PIN_VALUE+0x116>

	}else if (PIN_NB >= DIO_MAX_PIN_NB)
     4a8:	8b 81       	ldd	r24, Y+3	; 0x03
     4aa:	88 30       	cpi	r24, 0x08	; 8
     4ac:	18 f0       	brcs	.+6      	; 0x4b4 <DIO_GET_PIN_VALUE+0x36>

	{
		ERROR_STATE=2;//PIN ERROR
     4ae:	82 e0       	ldi	r24, 0x02	; 2
     4b0:	89 83       	std	Y+1, r24	; 0x01
     4b2:	70 c0       	rjmp	.+224    	; 0x594 <DIO_GET_PIN_VALUE+0x116>

	}
	else
	{

		switch (PORT_NB)
     4b4:	8a 81       	ldd	r24, Y+2	; 0x02
     4b6:	28 2f       	mov	r18, r24
     4b8:	30 e0       	ldi	r19, 0x00	; 0
     4ba:	3f 83       	std	Y+7, r19	; 0x07
     4bc:	2e 83       	std	Y+6, r18	; 0x06
     4be:	4e 81       	ldd	r20, Y+6	; 0x06
     4c0:	5f 81       	ldd	r21, Y+7	; 0x07
     4c2:	41 30       	cpi	r20, 0x01	; 1
     4c4:	51 05       	cpc	r21, r1
     4c6:	59 f1       	breq	.+86     	; 0x51e <DIO_GET_PIN_VALUE+0xa0>
     4c8:	8e 81       	ldd	r24, Y+6	; 0x06
     4ca:	9f 81       	ldd	r25, Y+7	; 0x07
     4cc:	82 30       	cpi	r24, 0x02	; 2
     4ce:	91 05       	cpc	r25, r1
     4d0:	34 f4       	brge	.+12     	; 0x4de <DIO_GET_PIN_VALUE+0x60>
     4d2:	2e 81       	ldd	r18, Y+6	; 0x06
     4d4:	3f 81       	ldd	r19, Y+7	; 0x07
     4d6:	21 15       	cp	r18, r1
     4d8:	31 05       	cpc	r19, r1
     4da:	69 f0       	breq	.+26     	; 0x4f6 <DIO_GET_PIN_VALUE+0x78>
     4dc:	5b c0       	rjmp	.+182    	; 0x594 <DIO_GET_PIN_VALUE+0x116>
     4de:	4e 81       	ldd	r20, Y+6	; 0x06
     4e0:	5f 81       	ldd	r21, Y+7	; 0x07
     4e2:	42 30       	cpi	r20, 0x02	; 2
     4e4:	51 05       	cpc	r21, r1
     4e6:	79 f1       	breq	.+94     	; 0x546 <DIO_GET_PIN_VALUE+0xc8>
     4e8:	8e 81       	ldd	r24, Y+6	; 0x06
     4ea:	9f 81       	ldd	r25, Y+7	; 0x07
     4ec:	83 30       	cpi	r24, 0x03	; 3
     4ee:	91 05       	cpc	r25, r1
     4f0:	09 f4       	brne	.+2      	; 0x4f4 <DIO_GET_PIN_VALUE+0x76>
     4f2:	3d c0       	rjmp	.+122    	; 0x56e <DIO_GET_PIN_VALUE+0xf0>
     4f4:	4f c0       	rjmp	.+158    	; 0x594 <DIO_GET_PIN_VALUE+0x116>
		{
		case GROUP_A:
			*PIN_VALUE = get_bit(DIO_U8_PINA,PIN_NB);
     4f6:	e9 e3       	ldi	r30, 0x39	; 57
     4f8:	f0 e0       	ldi	r31, 0x00	; 0
     4fa:	80 81       	ld	r24, Z
     4fc:	28 2f       	mov	r18, r24
     4fe:	30 e0       	ldi	r19, 0x00	; 0
     500:	8b 81       	ldd	r24, Y+3	; 0x03
     502:	88 2f       	mov	r24, r24
     504:	90 e0       	ldi	r25, 0x00	; 0
     506:	a9 01       	movw	r20, r18
     508:	02 c0       	rjmp	.+4      	; 0x50e <DIO_GET_PIN_VALUE+0x90>
     50a:	55 95       	asr	r21
     50c:	47 95       	ror	r20
     50e:	8a 95       	dec	r24
     510:	e2 f7       	brpl	.-8      	; 0x50a <DIO_GET_PIN_VALUE+0x8c>
     512:	ca 01       	movw	r24, r20
     514:	81 70       	andi	r24, 0x01	; 1
     516:	ec 81       	ldd	r30, Y+4	; 0x04
     518:	fd 81       	ldd	r31, Y+5	; 0x05
     51a:	80 83       	st	Z, r24
     51c:	3b c0       	rjmp	.+118    	; 0x594 <DIO_GET_PIN_VALUE+0x116>
			break;
		case GROUP_B:
			*PIN_VALUE = get_bit(DIO_U8_PINB,PIN_NB);
     51e:	e6 e3       	ldi	r30, 0x36	; 54
     520:	f0 e0       	ldi	r31, 0x00	; 0
     522:	80 81       	ld	r24, Z
     524:	28 2f       	mov	r18, r24
     526:	30 e0       	ldi	r19, 0x00	; 0
     528:	8b 81       	ldd	r24, Y+3	; 0x03
     52a:	88 2f       	mov	r24, r24
     52c:	90 e0       	ldi	r25, 0x00	; 0
     52e:	a9 01       	movw	r20, r18
     530:	02 c0       	rjmp	.+4      	; 0x536 <DIO_GET_PIN_VALUE+0xb8>
     532:	55 95       	asr	r21
     534:	47 95       	ror	r20
     536:	8a 95       	dec	r24
     538:	e2 f7       	brpl	.-8      	; 0x532 <DIO_GET_PIN_VALUE+0xb4>
     53a:	ca 01       	movw	r24, r20
     53c:	81 70       	andi	r24, 0x01	; 1
     53e:	ec 81       	ldd	r30, Y+4	; 0x04
     540:	fd 81       	ldd	r31, Y+5	; 0x05
     542:	80 83       	st	Z, r24
     544:	27 c0       	rjmp	.+78     	; 0x594 <DIO_GET_PIN_VALUE+0x116>
			break;
		case GROUP_C:
			*PIN_VALUE = get_bit(DIO_U8_PINC,PIN_NB);
     546:	e3 e3       	ldi	r30, 0x33	; 51
     548:	f0 e0       	ldi	r31, 0x00	; 0
     54a:	80 81       	ld	r24, Z
     54c:	28 2f       	mov	r18, r24
     54e:	30 e0       	ldi	r19, 0x00	; 0
     550:	8b 81       	ldd	r24, Y+3	; 0x03
     552:	88 2f       	mov	r24, r24
     554:	90 e0       	ldi	r25, 0x00	; 0
     556:	a9 01       	movw	r20, r18
     558:	02 c0       	rjmp	.+4      	; 0x55e <DIO_GET_PIN_VALUE+0xe0>
     55a:	55 95       	asr	r21
     55c:	47 95       	ror	r20
     55e:	8a 95       	dec	r24
     560:	e2 f7       	brpl	.-8      	; 0x55a <DIO_GET_PIN_VALUE+0xdc>
     562:	ca 01       	movw	r24, r20
     564:	81 70       	andi	r24, 0x01	; 1
     566:	ec 81       	ldd	r30, Y+4	; 0x04
     568:	fd 81       	ldd	r31, Y+5	; 0x05
     56a:	80 83       	st	Z, r24
     56c:	13 c0       	rjmp	.+38     	; 0x594 <DIO_GET_PIN_VALUE+0x116>
			break;
		case GROUP_D:
			*PIN_VALUE = get_bit(DIO_U8_PIND,PIN_NB);
     56e:	e0 e3       	ldi	r30, 0x30	; 48
     570:	f0 e0       	ldi	r31, 0x00	; 0
     572:	80 81       	ld	r24, Z
     574:	28 2f       	mov	r18, r24
     576:	30 e0       	ldi	r19, 0x00	; 0
     578:	8b 81       	ldd	r24, Y+3	; 0x03
     57a:	88 2f       	mov	r24, r24
     57c:	90 e0       	ldi	r25, 0x00	; 0
     57e:	a9 01       	movw	r20, r18
     580:	02 c0       	rjmp	.+4      	; 0x586 <DIO_GET_PIN_VALUE+0x108>
     582:	55 95       	asr	r21
     584:	47 95       	ror	r20
     586:	8a 95       	dec	r24
     588:	e2 f7       	brpl	.-8      	; 0x582 <DIO_GET_PIN_VALUE+0x104>
     58a:	ca 01       	movw	r24, r20
     58c:	81 70       	andi	r24, 0x01	; 1
     58e:	ec 81       	ldd	r30, Y+4	; 0x04
     590:	fd 81       	ldd	r31, Y+5	; 0x05
     592:	80 83       	st	Z, r24

	}



return ERROR_STATE;
     594:	89 81       	ldd	r24, Y+1	; 0x01
}
     596:	27 96       	adiw	r28, 0x07	; 7
     598:	0f b6       	in	r0, 0x3f	; 63
     59a:	f8 94       	cli
     59c:	de bf       	out	0x3e, r29	; 62
     59e:	0f be       	out	0x3f, r0	; 63
     5a0:	cd bf       	out	0x3d, r28	; 61
     5a2:	cf 91       	pop	r28
     5a4:	df 91       	pop	r29
     5a6:	08 95       	ret

000005a8 <DIO_SET_PORT_VALUE>:

//FUNCTION FOR OUTPUT VALUE (REG PORT) FOR 8 PIN **************


u8 DIO_SET_PORT_VALUE(u8 PORT_NB,u8 PORT_VALUE)//RIGESTER PORT (PORT PORT....
{u8 ERROR_STATE=0;
     5a8:	df 93       	push	r29
     5aa:	cf 93       	push	r28
     5ac:	00 d0       	rcall	.+0      	; 0x5ae <DIO_SET_PORT_VALUE+0x6>
     5ae:	00 d0       	rcall	.+0      	; 0x5b0 <DIO_SET_PORT_VALUE+0x8>
     5b0:	0f 92       	push	r0
     5b2:	cd b7       	in	r28, 0x3d	; 61
     5b4:	de b7       	in	r29, 0x3e	; 62
     5b6:	8a 83       	std	Y+2, r24	; 0x02
     5b8:	6b 83       	std	Y+3, r22	; 0x03
     5ba:	19 82       	std	Y+1, r1	; 0x01
	if (PORT_NB>=DIO_MAX_PORT_NB)
     5bc:	8a 81       	ldd	r24, Y+2	; 0x02
     5be:	84 30       	cpi	r24, 0x04	; 4
     5c0:	18 f0       	brcs	.+6      	; 0x5c8 <DIO_SET_PORT_VALUE+0x20>
	{
		ERROR_STATE=1;//PORT ERROR
     5c2:	81 e0       	ldi	r24, 0x01	; 1
     5c4:	89 83       	std	Y+1, r24	; 0x01
     5c6:	32 c0       	rjmp	.+100    	; 0x62c <DIO_SET_PORT_VALUE+0x84>

	}
	else
	{

		switch (PORT_NB)
     5c8:	8a 81       	ldd	r24, Y+2	; 0x02
     5ca:	28 2f       	mov	r18, r24
     5cc:	30 e0       	ldi	r19, 0x00	; 0
     5ce:	3d 83       	std	Y+5, r19	; 0x05
     5d0:	2c 83       	std	Y+4, r18	; 0x04
     5d2:	8c 81       	ldd	r24, Y+4	; 0x04
     5d4:	9d 81       	ldd	r25, Y+5	; 0x05
     5d6:	81 30       	cpi	r24, 0x01	; 1
     5d8:	91 05       	cpc	r25, r1
     5da:	d1 f0       	breq	.+52     	; 0x610 <DIO_SET_PORT_VALUE+0x68>
     5dc:	2c 81       	ldd	r18, Y+4	; 0x04
     5de:	3d 81       	ldd	r19, Y+5	; 0x05
     5e0:	22 30       	cpi	r18, 0x02	; 2
     5e2:	31 05       	cpc	r19, r1
     5e4:	2c f4       	brge	.+10     	; 0x5f0 <DIO_SET_PORT_VALUE+0x48>
     5e6:	8c 81       	ldd	r24, Y+4	; 0x04
     5e8:	9d 81       	ldd	r25, Y+5	; 0x05
     5ea:	00 97       	sbiw	r24, 0x00	; 0
     5ec:	61 f0       	breq	.+24     	; 0x606 <DIO_SET_PORT_VALUE+0x5e>
     5ee:	1e c0       	rjmp	.+60     	; 0x62c <DIO_SET_PORT_VALUE+0x84>
     5f0:	2c 81       	ldd	r18, Y+4	; 0x04
     5f2:	3d 81       	ldd	r19, Y+5	; 0x05
     5f4:	22 30       	cpi	r18, 0x02	; 2
     5f6:	31 05       	cpc	r19, r1
     5f8:	81 f0       	breq	.+32     	; 0x61a <DIO_SET_PORT_VALUE+0x72>
     5fa:	8c 81       	ldd	r24, Y+4	; 0x04
     5fc:	9d 81       	ldd	r25, Y+5	; 0x05
     5fe:	83 30       	cpi	r24, 0x03	; 3
     600:	91 05       	cpc	r25, r1
     602:	81 f0       	breq	.+32     	; 0x624 <DIO_SET_PORT_VALUE+0x7c>
     604:	13 c0       	rjmp	.+38     	; 0x62c <DIO_SET_PORT_VALUE+0x84>
		{
		case GROUP_A:
			DIO_U8_PORTA=PORT_VALUE;
     606:	eb e3       	ldi	r30, 0x3B	; 59
     608:	f0 e0       	ldi	r31, 0x00	; 0
     60a:	8b 81       	ldd	r24, Y+3	; 0x03
     60c:	80 83       	st	Z, r24
     60e:	0e c0       	rjmp	.+28     	; 0x62c <DIO_SET_PORT_VALUE+0x84>
			break;
		case GROUP_B:
			DIO_U8_PORTB=PORT_VALUE;
     610:	e8 e3       	ldi	r30, 0x38	; 56
     612:	f0 e0       	ldi	r31, 0x00	; 0
     614:	8b 81       	ldd	r24, Y+3	; 0x03
     616:	80 83       	st	Z, r24
     618:	09 c0       	rjmp	.+18     	; 0x62c <DIO_SET_PORT_VALUE+0x84>
			break;
		case GROUP_C:
			DIO_U8_PORTC=PORT_VALUE;
     61a:	e5 e3       	ldi	r30, 0x35	; 53
     61c:	f0 e0       	ldi	r31, 0x00	; 0
     61e:	8b 81       	ldd	r24, Y+3	; 0x03
     620:	80 83       	st	Z, r24
     622:	04 c0       	rjmp	.+8      	; 0x62c <DIO_SET_PORT_VALUE+0x84>
			break;
		case GROUP_D:
			DIO_U8_PORTD=PORT_VALUE;
     624:	e2 e3       	ldi	r30, 0x32	; 50
     626:	f0 e0       	ldi	r31, 0x00	; 0
     628:	8b 81       	ldd	r24, Y+3	; 0x03
     62a:	80 83       	st	Z, r24

	}



return ERROR_STATE;
     62c:	89 81       	ldd	r24, Y+1	; 0x01
}
     62e:	0f 90       	pop	r0
     630:	0f 90       	pop	r0
     632:	0f 90       	pop	r0
     634:	0f 90       	pop	r0
     636:	0f 90       	pop	r0
     638:	cf 91       	pop	r28
     63a:	df 91       	pop	r29
     63c:	08 95       	ret

0000063e <DIO_SET_PORT_DIRECTION>:

//FUNCTION FOR DIRECTION (REG DDR) FOR 8 PIN **************


u8 DIO_SET_PORT_DIRECTION(u8 PORT_NB,u8 PORT_DIRECTION)//RIGESTER PORT (PORT PORT....
{u8 ERROR_STATE=0;
     63e:	df 93       	push	r29
     640:	cf 93       	push	r28
     642:	00 d0       	rcall	.+0      	; 0x644 <DIO_SET_PORT_DIRECTION+0x6>
     644:	00 d0       	rcall	.+0      	; 0x646 <DIO_SET_PORT_DIRECTION+0x8>
     646:	0f 92       	push	r0
     648:	cd b7       	in	r28, 0x3d	; 61
     64a:	de b7       	in	r29, 0x3e	; 62
     64c:	8a 83       	std	Y+2, r24	; 0x02
     64e:	6b 83       	std	Y+3, r22	; 0x03
     650:	19 82       	std	Y+1, r1	; 0x01
	if (PORT_NB>=DIO_MAX_PORT_NB)
     652:	8a 81       	ldd	r24, Y+2	; 0x02
     654:	84 30       	cpi	r24, 0x04	; 4
     656:	18 f0       	brcs	.+6      	; 0x65e <DIO_SET_PORT_DIRECTION+0x20>
	{
		ERROR_STATE=1;//PORT ERROR
     658:	81 e0       	ldi	r24, 0x01	; 1
     65a:	89 83       	std	Y+1, r24	; 0x01
     65c:	32 c0       	rjmp	.+100    	; 0x6c2 <DIO_SET_PORT_DIRECTION+0x84>

	}
	else
	{

		switch (PORT_NB)
     65e:	8a 81       	ldd	r24, Y+2	; 0x02
     660:	28 2f       	mov	r18, r24
     662:	30 e0       	ldi	r19, 0x00	; 0
     664:	3d 83       	std	Y+5, r19	; 0x05
     666:	2c 83       	std	Y+4, r18	; 0x04
     668:	8c 81       	ldd	r24, Y+4	; 0x04
     66a:	9d 81       	ldd	r25, Y+5	; 0x05
     66c:	81 30       	cpi	r24, 0x01	; 1
     66e:	91 05       	cpc	r25, r1
     670:	d1 f0       	breq	.+52     	; 0x6a6 <DIO_SET_PORT_DIRECTION+0x68>
     672:	2c 81       	ldd	r18, Y+4	; 0x04
     674:	3d 81       	ldd	r19, Y+5	; 0x05
     676:	22 30       	cpi	r18, 0x02	; 2
     678:	31 05       	cpc	r19, r1
     67a:	2c f4       	brge	.+10     	; 0x686 <DIO_SET_PORT_DIRECTION+0x48>
     67c:	8c 81       	ldd	r24, Y+4	; 0x04
     67e:	9d 81       	ldd	r25, Y+5	; 0x05
     680:	00 97       	sbiw	r24, 0x00	; 0
     682:	61 f0       	breq	.+24     	; 0x69c <DIO_SET_PORT_DIRECTION+0x5e>
     684:	1e c0       	rjmp	.+60     	; 0x6c2 <DIO_SET_PORT_DIRECTION+0x84>
     686:	2c 81       	ldd	r18, Y+4	; 0x04
     688:	3d 81       	ldd	r19, Y+5	; 0x05
     68a:	22 30       	cpi	r18, 0x02	; 2
     68c:	31 05       	cpc	r19, r1
     68e:	81 f0       	breq	.+32     	; 0x6b0 <DIO_SET_PORT_DIRECTION+0x72>
     690:	8c 81       	ldd	r24, Y+4	; 0x04
     692:	9d 81       	ldd	r25, Y+5	; 0x05
     694:	83 30       	cpi	r24, 0x03	; 3
     696:	91 05       	cpc	r25, r1
     698:	81 f0       	breq	.+32     	; 0x6ba <DIO_SET_PORT_DIRECTION+0x7c>
     69a:	13 c0       	rjmp	.+38     	; 0x6c2 <DIO_SET_PORT_DIRECTION+0x84>
		{
		case GROUP_A:
			DIO_U8_DDRA=PORT_DIRECTION;
     69c:	ea e3       	ldi	r30, 0x3A	; 58
     69e:	f0 e0       	ldi	r31, 0x00	; 0
     6a0:	8b 81       	ldd	r24, Y+3	; 0x03
     6a2:	80 83       	st	Z, r24
     6a4:	0e c0       	rjmp	.+28     	; 0x6c2 <DIO_SET_PORT_DIRECTION+0x84>
			break;
		case GROUP_B:
			DIO_U8_DDRB=PORT_DIRECTION;
     6a6:	e7 e3       	ldi	r30, 0x37	; 55
     6a8:	f0 e0       	ldi	r31, 0x00	; 0
     6aa:	8b 81       	ldd	r24, Y+3	; 0x03
     6ac:	80 83       	st	Z, r24
     6ae:	09 c0       	rjmp	.+18     	; 0x6c2 <DIO_SET_PORT_DIRECTION+0x84>
			break;
		case GROUP_C:
			DIO_U8_DDRC=PORT_DIRECTION;
     6b0:	e4 e3       	ldi	r30, 0x34	; 52
     6b2:	f0 e0       	ldi	r31, 0x00	; 0
     6b4:	8b 81       	ldd	r24, Y+3	; 0x03
     6b6:	80 83       	st	Z, r24
     6b8:	04 c0       	rjmp	.+8      	; 0x6c2 <DIO_SET_PORT_DIRECTION+0x84>
			break;
		case GROUP_D:
			DIO_U8_DDRD=PORT_DIRECTION;
     6ba:	e1 e3       	ldi	r30, 0x31	; 49
     6bc:	f0 e0       	ldi	r31, 0x00	; 0
     6be:	8b 81       	ldd	r24, Y+3	; 0x03
     6c0:	80 83       	st	Z, r24

	}



return ERROR_STATE;
     6c2:	89 81       	ldd	r24, Y+1	; 0x01
}
     6c4:	0f 90       	pop	r0
     6c6:	0f 90       	pop	r0
     6c8:	0f 90       	pop	r0
     6ca:	0f 90       	pop	r0
     6cc:	0f 90       	pop	r0
     6ce:	cf 91       	pop	r28
     6d0:	df 91       	pop	r29
     6d2:	08 95       	ret

000006d4 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
     6d4:	df 93       	push	r29
     6d6:	cf 93       	push	r28
     6d8:	00 d0       	rcall	.+0      	; 0x6da <xEventGroupCreate+0x6>
     6da:	cd b7       	in	r28, 0x3d	; 61
     6dc:	de b7       	in	r29, 0x3e	; 62
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
     6de:	8b e0       	ldi	r24, 0x0B	; 11
     6e0:	90 e0       	ldi	r25, 0x00	; 0
     6e2:	0e 94 af 06 	call	0xd5e	; 0xd5e <pvPortMalloc>
     6e6:	9a 83       	std	Y+2, r25	; 0x02
     6e8:	89 83       	std	Y+1, r24	; 0x01

		if( pxEventBits != NULL )
     6ea:	89 81       	ldd	r24, Y+1	; 0x01
     6ec:	9a 81       	ldd	r25, Y+2	; 0x02
     6ee:	00 97       	sbiw	r24, 0x00	; 0
     6f0:	49 f0       	breq	.+18     	; 0x704 <xEventGroupCreate+0x30>
		{
			pxEventBits->uxEventBits = 0;
     6f2:	e9 81       	ldd	r30, Y+1	; 0x01
     6f4:	fa 81       	ldd	r31, Y+2	; 0x02
     6f6:	11 82       	std	Z+1, r1	; 0x01
     6f8:	10 82       	st	Z, r1
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     6fa:	89 81       	ldd	r24, Y+1	; 0x01
     6fc:	9a 81       	ldd	r25, Y+2	; 0x02
     6fe:	02 96       	adiw	r24, 0x02	; 2
     700:	0e 94 2b 07 	call	0xe56	; 0xe56 <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
     704:	89 81       	ldd	r24, Y+1	; 0x01
     706:	9a 81       	ldd	r25, Y+2	; 0x02
	}
     708:	0f 90       	pop	r0
     70a:	0f 90       	pop	r0
     70c:	cf 91       	pop	r28
     70e:	df 91       	pop	r29
     710:	08 95       	ret

00000712 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
     712:	df 93       	push	r29
     714:	cf 93       	push	r28
     716:	cd b7       	in	r28, 0x3d	; 61
     718:	de b7       	in	r29, 0x3e	; 62
     71a:	60 97       	sbiw	r28, 0x10	; 16
     71c:	0f b6       	in	r0, 0x3f	; 63
     71e:	f8 94       	cli
     720:	de bf       	out	0x3e, r29	; 62
     722:	0f be       	out	0x3f, r0	; 63
     724:	cd bf       	out	0x3d, r28	; 61
     726:	9a 87       	std	Y+10, r25	; 0x0a
     728:	89 87       	std	Y+9, r24	; 0x09
     72a:	7c 87       	std	Y+12, r23	; 0x0c
     72c:	6b 87       	std	Y+11, r22	; 0x0b
     72e:	5e 87       	std	Y+14, r21	; 0x0e
     730:	4d 87       	std	Y+13, r20	; 0x0d
     732:	38 8b       	std	Y+16, r19	; 0x10
     734:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
     736:	89 85       	ldd	r24, Y+9	; 0x09
     738:	9a 85       	ldd	r25, Y+10	; 0x0a
     73a:	9c 83       	std	Y+4, r25	; 0x04
     73c:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     73e:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     740:	0e 94 d1 15 	call	0x2ba2	; 0x2ba2 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     744:	eb 81       	ldd	r30, Y+3	; 0x03
     746:	fc 81       	ldd	r31, Y+4	; 0x04
     748:	80 81       	ld	r24, Z
     74a:	91 81       	ldd	r25, Z+1	; 0x01
     74c:	98 87       	std	Y+8, r25	; 0x08
     74e:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     750:	89 85       	ldd	r24, Y+9	; 0x09
     752:	9a 85       	ldd	r25, Y+10	; 0x0a
     754:	2b 85       	ldd	r18, Y+11	; 0x0b
     756:	3c 85       	ldd	r19, Y+12	; 0x0c
     758:	b9 01       	movw	r22, r18
     75a:	0e 94 60 05 	call	0xac0	; 0xac0 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     75e:	2f 81       	ldd	r18, Y+7	; 0x07
     760:	38 85       	ldd	r19, Y+8	; 0x08
     762:	8b 85       	ldd	r24, Y+11	; 0x0b
     764:	9c 85       	ldd	r25, Y+12	; 0x0c
     766:	28 2b       	or	r18, r24
     768:	39 2b       	or	r19, r25
     76a:	8d 85       	ldd	r24, Y+13	; 0x0d
     76c:	9e 85       	ldd	r25, Y+14	; 0x0e
     76e:	28 23       	and	r18, r24
     770:	39 23       	and	r19, r25
     772:	8d 85       	ldd	r24, Y+13	; 0x0d
     774:	9e 85       	ldd	r25, Y+14	; 0x0e
     776:	28 17       	cp	r18, r24
     778:	39 07       	cpc	r19, r25
     77a:	c9 f4       	brne	.+50     	; 0x7ae <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
     77c:	2f 81       	ldd	r18, Y+7	; 0x07
     77e:	38 85       	ldd	r19, Y+8	; 0x08
     780:	8b 85       	ldd	r24, Y+11	; 0x0b
     782:	9c 85       	ldd	r25, Y+12	; 0x0c
     784:	82 2b       	or	r24, r18
     786:	93 2b       	or	r25, r19
     788:	9e 83       	std	Y+6, r25	; 0x06
     78a:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     78c:	eb 81       	ldd	r30, Y+3	; 0x03
     78e:	fc 81       	ldd	r31, Y+4	; 0x04
     790:	20 81       	ld	r18, Z
     792:	31 81       	ldd	r19, Z+1	; 0x01
     794:	8d 85       	ldd	r24, Y+13	; 0x0d
     796:	9e 85       	ldd	r25, Y+14	; 0x0e
     798:	80 95       	com	r24
     79a:	90 95       	com	r25
     79c:	82 23       	and	r24, r18
     79e:	93 23       	and	r25, r19
     7a0:	eb 81       	ldd	r30, Y+3	; 0x03
     7a2:	fc 81       	ldd	r31, Y+4	; 0x04
     7a4:	91 83       	std	Z+1, r25	; 0x01
     7a6:	80 83       	st	Z, r24

			xTicksToWait = 0;
     7a8:	18 8a       	std	Y+16, r1	; 0x10
     7aa:	1f 86       	std	Y+15, r1	; 0x0f
     7ac:	1e c0       	rjmp	.+60     	; 0x7ea <xEventGroupSync+0xd8>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     7ae:	8f 85       	ldd	r24, Y+15	; 0x0f
     7b0:	98 89       	ldd	r25, Y+16	; 0x10
     7b2:	00 97       	sbiw	r24, 0x00	; 0
     7b4:	91 f0       	breq	.+36     	; 0x7da <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     7b6:	8b 81       	ldd	r24, Y+3	; 0x03
     7b8:	9c 81       	ldd	r25, Y+4	; 0x04
     7ba:	bc 01       	movw	r22, r24
     7bc:	6e 5f       	subi	r22, 0xFE	; 254
     7be:	7f 4f       	sbci	r23, 0xFF	; 255
     7c0:	8d 85       	ldd	r24, Y+13	; 0x0d
     7c2:	9e 85       	ldd	r25, Y+14	; 0x0e
     7c4:	9c 01       	movw	r18, r24
     7c6:	35 60       	ori	r19, 0x05	; 5
     7c8:	4f 85       	ldd	r20, Y+15	; 0x0f
     7ca:	58 89       	ldd	r21, Y+16	; 0x10
     7cc:	cb 01       	movw	r24, r22
     7ce:	b9 01       	movw	r22, r18
     7d0:	0e 94 41 18 	call	0x3082	; 0x3082 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
     7d4:	1e 82       	std	Y+6, r1	; 0x06
     7d6:	1d 82       	std	Y+5, r1	; 0x05
     7d8:	08 c0       	rjmp	.+16     	; 0x7ea <xEventGroupSync+0xd8>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     7da:	eb 81       	ldd	r30, Y+3	; 0x03
     7dc:	fc 81       	ldd	r31, Y+4	; 0x04
     7de:	80 81       	ld	r24, Z
     7e0:	91 81       	ldd	r25, Z+1	; 0x01
     7e2:	9e 83       	std	Y+6, r25	; 0x06
     7e4:	8d 83       	std	Y+5, r24	; 0x05
				xTimeoutOccurred = pdTRUE;
     7e6:	81 e0       	ldi	r24, 0x01	; 1
     7e8:	89 83       	std	Y+1, r24	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     7ea:	0e 94 dd 15 	call	0x2bba	; 0x2bba <xTaskResumeAll>
     7ee:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
     7f0:	8f 85       	ldd	r24, Y+15	; 0x0f
     7f2:	98 89       	ldd	r25, Y+16	; 0x10
     7f4:	00 97       	sbiw	r24, 0x00	; 0
     7f6:	09 f4       	brne	.+2      	; 0x7fa <xEventGroupSync+0xe8>
     7f8:	3a c0       	rjmp	.+116    	; 0x86e <__stack+0xf>
	{
		if( xAlreadyYielded == pdFALSE )
     7fa:	8a 81       	ldd	r24, Y+2	; 0x02
     7fc:	88 23       	and	r24, r24
     7fe:	11 f4       	brne	.+4      	; 0x804 <xEventGroupSync+0xf2>
		{
			portYIELD_WITHIN_API();
     800:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     804:	0e 94 94 1a 	call	0x3528	; 0x3528 <uxTaskResetEventItemValue>
     808:	9e 83       	std	Y+6, r25	; 0x06
     80a:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     80c:	8d 81       	ldd	r24, Y+5	; 0x05
     80e:	9e 81       	ldd	r25, Y+6	; 0x06
     810:	80 70       	andi	r24, 0x00	; 0
     812:	92 70       	andi	r25, 0x02	; 2
     814:	00 97       	sbiw	r24, 0x00	; 0
     816:	31 f5       	brne	.+76     	; 0x864 <__stack+0x5>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     818:	0f b6       	in	r0, 0x3f	; 63
     81a:	f8 94       	cli
     81c:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     81e:	eb 81       	ldd	r30, Y+3	; 0x03
     820:	fc 81       	ldd	r31, Y+4	; 0x04
     822:	80 81       	ld	r24, Z
     824:	91 81       	ldd	r25, Z+1	; 0x01
     826:	9e 83       	std	Y+6, r25	; 0x06
     828:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     82a:	2d 81       	ldd	r18, Y+5	; 0x05
     82c:	3e 81       	ldd	r19, Y+6	; 0x06
     82e:	8d 85       	ldd	r24, Y+13	; 0x0d
     830:	9e 85       	ldd	r25, Y+14	; 0x0e
     832:	28 23       	and	r18, r24
     834:	39 23       	and	r19, r25
     836:	8d 85       	ldd	r24, Y+13	; 0x0d
     838:	9e 85       	ldd	r25, Y+14	; 0x0e
     83a:	28 17       	cp	r18, r24
     83c:	39 07       	cpc	r19, r25
     83e:	71 f4       	brne	.+28     	; 0x85c <xEventGroupSync+0x14a>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     840:	eb 81       	ldd	r30, Y+3	; 0x03
     842:	fc 81       	ldd	r31, Y+4	; 0x04
     844:	20 81       	ld	r18, Z
     846:	31 81       	ldd	r19, Z+1	; 0x01
     848:	8d 85       	ldd	r24, Y+13	; 0x0d
     84a:	9e 85       	ldd	r25, Y+14	; 0x0e
     84c:	80 95       	com	r24
     84e:	90 95       	com	r25
     850:	82 23       	and	r24, r18
     852:	93 23       	and	r25, r19
     854:	eb 81       	ldd	r30, Y+3	; 0x03
     856:	fc 81       	ldd	r31, Y+4	; 0x04
     858:	91 83       	std	Z+1, r25	; 0x01
     85a:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     85c:	0f 90       	pop	r0
     85e:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
     860:	81 e0       	ldi	r24, 0x01	; 1
     862:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     864:	8d 81       	ldd	r24, Y+5	; 0x05
     866:	9e 81       	ldd	r25, Y+6	; 0x06
     868:	90 70       	andi	r25, 0x00	; 0
     86a:	9e 83       	std	Y+6, r25	; 0x06
     86c:	8d 83       	std	Y+5, r24	; 0x05
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     86e:	8d 81       	ldd	r24, Y+5	; 0x05
     870:	9e 81       	ldd	r25, Y+6	; 0x06
}
     872:	60 96       	adiw	r28, 0x10	; 16
     874:	0f b6       	in	r0, 0x3f	; 63
     876:	f8 94       	cli
     878:	de bf       	out	0x3e, r29	; 62
     87a:	0f be       	out	0x3f, r0	; 63
     87c:	cd bf       	out	0x3d, r28	; 61
     87e:	cf 91       	pop	r28
     880:	df 91       	pop	r29
     882:	08 95       	ret

00000884 <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
     884:	0f 93       	push	r16
     886:	1f 93       	push	r17
     888:	df 93       	push	r29
     88a:	cf 93       	push	r28
     88c:	cd b7       	in	r28, 0x3d	; 61
     88e:	de b7       	in	r29, 0x3e	; 62
     890:	63 97       	sbiw	r28, 0x13	; 19
     892:	0f b6       	in	r0, 0x3f	; 63
     894:	f8 94       	cli
     896:	de bf       	out	0x3e, r29	; 62
     898:	0f be       	out	0x3f, r0	; 63
     89a:	cd bf       	out	0x3d, r28	; 61
     89c:	9d 87       	std	Y+13, r25	; 0x0d
     89e:	8c 87       	std	Y+12, r24	; 0x0c
     8a0:	7f 87       	std	Y+15, r23	; 0x0f
     8a2:	6e 87       	std	Y+14, r22	; 0x0e
     8a4:	48 8b       	std	Y+16, r20	; 0x10
     8a6:	29 8b       	std	Y+17, r18	; 0x11
     8a8:	1b 8b       	std	Y+19, r17	; 0x13
     8aa:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
     8ac:	8c 85       	ldd	r24, Y+12	; 0x0c
     8ae:	9d 85       	ldd	r25, Y+13	; 0x0d
     8b0:	9b 87       	std	Y+11, r25	; 0x0b
     8b2:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
     8b4:	1f 82       	std	Y+7, r1	; 0x07
     8b6:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     8b8:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     8ba:	0e 94 d1 15 	call	0x2ba2	; 0x2ba2 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     8be:	ea 85       	ldd	r30, Y+10	; 0x0a
     8c0:	fb 85       	ldd	r31, Y+11	; 0x0b
     8c2:	80 81       	ld	r24, Z
     8c4:	91 81       	ldd	r25, Z+1	; 0x01
     8c6:	9a 83       	std	Y+2, r25	; 0x02
     8c8:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     8ca:	89 81       	ldd	r24, Y+1	; 0x01
     8cc:	9a 81       	ldd	r25, Y+2	; 0x02
     8ce:	2e 85       	ldd	r18, Y+14	; 0x0e
     8d0:	3f 85       	ldd	r19, Y+15	; 0x0f
     8d2:	b9 01       	movw	r22, r18
     8d4:	49 89       	ldd	r20, Y+17	; 0x11
     8d6:	0e 94 7d 06 	call	0xcfa	; 0xcfa <prvTestWaitCondition>
     8da:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
     8dc:	8d 81       	ldd	r24, Y+5	; 0x05
     8de:	88 23       	and	r24, r24
     8e0:	c1 f0       	breq	.+48     	; 0x912 <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
     8e2:	89 81       	ldd	r24, Y+1	; 0x01
     8e4:	9a 81       	ldd	r25, Y+2	; 0x02
     8e6:	99 87       	std	Y+9, r25	; 0x09
     8e8:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
     8ea:	1b 8a       	std	Y+19, r1	; 0x13
     8ec:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     8ee:	88 89       	ldd	r24, Y+16	; 0x10
     8f0:	88 23       	and	r24, r24
     8f2:	e9 f1       	breq	.+122    	; 0x96e <xEventGroupWaitBits+0xea>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     8f4:	ea 85       	ldd	r30, Y+10	; 0x0a
     8f6:	fb 85       	ldd	r31, Y+11	; 0x0b
     8f8:	20 81       	ld	r18, Z
     8fa:	31 81       	ldd	r19, Z+1	; 0x01
     8fc:	8e 85       	ldd	r24, Y+14	; 0x0e
     8fe:	9f 85       	ldd	r25, Y+15	; 0x0f
     900:	80 95       	com	r24
     902:	90 95       	com	r25
     904:	82 23       	and	r24, r18
     906:	93 23       	and	r25, r19
     908:	ea 85       	ldd	r30, Y+10	; 0x0a
     90a:	fb 85       	ldd	r31, Y+11	; 0x0b
     90c:	91 83       	std	Z+1, r25	; 0x01
     90e:	80 83       	st	Z, r24
     910:	2e c0       	rjmp	.+92     	; 0x96e <xEventGroupWaitBits+0xea>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     912:	8a 89       	ldd	r24, Y+18	; 0x12
     914:	9b 89       	ldd	r25, Y+19	; 0x13
     916:	00 97       	sbiw	r24, 0x00	; 0
     918:	39 f4       	brne	.+14     	; 0x928 <xEventGroupWaitBits+0xa4>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
     91a:	89 81       	ldd	r24, Y+1	; 0x01
     91c:	9a 81       	ldd	r25, Y+2	; 0x02
     91e:	99 87       	std	Y+9, r25	; 0x09
     920:	88 87       	std	Y+8, r24	; 0x08
			xTimeoutOccurred = pdTRUE;
     922:	81 e0       	ldi	r24, 0x01	; 1
     924:	8b 83       	std	Y+3, r24	; 0x03
     926:	23 c0       	rjmp	.+70     	; 0x96e <xEventGroupWaitBits+0xea>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     928:	88 89       	ldd	r24, Y+16	; 0x10
     92a:	88 23       	and	r24, r24
     92c:	29 f0       	breq	.+10     	; 0x938 <xEventGroupWaitBits+0xb4>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     92e:	8e 81       	ldd	r24, Y+6	; 0x06
     930:	9f 81       	ldd	r25, Y+7	; 0x07
     932:	91 60       	ori	r25, 0x01	; 1
     934:	9f 83       	std	Y+7, r25	; 0x07
     936:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     938:	89 89       	ldd	r24, Y+17	; 0x11
     93a:	88 23       	and	r24, r24
     93c:	29 f0       	breq	.+10     	; 0x948 <xEventGroupWaitBits+0xc4>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     93e:	8e 81       	ldd	r24, Y+6	; 0x06
     940:	9f 81       	ldd	r25, Y+7	; 0x07
     942:	94 60       	ori	r25, 0x04	; 4
     944:	9f 83       	std	Y+7, r25	; 0x07
     946:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     948:	8a 85       	ldd	r24, Y+10	; 0x0a
     94a:	9b 85       	ldd	r25, Y+11	; 0x0b
     94c:	bc 01       	movw	r22, r24
     94e:	6e 5f       	subi	r22, 0xFE	; 254
     950:	7f 4f       	sbci	r23, 0xFF	; 255
     952:	2e 85       	ldd	r18, Y+14	; 0x0e
     954:	3f 85       	ldd	r19, Y+15	; 0x0f
     956:	8e 81       	ldd	r24, Y+6	; 0x06
     958:	9f 81       	ldd	r25, Y+7	; 0x07
     95a:	28 2b       	or	r18, r24
     95c:	39 2b       	or	r19, r25
     95e:	4a 89       	ldd	r20, Y+18	; 0x12
     960:	5b 89       	ldd	r21, Y+19	; 0x13
     962:	cb 01       	movw	r24, r22
     964:	b9 01       	movw	r22, r18
     966:	0e 94 41 18 	call	0x3082	; 0x3082 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
     96a:	19 86       	std	Y+9, r1	; 0x09
     96c:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     96e:	0e 94 dd 15 	call	0x2bba	; 0x2bba <xTaskResumeAll>
     972:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
     974:	8a 89       	ldd	r24, Y+18	; 0x12
     976:	9b 89       	ldd	r25, Y+19	; 0x13
     978:	00 97       	sbiw	r24, 0x00	; 0
     97a:	09 f4       	brne	.+2      	; 0x97e <xEventGroupWaitBits+0xfa>
     97c:	3c c0       	rjmp	.+120    	; 0x9f6 <xEventGroupWaitBits+0x172>
	{
		if( xAlreadyYielded == pdFALSE )
     97e:	8c 81       	ldd	r24, Y+4	; 0x04
     980:	88 23       	and	r24, r24
     982:	11 f4       	brne	.+4      	; 0x988 <xEventGroupWaitBits+0x104>
		{
			portYIELD_WITHIN_API();
     984:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     988:	0e 94 94 1a 	call	0x3528	; 0x3528 <uxTaskResetEventItemValue>
     98c:	99 87       	std	Y+9, r25	; 0x09
     98e:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     990:	88 85       	ldd	r24, Y+8	; 0x08
     992:	99 85       	ldd	r25, Y+9	; 0x09
     994:	80 70       	andi	r24, 0x00	; 0
     996:	92 70       	andi	r25, 0x02	; 2
     998:	00 97       	sbiw	r24, 0x00	; 0
     99a:	41 f5       	brne	.+80     	; 0x9ec <xEventGroupWaitBits+0x168>
		{
			taskENTER_CRITICAL();
     99c:	0f b6       	in	r0, 0x3f	; 63
     99e:	f8 94       	cli
     9a0:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     9a2:	ea 85       	ldd	r30, Y+10	; 0x0a
     9a4:	fb 85       	ldd	r31, Y+11	; 0x0b
     9a6:	80 81       	ld	r24, Z
     9a8:	91 81       	ldd	r25, Z+1	; 0x01
     9aa:	99 87       	std	Y+9, r25	; 0x09
     9ac:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     9ae:	88 85       	ldd	r24, Y+8	; 0x08
     9b0:	99 85       	ldd	r25, Y+9	; 0x09
     9b2:	2e 85       	ldd	r18, Y+14	; 0x0e
     9b4:	3f 85       	ldd	r19, Y+15	; 0x0f
     9b6:	b9 01       	movw	r22, r18
     9b8:	49 89       	ldd	r20, Y+17	; 0x11
     9ba:	0e 94 7d 06 	call	0xcfa	; 0xcfa <prvTestWaitCondition>
     9be:	88 23       	and	r24, r24
     9c0:	89 f0       	breq	.+34     	; 0x9e4 <xEventGroupWaitBits+0x160>
				{
					if( xClearOnExit != pdFALSE )
     9c2:	88 89       	ldd	r24, Y+16	; 0x10
     9c4:	88 23       	and	r24, r24
     9c6:	71 f0       	breq	.+28     	; 0x9e4 <xEventGroupWaitBits+0x160>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     9c8:	ea 85       	ldd	r30, Y+10	; 0x0a
     9ca:	fb 85       	ldd	r31, Y+11	; 0x0b
     9cc:	20 81       	ld	r18, Z
     9ce:	31 81       	ldd	r19, Z+1	; 0x01
     9d0:	8e 85       	ldd	r24, Y+14	; 0x0e
     9d2:	9f 85       	ldd	r25, Y+15	; 0x0f
     9d4:	80 95       	com	r24
     9d6:	90 95       	com	r25
     9d8:	82 23       	and	r24, r18
     9da:	93 23       	and	r25, r19
     9dc:	ea 85       	ldd	r30, Y+10	; 0x0a
     9de:	fb 85       	ldd	r31, Y+11	; 0x0b
     9e0:	91 83       	std	Z+1, r25	; 0x01
     9e2:	80 83       	st	Z, r24
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
     9e4:	81 e0       	ldi	r24, 0x01	; 1
     9e6:	8b 83       	std	Y+3, r24	; 0x03
			}
			taskEXIT_CRITICAL();
     9e8:	0f 90       	pop	r0
     9ea:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     9ec:	88 85       	ldd	r24, Y+8	; 0x08
     9ee:	99 85       	ldd	r25, Y+9	; 0x09
     9f0:	90 70       	andi	r25, 0x00	; 0
     9f2:	99 87       	std	Y+9, r25	; 0x09
     9f4:	88 87       	std	Y+8, r24	; 0x08
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     9f6:	88 85       	ldd	r24, Y+8	; 0x08
     9f8:	99 85       	ldd	r25, Y+9	; 0x09
}
     9fa:	63 96       	adiw	r28, 0x13	; 19
     9fc:	0f b6       	in	r0, 0x3f	; 63
     9fe:	f8 94       	cli
     a00:	de bf       	out	0x3e, r29	; 62
     a02:	0f be       	out	0x3f, r0	; 63
     a04:	cd bf       	out	0x3d, r28	; 61
     a06:	cf 91       	pop	r28
     a08:	df 91       	pop	r29
     a0a:	1f 91       	pop	r17
     a0c:	0f 91       	pop	r16
     a0e:	08 95       	ret

00000a10 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
     a10:	df 93       	push	r29
     a12:	cf 93       	push	r28
     a14:	cd b7       	in	r28, 0x3d	; 61
     a16:	de b7       	in	r29, 0x3e	; 62
     a18:	28 97       	sbiw	r28, 0x08	; 8
     a1a:	0f b6       	in	r0, 0x3f	; 63
     a1c:	f8 94       	cli
     a1e:	de bf       	out	0x3e, r29	; 62
     a20:	0f be       	out	0x3f, r0	; 63
     a22:	cd bf       	out	0x3d, r28	; 61
     a24:	9e 83       	std	Y+6, r25	; 0x06
     a26:	8d 83       	std	Y+5, r24	; 0x05
     a28:	78 87       	std	Y+8, r23	; 0x08
     a2a:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
     a2c:	8d 81       	ldd	r24, Y+5	; 0x05
     a2e:	9e 81       	ldd	r25, Y+6	; 0x06
     a30:	9c 83       	std	Y+4, r25	; 0x04
     a32:	8b 83       	std	Y+3, r24	; 0x03
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
     a34:	0f b6       	in	r0, 0x3f	; 63
     a36:	f8 94       	cli
     a38:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
     a3a:	eb 81       	ldd	r30, Y+3	; 0x03
     a3c:	fc 81       	ldd	r31, Y+4	; 0x04
     a3e:	80 81       	ld	r24, Z
     a40:	91 81       	ldd	r25, Z+1	; 0x01
     a42:	9a 83       	std	Y+2, r25	; 0x02
     a44:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     a46:	eb 81       	ldd	r30, Y+3	; 0x03
     a48:	fc 81       	ldd	r31, Y+4	; 0x04
     a4a:	20 81       	ld	r18, Z
     a4c:	31 81       	ldd	r19, Z+1	; 0x01
     a4e:	8f 81       	ldd	r24, Y+7	; 0x07
     a50:	98 85       	ldd	r25, Y+8	; 0x08
     a52:	80 95       	com	r24
     a54:	90 95       	com	r25
     a56:	82 23       	and	r24, r18
     a58:	93 23       	and	r25, r19
     a5a:	eb 81       	ldd	r30, Y+3	; 0x03
     a5c:	fc 81       	ldd	r31, Y+4	; 0x04
     a5e:	91 83       	std	Z+1, r25	; 0x01
     a60:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
     a62:	0f 90       	pop	r0
     a64:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
     a66:	89 81       	ldd	r24, Y+1	; 0x01
     a68:	9a 81       	ldd	r25, Y+2	; 0x02
}
     a6a:	28 96       	adiw	r28, 0x08	; 8
     a6c:	0f b6       	in	r0, 0x3f	; 63
     a6e:	f8 94       	cli
     a70:	de bf       	out	0x3e, r29	; 62
     a72:	0f be       	out	0x3f, r0	; 63
     a74:	cd bf       	out	0x3d, r28	; 61
     a76:	cf 91       	pop	r28
     a78:	df 91       	pop	r29
     a7a:	08 95       	ret

00000a7c <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
     a7c:	df 93       	push	r29
     a7e:	cf 93       	push	r28
     a80:	cd b7       	in	r28, 0x3d	; 61
     a82:	de b7       	in	r29, 0x3e	; 62
     a84:	27 97       	sbiw	r28, 0x07	; 7
     a86:	0f b6       	in	r0, 0x3f	; 63
     a88:	f8 94       	cli
     a8a:	de bf       	out	0x3e, r29	; 62
     a8c:	0f be       	out	0x3f, r0	; 63
     a8e:	cd bf       	out	0x3d, r28	; 61
     a90:	9f 83       	std	Y+7, r25	; 0x07
     a92:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
     a94:	8e 81       	ldd	r24, Y+6	; 0x06
     a96:	9f 81       	ldd	r25, Y+7	; 0x07
     a98:	9c 83       	std	Y+4, r25	; 0x04
     a9a:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     a9c:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
     a9e:	eb 81       	ldd	r30, Y+3	; 0x03
     aa0:	fc 81       	ldd	r31, Y+4	; 0x04
     aa2:	80 81       	ld	r24, Z
     aa4:	91 81       	ldd	r25, Z+1	; 0x01
     aa6:	9a 83       	std	Y+2, r25	; 0x02
     aa8:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
     aaa:	89 81       	ldd	r24, Y+1	; 0x01
     aac:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
     aae:	27 96       	adiw	r28, 0x07	; 7
     ab0:	0f b6       	in	r0, 0x3f	; 63
     ab2:	f8 94       	cli
     ab4:	de bf       	out	0x3e, r29	; 62
     ab6:	0f be       	out	0x3f, r0	; 63
     ab8:	cd bf       	out	0x3d, r28	; 61
     aba:	cf 91       	pop	r28
     abc:	df 91       	pop	r29
     abe:	08 95       	ret

00000ac0 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     ac0:	df 93       	push	r29
     ac2:	cf 93       	push	r28
     ac4:	cd b7       	in	r28, 0x3d	; 61
     ac6:	de b7       	in	r29, 0x3e	; 62
     ac8:	65 97       	sbiw	r28, 0x15	; 21
     aca:	0f b6       	in	r0, 0x3f	; 63
     acc:	f8 94       	cli
     ace:	de bf       	out	0x3e, r29	; 62
     ad0:	0f be       	out	0x3f, r0	; 63
     ad2:	cd bf       	out	0x3d, r28	; 61
     ad4:	9b 8b       	std	Y+19, r25	; 0x13
     ad6:	8a 8b       	std	Y+18, r24	; 0x12
     ad8:	7d 8b       	std	Y+21, r23	; 0x15
     ada:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     adc:	19 86       	std	Y+9, r1	; 0x09
     ade:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = xEventGroup;
     ae0:	8a 89       	ldd	r24, Y+18	; 0x12
     ae2:	9b 89       	ldd	r25, Y+19	; 0x13
     ae4:	9b 83       	std	Y+3, r25	; 0x03
     ae6:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
     ae8:	19 82       	std	Y+1, r1	; 0x01
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
     aea:	8a 81       	ldd	r24, Y+2	; 0x02
     aec:	9b 81       	ldd	r25, Y+3	; 0x03
     aee:	02 96       	adiw	r24, 0x02	; 2
     af0:	9b 87       	std	Y+11, r25	; 0x0b
     af2:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     af4:	8a 85       	ldd	r24, Y+10	; 0x0a
     af6:	9b 85       	ldd	r25, Y+11	; 0x0b
     af8:	03 96       	adiw	r24, 0x03	; 3
     afa:	9d 87       	std	Y+13, r25	; 0x0d
     afc:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
     afe:	0e 94 d1 15 	call	0x2ba2	; 0x2ba2 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     b02:	ea 85       	ldd	r30, Y+10	; 0x0a
     b04:	fb 85       	ldd	r31, Y+11	; 0x0b
     b06:	85 81       	ldd	r24, Z+5	; 0x05
     b08:	96 81       	ldd	r25, Z+6	; 0x06
     b0a:	99 8b       	std	Y+17, r25	; 0x11
     b0c:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     b0e:	ea 81       	ldd	r30, Y+2	; 0x02
     b10:	fb 81       	ldd	r31, Y+3	; 0x03
     b12:	20 81       	ld	r18, Z
     b14:	31 81       	ldd	r19, Z+1	; 0x01
     b16:	8c 89       	ldd	r24, Y+20	; 0x14
     b18:	9d 89       	ldd	r25, Y+21	; 0x15
     b1a:	82 2b       	or	r24, r18
     b1c:	93 2b       	or	r25, r19
     b1e:	ea 81       	ldd	r30, Y+2	; 0x02
     b20:	fb 81       	ldd	r31, Y+3	; 0x03
     b22:	91 83       	std	Z+1, r25	; 0x01
     b24:	80 83       	st	Z, r24
     b26:	59 c0       	rjmp	.+178    	; 0xbda <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
     b28:	e8 89       	ldd	r30, Y+16	; 0x10
     b2a:	f9 89       	ldd	r31, Y+17	; 0x11
     b2c:	82 81       	ldd	r24, Z+2	; 0x02
     b2e:	93 81       	ldd	r25, Z+3	; 0x03
     b30:	9f 87       	std	Y+15, r25	; 0x0f
     b32:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     b34:	e8 89       	ldd	r30, Y+16	; 0x10
     b36:	f9 89       	ldd	r31, Y+17	; 0x11
     b38:	80 81       	ld	r24, Z
     b3a:	91 81       	ldd	r25, Z+1	; 0x01
     b3c:	9f 83       	std	Y+7, r25	; 0x07
     b3e:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
     b40:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
     b42:	8e 81       	ldd	r24, Y+6	; 0x06
     b44:	9f 81       	ldd	r25, Y+7	; 0x07
     b46:	80 70       	andi	r24, 0x00	; 0
     b48:	9d 83       	std	Y+5, r25	; 0x05
     b4a:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     b4c:	8e 81       	ldd	r24, Y+6	; 0x06
     b4e:	9f 81       	ldd	r25, Y+7	; 0x07
     b50:	90 70       	andi	r25, 0x00	; 0
     b52:	9f 83       	std	Y+7, r25	; 0x07
     b54:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     b56:	8c 81       	ldd	r24, Y+4	; 0x04
     b58:	9d 81       	ldd	r25, Y+5	; 0x05
     b5a:	80 70       	andi	r24, 0x00	; 0
     b5c:	94 70       	andi	r25, 0x04	; 4
     b5e:	00 97       	sbiw	r24, 0x00	; 0
     b60:	69 f4       	brne	.+26     	; 0xb7c <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     b62:	ea 81       	ldd	r30, Y+2	; 0x02
     b64:	fb 81       	ldd	r31, Y+3	; 0x03
     b66:	20 81       	ld	r18, Z
     b68:	31 81       	ldd	r19, Z+1	; 0x01
     b6a:	8e 81       	ldd	r24, Y+6	; 0x06
     b6c:	9f 81       	ldd	r25, Y+7	; 0x07
     b6e:	82 23       	and	r24, r18
     b70:	93 23       	and	r25, r19
     b72:	00 97       	sbiw	r24, 0x00	; 0
     b74:	91 f0       	breq	.+36     	; 0xb9a <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
     b76:	81 e0       	ldi	r24, 0x01	; 1
     b78:	89 83       	std	Y+1, r24	; 0x01
     b7a:	0f c0       	rjmp	.+30     	; 0xb9a <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     b7c:	ea 81       	ldd	r30, Y+2	; 0x02
     b7e:	fb 81       	ldd	r31, Y+3	; 0x03
     b80:	20 81       	ld	r18, Z
     b82:	31 81       	ldd	r19, Z+1	; 0x01
     b84:	8e 81       	ldd	r24, Y+6	; 0x06
     b86:	9f 81       	ldd	r25, Y+7	; 0x07
     b88:	28 23       	and	r18, r24
     b8a:	39 23       	and	r19, r25
     b8c:	8e 81       	ldd	r24, Y+6	; 0x06
     b8e:	9f 81       	ldd	r25, Y+7	; 0x07
     b90:	28 17       	cp	r18, r24
     b92:	39 07       	cpc	r19, r25
     b94:	11 f4       	brne	.+4      	; 0xb9a <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
     b96:	81 e0       	ldi	r24, 0x01	; 1
     b98:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     b9a:	89 81       	ldd	r24, Y+1	; 0x01
     b9c:	88 23       	and	r24, r24
     b9e:	c9 f0       	breq	.+50     	; 0xbd2 <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     ba0:	8c 81       	ldd	r24, Y+4	; 0x04
     ba2:	9d 81       	ldd	r25, Y+5	; 0x05
     ba4:	80 70       	andi	r24, 0x00	; 0
     ba6:	91 70       	andi	r25, 0x01	; 1
     ba8:	00 97       	sbiw	r24, 0x00	; 0
     baa:	41 f0       	breq	.+16     	; 0xbbc <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     bac:	88 85       	ldd	r24, Y+8	; 0x08
     bae:	99 85       	ldd	r25, Y+9	; 0x09
     bb0:	2e 81       	ldd	r18, Y+6	; 0x06
     bb2:	3f 81       	ldd	r19, Y+7	; 0x07
     bb4:	82 2b       	or	r24, r18
     bb6:	93 2b       	or	r25, r19
     bb8:	99 87       	std	Y+9, r25	; 0x09
     bba:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     bbc:	ea 81       	ldd	r30, Y+2	; 0x02
     bbe:	fb 81       	ldd	r31, Y+3	; 0x03
     bc0:	80 81       	ld	r24, Z
     bc2:	91 81       	ldd	r25, Z+1	; 0x01
     bc4:	9c 01       	movw	r18, r24
     bc6:	32 60       	ori	r19, 0x02	; 2
     bc8:	88 89       	ldd	r24, Y+16	; 0x10
     bca:	99 89       	ldd	r25, Y+17	; 0x11
     bcc:	b9 01       	movw	r22, r18
     bce:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
     bd2:	8e 85       	ldd	r24, Y+14	; 0x0e
     bd4:	9f 85       	ldd	r25, Y+15	; 0x0f
     bd6:	99 8b       	std	Y+17, r25	; 0x11
     bd8:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     bda:	28 89       	ldd	r18, Y+16	; 0x10
     bdc:	39 89       	ldd	r19, Y+17	; 0x11
     bde:	8c 85       	ldd	r24, Y+12	; 0x0c
     be0:	9d 85       	ldd	r25, Y+13	; 0x0d
     be2:	28 17       	cp	r18, r24
     be4:	39 07       	cpc	r19, r25
     be6:	09 f0       	breq	.+2      	; 0xbea <xEventGroupSetBits+0x12a>
     be8:	9f cf       	rjmp	.-194    	; 0xb28 <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     bea:	ea 81       	ldd	r30, Y+2	; 0x02
     bec:	fb 81       	ldd	r31, Y+3	; 0x03
     bee:	20 81       	ld	r18, Z
     bf0:	31 81       	ldd	r19, Z+1	; 0x01
     bf2:	88 85       	ldd	r24, Y+8	; 0x08
     bf4:	99 85       	ldd	r25, Y+9	; 0x09
     bf6:	80 95       	com	r24
     bf8:	90 95       	com	r25
     bfa:	82 23       	and	r24, r18
     bfc:	93 23       	and	r25, r19
     bfe:	ea 81       	ldd	r30, Y+2	; 0x02
     c00:	fb 81       	ldd	r31, Y+3	; 0x03
     c02:	91 83       	std	Z+1, r25	; 0x01
     c04:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
     c06:	0e 94 dd 15 	call	0x2bba	; 0x2bba <xTaskResumeAll>

	return pxEventBits->uxEventBits;
     c0a:	ea 81       	ldd	r30, Y+2	; 0x02
     c0c:	fb 81       	ldd	r31, Y+3	; 0x03
     c0e:	80 81       	ld	r24, Z
     c10:	91 81       	ldd	r25, Z+1	; 0x01
}
     c12:	65 96       	adiw	r28, 0x15	; 21
     c14:	0f b6       	in	r0, 0x3f	; 63
     c16:	f8 94       	cli
     c18:	de bf       	out	0x3e, r29	; 62
     c1a:	0f be       	out	0x3f, r0	; 63
     c1c:	cd bf       	out	0x3d, r28	; 61
     c1e:	cf 91       	pop	r28
     c20:	df 91       	pop	r29
     c22:	08 95       	ret

00000c24 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
     c24:	df 93       	push	r29
     c26:	cf 93       	push	r28
     c28:	00 d0       	rcall	.+0      	; 0xc2a <vEventGroupDelete+0x6>
     c2a:	00 d0       	rcall	.+0      	; 0xc2c <vEventGroupDelete+0x8>
     c2c:	00 d0       	rcall	.+0      	; 0xc2e <vEventGroupDelete+0xa>
     c2e:	cd b7       	in	r28, 0x3d	; 61
     c30:	de b7       	in	r29, 0x3e	; 62
     c32:	9e 83       	std	Y+6, r25	; 0x06
     c34:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
     c36:	8d 81       	ldd	r24, Y+5	; 0x05
     c38:	9e 81       	ldd	r25, Y+6	; 0x06
     c3a:	9c 83       	std	Y+4, r25	; 0x04
     c3c:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
     c3e:	8b 81       	ldd	r24, Y+3	; 0x03
     c40:	9c 81       	ldd	r25, Y+4	; 0x04
     c42:	02 96       	adiw	r24, 0x02	; 2
     c44:	9a 83       	std	Y+2, r25	; 0x02
     c46:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
     c48:	0e 94 d1 15 	call	0x2ba2	; 0x2ba2 <vTaskSuspendAll>
     c4c:	08 c0       	rjmp	.+16     	; 0xc5e <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
     c4e:	e9 81       	ldd	r30, Y+1	; 0x01
     c50:	fa 81       	ldd	r31, Y+2	; 0x02
     c52:	85 81       	ldd	r24, Z+5	; 0x05
     c54:	96 81       	ldd	r25, Z+6	; 0x06
     c56:	60 e0       	ldi	r22, 0x00	; 0
     c58:	72 e0       	ldi	r23, 0x02	; 2
     c5a:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     c5e:	e9 81       	ldd	r30, Y+1	; 0x01
     c60:	fa 81       	ldd	r31, Y+2	; 0x02
     c62:	80 81       	ld	r24, Z
     c64:	88 23       	and	r24, r24
     c66:	99 f7       	brne	.-26     	; 0xc4e <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
     c68:	8b 81       	ldd	r24, Y+3	; 0x03
     c6a:	9c 81       	ldd	r25, Y+4	; 0x04
     c6c:	0e 94 05 07 	call	0xe0a	; 0xe0a <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
     c70:	0e 94 dd 15 	call	0x2bba	; 0x2bba <xTaskResumeAll>
}
     c74:	26 96       	adiw	r28, 0x06	; 6
     c76:	0f b6       	in	r0, 0x3f	; 63
     c78:	f8 94       	cli
     c7a:	de bf       	out	0x3e, r29	; 62
     c7c:	0f be       	out	0x3f, r0	; 63
     c7e:	cd bf       	out	0x3d, r28	; 61
     c80:	cf 91       	pop	r28
     c82:	df 91       	pop	r29
     c84:	08 95       	ret

00000c86 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
     c86:	df 93       	push	r29
     c88:	cf 93       	push	r28
     c8a:	00 d0       	rcall	.+0      	; 0xc8c <vEventGroupSetBitsCallback+0x6>
     c8c:	00 d0       	rcall	.+0      	; 0xc8e <vEventGroupSetBitsCallback+0x8>
     c8e:	00 d0       	rcall	.+0      	; 0xc90 <vEventGroupSetBitsCallback+0xa>
     c90:	cd b7       	in	r28, 0x3d	; 61
     c92:	de b7       	in	r29, 0x3e	; 62
     c94:	9a 83       	std	Y+2, r25	; 0x02
     c96:	89 83       	std	Y+1, r24	; 0x01
     c98:	4b 83       	std	Y+3, r20	; 0x03
     c9a:	5c 83       	std	Y+4, r21	; 0x04
     c9c:	6d 83       	std	Y+5, r22	; 0x05
     c9e:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     ca0:	89 81       	ldd	r24, Y+1	; 0x01
     ca2:	9a 81       	ldd	r25, Y+2	; 0x02
     ca4:	2b 81       	ldd	r18, Y+3	; 0x03
     ca6:	3c 81       	ldd	r19, Y+4	; 0x04
     ca8:	b9 01       	movw	r22, r18
     caa:	0e 94 60 05 	call	0xac0	; 0xac0 <xEventGroupSetBits>
}
     cae:	26 96       	adiw	r28, 0x06	; 6
     cb0:	0f b6       	in	r0, 0x3f	; 63
     cb2:	f8 94       	cli
     cb4:	de bf       	out	0x3e, r29	; 62
     cb6:	0f be       	out	0x3f, r0	; 63
     cb8:	cd bf       	out	0x3d, r28	; 61
     cba:	cf 91       	pop	r28
     cbc:	df 91       	pop	r29
     cbe:	08 95       	ret

00000cc0 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
     cc0:	df 93       	push	r29
     cc2:	cf 93       	push	r28
     cc4:	00 d0       	rcall	.+0      	; 0xcc6 <vEventGroupClearBitsCallback+0x6>
     cc6:	00 d0       	rcall	.+0      	; 0xcc8 <vEventGroupClearBitsCallback+0x8>
     cc8:	00 d0       	rcall	.+0      	; 0xcca <vEventGroupClearBitsCallback+0xa>
     cca:	cd b7       	in	r28, 0x3d	; 61
     ccc:	de b7       	in	r29, 0x3e	; 62
     cce:	9a 83       	std	Y+2, r25	; 0x02
     cd0:	89 83       	std	Y+1, r24	; 0x01
     cd2:	4b 83       	std	Y+3, r20	; 0x03
     cd4:	5c 83       	std	Y+4, r21	; 0x04
     cd6:	6d 83       	std	Y+5, r22	; 0x05
     cd8:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     cda:	89 81       	ldd	r24, Y+1	; 0x01
     cdc:	9a 81       	ldd	r25, Y+2	; 0x02
     cde:	2b 81       	ldd	r18, Y+3	; 0x03
     ce0:	3c 81       	ldd	r19, Y+4	; 0x04
     ce2:	b9 01       	movw	r22, r18
     ce4:	0e 94 08 05 	call	0xa10	; 0xa10 <xEventGroupClearBits>
}
     ce8:	26 96       	adiw	r28, 0x06	; 6
     cea:	0f b6       	in	r0, 0x3f	; 63
     cec:	f8 94       	cli
     cee:	de bf       	out	0x3e, r29	; 62
     cf0:	0f be       	out	0x3f, r0	; 63
     cf2:	cd bf       	out	0x3d, r28	; 61
     cf4:	cf 91       	pop	r28
     cf6:	df 91       	pop	r29
     cf8:	08 95       	ret

00000cfa <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
     cfa:	df 93       	push	r29
     cfc:	cf 93       	push	r28
     cfe:	00 d0       	rcall	.+0      	; 0xd00 <prvTestWaitCondition+0x6>
     d00:	00 d0       	rcall	.+0      	; 0xd02 <prvTestWaitCondition+0x8>
     d02:	00 d0       	rcall	.+0      	; 0xd04 <prvTestWaitCondition+0xa>
     d04:	cd b7       	in	r28, 0x3d	; 61
     d06:	de b7       	in	r29, 0x3e	; 62
     d08:	9b 83       	std	Y+3, r25	; 0x03
     d0a:	8a 83       	std	Y+2, r24	; 0x02
     d0c:	7d 83       	std	Y+5, r23	; 0x05
     d0e:	6c 83       	std	Y+4, r22	; 0x04
     d10:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
     d12:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
     d14:	8e 81       	ldd	r24, Y+6	; 0x06
     d16:	88 23       	and	r24, r24
     d18:	59 f4       	brne	.+22     	; 0xd30 <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
     d1a:	8a 81       	ldd	r24, Y+2	; 0x02
     d1c:	9b 81       	ldd	r25, Y+3	; 0x03
     d1e:	2c 81       	ldd	r18, Y+4	; 0x04
     d20:	3d 81       	ldd	r19, Y+5	; 0x05
     d22:	82 23       	and	r24, r18
     d24:	93 23       	and	r25, r19
     d26:	00 97       	sbiw	r24, 0x00	; 0
     d28:	81 f0       	breq	.+32     	; 0xd4a <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
     d2a:	81 e0       	ldi	r24, 0x01	; 1
     d2c:	89 83       	std	Y+1, r24	; 0x01
     d2e:	0d c0       	rjmp	.+26     	; 0xd4a <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     d30:	2a 81       	ldd	r18, Y+2	; 0x02
     d32:	3b 81       	ldd	r19, Y+3	; 0x03
     d34:	8c 81       	ldd	r24, Y+4	; 0x04
     d36:	9d 81       	ldd	r25, Y+5	; 0x05
     d38:	28 23       	and	r18, r24
     d3a:	39 23       	and	r19, r25
     d3c:	8c 81       	ldd	r24, Y+4	; 0x04
     d3e:	9d 81       	ldd	r25, Y+5	; 0x05
     d40:	28 17       	cp	r18, r24
     d42:	39 07       	cpc	r19, r25
     d44:	11 f4       	brne	.+4      	; 0xd4a <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
     d46:	81 e0       	ldi	r24, 0x01	; 1
     d48:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
     d4a:	89 81       	ldd	r24, Y+1	; 0x01
}
     d4c:	26 96       	adiw	r28, 0x06	; 6
     d4e:	0f b6       	in	r0, 0x3f	; 63
     d50:	f8 94       	cli
     d52:	de bf       	out	0x3e, r29	; 62
     d54:	0f be       	out	0x3f, r0	; 63
     d56:	cd bf       	out	0x3d, r28	; 61
     d58:	cf 91       	pop	r28
     d5a:	df 91       	pop	r29
     d5c:	08 95       	ret

00000d5e <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     d5e:	df 93       	push	r29
     d60:	cf 93       	push	r28
     d62:	00 d0       	rcall	.+0      	; 0xd64 <pvPortMalloc+0x6>
     d64:	00 d0       	rcall	.+0      	; 0xd66 <pvPortMalloc+0x8>
     d66:	cd b7       	in	r28, 0x3d	; 61
     d68:	de b7       	in	r29, 0x3e	; 62
     d6a:	9c 83       	std	Y+4, r25	; 0x04
     d6c:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
     d6e:	1a 82       	std	Y+2, r1	; 0x02
     d70:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     d72:	0e 94 d1 15 	call	0x2ba2	; 0x2ba2 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     d76:	80 91 76 00 	lds	r24, 0x0076
     d7a:	90 91 77 00 	lds	r25, 0x0077
     d7e:	00 97       	sbiw	r24, 0x00	; 0
     d80:	31 f4       	brne	.+12     	; 0xd8e <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     d82:	89 e7       	ldi	r24, 0x79	; 121
     d84:	90 e0       	ldi	r25, 0x00	; 0
     d86:	90 93 77 00 	sts	0x0077, r25
     d8a:	80 93 76 00 	sts	0x0076, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     d8e:	80 91 74 00 	lds	r24, 0x0074
     d92:	90 91 75 00 	lds	r25, 0x0075
     d96:	2b 81       	ldd	r18, Y+3	; 0x03
     d98:	3c 81       	ldd	r19, Y+4	; 0x04
     d9a:	82 0f       	add	r24, r18
     d9c:	93 1f       	adc	r25, r19
     d9e:	22 e0       	ldi	r18, 0x02	; 2
     da0:	87 35       	cpi	r24, 0x57	; 87
     da2:	92 07       	cpc	r25, r18
     da4:	38 f5       	brcc	.+78     	; 0xdf4 <pvPortMalloc+0x96>
     da6:	20 91 74 00 	lds	r18, 0x0074
     daa:	30 91 75 00 	lds	r19, 0x0075
     dae:	8b 81       	ldd	r24, Y+3	; 0x03
     db0:	9c 81       	ldd	r25, Y+4	; 0x04
     db2:	28 0f       	add	r18, r24
     db4:	39 1f       	adc	r19, r25
     db6:	80 91 74 00 	lds	r24, 0x0074
     dba:	90 91 75 00 	lds	r25, 0x0075
     dbe:	82 17       	cp	r24, r18
     dc0:	93 07       	cpc	r25, r19
     dc2:	c0 f4       	brcc	.+48     	; 0xdf4 <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     dc4:	20 91 76 00 	lds	r18, 0x0076
     dc8:	30 91 77 00 	lds	r19, 0x0077
     dcc:	80 91 74 00 	lds	r24, 0x0074
     dd0:	90 91 75 00 	lds	r25, 0x0075
     dd4:	82 0f       	add	r24, r18
     dd6:	93 1f       	adc	r25, r19
     dd8:	9a 83       	std	Y+2, r25	; 0x02
     dda:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
     ddc:	20 91 74 00 	lds	r18, 0x0074
     de0:	30 91 75 00 	lds	r19, 0x0075
     de4:	8b 81       	ldd	r24, Y+3	; 0x03
     de6:	9c 81       	ldd	r25, Y+4	; 0x04
     de8:	82 0f       	add	r24, r18
     dea:	93 1f       	adc	r25, r19
     dec:	90 93 75 00 	sts	0x0075, r25
     df0:	80 93 74 00 	sts	0x0074, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     df4:	0e 94 dd 15 	call	0x2bba	; 0x2bba <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
     df8:	89 81       	ldd	r24, Y+1	; 0x01
     dfa:	9a 81       	ldd	r25, Y+2	; 0x02
}
     dfc:	0f 90       	pop	r0
     dfe:	0f 90       	pop	r0
     e00:	0f 90       	pop	r0
     e02:	0f 90       	pop	r0
     e04:	cf 91       	pop	r28
     e06:	df 91       	pop	r29
     e08:	08 95       	ret

00000e0a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     e0a:	df 93       	push	r29
     e0c:	cf 93       	push	r28
     e0e:	00 d0       	rcall	.+0      	; 0xe10 <vPortFree+0x6>
     e10:	cd b7       	in	r28, 0x3d	; 61
     e12:	de b7       	in	r29, 0x3e	; 62
     e14:	9a 83       	std	Y+2, r25	; 0x02
     e16:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
     e18:	0f 90       	pop	r0
     e1a:	0f 90       	pop	r0
     e1c:	cf 91       	pop	r28
     e1e:	df 91       	pop	r29
     e20:	08 95       	ret

00000e22 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     e22:	df 93       	push	r29
     e24:	cf 93       	push	r28
     e26:	cd b7       	in	r28, 0x3d	; 61
     e28:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     e2a:	10 92 75 00 	sts	0x0075, r1
     e2e:	10 92 74 00 	sts	0x0074, r1
}
     e32:	cf 91       	pop	r28
     e34:	df 91       	pop	r29
     e36:	08 95       	ret

00000e38 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     e38:	df 93       	push	r29
     e3a:	cf 93       	push	r28
     e3c:	cd b7       	in	r28, 0x3d	; 61
     e3e:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     e40:	20 91 74 00 	lds	r18, 0x0074
     e44:	30 91 75 00 	lds	r19, 0x0075
     e48:	87 e5       	ldi	r24, 0x57	; 87
     e4a:	92 e0       	ldi	r25, 0x02	; 2
     e4c:	82 1b       	sub	r24, r18
     e4e:	93 0b       	sbc	r25, r19
}
     e50:	cf 91       	pop	r28
     e52:	df 91       	pop	r29
     e54:	08 95       	ret

00000e56 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     e56:	df 93       	push	r29
     e58:	cf 93       	push	r28
     e5a:	00 d0       	rcall	.+0      	; 0xe5c <vListInitialise+0x6>
     e5c:	cd b7       	in	r28, 0x3d	; 61
     e5e:	de b7       	in	r29, 0x3e	; 62
     e60:	9a 83       	std	Y+2, r25	; 0x02
     e62:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     e64:	89 81       	ldd	r24, Y+1	; 0x01
     e66:	9a 81       	ldd	r25, Y+2	; 0x02
     e68:	03 96       	adiw	r24, 0x03	; 3
     e6a:	e9 81       	ldd	r30, Y+1	; 0x01
     e6c:	fa 81       	ldd	r31, Y+2	; 0x02
     e6e:	92 83       	std	Z+2, r25	; 0x02
     e70:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     e72:	e9 81       	ldd	r30, Y+1	; 0x01
     e74:	fa 81       	ldd	r31, Y+2	; 0x02
     e76:	8f ef       	ldi	r24, 0xFF	; 255
     e78:	9f ef       	ldi	r25, 0xFF	; 255
     e7a:	94 83       	std	Z+4, r25	; 0x04
     e7c:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     e7e:	89 81       	ldd	r24, Y+1	; 0x01
     e80:	9a 81       	ldd	r25, Y+2	; 0x02
     e82:	03 96       	adiw	r24, 0x03	; 3
     e84:	e9 81       	ldd	r30, Y+1	; 0x01
     e86:	fa 81       	ldd	r31, Y+2	; 0x02
     e88:	96 83       	std	Z+6, r25	; 0x06
     e8a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     e8c:	89 81       	ldd	r24, Y+1	; 0x01
     e8e:	9a 81       	ldd	r25, Y+2	; 0x02
     e90:	03 96       	adiw	r24, 0x03	; 3
     e92:	e9 81       	ldd	r30, Y+1	; 0x01
     e94:	fa 81       	ldd	r31, Y+2	; 0x02
     e96:	90 87       	std	Z+8, r25	; 0x08
     e98:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     e9a:	e9 81       	ldd	r30, Y+1	; 0x01
     e9c:	fa 81       	ldd	r31, Y+2	; 0x02
     e9e:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     ea0:	0f 90       	pop	r0
     ea2:	0f 90       	pop	r0
     ea4:	cf 91       	pop	r28
     ea6:	df 91       	pop	r29
     ea8:	08 95       	ret

00000eaa <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
     eaa:	df 93       	push	r29
     eac:	cf 93       	push	r28
     eae:	00 d0       	rcall	.+0      	; 0xeb0 <vListInitialiseItem+0x6>
     eb0:	cd b7       	in	r28, 0x3d	; 61
     eb2:	de b7       	in	r29, 0x3e	; 62
     eb4:	9a 83       	std	Y+2, r25	; 0x02
     eb6:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
     eb8:	e9 81       	ldd	r30, Y+1	; 0x01
     eba:	fa 81       	ldd	r31, Y+2	; 0x02
     ebc:	11 86       	std	Z+9, r1	; 0x09
     ebe:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     ec0:	0f 90       	pop	r0
     ec2:	0f 90       	pop	r0
     ec4:	cf 91       	pop	r28
     ec6:	df 91       	pop	r29
     ec8:	08 95       	ret

00000eca <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     eca:	df 93       	push	r29
     ecc:	cf 93       	push	r28
     ece:	00 d0       	rcall	.+0      	; 0xed0 <vListInsertEnd+0x6>
     ed0:	00 d0       	rcall	.+0      	; 0xed2 <vListInsertEnd+0x8>
     ed2:	00 d0       	rcall	.+0      	; 0xed4 <vListInsertEnd+0xa>
     ed4:	cd b7       	in	r28, 0x3d	; 61
     ed6:	de b7       	in	r29, 0x3e	; 62
     ed8:	9c 83       	std	Y+4, r25	; 0x04
     eda:	8b 83       	std	Y+3, r24	; 0x03
     edc:	7e 83       	std	Y+6, r23	; 0x06
     ede:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
     ee0:	eb 81       	ldd	r30, Y+3	; 0x03
     ee2:	fc 81       	ldd	r31, Y+4	; 0x04
     ee4:	81 81       	ldd	r24, Z+1	; 0x01
     ee6:	92 81       	ldd	r25, Z+2	; 0x02
     ee8:	9a 83       	std	Y+2, r25	; 0x02
     eea:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     eec:	ed 81       	ldd	r30, Y+5	; 0x05
     eee:	fe 81       	ldd	r31, Y+6	; 0x06
     ef0:	89 81       	ldd	r24, Y+1	; 0x01
     ef2:	9a 81       	ldd	r25, Y+2	; 0x02
     ef4:	93 83       	std	Z+3, r25	; 0x03
     ef6:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     ef8:	e9 81       	ldd	r30, Y+1	; 0x01
     efa:	fa 81       	ldd	r31, Y+2	; 0x02
     efc:	84 81       	ldd	r24, Z+4	; 0x04
     efe:	95 81       	ldd	r25, Z+5	; 0x05
     f00:	ed 81       	ldd	r30, Y+5	; 0x05
     f02:	fe 81       	ldd	r31, Y+6	; 0x06
     f04:	95 83       	std	Z+5, r25	; 0x05
     f06:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     f08:	e9 81       	ldd	r30, Y+1	; 0x01
     f0a:	fa 81       	ldd	r31, Y+2	; 0x02
     f0c:	04 80       	ldd	r0, Z+4	; 0x04
     f0e:	f5 81       	ldd	r31, Z+5	; 0x05
     f10:	e0 2d       	mov	r30, r0
     f12:	8d 81       	ldd	r24, Y+5	; 0x05
     f14:	9e 81       	ldd	r25, Y+6	; 0x06
     f16:	93 83       	std	Z+3, r25	; 0x03
     f18:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
     f1a:	e9 81       	ldd	r30, Y+1	; 0x01
     f1c:	fa 81       	ldd	r31, Y+2	; 0x02
     f1e:	8d 81       	ldd	r24, Y+5	; 0x05
     f20:	9e 81       	ldd	r25, Y+6	; 0x06
     f22:	95 83       	std	Z+5, r25	; 0x05
     f24:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
     f26:	ed 81       	ldd	r30, Y+5	; 0x05
     f28:	fe 81       	ldd	r31, Y+6	; 0x06
     f2a:	8b 81       	ldd	r24, Y+3	; 0x03
     f2c:	9c 81       	ldd	r25, Y+4	; 0x04
     f2e:	91 87       	std	Z+9, r25	; 0x09
     f30:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     f32:	eb 81       	ldd	r30, Y+3	; 0x03
     f34:	fc 81       	ldd	r31, Y+4	; 0x04
     f36:	80 81       	ld	r24, Z
     f38:	8f 5f       	subi	r24, 0xFF	; 255
     f3a:	eb 81       	ldd	r30, Y+3	; 0x03
     f3c:	fc 81       	ldd	r31, Y+4	; 0x04
     f3e:	80 83       	st	Z, r24
}
     f40:	26 96       	adiw	r28, 0x06	; 6
     f42:	0f b6       	in	r0, 0x3f	; 63
     f44:	f8 94       	cli
     f46:	de bf       	out	0x3e, r29	; 62
     f48:	0f be       	out	0x3f, r0	; 63
     f4a:	cd bf       	out	0x3d, r28	; 61
     f4c:	cf 91       	pop	r28
     f4e:	df 91       	pop	r29
     f50:	08 95       	ret

00000f52 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     f52:	df 93       	push	r29
     f54:	cf 93       	push	r28
     f56:	cd b7       	in	r28, 0x3d	; 61
     f58:	de b7       	in	r29, 0x3e	; 62
     f5a:	28 97       	sbiw	r28, 0x08	; 8
     f5c:	0f b6       	in	r0, 0x3f	; 63
     f5e:	f8 94       	cli
     f60:	de bf       	out	0x3e, r29	; 62
     f62:	0f be       	out	0x3f, r0	; 63
     f64:	cd bf       	out	0x3d, r28	; 61
     f66:	9e 83       	std	Y+6, r25	; 0x06
     f68:	8d 83       	std	Y+5, r24	; 0x05
     f6a:	78 87       	std	Y+8, r23	; 0x08
     f6c:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     f6e:	ef 81       	ldd	r30, Y+7	; 0x07
     f70:	f8 85       	ldd	r31, Y+8	; 0x08
     f72:	80 81       	ld	r24, Z
     f74:	91 81       	ldd	r25, Z+1	; 0x01
     f76:	9a 83       	std	Y+2, r25	; 0x02
     f78:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     f7a:	89 81       	ldd	r24, Y+1	; 0x01
     f7c:	9a 81       	ldd	r25, Y+2	; 0x02
     f7e:	2f ef       	ldi	r18, 0xFF	; 255
     f80:	8f 3f       	cpi	r24, 0xFF	; 255
     f82:	92 07       	cpc	r25, r18
     f84:	39 f4       	brne	.+14     	; 0xf94 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     f86:	ed 81       	ldd	r30, Y+5	; 0x05
     f88:	fe 81       	ldd	r31, Y+6	; 0x06
     f8a:	87 81       	ldd	r24, Z+7	; 0x07
     f8c:	90 85       	ldd	r25, Z+8	; 0x08
     f8e:	9c 83       	std	Y+4, r25	; 0x04
     f90:	8b 83       	std	Y+3, r24	; 0x03
     f92:	18 c0       	rjmp	.+48     	; 0xfc4 <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     f94:	8d 81       	ldd	r24, Y+5	; 0x05
     f96:	9e 81       	ldd	r25, Y+6	; 0x06
     f98:	03 96       	adiw	r24, 0x03	; 3
     f9a:	9c 83       	std	Y+4, r25	; 0x04
     f9c:	8b 83       	std	Y+3, r24	; 0x03
     f9e:	06 c0       	rjmp	.+12     	; 0xfac <vListInsert+0x5a>
     fa0:	eb 81       	ldd	r30, Y+3	; 0x03
     fa2:	fc 81       	ldd	r31, Y+4	; 0x04
     fa4:	82 81       	ldd	r24, Z+2	; 0x02
     fa6:	93 81       	ldd	r25, Z+3	; 0x03
     fa8:	9c 83       	std	Y+4, r25	; 0x04
     faa:	8b 83       	std	Y+3, r24	; 0x03
     fac:	eb 81       	ldd	r30, Y+3	; 0x03
     fae:	fc 81       	ldd	r31, Y+4	; 0x04
     fb0:	02 80       	ldd	r0, Z+2	; 0x02
     fb2:	f3 81       	ldd	r31, Z+3	; 0x03
     fb4:	e0 2d       	mov	r30, r0
     fb6:	20 81       	ld	r18, Z
     fb8:	31 81       	ldd	r19, Z+1	; 0x01
     fba:	89 81       	ldd	r24, Y+1	; 0x01
     fbc:	9a 81       	ldd	r25, Y+2	; 0x02
     fbe:	82 17       	cp	r24, r18
     fc0:	93 07       	cpc	r25, r19
     fc2:	70 f7       	brcc	.-36     	; 0xfa0 <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     fc4:	eb 81       	ldd	r30, Y+3	; 0x03
     fc6:	fc 81       	ldd	r31, Y+4	; 0x04
     fc8:	82 81       	ldd	r24, Z+2	; 0x02
     fca:	93 81       	ldd	r25, Z+3	; 0x03
     fcc:	ef 81       	ldd	r30, Y+7	; 0x07
     fce:	f8 85       	ldd	r31, Y+8	; 0x08
     fd0:	93 83       	std	Z+3, r25	; 0x03
     fd2:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     fd4:	ef 81       	ldd	r30, Y+7	; 0x07
     fd6:	f8 85       	ldd	r31, Y+8	; 0x08
     fd8:	02 80       	ldd	r0, Z+2	; 0x02
     fda:	f3 81       	ldd	r31, Z+3	; 0x03
     fdc:	e0 2d       	mov	r30, r0
     fde:	8f 81       	ldd	r24, Y+7	; 0x07
     fe0:	98 85       	ldd	r25, Y+8	; 0x08
     fe2:	95 83       	std	Z+5, r25	; 0x05
     fe4:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     fe6:	ef 81       	ldd	r30, Y+7	; 0x07
     fe8:	f8 85       	ldd	r31, Y+8	; 0x08
     fea:	8b 81       	ldd	r24, Y+3	; 0x03
     fec:	9c 81       	ldd	r25, Y+4	; 0x04
     fee:	95 83       	std	Z+5, r25	; 0x05
     ff0:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
     ff2:	eb 81       	ldd	r30, Y+3	; 0x03
     ff4:	fc 81       	ldd	r31, Y+4	; 0x04
     ff6:	8f 81       	ldd	r24, Y+7	; 0x07
     ff8:	98 85       	ldd	r25, Y+8	; 0x08
     ffa:	93 83       	std	Z+3, r25	; 0x03
     ffc:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
     ffe:	ef 81       	ldd	r30, Y+7	; 0x07
    1000:	f8 85       	ldd	r31, Y+8	; 0x08
    1002:	8d 81       	ldd	r24, Y+5	; 0x05
    1004:	9e 81       	ldd	r25, Y+6	; 0x06
    1006:	91 87       	std	Z+9, r25	; 0x09
    1008:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    100a:	ed 81       	ldd	r30, Y+5	; 0x05
    100c:	fe 81       	ldd	r31, Y+6	; 0x06
    100e:	80 81       	ld	r24, Z
    1010:	8f 5f       	subi	r24, 0xFF	; 255
    1012:	ed 81       	ldd	r30, Y+5	; 0x05
    1014:	fe 81       	ldd	r31, Y+6	; 0x06
    1016:	80 83       	st	Z, r24
}
    1018:	28 96       	adiw	r28, 0x08	; 8
    101a:	0f b6       	in	r0, 0x3f	; 63
    101c:	f8 94       	cli
    101e:	de bf       	out	0x3e, r29	; 62
    1020:	0f be       	out	0x3f, r0	; 63
    1022:	cd bf       	out	0x3d, r28	; 61
    1024:	cf 91       	pop	r28
    1026:	df 91       	pop	r29
    1028:	08 95       	ret

0000102a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    102a:	df 93       	push	r29
    102c:	cf 93       	push	r28
    102e:	00 d0       	rcall	.+0      	; 0x1030 <uxListRemove+0x6>
    1030:	00 d0       	rcall	.+0      	; 0x1032 <uxListRemove+0x8>
    1032:	cd b7       	in	r28, 0x3d	; 61
    1034:	de b7       	in	r29, 0x3e	; 62
    1036:	9c 83       	std	Y+4, r25	; 0x04
    1038:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    103a:	eb 81       	ldd	r30, Y+3	; 0x03
    103c:	fc 81       	ldd	r31, Y+4	; 0x04
    103e:	80 85       	ldd	r24, Z+8	; 0x08
    1040:	91 85       	ldd	r25, Z+9	; 0x09
    1042:	9a 83       	std	Y+2, r25	; 0x02
    1044:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1046:	eb 81       	ldd	r30, Y+3	; 0x03
    1048:	fc 81       	ldd	r31, Y+4	; 0x04
    104a:	a2 81       	ldd	r26, Z+2	; 0x02
    104c:	b3 81       	ldd	r27, Z+3	; 0x03
    104e:	eb 81       	ldd	r30, Y+3	; 0x03
    1050:	fc 81       	ldd	r31, Y+4	; 0x04
    1052:	84 81       	ldd	r24, Z+4	; 0x04
    1054:	95 81       	ldd	r25, Z+5	; 0x05
    1056:	15 96       	adiw	r26, 0x05	; 5
    1058:	9c 93       	st	X, r25
    105a:	8e 93       	st	-X, r24
    105c:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    105e:	eb 81       	ldd	r30, Y+3	; 0x03
    1060:	fc 81       	ldd	r31, Y+4	; 0x04
    1062:	a4 81       	ldd	r26, Z+4	; 0x04
    1064:	b5 81       	ldd	r27, Z+5	; 0x05
    1066:	eb 81       	ldd	r30, Y+3	; 0x03
    1068:	fc 81       	ldd	r31, Y+4	; 0x04
    106a:	82 81       	ldd	r24, Z+2	; 0x02
    106c:	93 81       	ldd	r25, Z+3	; 0x03
    106e:	13 96       	adiw	r26, 0x03	; 3
    1070:	9c 93       	st	X, r25
    1072:	8e 93       	st	-X, r24
    1074:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1076:	e9 81       	ldd	r30, Y+1	; 0x01
    1078:	fa 81       	ldd	r31, Y+2	; 0x02
    107a:	21 81       	ldd	r18, Z+1	; 0x01
    107c:	32 81       	ldd	r19, Z+2	; 0x02
    107e:	8b 81       	ldd	r24, Y+3	; 0x03
    1080:	9c 81       	ldd	r25, Y+4	; 0x04
    1082:	28 17       	cp	r18, r24
    1084:	39 07       	cpc	r19, r25
    1086:	41 f4       	brne	.+16     	; 0x1098 <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1088:	eb 81       	ldd	r30, Y+3	; 0x03
    108a:	fc 81       	ldd	r31, Y+4	; 0x04
    108c:	84 81       	ldd	r24, Z+4	; 0x04
    108e:	95 81       	ldd	r25, Z+5	; 0x05
    1090:	e9 81       	ldd	r30, Y+1	; 0x01
    1092:	fa 81       	ldd	r31, Y+2	; 0x02
    1094:	92 83       	std	Z+2, r25	; 0x02
    1096:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    1098:	eb 81       	ldd	r30, Y+3	; 0x03
    109a:	fc 81       	ldd	r31, Y+4	; 0x04
    109c:	11 86       	std	Z+9, r1	; 0x09
    109e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    10a0:	e9 81       	ldd	r30, Y+1	; 0x01
    10a2:	fa 81       	ldd	r31, Y+2	; 0x02
    10a4:	80 81       	ld	r24, Z
    10a6:	81 50       	subi	r24, 0x01	; 1
    10a8:	e9 81       	ldd	r30, Y+1	; 0x01
    10aa:	fa 81       	ldd	r31, Y+2	; 0x02
    10ac:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    10ae:	e9 81       	ldd	r30, Y+1	; 0x01
    10b0:	fa 81       	ldd	r31, Y+2	; 0x02
    10b2:	80 81       	ld	r24, Z
}
    10b4:	0f 90       	pop	r0
    10b6:	0f 90       	pop	r0
    10b8:	0f 90       	pop	r0
    10ba:	0f 90       	pop	r0
    10bc:	cf 91       	pop	r28
    10be:	df 91       	pop	r29
    10c0:	08 95       	ret

000010c2 <LED_1>:

// @ xSemaphoreTake()
// Setting xTicksToWait to portMAX_DELAY will cause the task to wait indefinitely
// (without timing out) provided INCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h.
void LED_1(void * pvParameters)
{
    10c2:	df 93       	push	r29
    10c4:	cf 93       	push	r28
    10c6:	00 d0       	rcall	.+0      	; 0x10c8 <LED_1+0x6>
    10c8:	0f 92       	push	r0
    10ca:	cd b7       	in	r28, 0x3d	; 61
    10cc:	de b7       	in	r29, 0x3e	; 62
    10ce:	9b 83       	std	Y+3, r25	; 0x03
    10d0:	8a 83       	std	Y+2, r24	; 0x02

	u8 pushbutton;
	while(1)
	{
		xSemaphoreTake(xSemaphore,10);//10 افضل حاول 10 مرات عشان لو السيميفورمعمله تييك من حاجه تانيه
    10d2:	80 91 2e 03 	lds	r24, 0x032E
    10d6:	90 91 2f 03 	lds	r25, 0x032F
    10da:	6a e0       	ldi	r22, 0x0A	; 10
    10dc:	70 e0       	ldi	r23, 0x00	; 0
    10de:	0e 94 d1 0e 	call	0x1da2	; 0x1da2 <xQueueSemaphoreTake>
		DIO_GET_PIN_VALUE(GROUP_C,PIN0,&pushbutton);
    10e2:	82 e0       	ldi	r24, 0x02	; 2
    10e4:	60 e0       	ldi	r22, 0x00	; 0
    10e6:	9e 01       	movw	r18, r28
    10e8:	2f 5f       	subi	r18, 0xFF	; 255
    10ea:	3f 4f       	sbci	r19, 0xFF	; 255
    10ec:	a9 01       	movw	r20, r18
    10ee:	0e 94 3f 02 	call	0x47e	; 0x47e <DIO_GET_PIN_VALUE>

		if(pushbutton == DIO_LOW)
    10f2:	89 81       	ldd	r24, Y+1	; 0x01
    10f4:	88 23       	and	r24, r24
    10f6:	59 f4       	brne	.+22     	; 0x110e <LED_1+0x4c>
		{
			xSemaphoreGive(xSemaphore);
    10f8:	80 91 2e 03 	lds	r24, 0x032E
    10fc:	90 91 2f 03 	lds	r25, 0x032F
    1100:	60 e0       	ldi	r22, 0x00	; 0
    1102:	70 e0       	ldi	r23, 0x00	; 0
    1104:	40 e0       	ldi	r20, 0x00	; 0
    1106:	50 e0       	ldi	r21, 0x00	; 0
    1108:	20 e0       	ldi	r18, 0x00	; 0
    110a:	0e 94 d1 0c 	call	0x19a2	; 0x19a2 <xQueueGenericSend>
		}
		vTaskDelay(200);
    110e:	88 ec       	ldi	r24, 0xC8	; 200
    1110:	90 e0       	ldi	r25, 0x00	; 0
    1112:	0e 94 71 15 	call	0x2ae2	; 0x2ae2 <vTaskDelay>
    1116:	dd cf       	rjmp	.-70     	; 0x10d2 <LED_1+0x10>

00001118 <LED_2>:
	}
}

void LED_2(void * pvParameters)
{
    1118:	df 93       	push	r29
    111a:	cf 93       	push	r28
    111c:	00 d0       	rcall	.+0      	; 0x111e <LED_2+0x6>
    111e:	cd b7       	in	r28, 0x3d	; 61
    1120:	de b7       	in	r29, 0x3e	; 62
    1122:	9a 83       	std	Y+2, r25	; 0x02
    1124:	89 83       	std	Y+1, r24	; 0x01
	static u8 state_2 = 0;
	while(1)
	{
		xSemaphoreTake(xSemaphore,portMAX_DELAY);
    1126:	80 91 2e 03 	lds	r24, 0x032E
    112a:	90 91 2f 03 	lds	r25, 0x032F
    112e:	6f ef       	ldi	r22, 0xFF	; 255
    1130:	7f ef       	ldi	r23, 0xFF	; 255
    1132:	0e 94 d1 0e 	call	0x1da2	; 0x1da2 <xQueueSemaphoreTake>
		DIO_SET_PIN_VALUE(GROUP_C,PIN1,toogle_bit(state_2,0));
    1136:	90 91 d0 02 	lds	r25, 0x02D0
    113a:	81 e0       	ldi	r24, 0x01	; 1
    113c:	89 27       	eor	r24, r25
    113e:	80 93 d0 02 	sts	0x02D0, r24
    1142:	90 91 d0 02 	lds	r25, 0x02D0
    1146:	82 e0       	ldi	r24, 0x02	; 2
    1148:	61 e0       	ldi	r22, 0x01	; 1
    114a:	49 2f       	mov	r20, r25
    114c:	0e 94 49 00 	call	0x92	; 0x92 <DIO_SET_PIN_VALUE>
//			LCD_u8Write("LED2ON ",8,0);
//		}else
//		{
//			LCD_u8Write("LED2OFF",8,0);
//		}
		vTaskDelay(1000);
    1150:	88 ee       	ldi	r24, 0xE8	; 232
    1152:	93 e0       	ldi	r25, 0x03	; 3
    1154:	0e 94 71 15 	call	0x2ae2	; 0x2ae2 <vTaskDelay>
    1158:	e6 cf       	rjmp	.-52     	; 0x1126 <LED_2+0xe>

0000115a <main>:
	}
}

void main(void)
{
    115a:	ef 92       	push	r14
    115c:	ff 92       	push	r15
    115e:	0f 93       	push	r16
    1160:	df 93       	push	r29
    1162:	cf 93       	push	r28
    1164:	cd b7       	in	r28, 0x3d	; 61
    1166:	de b7       	in	r29, 0x3e	; 62
	DIO_SET_PIN_DIRECTION(GROUP_C,PIN0,DIO_INPUT);
    1168:	82 e0       	ldi	r24, 0x02	; 2
    116a:	60 e0       	ldi	r22, 0x00	; 0
    116c:	40 e0       	ldi	r20, 0x00	; 0
    116e:	0e 94 44 01 	call	0x288	; 0x288 <DIO_SET_PIN_DIRECTION>
		DIO_SET_PIN_VALUE(GROUP_C,PIN0,DIO_OUTPUT);
    1172:	82 e0       	ldi	r24, 0x02	; 2
    1174:	60 e0       	ldi	r22, 0x00	; 0
    1176:	41 e0       	ldi	r20, 0x01	; 1
    1178:	0e 94 49 00 	call	0x92	; 0x92 <DIO_SET_PIN_VALUE>

		DIO_SET_PIN_DIRECTION(GROUP_C,PIN1,DIO_OUTPUT);
    117c:	82 e0       	ldi	r24, 0x02	; 2
    117e:	61 e0       	ldi	r22, 0x01	; 1
    1180:	41 e0       	ldi	r20, 0x01	; 1
    1182:	0e 94 44 01 	call	0x288	; 0x288 <DIO_SET_PIN_DIRECTION>
	// LCD Pins
	

//	LCD_void_Initialize();

	xSemaphore = xSemaphoreCreateBinary();
    1186:	81 e0       	ldi	r24, 0x01	; 1
    1188:	60 e0       	ldi	r22, 0x00	; 0
    118a:	43 e0       	ldi	r20, 0x03	; 3
    118c:	0e 94 45 0c 	call	0x188a	; 0x188a <xQueueGenericCreate>
    1190:	90 93 2f 03 	sts	0x032F, r25
    1194:	80 93 2e 03 	sts	0x032E, r24


	xTaskCreate(LED_1,"Task_1",150,NULL,1,NULL);
    1198:	81 e6       	ldi	r24, 0x61	; 97
    119a:	98 e0       	ldi	r25, 0x08	; 8
    119c:	20 e6       	ldi	r18, 0x60	; 96
    119e:	30 e0       	ldi	r19, 0x00	; 0
    11a0:	b9 01       	movw	r22, r18
    11a2:	46 e9       	ldi	r20, 0x96	; 150
    11a4:	50 e0       	ldi	r21, 0x00	; 0
    11a6:	20 e0       	ldi	r18, 0x00	; 0
    11a8:	30 e0       	ldi	r19, 0x00	; 0
    11aa:	01 e0       	ldi	r16, 0x01	; 1
    11ac:	ee 24       	eor	r14, r14
    11ae:	ff 24       	eor	r15, r15
    11b0:	0e 94 e1 12 	call	0x25c2	; 0x25c2 <xTaskCreate>
	xTaskCreate(LED_2,"Task_2",150,NULL,2,NULL);
    11b4:	8c e8       	ldi	r24, 0x8C	; 140
    11b6:	98 e0       	ldi	r25, 0x08	; 8
    11b8:	27 e6       	ldi	r18, 0x67	; 103
    11ba:	30 e0       	ldi	r19, 0x00	; 0
    11bc:	b9 01       	movw	r22, r18
    11be:	46 e9       	ldi	r20, 0x96	; 150
    11c0:	50 e0       	ldi	r21, 0x00	; 0
    11c2:	20 e0       	ldi	r18, 0x00	; 0
    11c4:	30 e0       	ldi	r19, 0x00	; 0
    11c6:	02 e0       	ldi	r16, 0x02	; 2
    11c8:	ee 24       	eor	r14, r14
    11ca:	ff 24       	eor	r15, r15
    11cc:	0e 94 e1 12 	call	0x25c2	; 0x25c2 <xTaskCreate>


	vTaskStartScheduler();
    11d0:	0e 94 93 15 	call	0x2b26	; 0x2b26 <vTaskStartScheduler>
    11d4:	ff cf       	rjmp	.-2      	; 0x11d4 <main+0x7a>

000011d6 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    11d6:	df 93       	push	r29
    11d8:	cf 93       	push	r28
    11da:	cd b7       	in	r28, 0x3d	; 61
    11dc:	de b7       	in	r29, 0x3e	; 62
    11de:	28 97       	sbiw	r28, 0x08	; 8
    11e0:	0f b6       	in	r0, 0x3f	; 63
    11e2:	f8 94       	cli
    11e4:	de bf       	out	0x3e, r29	; 62
    11e6:	0f be       	out	0x3f, r0	; 63
    11e8:	cd bf       	out	0x3d, r28	; 61
    11ea:	9c 83       	std	Y+4, r25	; 0x04
    11ec:	8b 83       	std	Y+3, r24	; 0x03
    11ee:	7e 83       	std	Y+6, r23	; 0x06
    11f0:	6d 83       	std	Y+5, r22	; 0x05
    11f2:	58 87       	std	Y+8, r21	; 0x08
    11f4:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    11f6:	eb 81       	ldd	r30, Y+3	; 0x03
    11f8:	fc 81       	ldd	r31, Y+4	; 0x04
    11fa:	81 e1       	ldi	r24, 0x11	; 17
    11fc:	80 83       	st	Z, r24
	pxTopOfStack--;
    11fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1200:	9c 81       	ldd	r25, Y+4	; 0x04
    1202:	01 97       	sbiw	r24, 0x01	; 1
    1204:	9c 83       	std	Y+4, r25	; 0x04
    1206:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    1208:	eb 81       	ldd	r30, Y+3	; 0x03
    120a:	fc 81       	ldd	r31, Y+4	; 0x04
    120c:	82 e2       	ldi	r24, 0x22	; 34
    120e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1210:	8b 81       	ldd	r24, Y+3	; 0x03
    1212:	9c 81       	ldd	r25, Y+4	; 0x04
    1214:	01 97       	sbiw	r24, 0x01	; 1
    1216:	9c 83       	std	Y+4, r25	; 0x04
    1218:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    121a:	eb 81       	ldd	r30, Y+3	; 0x03
    121c:	fc 81       	ldd	r31, Y+4	; 0x04
    121e:	83 e3       	ldi	r24, 0x33	; 51
    1220:	80 83       	st	Z, r24
	pxTopOfStack--;
    1222:	8b 81       	ldd	r24, Y+3	; 0x03
    1224:	9c 81       	ldd	r25, Y+4	; 0x04
    1226:	01 97       	sbiw	r24, 0x01	; 1
    1228:	9c 83       	std	Y+4, r25	; 0x04
    122a:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    122c:	8d 81       	ldd	r24, Y+5	; 0x05
    122e:	9e 81       	ldd	r25, Y+6	; 0x06
    1230:	9a 83       	std	Y+2, r25	; 0x02
    1232:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1234:	89 81       	ldd	r24, Y+1	; 0x01
    1236:	eb 81       	ldd	r30, Y+3	; 0x03
    1238:	fc 81       	ldd	r31, Y+4	; 0x04
    123a:	80 83       	st	Z, r24
	pxTopOfStack--;
    123c:	8b 81       	ldd	r24, Y+3	; 0x03
    123e:	9c 81       	ldd	r25, Y+4	; 0x04
    1240:	01 97       	sbiw	r24, 0x01	; 1
    1242:	9c 83       	std	Y+4, r25	; 0x04
    1244:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1246:	89 81       	ldd	r24, Y+1	; 0x01
    1248:	9a 81       	ldd	r25, Y+2	; 0x02
    124a:	89 2f       	mov	r24, r25
    124c:	99 27       	eor	r25, r25
    124e:	9a 83       	std	Y+2, r25	; 0x02
    1250:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1252:	89 81       	ldd	r24, Y+1	; 0x01
    1254:	eb 81       	ldd	r30, Y+3	; 0x03
    1256:	fc 81       	ldd	r31, Y+4	; 0x04
    1258:	80 83       	st	Z, r24
	pxTopOfStack--;
    125a:	8b 81       	ldd	r24, Y+3	; 0x03
    125c:	9c 81       	ldd	r25, Y+4	; 0x04
    125e:	01 97       	sbiw	r24, 0x01	; 1
    1260:	9c 83       	std	Y+4, r25	; 0x04
    1262:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    1264:	eb 81       	ldd	r30, Y+3	; 0x03
    1266:	fc 81       	ldd	r31, Y+4	; 0x04
    1268:	10 82       	st	Z, r1
	pxTopOfStack--;
    126a:	8b 81       	ldd	r24, Y+3	; 0x03
    126c:	9c 81       	ldd	r25, Y+4	; 0x04
    126e:	01 97       	sbiw	r24, 0x01	; 1
    1270:	9c 83       	std	Y+4, r25	; 0x04
    1272:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1274:	eb 81       	ldd	r30, Y+3	; 0x03
    1276:	fc 81       	ldd	r31, Y+4	; 0x04
    1278:	80 e8       	ldi	r24, 0x80	; 128
    127a:	80 83       	st	Z, r24
	pxTopOfStack--;
    127c:	8b 81       	ldd	r24, Y+3	; 0x03
    127e:	9c 81       	ldd	r25, Y+4	; 0x04
    1280:	01 97       	sbiw	r24, 0x01	; 1
    1282:	9c 83       	std	Y+4, r25	; 0x04
    1284:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    1286:	eb 81       	ldd	r30, Y+3	; 0x03
    1288:	fc 81       	ldd	r31, Y+4	; 0x04
    128a:	10 82       	st	Z, r1
	pxTopOfStack--;
    128c:	8b 81       	ldd	r24, Y+3	; 0x03
    128e:	9c 81       	ldd	r25, Y+4	; 0x04
    1290:	01 97       	sbiw	r24, 0x01	; 1
    1292:	9c 83       	std	Y+4, r25	; 0x04
    1294:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    1296:	eb 81       	ldd	r30, Y+3	; 0x03
    1298:	fc 81       	ldd	r31, Y+4	; 0x04
    129a:	82 e0       	ldi	r24, 0x02	; 2
    129c:	80 83       	st	Z, r24
	pxTopOfStack--;
    129e:	8b 81       	ldd	r24, Y+3	; 0x03
    12a0:	9c 81       	ldd	r25, Y+4	; 0x04
    12a2:	01 97       	sbiw	r24, 0x01	; 1
    12a4:	9c 83       	std	Y+4, r25	; 0x04
    12a6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    12a8:	eb 81       	ldd	r30, Y+3	; 0x03
    12aa:	fc 81       	ldd	r31, Y+4	; 0x04
    12ac:	83 e0       	ldi	r24, 0x03	; 3
    12ae:	80 83       	st	Z, r24
	pxTopOfStack--;
    12b0:	8b 81       	ldd	r24, Y+3	; 0x03
    12b2:	9c 81       	ldd	r25, Y+4	; 0x04
    12b4:	01 97       	sbiw	r24, 0x01	; 1
    12b6:	9c 83       	std	Y+4, r25	; 0x04
    12b8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    12ba:	eb 81       	ldd	r30, Y+3	; 0x03
    12bc:	fc 81       	ldd	r31, Y+4	; 0x04
    12be:	84 e0       	ldi	r24, 0x04	; 4
    12c0:	80 83       	st	Z, r24
	pxTopOfStack--;
    12c2:	8b 81       	ldd	r24, Y+3	; 0x03
    12c4:	9c 81       	ldd	r25, Y+4	; 0x04
    12c6:	01 97       	sbiw	r24, 0x01	; 1
    12c8:	9c 83       	std	Y+4, r25	; 0x04
    12ca:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    12cc:	eb 81       	ldd	r30, Y+3	; 0x03
    12ce:	fc 81       	ldd	r31, Y+4	; 0x04
    12d0:	85 e0       	ldi	r24, 0x05	; 5
    12d2:	80 83       	st	Z, r24
	pxTopOfStack--;
    12d4:	8b 81       	ldd	r24, Y+3	; 0x03
    12d6:	9c 81       	ldd	r25, Y+4	; 0x04
    12d8:	01 97       	sbiw	r24, 0x01	; 1
    12da:	9c 83       	std	Y+4, r25	; 0x04
    12dc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    12de:	eb 81       	ldd	r30, Y+3	; 0x03
    12e0:	fc 81       	ldd	r31, Y+4	; 0x04
    12e2:	86 e0       	ldi	r24, 0x06	; 6
    12e4:	80 83       	st	Z, r24
	pxTopOfStack--;
    12e6:	8b 81       	ldd	r24, Y+3	; 0x03
    12e8:	9c 81       	ldd	r25, Y+4	; 0x04
    12ea:	01 97       	sbiw	r24, 0x01	; 1
    12ec:	9c 83       	std	Y+4, r25	; 0x04
    12ee:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    12f0:	eb 81       	ldd	r30, Y+3	; 0x03
    12f2:	fc 81       	ldd	r31, Y+4	; 0x04
    12f4:	87 e0       	ldi	r24, 0x07	; 7
    12f6:	80 83       	st	Z, r24
	pxTopOfStack--;
    12f8:	8b 81       	ldd	r24, Y+3	; 0x03
    12fa:	9c 81       	ldd	r25, Y+4	; 0x04
    12fc:	01 97       	sbiw	r24, 0x01	; 1
    12fe:	9c 83       	std	Y+4, r25	; 0x04
    1300:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    1302:	eb 81       	ldd	r30, Y+3	; 0x03
    1304:	fc 81       	ldd	r31, Y+4	; 0x04
    1306:	88 e0       	ldi	r24, 0x08	; 8
    1308:	80 83       	st	Z, r24
	pxTopOfStack--;
    130a:	8b 81       	ldd	r24, Y+3	; 0x03
    130c:	9c 81       	ldd	r25, Y+4	; 0x04
    130e:	01 97       	sbiw	r24, 0x01	; 1
    1310:	9c 83       	std	Y+4, r25	; 0x04
    1312:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    1314:	eb 81       	ldd	r30, Y+3	; 0x03
    1316:	fc 81       	ldd	r31, Y+4	; 0x04
    1318:	89 e0       	ldi	r24, 0x09	; 9
    131a:	80 83       	st	Z, r24
	pxTopOfStack--;
    131c:	8b 81       	ldd	r24, Y+3	; 0x03
    131e:	9c 81       	ldd	r25, Y+4	; 0x04
    1320:	01 97       	sbiw	r24, 0x01	; 1
    1322:	9c 83       	std	Y+4, r25	; 0x04
    1324:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    1326:	eb 81       	ldd	r30, Y+3	; 0x03
    1328:	fc 81       	ldd	r31, Y+4	; 0x04
    132a:	80 e1       	ldi	r24, 0x10	; 16
    132c:	80 83       	st	Z, r24
	pxTopOfStack--;
    132e:	8b 81       	ldd	r24, Y+3	; 0x03
    1330:	9c 81       	ldd	r25, Y+4	; 0x04
    1332:	01 97       	sbiw	r24, 0x01	; 1
    1334:	9c 83       	std	Y+4, r25	; 0x04
    1336:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    1338:	eb 81       	ldd	r30, Y+3	; 0x03
    133a:	fc 81       	ldd	r31, Y+4	; 0x04
    133c:	81 e1       	ldi	r24, 0x11	; 17
    133e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1340:	8b 81       	ldd	r24, Y+3	; 0x03
    1342:	9c 81       	ldd	r25, Y+4	; 0x04
    1344:	01 97       	sbiw	r24, 0x01	; 1
    1346:	9c 83       	std	Y+4, r25	; 0x04
    1348:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    134a:	eb 81       	ldd	r30, Y+3	; 0x03
    134c:	fc 81       	ldd	r31, Y+4	; 0x04
    134e:	82 e1       	ldi	r24, 0x12	; 18
    1350:	80 83       	st	Z, r24
	pxTopOfStack--;
    1352:	8b 81       	ldd	r24, Y+3	; 0x03
    1354:	9c 81       	ldd	r25, Y+4	; 0x04
    1356:	01 97       	sbiw	r24, 0x01	; 1
    1358:	9c 83       	std	Y+4, r25	; 0x04
    135a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    135c:	eb 81       	ldd	r30, Y+3	; 0x03
    135e:	fc 81       	ldd	r31, Y+4	; 0x04
    1360:	83 e1       	ldi	r24, 0x13	; 19
    1362:	80 83       	st	Z, r24
	pxTopOfStack--;
    1364:	8b 81       	ldd	r24, Y+3	; 0x03
    1366:	9c 81       	ldd	r25, Y+4	; 0x04
    1368:	01 97       	sbiw	r24, 0x01	; 1
    136a:	9c 83       	std	Y+4, r25	; 0x04
    136c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    136e:	eb 81       	ldd	r30, Y+3	; 0x03
    1370:	fc 81       	ldd	r31, Y+4	; 0x04
    1372:	84 e1       	ldi	r24, 0x14	; 20
    1374:	80 83       	st	Z, r24
	pxTopOfStack--;
    1376:	8b 81       	ldd	r24, Y+3	; 0x03
    1378:	9c 81       	ldd	r25, Y+4	; 0x04
    137a:	01 97       	sbiw	r24, 0x01	; 1
    137c:	9c 83       	std	Y+4, r25	; 0x04
    137e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    1380:	eb 81       	ldd	r30, Y+3	; 0x03
    1382:	fc 81       	ldd	r31, Y+4	; 0x04
    1384:	85 e1       	ldi	r24, 0x15	; 21
    1386:	80 83       	st	Z, r24
	pxTopOfStack--;
    1388:	8b 81       	ldd	r24, Y+3	; 0x03
    138a:	9c 81       	ldd	r25, Y+4	; 0x04
    138c:	01 97       	sbiw	r24, 0x01	; 1
    138e:	9c 83       	std	Y+4, r25	; 0x04
    1390:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    1392:	eb 81       	ldd	r30, Y+3	; 0x03
    1394:	fc 81       	ldd	r31, Y+4	; 0x04
    1396:	86 e1       	ldi	r24, 0x16	; 22
    1398:	80 83       	st	Z, r24
	pxTopOfStack--;
    139a:	8b 81       	ldd	r24, Y+3	; 0x03
    139c:	9c 81       	ldd	r25, Y+4	; 0x04
    139e:	01 97       	sbiw	r24, 0x01	; 1
    13a0:	9c 83       	std	Y+4, r25	; 0x04
    13a2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    13a4:	eb 81       	ldd	r30, Y+3	; 0x03
    13a6:	fc 81       	ldd	r31, Y+4	; 0x04
    13a8:	87 e1       	ldi	r24, 0x17	; 23
    13aa:	80 83       	st	Z, r24
	pxTopOfStack--;
    13ac:	8b 81       	ldd	r24, Y+3	; 0x03
    13ae:	9c 81       	ldd	r25, Y+4	; 0x04
    13b0:	01 97       	sbiw	r24, 0x01	; 1
    13b2:	9c 83       	std	Y+4, r25	; 0x04
    13b4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    13b6:	eb 81       	ldd	r30, Y+3	; 0x03
    13b8:	fc 81       	ldd	r31, Y+4	; 0x04
    13ba:	88 e1       	ldi	r24, 0x18	; 24
    13bc:	80 83       	st	Z, r24
	pxTopOfStack--;
    13be:	8b 81       	ldd	r24, Y+3	; 0x03
    13c0:	9c 81       	ldd	r25, Y+4	; 0x04
    13c2:	01 97       	sbiw	r24, 0x01	; 1
    13c4:	9c 83       	std	Y+4, r25	; 0x04
    13c6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    13c8:	eb 81       	ldd	r30, Y+3	; 0x03
    13ca:	fc 81       	ldd	r31, Y+4	; 0x04
    13cc:	89 e1       	ldi	r24, 0x19	; 25
    13ce:	80 83       	st	Z, r24
	pxTopOfStack--;
    13d0:	8b 81       	ldd	r24, Y+3	; 0x03
    13d2:	9c 81       	ldd	r25, Y+4	; 0x04
    13d4:	01 97       	sbiw	r24, 0x01	; 1
    13d6:	9c 83       	std	Y+4, r25	; 0x04
    13d8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    13da:	eb 81       	ldd	r30, Y+3	; 0x03
    13dc:	fc 81       	ldd	r31, Y+4	; 0x04
    13de:	80 e2       	ldi	r24, 0x20	; 32
    13e0:	80 83       	st	Z, r24
	pxTopOfStack--;
    13e2:	8b 81       	ldd	r24, Y+3	; 0x03
    13e4:	9c 81       	ldd	r25, Y+4	; 0x04
    13e6:	01 97       	sbiw	r24, 0x01	; 1
    13e8:	9c 83       	std	Y+4, r25	; 0x04
    13ea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    13ec:	eb 81       	ldd	r30, Y+3	; 0x03
    13ee:	fc 81       	ldd	r31, Y+4	; 0x04
    13f0:	81 e2       	ldi	r24, 0x21	; 33
    13f2:	80 83       	st	Z, r24
	pxTopOfStack--;
    13f4:	8b 81       	ldd	r24, Y+3	; 0x03
    13f6:	9c 81       	ldd	r25, Y+4	; 0x04
    13f8:	01 97       	sbiw	r24, 0x01	; 1
    13fa:	9c 83       	std	Y+4, r25	; 0x04
    13fc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    13fe:	eb 81       	ldd	r30, Y+3	; 0x03
    1400:	fc 81       	ldd	r31, Y+4	; 0x04
    1402:	82 e2       	ldi	r24, 0x22	; 34
    1404:	80 83       	st	Z, r24
	pxTopOfStack--;
    1406:	8b 81       	ldd	r24, Y+3	; 0x03
    1408:	9c 81       	ldd	r25, Y+4	; 0x04
    140a:	01 97       	sbiw	r24, 0x01	; 1
    140c:	9c 83       	std	Y+4, r25	; 0x04
    140e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    1410:	eb 81       	ldd	r30, Y+3	; 0x03
    1412:	fc 81       	ldd	r31, Y+4	; 0x04
    1414:	83 e2       	ldi	r24, 0x23	; 35
    1416:	80 83       	st	Z, r24
	pxTopOfStack--;
    1418:	8b 81       	ldd	r24, Y+3	; 0x03
    141a:	9c 81       	ldd	r25, Y+4	; 0x04
    141c:	01 97       	sbiw	r24, 0x01	; 1
    141e:	9c 83       	std	Y+4, r25	; 0x04
    1420:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    1422:	8f 81       	ldd	r24, Y+7	; 0x07
    1424:	98 85       	ldd	r25, Y+8	; 0x08
    1426:	9a 83       	std	Y+2, r25	; 0x02
    1428:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    142a:	89 81       	ldd	r24, Y+1	; 0x01
    142c:	eb 81       	ldd	r30, Y+3	; 0x03
    142e:	fc 81       	ldd	r31, Y+4	; 0x04
    1430:	80 83       	st	Z, r24
	pxTopOfStack--;
    1432:	8b 81       	ldd	r24, Y+3	; 0x03
    1434:	9c 81       	ldd	r25, Y+4	; 0x04
    1436:	01 97       	sbiw	r24, 0x01	; 1
    1438:	9c 83       	std	Y+4, r25	; 0x04
    143a:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    143c:	89 81       	ldd	r24, Y+1	; 0x01
    143e:	9a 81       	ldd	r25, Y+2	; 0x02
    1440:	89 2f       	mov	r24, r25
    1442:	99 27       	eor	r25, r25
    1444:	9a 83       	std	Y+2, r25	; 0x02
    1446:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1448:	89 81       	ldd	r24, Y+1	; 0x01
    144a:	eb 81       	ldd	r30, Y+3	; 0x03
    144c:	fc 81       	ldd	r31, Y+4	; 0x04
    144e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1450:	8b 81       	ldd	r24, Y+3	; 0x03
    1452:	9c 81       	ldd	r25, Y+4	; 0x04
    1454:	01 97       	sbiw	r24, 0x01	; 1
    1456:	9c 83       	std	Y+4, r25	; 0x04
    1458:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    145a:	eb 81       	ldd	r30, Y+3	; 0x03
    145c:	fc 81       	ldd	r31, Y+4	; 0x04
    145e:	86 e2       	ldi	r24, 0x26	; 38
    1460:	80 83       	st	Z, r24
	pxTopOfStack--;
    1462:	8b 81       	ldd	r24, Y+3	; 0x03
    1464:	9c 81       	ldd	r25, Y+4	; 0x04
    1466:	01 97       	sbiw	r24, 0x01	; 1
    1468:	9c 83       	std	Y+4, r25	; 0x04
    146a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    146c:	eb 81       	ldd	r30, Y+3	; 0x03
    146e:	fc 81       	ldd	r31, Y+4	; 0x04
    1470:	87 e2       	ldi	r24, 0x27	; 39
    1472:	80 83       	st	Z, r24
	pxTopOfStack--;
    1474:	8b 81       	ldd	r24, Y+3	; 0x03
    1476:	9c 81       	ldd	r25, Y+4	; 0x04
    1478:	01 97       	sbiw	r24, 0x01	; 1
    147a:	9c 83       	std	Y+4, r25	; 0x04
    147c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    147e:	eb 81       	ldd	r30, Y+3	; 0x03
    1480:	fc 81       	ldd	r31, Y+4	; 0x04
    1482:	88 e2       	ldi	r24, 0x28	; 40
    1484:	80 83       	st	Z, r24
	pxTopOfStack--;
    1486:	8b 81       	ldd	r24, Y+3	; 0x03
    1488:	9c 81       	ldd	r25, Y+4	; 0x04
    148a:	01 97       	sbiw	r24, 0x01	; 1
    148c:	9c 83       	std	Y+4, r25	; 0x04
    148e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    1490:	eb 81       	ldd	r30, Y+3	; 0x03
    1492:	fc 81       	ldd	r31, Y+4	; 0x04
    1494:	89 e2       	ldi	r24, 0x29	; 41
    1496:	80 83       	st	Z, r24
	pxTopOfStack--;
    1498:	8b 81       	ldd	r24, Y+3	; 0x03
    149a:	9c 81       	ldd	r25, Y+4	; 0x04
    149c:	01 97       	sbiw	r24, 0x01	; 1
    149e:	9c 83       	std	Y+4, r25	; 0x04
    14a0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    14a2:	eb 81       	ldd	r30, Y+3	; 0x03
    14a4:	fc 81       	ldd	r31, Y+4	; 0x04
    14a6:	80 e3       	ldi	r24, 0x30	; 48
    14a8:	80 83       	st	Z, r24
	pxTopOfStack--;
    14aa:	8b 81       	ldd	r24, Y+3	; 0x03
    14ac:	9c 81       	ldd	r25, Y+4	; 0x04
    14ae:	01 97       	sbiw	r24, 0x01	; 1
    14b0:	9c 83       	std	Y+4, r25	; 0x04
    14b2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    14b4:	eb 81       	ldd	r30, Y+3	; 0x03
    14b6:	fc 81       	ldd	r31, Y+4	; 0x04
    14b8:	81 e3       	ldi	r24, 0x31	; 49
    14ba:	80 83       	st	Z, r24
	pxTopOfStack--;
    14bc:	8b 81       	ldd	r24, Y+3	; 0x03
    14be:	9c 81       	ldd	r25, Y+4	; 0x04
    14c0:	01 97       	sbiw	r24, 0x01	; 1
    14c2:	9c 83       	std	Y+4, r25	; 0x04
    14c4:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    14c6:	8b 81       	ldd	r24, Y+3	; 0x03
    14c8:	9c 81       	ldd	r25, Y+4	; 0x04
}
    14ca:	28 96       	adiw	r28, 0x08	; 8
    14cc:	0f b6       	in	r0, 0x3f	; 63
    14ce:	f8 94       	cli
    14d0:	de bf       	out	0x3e, r29	; 62
    14d2:	0f be       	out	0x3f, r0	; 63
    14d4:	cd bf       	out	0x3d, r28	; 61
    14d6:	cf 91       	pop	r28
    14d8:	df 91       	pop	r29
    14da:	08 95       	ret

000014dc <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    14dc:	df 93       	push	r29
    14de:	cf 93       	push	r28
    14e0:	cd b7       	in	r28, 0x3d	; 61
    14e2:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    14e4:	0e 94 60 0b 	call	0x16c0	; 0x16c0 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    14e8:	a0 91 d1 02 	lds	r26, 0x02D1
    14ec:	b0 91 d2 02 	lds	r27, 0x02D2
    14f0:	cd 91       	ld	r28, X+
    14f2:	cd bf       	out	0x3d, r28	; 61
    14f4:	dd 91       	ld	r29, X+
    14f6:	de bf       	out	0x3e, r29	; 62
    14f8:	ff 91       	pop	r31
    14fa:	ef 91       	pop	r30
    14fc:	df 91       	pop	r29
    14fe:	cf 91       	pop	r28
    1500:	bf 91       	pop	r27
    1502:	af 91       	pop	r26
    1504:	9f 91       	pop	r25
    1506:	8f 91       	pop	r24
    1508:	7f 91       	pop	r23
    150a:	6f 91       	pop	r22
    150c:	5f 91       	pop	r21
    150e:	4f 91       	pop	r20
    1510:	3f 91       	pop	r19
    1512:	2f 91       	pop	r18
    1514:	1f 91       	pop	r17
    1516:	0f 91       	pop	r16
    1518:	ff 90       	pop	r15
    151a:	ef 90       	pop	r14
    151c:	df 90       	pop	r13
    151e:	cf 90       	pop	r12
    1520:	bf 90       	pop	r11
    1522:	af 90       	pop	r10
    1524:	9f 90       	pop	r9
    1526:	8f 90       	pop	r8
    1528:	7f 90       	pop	r7
    152a:	6f 90       	pop	r6
    152c:	5f 90       	pop	r5
    152e:	4f 90       	pop	r4
    1530:	3f 90       	pop	r3
    1532:	2f 90       	pop	r2
    1534:	1f 90       	pop	r1
    1536:	0f 90       	pop	r0
    1538:	0f be       	out	0x3f, r0	; 63
    153a:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    153c:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    153e:	81 e0       	ldi	r24, 0x01	; 1
}
    1540:	cf 91       	pop	r28
    1542:	df 91       	pop	r29
    1544:	08 95       	ret

00001546 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1546:	df 93       	push	r29
    1548:	cf 93       	push	r28
    154a:	cd b7       	in	r28, 0x3d	; 61
    154c:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    154e:	cf 91       	pop	r28
    1550:	df 91       	pop	r29
    1552:	08 95       	ret

00001554 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1554:	0f 92       	push	r0
    1556:	0f b6       	in	r0, 0x3f	; 63
    1558:	f8 94       	cli
    155a:	0f 92       	push	r0
    155c:	1f 92       	push	r1
    155e:	11 24       	eor	r1, r1
    1560:	2f 92       	push	r2
    1562:	3f 92       	push	r3
    1564:	4f 92       	push	r4
    1566:	5f 92       	push	r5
    1568:	6f 92       	push	r6
    156a:	7f 92       	push	r7
    156c:	8f 92       	push	r8
    156e:	9f 92       	push	r9
    1570:	af 92       	push	r10
    1572:	bf 92       	push	r11
    1574:	cf 92       	push	r12
    1576:	df 92       	push	r13
    1578:	ef 92       	push	r14
    157a:	ff 92       	push	r15
    157c:	0f 93       	push	r16
    157e:	1f 93       	push	r17
    1580:	2f 93       	push	r18
    1582:	3f 93       	push	r19
    1584:	4f 93       	push	r20
    1586:	5f 93       	push	r21
    1588:	6f 93       	push	r22
    158a:	7f 93       	push	r23
    158c:	8f 93       	push	r24
    158e:	9f 93       	push	r25
    1590:	af 93       	push	r26
    1592:	bf 93       	push	r27
    1594:	cf 93       	push	r28
    1596:	df 93       	push	r29
    1598:	ef 93       	push	r30
    159a:	ff 93       	push	r31
    159c:	a0 91 d1 02 	lds	r26, 0x02D1
    15a0:	b0 91 d2 02 	lds	r27, 0x02D2
    15a4:	0d b6       	in	r0, 0x3d	; 61
    15a6:	0d 92       	st	X+, r0
    15a8:	0e b6       	in	r0, 0x3e	; 62
    15aa:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    15ac:	0e 94 b2 17 	call	0x2f64	; 0x2f64 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    15b0:	a0 91 d1 02 	lds	r26, 0x02D1
    15b4:	b0 91 d2 02 	lds	r27, 0x02D2
    15b8:	cd 91       	ld	r28, X+
    15ba:	cd bf       	out	0x3d, r28	; 61
    15bc:	dd 91       	ld	r29, X+
    15be:	de bf       	out	0x3e, r29	; 62
    15c0:	ff 91       	pop	r31
    15c2:	ef 91       	pop	r30
    15c4:	df 91       	pop	r29
    15c6:	cf 91       	pop	r28
    15c8:	bf 91       	pop	r27
    15ca:	af 91       	pop	r26
    15cc:	9f 91       	pop	r25
    15ce:	8f 91       	pop	r24
    15d0:	7f 91       	pop	r23
    15d2:	6f 91       	pop	r22
    15d4:	5f 91       	pop	r21
    15d6:	4f 91       	pop	r20
    15d8:	3f 91       	pop	r19
    15da:	2f 91       	pop	r18
    15dc:	1f 91       	pop	r17
    15de:	0f 91       	pop	r16
    15e0:	ff 90       	pop	r15
    15e2:	ef 90       	pop	r14
    15e4:	df 90       	pop	r13
    15e6:	cf 90       	pop	r12
    15e8:	bf 90       	pop	r11
    15ea:	af 90       	pop	r10
    15ec:	9f 90       	pop	r9
    15ee:	8f 90       	pop	r8
    15f0:	7f 90       	pop	r7
    15f2:	6f 90       	pop	r6
    15f4:	5f 90       	pop	r5
    15f6:	4f 90       	pop	r4
    15f8:	3f 90       	pop	r3
    15fa:	2f 90       	pop	r2
    15fc:	1f 90       	pop	r1
    15fe:	0f 90       	pop	r0
    1600:	0f be       	out	0x3f, r0	; 63
    1602:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1604:	08 95       	ret

00001606 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1606:	0f 92       	push	r0
    1608:	0f b6       	in	r0, 0x3f	; 63
    160a:	f8 94       	cli
    160c:	0f 92       	push	r0
    160e:	1f 92       	push	r1
    1610:	11 24       	eor	r1, r1
    1612:	2f 92       	push	r2
    1614:	3f 92       	push	r3
    1616:	4f 92       	push	r4
    1618:	5f 92       	push	r5
    161a:	6f 92       	push	r6
    161c:	7f 92       	push	r7
    161e:	8f 92       	push	r8
    1620:	9f 92       	push	r9
    1622:	af 92       	push	r10
    1624:	bf 92       	push	r11
    1626:	cf 92       	push	r12
    1628:	df 92       	push	r13
    162a:	ef 92       	push	r14
    162c:	ff 92       	push	r15
    162e:	0f 93       	push	r16
    1630:	1f 93       	push	r17
    1632:	2f 93       	push	r18
    1634:	3f 93       	push	r19
    1636:	4f 93       	push	r20
    1638:	5f 93       	push	r21
    163a:	6f 93       	push	r22
    163c:	7f 93       	push	r23
    163e:	8f 93       	push	r24
    1640:	9f 93       	push	r25
    1642:	af 93       	push	r26
    1644:	bf 93       	push	r27
    1646:	cf 93       	push	r28
    1648:	df 93       	push	r29
    164a:	ef 93       	push	r30
    164c:	ff 93       	push	r31
    164e:	a0 91 d1 02 	lds	r26, 0x02D1
    1652:	b0 91 d2 02 	lds	r27, 0x02D2
    1656:	0d b6       	in	r0, 0x3d	; 61
    1658:	0d 92       	st	X+, r0
    165a:	0e b6       	in	r0, 0x3e	; 62
    165c:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    165e:	0e 94 cd 16 	call	0x2d9a	; 0x2d9a <xTaskIncrementTick>
    1662:	88 23       	and	r24, r24
    1664:	11 f0       	breq	.+4      	; 0x166a <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    1666:	0e 94 b2 17 	call	0x2f64	; 0x2f64 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    166a:	a0 91 d1 02 	lds	r26, 0x02D1
    166e:	b0 91 d2 02 	lds	r27, 0x02D2
    1672:	cd 91       	ld	r28, X+
    1674:	cd bf       	out	0x3d, r28	; 61
    1676:	dd 91       	ld	r29, X+
    1678:	de bf       	out	0x3e, r29	; 62
    167a:	ff 91       	pop	r31
    167c:	ef 91       	pop	r30
    167e:	df 91       	pop	r29
    1680:	cf 91       	pop	r28
    1682:	bf 91       	pop	r27
    1684:	af 91       	pop	r26
    1686:	9f 91       	pop	r25
    1688:	8f 91       	pop	r24
    168a:	7f 91       	pop	r23
    168c:	6f 91       	pop	r22
    168e:	5f 91       	pop	r21
    1690:	4f 91       	pop	r20
    1692:	3f 91       	pop	r19
    1694:	2f 91       	pop	r18
    1696:	1f 91       	pop	r17
    1698:	0f 91       	pop	r16
    169a:	ff 90       	pop	r15
    169c:	ef 90       	pop	r14
    169e:	df 90       	pop	r13
    16a0:	cf 90       	pop	r12
    16a2:	bf 90       	pop	r11
    16a4:	af 90       	pop	r10
    16a6:	9f 90       	pop	r9
    16a8:	8f 90       	pop	r8
    16aa:	7f 90       	pop	r7
    16ac:	6f 90       	pop	r6
    16ae:	5f 90       	pop	r5
    16b0:	4f 90       	pop	r4
    16b2:	3f 90       	pop	r3
    16b4:	2f 90       	pop	r2
    16b6:	1f 90       	pop	r1
    16b8:	0f 90       	pop	r0
    16ba:	0f be       	out	0x3f, r0	; 63
    16bc:	0f 90       	pop	r0

	asm volatile ( "ret" );
    16be:	08 95       	ret

000016c0 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    16c0:	df 93       	push	r29
    16c2:	cf 93       	push	r28
    16c4:	00 d0       	rcall	.+0      	; 0x16c6 <prvSetupTimerInterrupt+0x6>
    16c6:	00 d0       	rcall	.+0      	; 0x16c8 <prvSetupTimerInterrupt+0x8>
    16c8:	00 d0       	rcall	.+0      	; 0x16ca <prvSetupTimerInterrupt+0xa>
    16ca:	cd b7       	in	r28, 0x3d	; 61
    16cc:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    16ce:	80 e4       	ldi	r24, 0x40	; 64
    16d0:	9f e1       	ldi	r25, 0x1F	; 31
    16d2:	a0 e0       	ldi	r26, 0x00	; 0
    16d4:	b0 e0       	ldi	r27, 0x00	; 0
    16d6:	8b 83       	std	Y+3, r24	; 0x03
    16d8:	9c 83       	std	Y+4, r25	; 0x04
    16da:	ad 83       	std	Y+5, r26	; 0x05
    16dc:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    16de:	8b 81       	ldd	r24, Y+3	; 0x03
    16e0:	9c 81       	ldd	r25, Y+4	; 0x04
    16e2:	ad 81       	ldd	r26, Y+5	; 0x05
    16e4:	be 81       	ldd	r27, Y+6	; 0x06
    16e6:	68 94       	set
    16e8:	15 f8       	bld	r1, 5
    16ea:	b6 95       	lsr	r27
    16ec:	a7 95       	ror	r26
    16ee:	97 95       	ror	r25
    16f0:	87 95       	ror	r24
    16f2:	16 94       	lsr	r1
    16f4:	d1 f7       	brne	.-12     	; 0x16ea <prvSetupTimerInterrupt+0x2a>
    16f6:	8b 83       	std	Y+3, r24	; 0x03
    16f8:	9c 83       	std	Y+4, r25	; 0x04
    16fa:	ad 83       	std	Y+5, r26	; 0x05
    16fc:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    16fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1700:	9c 81       	ldd	r25, Y+4	; 0x04
    1702:	ad 81       	ldd	r26, Y+5	; 0x05
    1704:	be 81       	ldd	r27, Y+6	; 0x06
    1706:	01 97       	sbiw	r24, 0x01	; 1
    1708:	a1 09       	sbc	r26, r1
    170a:	b1 09       	sbc	r27, r1
    170c:	8b 83       	std	Y+3, r24	; 0x03
    170e:	9c 83       	std	Y+4, r25	; 0x04
    1710:	ad 83       	std	Y+5, r26	; 0x05
    1712:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    1714:	8b 81       	ldd	r24, Y+3	; 0x03
    1716:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    1718:	8b 81       	ldd	r24, Y+3	; 0x03
    171a:	9c 81       	ldd	r25, Y+4	; 0x04
    171c:	ad 81       	ldd	r26, Y+5	; 0x05
    171e:	be 81       	ldd	r27, Y+6	; 0x06
    1720:	89 2f       	mov	r24, r25
    1722:	9a 2f       	mov	r25, r26
    1724:	ab 2f       	mov	r26, r27
    1726:	bb 27       	eor	r27, r27
    1728:	8b 83       	std	Y+3, r24	; 0x03
    172a:	9c 83       	std	Y+4, r25	; 0x04
    172c:	ad 83       	std	Y+5, r26	; 0x05
    172e:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    1730:	8b 81       	ldd	r24, Y+3	; 0x03
    1732:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    1734:	eb e4       	ldi	r30, 0x4B	; 75
    1736:	f0 e0       	ldi	r31, 0x00	; 0
    1738:	8a 81       	ldd	r24, Y+2	; 0x02
    173a:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    173c:	ea e4       	ldi	r30, 0x4A	; 74
    173e:	f0 e0       	ldi	r31, 0x00	; 0
    1740:	89 81       	ldd	r24, Y+1	; 0x01
    1742:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    1744:	8b e0       	ldi	r24, 0x0B	; 11
    1746:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    1748:	ee e4       	ldi	r30, 0x4E	; 78
    174a:	f0 e0       	ldi	r31, 0x00	; 0
    174c:	89 81       	ldd	r24, Y+1	; 0x01
    174e:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1750:	e9 e5       	ldi	r30, 0x59	; 89
    1752:	f0 e0       	ldi	r31, 0x00	; 0
    1754:	80 81       	ld	r24, Z
    1756:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1758:	89 81       	ldd	r24, Y+1	; 0x01
    175a:	80 61       	ori	r24, 0x10	; 16
    175c:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    175e:	e9 e5       	ldi	r30, 0x59	; 89
    1760:	f0 e0       	ldi	r31, 0x00	; 0
    1762:	89 81       	ldd	r24, Y+1	; 0x01
    1764:	80 83       	st	Z, r24
}
    1766:	26 96       	adiw	r28, 0x06	; 6
    1768:	0f b6       	in	r0, 0x3f	; 63
    176a:	f8 94       	cli
    176c:	de bf       	out	0x3e, r29	; 62
    176e:	0f be       	out	0x3f, r0	; 63
    1770:	cd bf       	out	0x3d, r28	; 61
    1772:	cf 91       	pop	r28
    1774:	df 91       	pop	r29
    1776:	08 95       	ret

00001778 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    1778:	0e 94 03 0b 	call	0x1606	; 0x1606 <vPortYieldFromTick>
		asm volatile ( "reti" );
    177c:	18 95       	reti

0000177e <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    177e:	df 93       	push	r29
    1780:	cf 93       	push	r28
    1782:	00 d0       	rcall	.+0      	; 0x1784 <xQueueGenericReset+0x6>
    1784:	00 d0       	rcall	.+0      	; 0x1786 <xQueueGenericReset+0x8>
    1786:	0f 92       	push	r0
    1788:	cd b7       	in	r28, 0x3d	; 61
    178a:	de b7       	in	r29, 0x3e	; 62
    178c:	9c 83       	std	Y+4, r25	; 0x04
    178e:	8b 83       	std	Y+3, r24	; 0x03
    1790:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    1792:	8b 81       	ldd	r24, Y+3	; 0x03
    1794:	9c 81       	ldd	r25, Y+4	; 0x04
    1796:	9a 83       	std	Y+2, r25	; 0x02
    1798:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    179a:	0f b6       	in	r0, 0x3f	; 63
    179c:	f8 94       	cli
    179e:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    17a0:	e9 81       	ldd	r30, Y+1	; 0x01
    17a2:	fa 81       	ldd	r31, Y+2	; 0x02
    17a4:	40 81       	ld	r20, Z
    17a6:	51 81       	ldd	r21, Z+1	; 0x01
    17a8:	e9 81       	ldd	r30, Y+1	; 0x01
    17aa:	fa 81       	ldd	r31, Y+2	; 0x02
    17ac:	83 8d       	ldd	r24, Z+27	; 0x1b
    17ae:	28 2f       	mov	r18, r24
    17b0:	30 e0       	ldi	r19, 0x00	; 0
    17b2:	e9 81       	ldd	r30, Y+1	; 0x01
    17b4:	fa 81       	ldd	r31, Y+2	; 0x02
    17b6:	84 8d       	ldd	r24, Z+28	; 0x1c
    17b8:	88 2f       	mov	r24, r24
    17ba:	90 e0       	ldi	r25, 0x00	; 0
    17bc:	bc 01       	movw	r22, r24
    17be:	26 9f       	mul	r18, r22
    17c0:	c0 01       	movw	r24, r0
    17c2:	27 9f       	mul	r18, r23
    17c4:	90 0d       	add	r25, r0
    17c6:	36 9f       	mul	r19, r22
    17c8:	90 0d       	add	r25, r0
    17ca:	11 24       	eor	r1, r1
    17cc:	84 0f       	add	r24, r20
    17ce:	95 1f       	adc	r25, r21
    17d0:	e9 81       	ldd	r30, Y+1	; 0x01
    17d2:	fa 81       	ldd	r31, Y+2	; 0x02
    17d4:	95 83       	std	Z+5, r25	; 0x05
    17d6:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    17d8:	e9 81       	ldd	r30, Y+1	; 0x01
    17da:	fa 81       	ldd	r31, Y+2	; 0x02
    17dc:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    17de:	e9 81       	ldd	r30, Y+1	; 0x01
    17e0:	fa 81       	ldd	r31, Y+2	; 0x02
    17e2:	80 81       	ld	r24, Z
    17e4:	91 81       	ldd	r25, Z+1	; 0x01
    17e6:	e9 81       	ldd	r30, Y+1	; 0x01
    17e8:	fa 81       	ldd	r31, Y+2	; 0x02
    17ea:	93 83       	std	Z+3, r25	; 0x03
    17ec:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    17ee:	e9 81       	ldd	r30, Y+1	; 0x01
    17f0:	fa 81       	ldd	r31, Y+2	; 0x02
    17f2:	40 81       	ld	r20, Z
    17f4:	51 81       	ldd	r21, Z+1	; 0x01
    17f6:	e9 81       	ldd	r30, Y+1	; 0x01
    17f8:	fa 81       	ldd	r31, Y+2	; 0x02
    17fa:	83 8d       	ldd	r24, Z+27	; 0x1b
    17fc:	88 2f       	mov	r24, r24
    17fe:	90 e0       	ldi	r25, 0x00	; 0
    1800:	9c 01       	movw	r18, r24
    1802:	21 50       	subi	r18, 0x01	; 1
    1804:	30 40       	sbci	r19, 0x00	; 0
    1806:	e9 81       	ldd	r30, Y+1	; 0x01
    1808:	fa 81       	ldd	r31, Y+2	; 0x02
    180a:	84 8d       	ldd	r24, Z+28	; 0x1c
    180c:	88 2f       	mov	r24, r24
    180e:	90 e0       	ldi	r25, 0x00	; 0
    1810:	bc 01       	movw	r22, r24
    1812:	26 9f       	mul	r18, r22
    1814:	c0 01       	movw	r24, r0
    1816:	27 9f       	mul	r18, r23
    1818:	90 0d       	add	r25, r0
    181a:	36 9f       	mul	r19, r22
    181c:	90 0d       	add	r25, r0
    181e:	11 24       	eor	r1, r1
    1820:	84 0f       	add	r24, r20
    1822:	95 1f       	adc	r25, r21
    1824:	e9 81       	ldd	r30, Y+1	; 0x01
    1826:	fa 81       	ldd	r31, Y+2	; 0x02
    1828:	97 83       	std	Z+7, r25	; 0x07
    182a:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    182c:	e9 81       	ldd	r30, Y+1	; 0x01
    182e:	fa 81       	ldd	r31, Y+2	; 0x02
    1830:	8f ef       	ldi	r24, 0xFF	; 255
    1832:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    1834:	e9 81       	ldd	r30, Y+1	; 0x01
    1836:	fa 81       	ldd	r31, Y+2	; 0x02
    1838:	8f ef       	ldi	r24, 0xFF	; 255
    183a:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    183c:	8d 81       	ldd	r24, Y+5	; 0x05
    183e:	88 23       	and	r24, r24
    1840:	79 f4       	brne	.+30     	; 0x1860 <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1842:	e9 81       	ldd	r30, Y+1	; 0x01
    1844:	fa 81       	ldd	r31, Y+2	; 0x02
    1846:	80 85       	ldd	r24, Z+8	; 0x08
    1848:	88 23       	and	r24, r24
    184a:	a1 f0       	breq	.+40     	; 0x1874 <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    184c:	89 81       	ldd	r24, Y+1	; 0x01
    184e:	9a 81       	ldd	r25, Y+2	; 0x02
    1850:	08 96       	adiw	r24, 0x08	; 8
    1852:	0e 94 71 18 	call	0x30e2	; 0x30e2 <xTaskRemoveFromEventList>
    1856:	88 23       	and	r24, r24
    1858:	69 f0       	breq	.+26     	; 0x1874 <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    185a:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vPortYield>
    185e:	0a c0       	rjmp	.+20     	; 0x1874 <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1860:	89 81       	ldd	r24, Y+1	; 0x01
    1862:	9a 81       	ldd	r25, Y+2	; 0x02
    1864:	08 96       	adiw	r24, 0x08	; 8
    1866:	0e 94 2b 07 	call	0xe56	; 0xe56 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    186a:	89 81       	ldd	r24, Y+1	; 0x01
    186c:	9a 81       	ldd	r25, Y+2	; 0x02
    186e:	41 96       	adiw	r24, 0x11	; 17
    1870:	0e 94 2b 07 	call	0xe56	; 0xe56 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1874:	0f 90       	pop	r0
    1876:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    1878:	81 e0       	ldi	r24, 0x01	; 1
}
    187a:	0f 90       	pop	r0
    187c:	0f 90       	pop	r0
    187e:	0f 90       	pop	r0
    1880:	0f 90       	pop	r0
    1882:	0f 90       	pop	r0
    1884:	cf 91       	pop	r28
    1886:	df 91       	pop	r29
    1888:	08 95       	ret

0000188a <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    188a:	0f 93       	push	r16
    188c:	1f 93       	push	r17
    188e:	df 93       	push	r29
    1890:	cf 93       	push	r28
    1892:	cd b7       	in	r28, 0x3d	; 61
    1894:	de b7       	in	r29, 0x3e	; 62
    1896:	29 97       	sbiw	r28, 0x09	; 9
    1898:	0f b6       	in	r0, 0x3f	; 63
    189a:	f8 94       	cli
    189c:	de bf       	out	0x3e, r29	; 62
    189e:	0f be       	out	0x3f, r0	; 63
    18a0:	cd bf       	out	0x3d, r28	; 61
    18a2:	8f 83       	std	Y+7, r24	; 0x07
    18a4:	68 87       	std	Y+8, r22	; 0x08
    18a6:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    18a8:	88 85       	ldd	r24, Y+8	; 0x08
    18aa:	88 23       	and	r24, r24
    18ac:	19 f4       	brne	.+6      	; 0x18b4 <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    18ae:	1c 82       	std	Y+4, r1	; 0x04
    18b0:	1b 82       	std	Y+3, r1	; 0x03
    18b2:	10 c0       	rjmp	.+32     	; 0x18d4 <xQueueGenericCreate+0x4a>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    18b4:	8f 81       	ldd	r24, Y+7	; 0x07
    18b6:	28 2f       	mov	r18, r24
    18b8:	30 e0       	ldi	r19, 0x00	; 0
    18ba:	88 85       	ldd	r24, Y+8	; 0x08
    18bc:	88 2f       	mov	r24, r24
    18be:	90 e0       	ldi	r25, 0x00	; 0
    18c0:	ac 01       	movw	r20, r24
    18c2:	24 9f       	mul	r18, r20
    18c4:	c0 01       	movw	r24, r0
    18c6:	25 9f       	mul	r18, r21
    18c8:	90 0d       	add	r25, r0
    18ca:	34 9f       	mul	r19, r20
    18cc:	90 0d       	add	r25, r0
    18ce:	11 24       	eor	r1, r1
    18d0:	9c 83       	std	Y+4, r25	; 0x04
    18d2:	8b 83       	std	Y+3, r24	; 0x03
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    18d4:	8b 81       	ldd	r24, Y+3	; 0x03
    18d6:	9c 81       	ldd	r25, Y+4	; 0x04
    18d8:	4f 96       	adiw	r24, 0x1f	; 31
    18da:	0e 94 af 06 	call	0xd5e	; 0xd5e <pvPortMalloc>
    18de:	9e 83       	std	Y+6, r25	; 0x06
    18e0:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    18e2:	8d 81       	ldd	r24, Y+5	; 0x05
    18e4:	9e 81       	ldd	r25, Y+6	; 0x06
    18e6:	00 97       	sbiw	r24, 0x00	; 0
    18e8:	a1 f0       	breq	.+40     	; 0x1912 <xQueueGenericCreate+0x88>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    18ea:	8d 81       	ldd	r24, Y+5	; 0x05
    18ec:	9e 81       	ldd	r25, Y+6	; 0x06
    18ee:	9a 83       	std	Y+2, r25	; 0x02
    18f0:	89 83       	std	Y+1, r24	; 0x01
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    18f2:	89 81       	ldd	r24, Y+1	; 0x01
    18f4:	9a 81       	ldd	r25, Y+2	; 0x02
    18f6:	4f 96       	adiw	r24, 0x1f	; 31
    18f8:	9a 83       	std	Y+2, r25	; 0x02
    18fa:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    18fc:	29 81       	ldd	r18, Y+1	; 0x01
    18fe:	3a 81       	ldd	r19, Y+2	; 0x02
    1900:	ed 81       	ldd	r30, Y+5	; 0x05
    1902:	fe 81       	ldd	r31, Y+6	; 0x06
    1904:	8f 81       	ldd	r24, Y+7	; 0x07
    1906:	68 85       	ldd	r22, Y+8	; 0x08
    1908:	a9 01       	movw	r20, r18
    190a:	29 85       	ldd	r18, Y+9	; 0x09
    190c:	8f 01       	movw	r16, r30
    190e:	0e 94 96 0c 	call	0x192c	; 0x192c <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    1912:	8d 81       	ldd	r24, Y+5	; 0x05
    1914:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    1916:	29 96       	adiw	r28, 0x09	; 9
    1918:	0f b6       	in	r0, 0x3f	; 63
    191a:	f8 94       	cli
    191c:	de bf       	out	0x3e, r29	; 62
    191e:	0f be       	out	0x3f, r0	; 63
    1920:	cd bf       	out	0x3d, r28	; 61
    1922:	cf 91       	pop	r28
    1924:	df 91       	pop	r29
    1926:	1f 91       	pop	r17
    1928:	0f 91       	pop	r16
    192a:	08 95       	ret

0000192c <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    192c:	0f 93       	push	r16
    192e:	1f 93       	push	r17
    1930:	df 93       	push	r29
    1932:	cf 93       	push	r28
    1934:	cd b7       	in	r28, 0x3d	; 61
    1936:	de b7       	in	r29, 0x3e	; 62
    1938:	27 97       	sbiw	r28, 0x07	; 7
    193a:	0f b6       	in	r0, 0x3f	; 63
    193c:	f8 94       	cli
    193e:	de bf       	out	0x3e, r29	; 62
    1940:	0f be       	out	0x3f, r0	; 63
    1942:	cd bf       	out	0x3d, r28	; 61
    1944:	89 83       	std	Y+1, r24	; 0x01
    1946:	6a 83       	std	Y+2, r22	; 0x02
    1948:	5c 83       	std	Y+4, r21	; 0x04
    194a:	4b 83       	std	Y+3, r20	; 0x03
    194c:	2d 83       	std	Y+5, r18	; 0x05
    194e:	1f 83       	std	Y+7, r17	; 0x07
    1950:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    1952:	8a 81       	ldd	r24, Y+2	; 0x02
    1954:	88 23       	and	r24, r24
    1956:	39 f4       	brne	.+14     	; 0x1966 <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1958:	8e 81       	ldd	r24, Y+6	; 0x06
    195a:	9f 81       	ldd	r25, Y+7	; 0x07
    195c:	ee 81       	ldd	r30, Y+6	; 0x06
    195e:	ff 81       	ldd	r31, Y+7	; 0x07
    1960:	91 83       	std	Z+1, r25	; 0x01
    1962:	80 83       	st	Z, r24
    1964:	06 c0       	rjmp	.+12     	; 0x1972 <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1966:	8b 81       	ldd	r24, Y+3	; 0x03
    1968:	9c 81       	ldd	r25, Y+4	; 0x04
    196a:	ee 81       	ldd	r30, Y+6	; 0x06
    196c:	ff 81       	ldd	r31, Y+7	; 0x07
    196e:	91 83       	std	Z+1, r25	; 0x01
    1970:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    1972:	ee 81       	ldd	r30, Y+6	; 0x06
    1974:	ff 81       	ldd	r31, Y+7	; 0x07
    1976:	89 81       	ldd	r24, Y+1	; 0x01
    1978:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    197a:	ee 81       	ldd	r30, Y+6	; 0x06
    197c:	ff 81       	ldd	r31, Y+7	; 0x07
    197e:	8a 81       	ldd	r24, Y+2	; 0x02
    1980:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1982:	8e 81       	ldd	r24, Y+6	; 0x06
    1984:	9f 81       	ldd	r25, Y+7	; 0x07
    1986:	61 e0       	ldi	r22, 0x01	; 1
    1988:	0e 94 bf 0b 	call	0x177e	; 0x177e <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    198c:	27 96       	adiw	r28, 0x07	; 7
    198e:	0f b6       	in	r0, 0x3f	; 63
    1990:	f8 94       	cli
    1992:	de bf       	out	0x3e, r29	; 62
    1994:	0f be       	out	0x3f, r0	; 63
    1996:	cd bf       	out	0x3d, r28	; 61
    1998:	cf 91       	pop	r28
    199a:	df 91       	pop	r29
    199c:	1f 91       	pop	r17
    199e:	0f 91       	pop	r16
    19a0:	08 95       	ret

000019a2 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    19a2:	df 93       	push	r29
    19a4:	cf 93       	push	r28
    19a6:	cd b7       	in	r28, 0x3d	; 61
    19a8:	de b7       	in	r29, 0x3e	; 62
    19aa:	2f 97       	sbiw	r28, 0x0f	; 15
    19ac:	0f b6       	in	r0, 0x3f	; 63
    19ae:	f8 94       	cli
    19b0:	de bf       	out	0x3e, r29	; 62
    19b2:	0f be       	out	0x3f, r0	; 63
    19b4:	cd bf       	out	0x3d, r28	; 61
    19b6:	99 87       	std	Y+9, r25	; 0x09
    19b8:	88 87       	std	Y+8, r24	; 0x08
    19ba:	7b 87       	std	Y+11, r23	; 0x0b
    19bc:	6a 87       	std	Y+10, r22	; 0x0a
    19be:	5d 87       	std	Y+13, r21	; 0x0d
    19c0:	4c 87       	std	Y+12, r20	; 0x0c
    19c2:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    19c4:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    19c6:	88 85       	ldd	r24, Y+8	; 0x08
    19c8:	99 85       	ldd	r25, Y+9	; 0x09
    19ca:	9a 83       	std	Y+2, r25	; 0x02
    19cc:	89 83       	std	Y+1, r24	; 0x01
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    19ce:	0f b6       	in	r0, 0x3f	; 63
    19d0:	f8 94       	cli
    19d2:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    19d4:	e9 81       	ldd	r30, Y+1	; 0x01
    19d6:	fa 81       	ldd	r31, Y+2	; 0x02
    19d8:	92 8d       	ldd	r25, Z+26	; 0x1a
    19da:	e9 81       	ldd	r30, Y+1	; 0x01
    19dc:	fa 81       	ldd	r31, Y+2	; 0x02
    19de:	83 8d       	ldd	r24, Z+27	; 0x1b
    19e0:	98 17       	cp	r25, r24
    19e2:	18 f0       	brcs	.+6      	; 0x19ea <xQueueGenericSend+0x48>
    19e4:	8e 85       	ldd	r24, Y+14	; 0x0e
    19e6:	82 30       	cpi	r24, 0x02	; 2
    19e8:	11 f5       	brne	.+68     	; 0x1a2e <xQueueGenericSend+0x8c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    19ea:	89 81       	ldd	r24, Y+1	; 0x01
    19ec:	9a 81       	ldd	r25, Y+2	; 0x02
    19ee:	2a 85       	ldd	r18, Y+10	; 0x0a
    19f0:	3b 85       	ldd	r19, Y+11	; 0x0b
    19f2:	b9 01       	movw	r22, r18
    19f4:	4e 85       	ldd	r20, Y+14	; 0x0e
    19f6:	0e 94 23 11 	call	0x2246	; 0x2246 <prvCopyDataToQueue>
    19fa:	8b 83       	std	Y+3, r24	; 0x03

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    19fc:	e9 81       	ldd	r30, Y+1	; 0x01
    19fe:	fa 81       	ldd	r31, Y+2	; 0x02
    1a00:	81 89       	ldd	r24, Z+17	; 0x11
    1a02:	88 23       	and	r24, r24
    1a04:	51 f0       	breq	.+20     	; 0x1a1a <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a06:	89 81       	ldd	r24, Y+1	; 0x01
    1a08:	9a 81       	ldd	r25, Y+2	; 0x02
    1a0a:	41 96       	adiw	r24, 0x11	; 17
    1a0c:	0e 94 71 18 	call	0x30e2	; 0x30e2 <xTaskRemoveFromEventList>
    1a10:	88 23       	and	r24, r24
    1a12:	41 f0       	breq	.+16     	; 0x1a24 <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1a14:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vPortYield>
    1a18:	05 c0       	rjmp	.+10     	; 0x1a24 <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1a1a:	8b 81       	ldd	r24, Y+3	; 0x03
    1a1c:	88 23       	and	r24, r24
    1a1e:	11 f0       	breq	.+4      	; 0x1a24 <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1a20:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1a24:	0f 90       	pop	r0
    1a26:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1a28:	81 e0       	ldi	r24, 0x01	; 1
    1a2a:	8f 87       	std	Y+15, r24	; 0x0f
    1a2c:	5c c0       	rjmp	.+184    	; 0x1ae6 <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1a2e:	8c 85       	ldd	r24, Y+12	; 0x0c
    1a30:	9d 85       	ldd	r25, Y+13	; 0x0d
    1a32:	00 97       	sbiw	r24, 0x00	; 0
    1a34:	21 f4       	brne	.+8      	; 0x1a3e <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1a36:	0f 90       	pop	r0
    1a38:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1a3a:	1f 86       	std	Y+15, r1	; 0x0f
    1a3c:	54 c0       	rjmp	.+168    	; 0x1ae6 <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1a3e:	8c 81       	ldd	r24, Y+4	; 0x04
    1a40:	88 23       	and	r24, r24
    1a42:	31 f4       	brne	.+12     	; 0x1a50 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1a44:	ce 01       	movw	r24, r28
    1a46:	05 96       	adiw	r24, 0x05	; 5
    1a48:	0e 94 57 19 	call	0x32ae	; 0x32ae <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1a4c:	81 e0       	ldi	r24, 0x01	; 1
    1a4e:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1a50:	0f 90       	pop	r0
    1a52:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1a54:	0e 94 d1 15 	call	0x2ba2	; 0x2ba2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1a58:	0f b6       	in	r0, 0x3f	; 63
    1a5a:	f8 94       	cli
    1a5c:	0f 92       	push	r0
    1a5e:	e9 81       	ldd	r30, Y+1	; 0x01
    1a60:	fa 81       	ldd	r31, Y+2	; 0x02
    1a62:	85 8d       	ldd	r24, Z+29	; 0x1d
    1a64:	8f 3f       	cpi	r24, 0xFF	; 255
    1a66:	19 f4       	brne	.+6      	; 0x1a6e <xQueueGenericSend+0xcc>
    1a68:	e9 81       	ldd	r30, Y+1	; 0x01
    1a6a:	fa 81       	ldd	r31, Y+2	; 0x02
    1a6c:	15 8e       	std	Z+29, r1	; 0x1d
    1a6e:	e9 81       	ldd	r30, Y+1	; 0x01
    1a70:	fa 81       	ldd	r31, Y+2	; 0x02
    1a72:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a74:	8f 3f       	cpi	r24, 0xFF	; 255
    1a76:	19 f4       	brne	.+6      	; 0x1a7e <xQueueGenericSend+0xdc>
    1a78:	e9 81       	ldd	r30, Y+1	; 0x01
    1a7a:	fa 81       	ldd	r31, Y+2	; 0x02
    1a7c:	16 8e       	std	Z+30, r1	; 0x1e
    1a7e:	0f 90       	pop	r0
    1a80:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1a82:	ce 01       	movw	r24, r28
    1a84:	05 96       	adiw	r24, 0x05	; 5
    1a86:	9e 01       	movw	r18, r28
    1a88:	24 5f       	subi	r18, 0xF4	; 244
    1a8a:	3f 4f       	sbci	r19, 0xFF	; 255
    1a8c:	b9 01       	movw	r22, r18
    1a8e:	0e 94 70 19 	call	0x32e0	; 0x32e0 <xTaskCheckForTimeOut>
    1a92:	88 23       	and	r24, r24
    1a94:	09 f5       	brne	.+66     	; 0x1ad8 <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1a96:	89 81       	ldd	r24, Y+1	; 0x01
    1a98:	9a 81       	ldd	r25, Y+2	; 0x02
    1a9a:	0e 94 9f 12 	call	0x253e	; 0x253e <prvIsQueueFull>
    1a9e:	88 23       	and	r24, r24
    1aa0:	a1 f0       	breq	.+40     	; 0x1aca <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1aa2:	89 81       	ldd	r24, Y+1	; 0x01
    1aa4:	9a 81       	ldd	r25, Y+2	; 0x02
    1aa6:	08 96       	adiw	r24, 0x08	; 8
    1aa8:	2c 85       	ldd	r18, Y+12	; 0x0c
    1aaa:	3d 85       	ldd	r19, Y+13	; 0x0d
    1aac:	b9 01       	movw	r22, r18
    1aae:	0e 94 1f 18 	call	0x303e	; 0x303e <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1ab2:	89 81       	ldd	r24, Y+1	; 0x01
    1ab4:	9a 81       	ldd	r25, Y+2	; 0x02
    1ab6:	0e 94 10 12 	call	0x2420	; 0x2420 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1aba:	0e 94 dd 15 	call	0x2bba	; 0x2bba <xTaskResumeAll>
    1abe:	88 23       	and	r24, r24
    1ac0:	09 f0       	breq	.+2      	; 0x1ac4 <xQueueGenericSend+0x122>
    1ac2:	85 cf       	rjmp	.-246    	; 0x19ce <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    1ac4:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vPortYield>
    1ac8:	82 cf       	rjmp	.-252    	; 0x19ce <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1aca:	89 81       	ldd	r24, Y+1	; 0x01
    1acc:	9a 81       	ldd	r25, Y+2	; 0x02
    1ace:	0e 94 10 12 	call	0x2420	; 0x2420 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1ad2:	0e 94 dd 15 	call	0x2bba	; 0x2bba <xTaskResumeAll>
    1ad6:	7b cf       	rjmp	.-266    	; 0x19ce <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1ad8:	89 81       	ldd	r24, Y+1	; 0x01
    1ada:	9a 81       	ldd	r25, Y+2	; 0x02
    1adc:	0e 94 10 12 	call	0x2420	; 0x2420 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1ae0:	0e 94 dd 15 	call	0x2bba	; 0x2bba <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1ae4:	1f 86       	std	Y+15, r1	; 0x0f
    1ae6:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	} /*lint -restore */
}
    1ae8:	2f 96       	adiw	r28, 0x0f	; 15
    1aea:	0f b6       	in	r0, 0x3f	; 63
    1aec:	f8 94       	cli
    1aee:	de bf       	out	0x3e, r29	; 62
    1af0:	0f be       	out	0x3f, r0	; 63
    1af2:	cd bf       	out	0x3d, r28	; 61
    1af4:	cf 91       	pop	r28
    1af6:	df 91       	pop	r29
    1af8:	08 95       	ret

00001afa <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1afa:	df 93       	push	r29
    1afc:	cf 93       	push	r28
    1afe:	cd b7       	in	r28, 0x3d	; 61
    1b00:	de b7       	in	r29, 0x3e	; 62
    1b02:	2c 97       	sbiw	r28, 0x0c	; 12
    1b04:	0f b6       	in	r0, 0x3f	; 63
    1b06:	f8 94       	cli
    1b08:	de bf       	out	0x3e, r29	; 62
    1b0a:	0f be       	out	0x3f, r0	; 63
    1b0c:	cd bf       	out	0x3d, r28	; 61
    1b0e:	9f 83       	std	Y+7, r25	; 0x07
    1b10:	8e 83       	std	Y+6, r24	; 0x06
    1b12:	79 87       	std	Y+9, r23	; 0x09
    1b14:	68 87       	std	Y+8, r22	; 0x08
    1b16:	5b 87       	std	Y+11, r21	; 0x0b
    1b18:	4a 87       	std	Y+10, r20	; 0x0a
    1b1a:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    1b1c:	8e 81       	ldd	r24, Y+6	; 0x06
    1b1e:	9f 81       	ldd	r25, Y+7	; 0x07
    1b20:	9b 83       	std	Y+3, r25	; 0x03
    1b22:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1b24:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1b26:	ea 81       	ldd	r30, Y+2	; 0x02
    1b28:	fb 81       	ldd	r31, Y+3	; 0x03
    1b2a:	92 8d       	ldd	r25, Z+26	; 0x1a
    1b2c:	ea 81       	ldd	r30, Y+2	; 0x02
    1b2e:	fb 81       	ldd	r31, Y+3	; 0x03
    1b30:	83 8d       	ldd	r24, Z+27	; 0x1b
    1b32:	98 17       	cp	r25, r24
    1b34:	18 f0       	brcs	.+6      	; 0x1b3c <xQueueGenericSendFromISR+0x42>
    1b36:	8c 85       	ldd	r24, Y+12	; 0x0c
    1b38:	82 30       	cpi	r24, 0x02	; 2
    1b3a:	61 f5       	brne	.+88     	; 0x1b94 <xQueueGenericSendFromISR+0x9a>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1b3c:	ea 81       	ldd	r30, Y+2	; 0x02
    1b3e:	fb 81       	ldd	r31, Y+3	; 0x03
    1b40:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b42:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1b44:	8a 81       	ldd	r24, Y+2	; 0x02
    1b46:	9b 81       	ldd	r25, Y+3	; 0x03
    1b48:	28 85       	ldd	r18, Y+8	; 0x08
    1b4a:	39 85       	ldd	r19, Y+9	; 0x09
    1b4c:	b9 01       	movw	r22, r18
    1b4e:	4c 85       	ldd	r20, Y+12	; 0x0c
    1b50:	0e 94 23 11 	call	0x2246	; 0x2246 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1b54:	89 81       	ldd	r24, Y+1	; 0x01
    1b56:	8f 3f       	cpi	r24, 0xFF	; 255
    1b58:	a9 f4       	brne	.+42     	; 0x1b84 <xQueueGenericSendFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b5a:	ea 81       	ldd	r30, Y+2	; 0x02
    1b5c:	fb 81       	ldd	r31, Y+3	; 0x03
    1b5e:	81 89       	ldd	r24, Z+17	; 0x11
    1b60:	88 23       	and	r24, r24
    1b62:	a9 f0       	breq	.+42     	; 0x1b8e <xQueueGenericSendFromISR+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b64:	8a 81       	ldd	r24, Y+2	; 0x02
    1b66:	9b 81       	ldd	r25, Y+3	; 0x03
    1b68:	41 96       	adiw	r24, 0x11	; 17
    1b6a:	0e 94 71 18 	call	0x30e2	; 0x30e2 <xTaskRemoveFromEventList>
    1b6e:	88 23       	and	r24, r24
    1b70:	71 f0       	breq	.+28     	; 0x1b8e <xQueueGenericSendFromISR+0x94>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1b72:	8a 85       	ldd	r24, Y+10	; 0x0a
    1b74:	9b 85       	ldd	r25, Y+11	; 0x0b
    1b76:	00 97       	sbiw	r24, 0x00	; 0
    1b78:	51 f0       	breq	.+20     	; 0x1b8e <xQueueGenericSendFromISR+0x94>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1b7a:	ea 85       	ldd	r30, Y+10	; 0x0a
    1b7c:	fb 85       	ldd	r31, Y+11	; 0x0b
    1b7e:	81 e0       	ldi	r24, 0x01	; 1
    1b80:	80 83       	st	Z, r24
    1b82:	05 c0       	rjmp	.+10     	; 0x1b8e <xQueueGenericSendFromISR+0x94>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1b84:	89 81       	ldd	r24, Y+1	; 0x01
    1b86:	8f 5f       	subi	r24, 0xFF	; 255
    1b88:	ea 81       	ldd	r30, Y+2	; 0x02
    1b8a:	fb 81       	ldd	r31, Y+3	; 0x03
    1b8c:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1b8e:	81 e0       	ldi	r24, 0x01	; 1
    1b90:	8d 83       	std	Y+5, r24	; 0x05
    1b92:	01 c0       	rjmp	.+2      	; 0x1b96 <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1b94:	1d 82       	std	Y+5, r1	; 0x05
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1b96:	8d 81       	ldd	r24, Y+5	; 0x05
}
    1b98:	2c 96       	adiw	r28, 0x0c	; 12
    1b9a:	0f b6       	in	r0, 0x3f	; 63
    1b9c:	f8 94       	cli
    1b9e:	de bf       	out	0x3e, r29	; 62
    1ba0:	0f be       	out	0x3f, r0	; 63
    1ba2:	cd bf       	out	0x3d, r28	; 61
    1ba4:	cf 91       	pop	r28
    1ba6:	df 91       	pop	r29
    1ba8:	08 95       	ret

00001baa <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1baa:	df 93       	push	r29
    1bac:	cf 93       	push	r28
    1bae:	cd b7       	in	r28, 0x3d	; 61
    1bb0:	de b7       	in	r29, 0x3e	; 62
    1bb2:	2a 97       	sbiw	r28, 0x0a	; 10
    1bb4:	0f b6       	in	r0, 0x3f	; 63
    1bb6:	f8 94       	cli
    1bb8:	de bf       	out	0x3e, r29	; 62
    1bba:	0f be       	out	0x3f, r0	; 63
    1bbc:	cd bf       	out	0x3d, r28	; 61
    1bbe:	98 87       	std	Y+8, r25	; 0x08
    1bc0:	8f 83       	std	Y+7, r24	; 0x07
    1bc2:	7a 87       	std	Y+10, r23	; 0x0a
    1bc4:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    1bc6:	8f 81       	ldd	r24, Y+7	; 0x07
    1bc8:	98 85       	ldd	r25, Y+8	; 0x08
    1bca:	9c 83       	std	Y+4, r25	; 0x04
    1bcc:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1bce:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1bd0:	eb 81       	ldd	r30, Y+3	; 0x03
    1bd2:	fc 81       	ldd	r31, Y+4	; 0x04
    1bd4:	82 8d       	ldd	r24, Z+26	; 0x1a
    1bd6:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    1bd8:	eb 81       	ldd	r30, Y+3	; 0x03
    1bda:	fc 81       	ldd	r31, Y+4	; 0x04
    1bdc:	93 8d       	ldd	r25, Z+27	; 0x1b
    1bde:	8a 81       	ldd	r24, Y+2	; 0x02
    1be0:	89 17       	cp	r24, r25
    1be2:	48 f5       	brcc	.+82     	; 0x1c36 <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1be4:	eb 81       	ldd	r30, Y+3	; 0x03
    1be6:	fc 81       	ldd	r31, Y+4	; 0x04
    1be8:	86 8d       	ldd	r24, Z+30	; 0x1e
    1bea:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1bec:	8a 81       	ldd	r24, Y+2	; 0x02
    1bee:	8f 5f       	subi	r24, 0xFF	; 255
    1bf0:	eb 81       	ldd	r30, Y+3	; 0x03
    1bf2:	fc 81       	ldd	r31, Y+4	; 0x04
    1bf4:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1bf6:	89 81       	ldd	r24, Y+1	; 0x01
    1bf8:	8f 3f       	cpi	r24, 0xFF	; 255
    1bfa:	a9 f4       	brne	.+42     	; 0x1c26 <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1bfc:	eb 81       	ldd	r30, Y+3	; 0x03
    1bfe:	fc 81       	ldd	r31, Y+4	; 0x04
    1c00:	81 89       	ldd	r24, Z+17	; 0x11
    1c02:	88 23       	and	r24, r24
    1c04:	a9 f0       	breq	.+42     	; 0x1c30 <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1c06:	8b 81       	ldd	r24, Y+3	; 0x03
    1c08:	9c 81       	ldd	r25, Y+4	; 0x04
    1c0a:	41 96       	adiw	r24, 0x11	; 17
    1c0c:	0e 94 71 18 	call	0x30e2	; 0x30e2 <xTaskRemoveFromEventList>
    1c10:	88 23       	and	r24, r24
    1c12:	71 f0       	breq	.+28     	; 0x1c30 <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1c14:	89 85       	ldd	r24, Y+9	; 0x09
    1c16:	9a 85       	ldd	r25, Y+10	; 0x0a
    1c18:	00 97       	sbiw	r24, 0x00	; 0
    1c1a:	51 f0       	breq	.+20     	; 0x1c30 <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1c1c:	e9 85       	ldd	r30, Y+9	; 0x09
    1c1e:	fa 85       	ldd	r31, Y+10	; 0x0a
    1c20:	81 e0       	ldi	r24, 0x01	; 1
    1c22:	80 83       	st	Z, r24
    1c24:	05 c0       	rjmp	.+10     	; 0x1c30 <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1c26:	89 81       	ldd	r24, Y+1	; 0x01
    1c28:	8f 5f       	subi	r24, 0xFF	; 255
    1c2a:	eb 81       	ldd	r30, Y+3	; 0x03
    1c2c:	fc 81       	ldd	r31, Y+4	; 0x04
    1c2e:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1c30:	81 e0       	ldi	r24, 0x01	; 1
    1c32:	8e 83       	std	Y+6, r24	; 0x06
    1c34:	01 c0       	rjmp	.+2      	; 0x1c38 <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1c36:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1c38:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1c3a:	2a 96       	adiw	r28, 0x0a	; 10
    1c3c:	0f b6       	in	r0, 0x3f	; 63
    1c3e:	f8 94       	cli
    1c40:	de bf       	out	0x3e, r29	; 62
    1c42:	0f be       	out	0x3f, r0	; 63
    1c44:	cd bf       	out	0x3d, r28	; 61
    1c46:	cf 91       	pop	r28
    1c48:	df 91       	pop	r29
    1c4a:	08 95       	ret

00001c4c <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1c4c:	df 93       	push	r29
    1c4e:	cf 93       	push	r28
    1c50:	cd b7       	in	r28, 0x3d	; 61
    1c52:	de b7       	in	r29, 0x3e	; 62
    1c54:	2e 97       	sbiw	r28, 0x0e	; 14
    1c56:	0f b6       	in	r0, 0x3f	; 63
    1c58:	f8 94       	cli
    1c5a:	de bf       	out	0x3e, r29	; 62
    1c5c:	0f be       	out	0x3f, r0	; 63
    1c5e:	cd bf       	out	0x3d, r28	; 61
    1c60:	99 87       	std	Y+9, r25	; 0x09
    1c62:	88 87       	std	Y+8, r24	; 0x08
    1c64:	7b 87       	std	Y+11, r23	; 0x0b
    1c66:	6a 87       	std	Y+10, r22	; 0x0a
    1c68:	5d 87       	std	Y+13, r21	; 0x0d
    1c6a:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    1c6c:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    1c6e:	88 85       	ldd	r24, Y+8	; 0x08
    1c70:	99 85       	ldd	r25, Y+9	; 0x09
    1c72:	9b 83       	std	Y+3, r25	; 0x03
    1c74:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1c76:	0f b6       	in	r0, 0x3f	; 63
    1c78:	f8 94       	cli
    1c7a:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1c7c:	ea 81       	ldd	r30, Y+2	; 0x02
    1c7e:	fb 81       	ldd	r31, Y+3	; 0x03
    1c80:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c82:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1c84:	89 81       	ldd	r24, Y+1	; 0x01
    1c86:	88 23       	and	r24, r24
    1c88:	f9 f0       	breq	.+62     	; 0x1cc8 <xQueueReceive+0x7c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1c8a:	8a 81       	ldd	r24, Y+2	; 0x02
    1c8c:	9b 81       	ldd	r25, Y+3	; 0x03
    1c8e:	2a 85       	ldd	r18, Y+10	; 0x0a
    1c90:	3b 85       	ldd	r19, Y+11	; 0x0b
    1c92:	b9 01       	movw	r22, r18
    1c94:	0e 94 c9 11 	call	0x2392	; 0x2392 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1c98:	89 81       	ldd	r24, Y+1	; 0x01
    1c9a:	81 50       	subi	r24, 0x01	; 1
    1c9c:	ea 81       	ldd	r30, Y+2	; 0x02
    1c9e:	fb 81       	ldd	r31, Y+3	; 0x03
    1ca0:	82 8f       	std	Z+26, r24	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1ca2:	ea 81       	ldd	r30, Y+2	; 0x02
    1ca4:	fb 81       	ldd	r31, Y+3	; 0x03
    1ca6:	80 85       	ldd	r24, Z+8	; 0x08
    1ca8:	88 23       	and	r24, r24
    1caa:	49 f0       	breq	.+18     	; 0x1cbe <xQueueReceive+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1cac:	8a 81       	ldd	r24, Y+2	; 0x02
    1cae:	9b 81       	ldd	r25, Y+3	; 0x03
    1cb0:	08 96       	adiw	r24, 0x08	; 8
    1cb2:	0e 94 71 18 	call	0x30e2	; 0x30e2 <xTaskRemoveFromEventList>
    1cb6:	88 23       	and	r24, r24
    1cb8:	11 f0       	breq	.+4      	; 0x1cbe <xQueueReceive+0x72>
					{
						queueYIELD_IF_USING_PREEMPTION();
    1cba:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1cbe:	0f 90       	pop	r0
    1cc0:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1cc2:	81 e0       	ldi	r24, 0x01	; 1
    1cc4:	8e 87       	std	Y+14, r24	; 0x0e
    1cc6:	63 c0       	rjmp	.+198    	; 0x1d8e <xQueueReceive+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1cc8:	8c 85       	ldd	r24, Y+12	; 0x0c
    1cca:	9d 85       	ldd	r25, Y+13	; 0x0d
    1ccc:	00 97       	sbiw	r24, 0x00	; 0
    1cce:	21 f4       	brne	.+8      	; 0x1cd8 <xQueueReceive+0x8c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1cd0:	0f 90       	pop	r0
    1cd2:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1cd4:	1e 86       	std	Y+14, r1	; 0x0e
    1cd6:	5b c0       	rjmp	.+182    	; 0x1d8e <xQueueReceive+0x142>
				}
				else if( xEntryTimeSet == pdFALSE )
    1cd8:	8c 81       	ldd	r24, Y+4	; 0x04
    1cda:	88 23       	and	r24, r24
    1cdc:	31 f4       	brne	.+12     	; 0x1cea <xQueueReceive+0x9e>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1cde:	ce 01       	movw	r24, r28
    1ce0:	05 96       	adiw	r24, 0x05	; 5
    1ce2:	0e 94 57 19 	call	0x32ae	; 0x32ae <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1ce6:	81 e0       	ldi	r24, 0x01	; 1
    1ce8:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1cea:	0f 90       	pop	r0
    1cec:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1cee:	0e 94 d1 15 	call	0x2ba2	; 0x2ba2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1cf2:	0f b6       	in	r0, 0x3f	; 63
    1cf4:	f8 94       	cli
    1cf6:	0f 92       	push	r0
    1cf8:	ea 81       	ldd	r30, Y+2	; 0x02
    1cfa:	fb 81       	ldd	r31, Y+3	; 0x03
    1cfc:	85 8d       	ldd	r24, Z+29	; 0x1d
    1cfe:	8f 3f       	cpi	r24, 0xFF	; 255
    1d00:	19 f4       	brne	.+6      	; 0x1d08 <xQueueReceive+0xbc>
    1d02:	ea 81       	ldd	r30, Y+2	; 0x02
    1d04:	fb 81       	ldd	r31, Y+3	; 0x03
    1d06:	15 8e       	std	Z+29, r1	; 0x1d
    1d08:	ea 81       	ldd	r30, Y+2	; 0x02
    1d0a:	fb 81       	ldd	r31, Y+3	; 0x03
    1d0c:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d0e:	8f 3f       	cpi	r24, 0xFF	; 255
    1d10:	19 f4       	brne	.+6      	; 0x1d18 <xQueueReceive+0xcc>
    1d12:	ea 81       	ldd	r30, Y+2	; 0x02
    1d14:	fb 81       	ldd	r31, Y+3	; 0x03
    1d16:	16 8e       	std	Z+30, r1	; 0x1e
    1d18:	0f 90       	pop	r0
    1d1a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1d1c:	ce 01       	movw	r24, r28
    1d1e:	05 96       	adiw	r24, 0x05	; 5
    1d20:	9e 01       	movw	r18, r28
    1d22:	24 5f       	subi	r18, 0xF4	; 244
    1d24:	3f 4f       	sbci	r19, 0xFF	; 255
    1d26:	b9 01       	movw	r22, r18
    1d28:	0e 94 70 19 	call	0x32e0	; 0x32e0 <xTaskCheckForTimeOut>
    1d2c:	88 23       	and	r24, r24
    1d2e:	09 f5       	brne	.+66     	; 0x1d72 <xQueueReceive+0x126>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1d30:	8a 81       	ldd	r24, Y+2	; 0x02
    1d32:	9b 81       	ldd	r25, Y+3	; 0x03
    1d34:	0e 94 63 12 	call	0x24c6	; 0x24c6 <prvIsQueueEmpty>
    1d38:	88 23       	and	r24, r24
    1d3a:	a1 f0       	breq	.+40     	; 0x1d64 <xQueueReceive+0x118>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1d3c:	8a 81       	ldd	r24, Y+2	; 0x02
    1d3e:	9b 81       	ldd	r25, Y+3	; 0x03
    1d40:	41 96       	adiw	r24, 0x11	; 17
    1d42:	2c 85       	ldd	r18, Y+12	; 0x0c
    1d44:	3d 85       	ldd	r19, Y+13	; 0x0d
    1d46:	b9 01       	movw	r22, r18
    1d48:	0e 94 1f 18 	call	0x303e	; 0x303e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1d4c:	8a 81       	ldd	r24, Y+2	; 0x02
    1d4e:	9b 81       	ldd	r25, Y+3	; 0x03
    1d50:	0e 94 10 12 	call	0x2420	; 0x2420 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1d54:	0e 94 dd 15 	call	0x2bba	; 0x2bba <xTaskResumeAll>
    1d58:	88 23       	and	r24, r24
    1d5a:	09 f0       	breq	.+2      	; 0x1d5e <xQueueReceive+0x112>
    1d5c:	8c cf       	rjmp	.-232    	; 0x1c76 <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    1d5e:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vPortYield>
    1d62:	89 cf       	rjmp	.-238    	; 0x1c76 <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    1d64:	8a 81       	ldd	r24, Y+2	; 0x02
    1d66:	9b 81       	ldd	r25, Y+3	; 0x03
    1d68:	0e 94 10 12 	call	0x2420	; 0x2420 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1d6c:	0e 94 dd 15 	call	0x2bba	; 0x2bba <xTaskResumeAll>
    1d70:	82 cf       	rjmp	.-252    	; 0x1c76 <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    1d72:	8a 81       	ldd	r24, Y+2	; 0x02
    1d74:	9b 81       	ldd	r25, Y+3	; 0x03
    1d76:	0e 94 10 12 	call	0x2420	; 0x2420 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1d7a:	0e 94 dd 15 	call	0x2bba	; 0x2bba <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1d7e:	8a 81       	ldd	r24, Y+2	; 0x02
    1d80:	9b 81       	ldd	r25, Y+3	; 0x03
    1d82:	0e 94 63 12 	call	0x24c6	; 0x24c6 <prvIsQueueEmpty>
    1d86:	88 23       	and	r24, r24
    1d88:	09 f4       	brne	.+2      	; 0x1d8c <xQueueReceive+0x140>
    1d8a:	75 cf       	rjmp	.-278    	; 0x1c76 <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1d8c:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    1d8e:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    1d90:	2e 96       	adiw	r28, 0x0e	; 14
    1d92:	0f b6       	in	r0, 0x3f	; 63
    1d94:	f8 94       	cli
    1d96:	de bf       	out	0x3e, r29	; 62
    1d98:	0f be       	out	0x3f, r0	; 63
    1d9a:	cd bf       	out	0x3d, r28	; 61
    1d9c:	cf 91       	pop	r28
    1d9e:	df 91       	pop	r29
    1da0:	08 95       	ret

00001da2 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    1da2:	df 93       	push	r29
    1da4:	cf 93       	push	r28
    1da6:	cd b7       	in	r28, 0x3d	; 61
    1da8:	de b7       	in	r29, 0x3e	; 62
    1daa:	2c 97       	sbiw	r28, 0x0c	; 12
    1dac:	0f b6       	in	r0, 0x3f	; 63
    1dae:	f8 94       	cli
    1db0:	de bf       	out	0x3e, r29	; 62
    1db2:	0f be       	out	0x3f, r0	; 63
    1db4:	cd bf       	out	0x3d, r28	; 61
    1db6:	99 87       	std	Y+9, r25	; 0x09
    1db8:	88 87       	std	Y+8, r24	; 0x08
    1dba:	7b 87       	std	Y+11, r23	; 0x0b
    1dbc:	6a 87       	std	Y+10, r22	; 0x0a
BaseType_t xEntryTimeSet = pdFALSE;
    1dbe:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    1dc0:	88 85       	ldd	r24, Y+8	; 0x08
    1dc2:	99 85       	ldd	r25, Y+9	; 0x09
    1dc4:	9b 83       	std	Y+3, r25	; 0x03
    1dc6:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1dc8:	0f b6       	in	r0, 0x3f	; 63
    1dca:	f8 94       	cli
    1dcc:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    1dce:	ea 81       	ldd	r30, Y+2	; 0x02
    1dd0:	fb 81       	ldd	r31, Y+3	; 0x03
    1dd2:	82 8d       	ldd	r24, Z+26	; 0x1a
    1dd4:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    1dd6:	89 81       	ldd	r24, Y+1	; 0x01
    1dd8:	88 23       	and	r24, r24
    1dda:	c1 f0       	breq	.+48     	; 0x1e0c <xQueueSemaphoreTake+0x6a>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    1ddc:	89 81       	ldd	r24, Y+1	; 0x01
    1dde:	81 50       	subi	r24, 0x01	; 1
    1de0:	ea 81       	ldd	r30, Y+2	; 0x02
    1de2:	fb 81       	ldd	r31, Y+3	; 0x03
    1de4:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1de6:	ea 81       	ldd	r30, Y+2	; 0x02
    1de8:	fb 81       	ldd	r31, Y+3	; 0x03
    1dea:	80 85       	ldd	r24, Z+8	; 0x08
    1dec:	88 23       	and	r24, r24
    1dee:	49 f0       	breq	.+18     	; 0x1e02 <xQueueSemaphoreTake+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1df0:	8a 81       	ldd	r24, Y+2	; 0x02
    1df2:	9b 81       	ldd	r25, Y+3	; 0x03
    1df4:	08 96       	adiw	r24, 0x08	; 8
    1df6:	0e 94 71 18 	call	0x30e2	; 0x30e2 <xTaskRemoveFromEventList>
    1dfa:	88 23       	and	r24, r24
    1dfc:	11 f0       	breq	.+4      	; 0x1e02 <xQueueSemaphoreTake+0x60>
					{
						queueYIELD_IF_USING_PREEMPTION();
    1dfe:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1e02:	0f 90       	pop	r0
    1e04:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1e06:	81 e0       	ldi	r24, 0x01	; 1
    1e08:	8c 87       	std	Y+12, r24	; 0x0c
    1e0a:	63 c0       	rjmp	.+198    	; 0x1ed2 <xQueueSemaphoreTake+0x130>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1e0c:	8a 85       	ldd	r24, Y+10	; 0x0a
    1e0e:	9b 85       	ldd	r25, Y+11	; 0x0b
    1e10:	00 97       	sbiw	r24, 0x00	; 0
    1e12:	21 f4       	brne	.+8      	; 0x1e1c <xQueueSemaphoreTake+0x7a>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    1e14:	0f 90       	pop	r0
    1e16:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1e18:	1c 86       	std	Y+12, r1	; 0x0c
    1e1a:	5b c0       	rjmp	.+182    	; 0x1ed2 <xQueueSemaphoreTake+0x130>
				}
				else if( xEntryTimeSet == pdFALSE )
    1e1c:	8c 81       	ldd	r24, Y+4	; 0x04
    1e1e:	88 23       	and	r24, r24
    1e20:	31 f4       	brne	.+12     	; 0x1e2e <xQueueSemaphoreTake+0x8c>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1e22:	ce 01       	movw	r24, r28
    1e24:	05 96       	adiw	r24, 0x05	; 5
    1e26:	0e 94 57 19 	call	0x32ae	; 0x32ae <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1e2a:	81 e0       	ldi	r24, 0x01	; 1
    1e2c:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1e2e:	0f 90       	pop	r0
    1e30:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    1e32:	0e 94 d1 15 	call	0x2ba2	; 0x2ba2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1e36:	0f b6       	in	r0, 0x3f	; 63
    1e38:	f8 94       	cli
    1e3a:	0f 92       	push	r0
    1e3c:	ea 81       	ldd	r30, Y+2	; 0x02
    1e3e:	fb 81       	ldd	r31, Y+3	; 0x03
    1e40:	85 8d       	ldd	r24, Z+29	; 0x1d
    1e42:	8f 3f       	cpi	r24, 0xFF	; 255
    1e44:	19 f4       	brne	.+6      	; 0x1e4c <xQueueSemaphoreTake+0xaa>
    1e46:	ea 81       	ldd	r30, Y+2	; 0x02
    1e48:	fb 81       	ldd	r31, Y+3	; 0x03
    1e4a:	15 8e       	std	Z+29, r1	; 0x1d
    1e4c:	ea 81       	ldd	r30, Y+2	; 0x02
    1e4e:	fb 81       	ldd	r31, Y+3	; 0x03
    1e50:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e52:	8f 3f       	cpi	r24, 0xFF	; 255
    1e54:	19 f4       	brne	.+6      	; 0x1e5c <xQueueSemaphoreTake+0xba>
    1e56:	ea 81       	ldd	r30, Y+2	; 0x02
    1e58:	fb 81       	ldd	r31, Y+3	; 0x03
    1e5a:	16 8e       	std	Z+30, r1	; 0x1e
    1e5c:	0f 90       	pop	r0
    1e5e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1e60:	ce 01       	movw	r24, r28
    1e62:	05 96       	adiw	r24, 0x05	; 5
    1e64:	9e 01       	movw	r18, r28
    1e66:	26 5f       	subi	r18, 0xF6	; 246
    1e68:	3f 4f       	sbci	r19, 0xFF	; 255
    1e6a:	b9 01       	movw	r22, r18
    1e6c:	0e 94 70 19 	call	0x32e0	; 0x32e0 <xTaskCheckForTimeOut>
    1e70:	88 23       	and	r24, r24
    1e72:	09 f5       	brne	.+66     	; 0x1eb6 <xQueueSemaphoreTake+0x114>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1e74:	8a 81       	ldd	r24, Y+2	; 0x02
    1e76:	9b 81       	ldd	r25, Y+3	; 0x03
    1e78:	0e 94 63 12 	call	0x24c6	; 0x24c6 <prvIsQueueEmpty>
    1e7c:	88 23       	and	r24, r24
    1e7e:	a1 f0       	breq	.+40     	; 0x1ea8 <xQueueSemaphoreTake+0x106>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1e80:	8a 81       	ldd	r24, Y+2	; 0x02
    1e82:	9b 81       	ldd	r25, Y+3	; 0x03
    1e84:	41 96       	adiw	r24, 0x11	; 17
    1e86:	2a 85       	ldd	r18, Y+10	; 0x0a
    1e88:	3b 85       	ldd	r19, Y+11	; 0x0b
    1e8a:	b9 01       	movw	r22, r18
    1e8c:	0e 94 1f 18 	call	0x303e	; 0x303e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1e90:	8a 81       	ldd	r24, Y+2	; 0x02
    1e92:	9b 81       	ldd	r25, Y+3	; 0x03
    1e94:	0e 94 10 12 	call	0x2420	; 0x2420 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1e98:	0e 94 dd 15 	call	0x2bba	; 0x2bba <xTaskResumeAll>
    1e9c:	88 23       	and	r24, r24
    1e9e:	09 f0       	breq	.+2      	; 0x1ea2 <xQueueSemaphoreTake+0x100>
    1ea0:	93 cf       	rjmp	.-218    	; 0x1dc8 <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    1ea2:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vPortYield>
    1ea6:	90 cf       	rjmp	.-224    	; 0x1dc8 <xQueueSemaphoreTake+0x26>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    1ea8:	8a 81       	ldd	r24, Y+2	; 0x02
    1eaa:	9b 81       	ldd	r25, Y+3	; 0x03
    1eac:	0e 94 10 12 	call	0x2420	; 0x2420 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1eb0:	0e 94 dd 15 	call	0x2bba	; 0x2bba <xTaskResumeAll>
    1eb4:	89 cf       	rjmp	.-238    	; 0x1dc8 <xQueueSemaphoreTake+0x26>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    1eb6:	8a 81       	ldd	r24, Y+2	; 0x02
    1eb8:	9b 81       	ldd	r25, Y+3	; 0x03
    1eba:	0e 94 10 12 	call	0x2420	; 0x2420 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1ebe:	0e 94 dd 15 	call	0x2bba	; 0x2bba <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1ec2:	8a 81       	ldd	r24, Y+2	; 0x02
    1ec4:	9b 81       	ldd	r25, Y+3	; 0x03
    1ec6:	0e 94 63 12 	call	0x24c6	; 0x24c6 <prvIsQueueEmpty>
    1eca:	88 23       	and	r24, r24
    1ecc:	09 f4       	brne	.+2      	; 0x1ed0 <xQueueSemaphoreTake+0x12e>
    1ece:	7c cf       	rjmp	.-264    	; 0x1dc8 <xQueueSemaphoreTake+0x26>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1ed0:	1c 86       	std	Y+12, r1	; 0x0c
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    1ed2:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    1ed4:	2c 96       	adiw	r28, 0x0c	; 12
    1ed6:	0f b6       	in	r0, 0x3f	; 63
    1ed8:	f8 94       	cli
    1eda:	de bf       	out	0x3e, r29	; 62
    1edc:	0f be       	out	0x3f, r0	; 63
    1ede:	cd bf       	out	0x3d, r28	; 61
    1ee0:	cf 91       	pop	r28
    1ee2:	df 91       	pop	r29
    1ee4:	08 95       	ret

00001ee6 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1ee6:	df 93       	push	r29
    1ee8:	cf 93       	push	r28
    1eea:	cd b7       	in	r28, 0x3d	; 61
    1eec:	de b7       	in	r29, 0x3e	; 62
    1eee:	60 97       	sbiw	r28, 0x10	; 16
    1ef0:	0f b6       	in	r0, 0x3f	; 63
    1ef2:	f8 94       	cli
    1ef4:	de bf       	out	0x3e, r29	; 62
    1ef6:	0f be       	out	0x3f, r0	; 63
    1ef8:	cd bf       	out	0x3d, r28	; 61
    1efa:	9b 87       	std	Y+11, r25	; 0x0b
    1efc:	8a 87       	std	Y+10, r24	; 0x0a
    1efe:	7d 87       	std	Y+13, r23	; 0x0d
    1f00:	6c 87       	std	Y+12, r22	; 0x0c
    1f02:	5f 87       	std	Y+15, r21	; 0x0f
    1f04:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    1f06:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    1f08:	8a 85       	ldd	r24, Y+10	; 0x0a
    1f0a:	9b 85       	ldd	r25, Y+11	; 0x0b
    1f0c:	9b 83       	std	Y+3, r25	; 0x03
    1f0e:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1f10:	0f b6       	in	r0, 0x3f	; 63
    1f12:	f8 94       	cli
    1f14:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1f16:	ea 81       	ldd	r30, Y+2	; 0x02
    1f18:	fb 81       	ldd	r31, Y+3	; 0x03
    1f1a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f1c:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1f1e:	89 81       	ldd	r24, Y+1	; 0x01
    1f20:	88 23       	and	r24, r24
    1f22:	31 f1       	breq	.+76     	; 0x1f70 <xQueuePeek+0x8a>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1f24:	ea 81       	ldd	r30, Y+2	; 0x02
    1f26:	fb 81       	ldd	r31, Y+3	; 0x03
    1f28:	86 81       	ldd	r24, Z+6	; 0x06
    1f2a:	97 81       	ldd	r25, Z+7	; 0x07
    1f2c:	9d 83       	std	Y+5, r25	; 0x05
    1f2e:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1f30:	8a 81       	ldd	r24, Y+2	; 0x02
    1f32:	9b 81       	ldd	r25, Y+3	; 0x03
    1f34:	2c 85       	ldd	r18, Y+12	; 0x0c
    1f36:	3d 85       	ldd	r19, Y+13	; 0x0d
    1f38:	b9 01       	movw	r22, r18
    1f3a:	0e 94 c9 11 	call	0x2392	; 0x2392 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1f3e:	ea 81       	ldd	r30, Y+2	; 0x02
    1f40:	fb 81       	ldd	r31, Y+3	; 0x03
    1f42:	8c 81       	ldd	r24, Y+4	; 0x04
    1f44:	9d 81       	ldd	r25, Y+5	; 0x05
    1f46:	97 83       	std	Z+7, r25	; 0x07
    1f48:	86 83       	std	Z+6, r24	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1f4a:	ea 81       	ldd	r30, Y+2	; 0x02
    1f4c:	fb 81       	ldd	r31, Y+3	; 0x03
    1f4e:	81 89       	ldd	r24, Z+17	; 0x11
    1f50:	88 23       	and	r24, r24
    1f52:	49 f0       	breq	.+18     	; 0x1f66 <xQueuePeek+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1f54:	8a 81       	ldd	r24, Y+2	; 0x02
    1f56:	9b 81       	ldd	r25, Y+3	; 0x03
    1f58:	41 96       	adiw	r24, 0x11	; 17
    1f5a:	0e 94 71 18 	call	0x30e2	; 0x30e2 <xTaskRemoveFromEventList>
    1f5e:	88 23       	and	r24, r24
    1f60:	11 f0       	breq	.+4      	; 0x1f66 <xQueuePeek+0x80>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    1f62:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1f66:	0f 90       	pop	r0
    1f68:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1f6a:	81 e0       	ldi	r24, 0x01	; 1
    1f6c:	88 8b       	std	Y+16, r24	; 0x10
    1f6e:	63 c0       	rjmp	.+198    	; 0x2036 <xQueuePeek+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1f70:	8e 85       	ldd	r24, Y+14	; 0x0e
    1f72:	9f 85       	ldd	r25, Y+15	; 0x0f
    1f74:	00 97       	sbiw	r24, 0x00	; 0
    1f76:	21 f4       	brne	.+8      	; 0x1f80 <xQueuePeek+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1f78:	0f 90       	pop	r0
    1f7a:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1f7c:	18 8a       	std	Y+16, r1	; 0x10
    1f7e:	5b c0       	rjmp	.+182    	; 0x2036 <xQueuePeek+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    1f80:	8e 81       	ldd	r24, Y+6	; 0x06
    1f82:	88 23       	and	r24, r24
    1f84:	31 f4       	brne	.+12     	; 0x1f92 <xQueuePeek+0xac>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1f86:	ce 01       	movw	r24, r28
    1f88:	07 96       	adiw	r24, 0x07	; 7
    1f8a:	0e 94 57 19 	call	0x32ae	; 0x32ae <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1f8e:	81 e0       	ldi	r24, 0x01	; 1
    1f90:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1f92:	0f 90       	pop	r0
    1f94:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1f96:	0e 94 d1 15 	call	0x2ba2	; 0x2ba2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1f9a:	0f b6       	in	r0, 0x3f	; 63
    1f9c:	f8 94       	cli
    1f9e:	0f 92       	push	r0
    1fa0:	ea 81       	ldd	r30, Y+2	; 0x02
    1fa2:	fb 81       	ldd	r31, Y+3	; 0x03
    1fa4:	85 8d       	ldd	r24, Z+29	; 0x1d
    1fa6:	8f 3f       	cpi	r24, 0xFF	; 255
    1fa8:	19 f4       	brne	.+6      	; 0x1fb0 <xQueuePeek+0xca>
    1faa:	ea 81       	ldd	r30, Y+2	; 0x02
    1fac:	fb 81       	ldd	r31, Y+3	; 0x03
    1fae:	15 8e       	std	Z+29, r1	; 0x1d
    1fb0:	ea 81       	ldd	r30, Y+2	; 0x02
    1fb2:	fb 81       	ldd	r31, Y+3	; 0x03
    1fb4:	86 8d       	ldd	r24, Z+30	; 0x1e
    1fb6:	8f 3f       	cpi	r24, 0xFF	; 255
    1fb8:	19 f4       	brne	.+6      	; 0x1fc0 <xQueuePeek+0xda>
    1fba:	ea 81       	ldd	r30, Y+2	; 0x02
    1fbc:	fb 81       	ldd	r31, Y+3	; 0x03
    1fbe:	16 8e       	std	Z+30, r1	; 0x1e
    1fc0:	0f 90       	pop	r0
    1fc2:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1fc4:	ce 01       	movw	r24, r28
    1fc6:	07 96       	adiw	r24, 0x07	; 7
    1fc8:	9e 01       	movw	r18, r28
    1fca:	22 5f       	subi	r18, 0xF2	; 242
    1fcc:	3f 4f       	sbci	r19, 0xFF	; 255
    1fce:	b9 01       	movw	r22, r18
    1fd0:	0e 94 70 19 	call	0x32e0	; 0x32e0 <xTaskCheckForTimeOut>
    1fd4:	88 23       	and	r24, r24
    1fd6:	09 f5       	brne	.+66     	; 0x201a <xQueuePeek+0x134>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1fd8:	8a 81       	ldd	r24, Y+2	; 0x02
    1fda:	9b 81       	ldd	r25, Y+3	; 0x03
    1fdc:	0e 94 63 12 	call	0x24c6	; 0x24c6 <prvIsQueueEmpty>
    1fe0:	88 23       	and	r24, r24
    1fe2:	a1 f0       	breq	.+40     	; 0x200c <xQueuePeek+0x126>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1fe4:	8a 81       	ldd	r24, Y+2	; 0x02
    1fe6:	9b 81       	ldd	r25, Y+3	; 0x03
    1fe8:	41 96       	adiw	r24, 0x11	; 17
    1fea:	2e 85       	ldd	r18, Y+14	; 0x0e
    1fec:	3f 85       	ldd	r19, Y+15	; 0x0f
    1fee:	b9 01       	movw	r22, r18
    1ff0:	0e 94 1f 18 	call	0x303e	; 0x303e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1ff4:	8a 81       	ldd	r24, Y+2	; 0x02
    1ff6:	9b 81       	ldd	r25, Y+3	; 0x03
    1ff8:	0e 94 10 12 	call	0x2420	; 0x2420 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1ffc:	0e 94 dd 15 	call	0x2bba	; 0x2bba <xTaskResumeAll>
    2000:	88 23       	and	r24, r24
    2002:	09 f0       	breq	.+2      	; 0x2006 <xQueuePeek+0x120>
    2004:	85 cf       	rjmp	.-246    	; 0x1f10 <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    2006:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vPortYield>
    200a:	82 cf       	rjmp	.-252    	; 0x1f10 <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    200c:	8a 81       	ldd	r24, Y+2	; 0x02
    200e:	9b 81       	ldd	r25, Y+3	; 0x03
    2010:	0e 94 10 12 	call	0x2420	; 0x2420 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2014:	0e 94 dd 15 	call	0x2bba	; 0x2bba <xTaskResumeAll>
    2018:	7b cf       	rjmp	.-266    	; 0x1f10 <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    201a:	8a 81       	ldd	r24, Y+2	; 0x02
    201c:	9b 81       	ldd	r25, Y+3	; 0x03
    201e:	0e 94 10 12 	call	0x2420	; 0x2420 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2022:	0e 94 dd 15 	call	0x2bba	; 0x2bba <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2026:	8a 81       	ldd	r24, Y+2	; 0x02
    2028:	9b 81       	ldd	r25, Y+3	; 0x03
    202a:	0e 94 63 12 	call	0x24c6	; 0x24c6 <prvIsQueueEmpty>
    202e:	88 23       	and	r24, r24
    2030:	09 f4       	brne	.+2      	; 0x2034 <xQueuePeek+0x14e>
    2032:	6e cf       	rjmp	.-292    	; 0x1f10 <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    2034:	18 8a       	std	Y+16, r1	; 0x10
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    2036:	88 89       	ldd	r24, Y+16	; 0x10
}
    2038:	60 96       	adiw	r28, 0x10	; 16
    203a:	0f b6       	in	r0, 0x3f	; 63
    203c:	f8 94       	cli
    203e:	de bf       	out	0x3e, r29	; 62
    2040:	0f be       	out	0x3f, r0	; 63
    2042:	cd bf       	out	0x3d, r28	; 61
    2044:	cf 91       	pop	r28
    2046:	df 91       	pop	r29
    2048:	08 95       	ret

0000204a <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    204a:	df 93       	push	r29
    204c:	cf 93       	push	r28
    204e:	cd b7       	in	r28, 0x3d	; 61
    2050:	de b7       	in	r29, 0x3e	; 62
    2052:	2c 97       	sbiw	r28, 0x0c	; 12
    2054:	0f b6       	in	r0, 0x3f	; 63
    2056:	f8 94       	cli
    2058:	de bf       	out	0x3e, r29	; 62
    205a:	0f be       	out	0x3f, r0	; 63
    205c:	cd bf       	out	0x3d, r28	; 61
    205e:	98 87       	std	Y+8, r25	; 0x08
    2060:	8f 83       	std	Y+7, r24	; 0x07
    2062:	7a 87       	std	Y+10, r23	; 0x0a
    2064:	69 87       	std	Y+9, r22	; 0x09
    2066:	5c 87       	std	Y+12, r21	; 0x0c
    2068:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    206a:	8f 81       	ldd	r24, Y+7	; 0x07
    206c:	98 85       	ldd	r25, Y+8	; 0x08
    206e:	9c 83       	std	Y+4, r25	; 0x04
    2070:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2072:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2074:	eb 81       	ldd	r30, Y+3	; 0x03
    2076:	fc 81       	ldd	r31, Y+4	; 0x04
    2078:	82 8d       	ldd	r24, Z+26	; 0x1a
    207a:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    207c:	8a 81       	ldd	r24, Y+2	; 0x02
    207e:	88 23       	and	r24, r24
    2080:	81 f1       	breq	.+96     	; 0x20e2 <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    2082:	eb 81       	ldd	r30, Y+3	; 0x03
    2084:	fc 81       	ldd	r31, Y+4	; 0x04
    2086:	85 8d       	ldd	r24, Z+29	; 0x1d
    2088:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    208a:	8b 81       	ldd	r24, Y+3	; 0x03
    208c:	9c 81       	ldd	r25, Y+4	; 0x04
    208e:	29 85       	ldd	r18, Y+9	; 0x09
    2090:	3a 85       	ldd	r19, Y+10	; 0x0a
    2092:	b9 01       	movw	r22, r18
    2094:	0e 94 c9 11 	call	0x2392	; 0x2392 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    2098:	8a 81       	ldd	r24, Y+2	; 0x02
    209a:	81 50       	subi	r24, 0x01	; 1
    209c:	eb 81       	ldd	r30, Y+3	; 0x03
    209e:	fc 81       	ldd	r31, Y+4	; 0x04
    20a0:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    20a2:	89 81       	ldd	r24, Y+1	; 0x01
    20a4:	8f 3f       	cpi	r24, 0xFF	; 255
    20a6:	a9 f4       	brne	.+42     	; 0x20d2 <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    20a8:	eb 81       	ldd	r30, Y+3	; 0x03
    20aa:	fc 81       	ldd	r31, Y+4	; 0x04
    20ac:	80 85       	ldd	r24, Z+8	; 0x08
    20ae:	88 23       	and	r24, r24
    20b0:	a9 f0       	breq	.+42     	; 0x20dc <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    20b2:	8b 81       	ldd	r24, Y+3	; 0x03
    20b4:	9c 81       	ldd	r25, Y+4	; 0x04
    20b6:	08 96       	adiw	r24, 0x08	; 8
    20b8:	0e 94 71 18 	call	0x30e2	; 0x30e2 <xTaskRemoveFromEventList>
    20bc:	88 23       	and	r24, r24
    20be:	71 f0       	breq	.+28     	; 0x20dc <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    20c0:	8b 85       	ldd	r24, Y+11	; 0x0b
    20c2:	9c 85       	ldd	r25, Y+12	; 0x0c
    20c4:	00 97       	sbiw	r24, 0x00	; 0
    20c6:	51 f0       	breq	.+20     	; 0x20dc <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    20c8:	eb 85       	ldd	r30, Y+11	; 0x0b
    20ca:	fc 85       	ldd	r31, Y+12	; 0x0c
    20cc:	81 e0       	ldi	r24, 0x01	; 1
    20ce:	80 83       	st	Z, r24
    20d0:	05 c0       	rjmp	.+10     	; 0x20dc <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    20d2:	89 81       	ldd	r24, Y+1	; 0x01
    20d4:	8f 5f       	subi	r24, 0xFF	; 255
    20d6:	eb 81       	ldd	r30, Y+3	; 0x03
    20d8:	fc 81       	ldd	r31, Y+4	; 0x04
    20da:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    20dc:	81 e0       	ldi	r24, 0x01	; 1
    20de:	8e 83       	std	Y+6, r24	; 0x06
    20e0:	01 c0       	rjmp	.+2      	; 0x20e4 <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    20e2:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    20e4:	8e 81       	ldd	r24, Y+6	; 0x06
}
    20e6:	2c 96       	adiw	r28, 0x0c	; 12
    20e8:	0f b6       	in	r0, 0x3f	; 63
    20ea:	f8 94       	cli
    20ec:	de bf       	out	0x3e, r29	; 62
    20ee:	0f be       	out	0x3f, r0	; 63
    20f0:	cd bf       	out	0x3d, r28	; 61
    20f2:	cf 91       	pop	r28
    20f4:	df 91       	pop	r29
    20f6:	08 95       	ret

000020f8 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    20f8:	df 93       	push	r29
    20fa:	cf 93       	push	r28
    20fc:	cd b7       	in	r28, 0x3d	; 61
    20fe:	de b7       	in	r29, 0x3e	; 62
    2100:	2a 97       	sbiw	r28, 0x0a	; 10
    2102:	0f b6       	in	r0, 0x3f	; 63
    2104:	f8 94       	cli
    2106:	de bf       	out	0x3e, r29	; 62
    2108:	0f be       	out	0x3f, r0	; 63
    210a:	cd bf       	out	0x3d, r28	; 61
    210c:	98 87       	std	Y+8, r25	; 0x08
    210e:	8f 83       	std	Y+7, r24	; 0x07
    2110:	7a 87       	std	Y+10, r23	; 0x0a
    2112:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    2114:	8f 81       	ldd	r24, Y+7	; 0x07
    2116:	98 85       	ldd	r25, Y+8	; 0x08
    2118:	9a 83       	std	Y+2, r25	; 0x02
    211a:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    211c:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    211e:	e9 81       	ldd	r30, Y+1	; 0x01
    2120:	fa 81       	ldd	r31, Y+2	; 0x02
    2122:	82 8d       	ldd	r24, Z+26	; 0x1a
    2124:	88 23       	and	r24, r24
    2126:	b1 f0       	breq	.+44     	; 0x2154 <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2128:	e9 81       	ldd	r30, Y+1	; 0x01
    212a:	fa 81       	ldd	r31, Y+2	; 0x02
    212c:	86 81       	ldd	r24, Z+6	; 0x06
    212e:	97 81       	ldd	r25, Z+7	; 0x07
    2130:	9c 83       	std	Y+4, r25	; 0x04
    2132:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2134:	89 81       	ldd	r24, Y+1	; 0x01
    2136:	9a 81       	ldd	r25, Y+2	; 0x02
    2138:	29 85       	ldd	r18, Y+9	; 0x09
    213a:	3a 85       	ldd	r19, Y+10	; 0x0a
    213c:	b9 01       	movw	r22, r18
    213e:	0e 94 c9 11 	call	0x2392	; 0x2392 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2142:	e9 81       	ldd	r30, Y+1	; 0x01
    2144:	fa 81       	ldd	r31, Y+2	; 0x02
    2146:	8b 81       	ldd	r24, Y+3	; 0x03
    2148:	9c 81       	ldd	r25, Y+4	; 0x04
    214a:	97 83       	std	Z+7, r25	; 0x07
    214c:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    214e:	81 e0       	ldi	r24, 0x01	; 1
    2150:	8e 83       	std	Y+6, r24	; 0x06
    2152:	01 c0       	rjmp	.+2      	; 0x2156 <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    2154:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2156:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2158:	2a 96       	adiw	r28, 0x0a	; 10
    215a:	0f b6       	in	r0, 0x3f	; 63
    215c:	f8 94       	cli
    215e:	de bf       	out	0x3e, r29	; 62
    2160:	0f be       	out	0x3f, r0	; 63
    2162:	cd bf       	out	0x3d, r28	; 61
    2164:	cf 91       	pop	r28
    2166:	df 91       	pop	r29
    2168:	08 95       	ret

0000216a <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    216a:	df 93       	push	r29
    216c:	cf 93       	push	r28
    216e:	00 d0       	rcall	.+0      	; 0x2170 <uxQueueMessagesWaiting+0x6>
    2170:	0f 92       	push	r0
    2172:	cd b7       	in	r28, 0x3d	; 61
    2174:	de b7       	in	r29, 0x3e	; 62
    2176:	9b 83       	std	Y+3, r25	; 0x03
    2178:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    217a:	0f b6       	in	r0, 0x3f	; 63
    217c:	f8 94       	cli
    217e:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    2180:	ea 81       	ldd	r30, Y+2	; 0x02
    2182:	fb 81       	ldd	r31, Y+3	; 0x03
    2184:	82 8d       	ldd	r24, Z+26	; 0x1a
    2186:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    2188:	0f 90       	pop	r0
    218a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    218c:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    218e:	0f 90       	pop	r0
    2190:	0f 90       	pop	r0
    2192:	0f 90       	pop	r0
    2194:	cf 91       	pop	r28
    2196:	df 91       	pop	r29
    2198:	08 95       	ret

0000219a <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    219a:	df 93       	push	r29
    219c:	cf 93       	push	r28
    219e:	00 d0       	rcall	.+0      	; 0x21a0 <uxQueueSpacesAvailable+0x6>
    21a0:	00 d0       	rcall	.+0      	; 0x21a2 <uxQueueSpacesAvailable+0x8>
    21a2:	0f 92       	push	r0
    21a4:	cd b7       	in	r28, 0x3d	; 61
    21a6:	de b7       	in	r29, 0x3e	; 62
    21a8:	9d 83       	std	Y+5, r25	; 0x05
    21aa:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    21ac:	8c 81       	ldd	r24, Y+4	; 0x04
    21ae:	9d 81       	ldd	r25, Y+5	; 0x05
    21b0:	9a 83       	std	Y+2, r25	; 0x02
    21b2:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    21b4:	0f b6       	in	r0, 0x3f	; 63
    21b6:	f8 94       	cli
    21b8:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    21ba:	e9 81       	ldd	r30, Y+1	; 0x01
    21bc:	fa 81       	ldd	r31, Y+2	; 0x02
    21be:	93 8d       	ldd	r25, Z+27	; 0x1b
    21c0:	e9 81       	ldd	r30, Y+1	; 0x01
    21c2:	fa 81       	ldd	r31, Y+2	; 0x02
    21c4:	82 8d       	ldd	r24, Z+26	; 0x1a
    21c6:	29 2f       	mov	r18, r25
    21c8:	28 1b       	sub	r18, r24
    21ca:	82 2f       	mov	r24, r18
    21cc:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    21ce:	0f 90       	pop	r0
    21d0:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    21d2:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    21d4:	0f 90       	pop	r0
    21d6:	0f 90       	pop	r0
    21d8:	0f 90       	pop	r0
    21da:	0f 90       	pop	r0
    21dc:	0f 90       	pop	r0
    21de:	cf 91       	pop	r28
    21e0:	df 91       	pop	r29
    21e2:	08 95       	ret

000021e4 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    21e4:	df 93       	push	r29
    21e6:	cf 93       	push	r28
    21e8:	00 d0       	rcall	.+0      	; 0x21ea <uxQueueMessagesWaitingFromISR+0x6>
    21ea:	00 d0       	rcall	.+0      	; 0x21ec <uxQueueMessagesWaitingFromISR+0x8>
    21ec:	0f 92       	push	r0
    21ee:	cd b7       	in	r28, 0x3d	; 61
    21f0:	de b7       	in	r29, 0x3e	; 62
    21f2:	9d 83       	std	Y+5, r25	; 0x05
    21f4:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    21f6:	8c 81       	ldd	r24, Y+4	; 0x04
    21f8:	9d 81       	ldd	r25, Y+5	; 0x05
    21fa:	9a 83       	std	Y+2, r25	; 0x02
    21fc:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    21fe:	e9 81       	ldd	r30, Y+1	; 0x01
    2200:	fa 81       	ldd	r31, Y+2	; 0x02
    2202:	82 8d       	ldd	r24, Z+26	; 0x1a
    2204:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    2206:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2208:	0f 90       	pop	r0
    220a:	0f 90       	pop	r0
    220c:	0f 90       	pop	r0
    220e:	0f 90       	pop	r0
    2210:	0f 90       	pop	r0
    2212:	cf 91       	pop	r28
    2214:	df 91       	pop	r29
    2216:	08 95       	ret

00002218 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    2218:	df 93       	push	r29
    221a:	cf 93       	push	r28
    221c:	00 d0       	rcall	.+0      	; 0x221e <vQueueDelete+0x6>
    221e:	00 d0       	rcall	.+0      	; 0x2220 <vQueueDelete+0x8>
    2220:	cd b7       	in	r28, 0x3d	; 61
    2222:	de b7       	in	r29, 0x3e	; 62
    2224:	9c 83       	std	Y+4, r25	; 0x04
    2226:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    2228:	8b 81       	ldd	r24, Y+3	; 0x03
    222a:	9c 81       	ldd	r25, Y+4	; 0x04
    222c:	9a 83       	std	Y+2, r25	; 0x02
    222e:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    2230:	89 81       	ldd	r24, Y+1	; 0x01
    2232:	9a 81       	ldd	r25, Y+2	; 0x02
    2234:	0e 94 05 07 	call	0xe0a	; 0xe0a <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    2238:	0f 90       	pop	r0
    223a:	0f 90       	pop	r0
    223c:	0f 90       	pop	r0
    223e:	0f 90       	pop	r0
    2240:	cf 91       	pop	r28
    2242:	df 91       	pop	r29
    2244:	08 95       	ret

00002246 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    2246:	df 93       	push	r29
    2248:	cf 93       	push	r28
    224a:	cd b7       	in	r28, 0x3d	; 61
    224c:	de b7       	in	r29, 0x3e	; 62
    224e:	27 97       	sbiw	r28, 0x07	; 7
    2250:	0f b6       	in	r0, 0x3f	; 63
    2252:	f8 94       	cli
    2254:	de bf       	out	0x3e, r29	; 62
    2256:	0f be       	out	0x3f, r0	; 63
    2258:	cd bf       	out	0x3d, r28	; 61
    225a:	9c 83       	std	Y+4, r25	; 0x04
    225c:	8b 83       	std	Y+3, r24	; 0x03
    225e:	7e 83       	std	Y+6, r23	; 0x06
    2260:	6d 83       	std	Y+5, r22	; 0x05
    2262:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    2264:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2266:	eb 81       	ldd	r30, Y+3	; 0x03
    2268:	fc 81       	ldd	r31, Y+4	; 0x04
    226a:	82 8d       	ldd	r24, Z+26	; 0x1a
    226c:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    226e:	eb 81       	ldd	r30, Y+3	; 0x03
    2270:	fc 81       	ldd	r31, Y+4	; 0x04
    2272:	84 8d       	ldd	r24, Z+28	; 0x1c
    2274:	88 23       	and	r24, r24
    2276:	09 f4       	brne	.+2      	; 0x227a <prvCopyDataToQueue+0x34>
    2278:	7d c0       	rjmp	.+250    	; 0x2374 <prvCopyDataToQueue+0x12e>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    227a:	8f 81       	ldd	r24, Y+7	; 0x07
    227c:	88 23       	and	r24, r24
    227e:	99 f5       	brne	.+102    	; 0x22e6 <prvCopyDataToQueue+0xa0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2280:	eb 81       	ldd	r30, Y+3	; 0x03
    2282:	fc 81       	ldd	r31, Y+4	; 0x04
    2284:	62 81       	ldd	r22, Z+2	; 0x02
    2286:	73 81       	ldd	r23, Z+3	; 0x03
    2288:	eb 81       	ldd	r30, Y+3	; 0x03
    228a:	fc 81       	ldd	r31, Y+4	; 0x04
    228c:	84 8d       	ldd	r24, Z+28	; 0x1c
    228e:	48 2f       	mov	r20, r24
    2290:	50 e0       	ldi	r21, 0x00	; 0
    2292:	2d 81       	ldd	r18, Y+5	; 0x05
    2294:	3e 81       	ldd	r19, Y+6	; 0x06
    2296:	cb 01       	movw	r24, r22
    2298:	b9 01       	movw	r22, r18
    229a:	0e 94 c9 1e 	call	0x3d92	; 0x3d92 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    229e:	eb 81       	ldd	r30, Y+3	; 0x03
    22a0:	fc 81       	ldd	r31, Y+4	; 0x04
    22a2:	22 81       	ldd	r18, Z+2	; 0x02
    22a4:	33 81       	ldd	r19, Z+3	; 0x03
    22a6:	eb 81       	ldd	r30, Y+3	; 0x03
    22a8:	fc 81       	ldd	r31, Y+4	; 0x04
    22aa:	84 8d       	ldd	r24, Z+28	; 0x1c
    22ac:	88 2f       	mov	r24, r24
    22ae:	90 e0       	ldi	r25, 0x00	; 0
    22b0:	82 0f       	add	r24, r18
    22b2:	93 1f       	adc	r25, r19
    22b4:	eb 81       	ldd	r30, Y+3	; 0x03
    22b6:	fc 81       	ldd	r31, Y+4	; 0x04
    22b8:	93 83       	std	Z+3, r25	; 0x03
    22ba:	82 83       	std	Z+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    22bc:	eb 81       	ldd	r30, Y+3	; 0x03
    22be:	fc 81       	ldd	r31, Y+4	; 0x04
    22c0:	22 81       	ldd	r18, Z+2	; 0x02
    22c2:	33 81       	ldd	r19, Z+3	; 0x03
    22c4:	eb 81       	ldd	r30, Y+3	; 0x03
    22c6:	fc 81       	ldd	r31, Y+4	; 0x04
    22c8:	84 81       	ldd	r24, Z+4	; 0x04
    22ca:	95 81       	ldd	r25, Z+5	; 0x05
    22cc:	28 17       	cp	r18, r24
    22ce:	39 07       	cpc	r19, r25
    22d0:	08 f4       	brcc	.+2      	; 0x22d4 <prvCopyDataToQueue+0x8e>
    22d2:	50 c0       	rjmp	.+160    	; 0x2374 <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    22d4:	eb 81       	ldd	r30, Y+3	; 0x03
    22d6:	fc 81       	ldd	r31, Y+4	; 0x04
    22d8:	80 81       	ld	r24, Z
    22da:	91 81       	ldd	r25, Z+1	; 0x01
    22dc:	eb 81       	ldd	r30, Y+3	; 0x03
    22de:	fc 81       	ldd	r31, Y+4	; 0x04
    22e0:	93 83       	std	Z+3, r25	; 0x03
    22e2:	82 83       	std	Z+2, r24	; 0x02
    22e4:	47 c0       	rjmp	.+142    	; 0x2374 <prvCopyDataToQueue+0x12e>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    22e6:	eb 81       	ldd	r30, Y+3	; 0x03
    22e8:	fc 81       	ldd	r31, Y+4	; 0x04
    22ea:	66 81       	ldd	r22, Z+6	; 0x06
    22ec:	77 81       	ldd	r23, Z+7	; 0x07
    22ee:	eb 81       	ldd	r30, Y+3	; 0x03
    22f0:	fc 81       	ldd	r31, Y+4	; 0x04
    22f2:	84 8d       	ldd	r24, Z+28	; 0x1c
    22f4:	48 2f       	mov	r20, r24
    22f6:	50 e0       	ldi	r21, 0x00	; 0
    22f8:	2d 81       	ldd	r18, Y+5	; 0x05
    22fa:	3e 81       	ldd	r19, Y+6	; 0x06
    22fc:	cb 01       	movw	r24, r22
    22fe:	b9 01       	movw	r22, r18
    2300:	0e 94 c9 1e 	call	0x3d92	; 0x3d92 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    2304:	eb 81       	ldd	r30, Y+3	; 0x03
    2306:	fc 81       	ldd	r31, Y+4	; 0x04
    2308:	26 81       	ldd	r18, Z+6	; 0x06
    230a:	37 81       	ldd	r19, Z+7	; 0x07
    230c:	eb 81       	ldd	r30, Y+3	; 0x03
    230e:	fc 81       	ldd	r31, Y+4	; 0x04
    2310:	84 8d       	ldd	r24, Z+28	; 0x1c
    2312:	88 2f       	mov	r24, r24
    2314:	90 e0       	ldi	r25, 0x00	; 0
    2316:	90 95       	com	r25
    2318:	81 95       	neg	r24
    231a:	9f 4f       	sbci	r25, 0xFF	; 255
    231c:	82 0f       	add	r24, r18
    231e:	93 1f       	adc	r25, r19
    2320:	eb 81       	ldd	r30, Y+3	; 0x03
    2322:	fc 81       	ldd	r31, Y+4	; 0x04
    2324:	97 83       	std	Z+7, r25	; 0x07
    2326:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2328:	eb 81       	ldd	r30, Y+3	; 0x03
    232a:	fc 81       	ldd	r31, Y+4	; 0x04
    232c:	26 81       	ldd	r18, Z+6	; 0x06
    232e:	37 81       	ldd	r19, Z+7	; 0x07
    2330:	eb 81       	ldd	r30, Y+3	; 0x03
    2332:	fc 81       	ldd	r31, Y+4	; 0x04
    2334:	80 81       	ld	r24, Z
    2336:	91 81       	ldd	r25, Z+1	; 0x01
    2338:	28 17       	cp	r18, r24
    233a:	39 07       	cpc	r19, r25
    233c:	90 f4       	brcc	.+36     	; 0x2362 <prvCopyDataToQueue+0x11c>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    233e:	eb 81       	ldd	r30, Y+3	; 0x03
    2340:	fc 81       	ldd	r31, Y+4	; 0x04
    2342:	24 81       	ldd	r18, Z+4	; 0x04
    2344:	35 81       	ldd	r19, Z+5	; 0x05
    2346:	eb 81       	ldd	r30, Y+3	; 0x03
    2348:	fc 81       	ldd	r31, Y+4	; 0x04
    234a:	84 8d       	ldd	r24, Z+28	; 0x1c
    234c:	88 2f       	mov	r24, r24
    234e:	90 e0       	ldi	r25, 0x00	; 0
    2350:	90 95       	com	r25
    2352:	81 95       	neg	r24
    2354:	9f 4f       	sbci	r25, 0xFF	; 255
    2356:	82 0f       	add	r24, r18
    2358:	93 1f       	adc	r25, r19
    235a:	eb 81       	ldd	r30, Y+3	; 0x03
    235c:	fc 81       	ldd	r31, Y+4	; 0x04
    235e:	97 83       	std	Z+7, r25	; 0x07
    2360:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    2362:	8f 81       	ldd	r24, Y+7	; 0x07
    2364:	82 30       	cpi	r24, 0x02	; 2
    2366:	31 f4       	brne	.+12     	; 0x2374 <prvCopyDataToQueue+0x12e>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2368:	89 81       	ldd	r24, Y+1	; 0x01
    236a:	88 23       	and	r24, r24
    236c:	19 f0       	breq	.+6      	; 0x2374 <prvCopyDataToQueue+0x12e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    236e:	89 81       	ldd	r24, Y+1	; 0x01
    2370:	81 50       	subi	r24, 0x01	; 1
    2372:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    2374:	89 81       	ldd	r24, Y+1	; 0x01
    2376:	8f 5f       	subi	r24, 0xFF	; 255
    2378:	eb 81       	ldd	r30, Y+3	; 0x03
    237a:	fc 81       	ldd	r31, Y+4	; 0x04
    237c:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    237e:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2380:	27 96       	adiw	r28, 0x07	; 7
    2382:	0f b6       	in	r0, 0x3f	; 63
    2384:	f8 94       	cli
    2386:	de bf       	out	0x3e, r29	; 62
    2388:	0f be       	out	0x3f, r0	; 63
    238a:	cd bf       	out	0x3d, r28	; 61
    238c:	cf 91       	pop	r28
    238e:	df 91       	pop	r29
    2390:	08 95       	ret

00002392 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    2392:	df 93       	push	r29
    2394:	cf 93       	push	r28
    2396:	00 d0       	rcall	.+0      	; 0x2398 <prvCopyDataFromQueue+0x6>
    2398:	00 d0       	rcall	.+0      	; 0x239a <prvCopyDataFromQueue+0x8>
    239a:	cd b7       	in	r28, 0x3d	; 61
    239c:	de b7       	in	r29, 0x3e	; 62
    239e:	9a 83       	std	Y+2, r25	; 0x02
    23a0:	89 83       	std	Y+1, r24	; 0x01
    23a2:	7c 83       	std	Y+4, r23	; 0x04
    23a4:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    23a6:	e9 81       	ldd	r30, Y+1	; 0x01
    23a8:	fa 81       	ldd	r31, Y+2	; 0x02
    23aa:	84 8d       	ldd	r24, Z+28	; 0x1c
    23ac:	88 23       	and	r24, r24
    23ae:	89 f1       	breq	.+98     	; 0x2412 <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    23b0:	e9 81       	ldd	r30, Y+1	; 0x01
    23b2:	fa 81       	ldd	r31, Y+2	; 0x02
    23b4:	26 81       	ldd	r18, Z+6	; 0x06
    23b6:	37 81       	ldd	r19, Z+7	; 0x07
    23b8:	e9 81       	ldd	r30, Y+1	; 0x01
    23ba:	fa 81       	ldd	r31, Y+2	; 0x02
    23bc:	84 8d       	ldd	r24, Z+28	; 0x1c
    23be:	88 2f       	mov	r24, r24
    23c0:	90 e0       	ldi	r25, 0x00	; 0
    23c2:	82 0f       	add	r24, r18
    23c4:	93 1f       	adc	r25, r19
    23c6:	e9 81       	ldd	r30, Y+1	; 0x01
    23c8:	fa 81       	ldd	r31, Y+2	; 0x02
    23ca:	97 83       	std	Z+7, r25	; 0x07
    23cc:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    23ce:	e9 81       	ldd	r30, Y+1	; 0x01
    23d0:	fa 81       	ldd	r31, Y+2	; 0x02
    23d2:	26 81       	ldd	r18, Z+6	; 0x06
    23d4:	37 81       	ldd	r19, Z+7	; 0x07
    23d6:	e9 81       	ldd	r30, Y+1	; 0x01
    23d8:	fa 81       	ldd	r31, Y+2	; 0x02
    23da:	84 81       	ldd	r24, Z+4	; 0x04
    23dc:	95 81       	ldd	r25, Z+5	; 0x05
    23de:	28 17       	cp	r18, r24
    23e0:	39 07       	cpc	r19, r25
    23e2:	40 f0       	brcs	.+16     	; 0x23f4 <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    23e4:	e9 81       	ldd	r30, Y+1	; 0x01
    23e6:	fa 81       	ldd	r31, Y+2	; 0x02
    23e8:	80 81       	ld	r24, Z
    23ea:	91 81       	ldd	r25, Z+1	; 0x01
    23ec:	e9 81       	ldd	r30, Y+1	; 0x01
    23ee:	fa 81       	ldd	r31, Y+2	; 0x02
    23f0:	97 83       	std	Z+7, r25	; 0x07
    23f2:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    23f4:	e9 81       	ldd	r30, Y+1	; 0x01
    23f6:	fa 81       	ldd	r31, Y+2	; 0x02
    23f8:	46 81       	ldd	r20, Z+6	; 0x06
    23fa:	57 81       	ldd	r21, Z+7	; 0x07
    23fc:	e9 81       	ldd	r30, Y+1	; 0x01
    23fe:	fa 81       	ldd	r31, Y+2	; 0x02
    2400:	84 8d       	ldd	r24, Z+28	; 0x1c
    2402:	28 2f       	mov	r18, r24
    2404:	30 e0       	ldi	r19, 0x00	; 0
    2406:	8b 81       	ldd	r24, Y+3	; 0x03
    2408:	9c 81       	ldd	r25, Y+4	; 0x04
    240a:	ba 01       	movw	r22, r20
    240c:	a9 01       	movw	r20, r18
    240e:	0e 94 c9 1e 	call	0x3d92	; 0x3d92 <memcpy>
	}
}
    2412:	0f 90       	pop	r0
    2414:	0f 90       	pop	r0
    2416:	0f 90       	pop	r0
    2418:	0f 90       	pop	r0
    241a:	cf 91       	pop	r28
    241c:	df 91       	pop	r29
    241e:	08 95       	ret

00002420 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    2420:	df 93       	push	r29
    2422:	cf 93       	push	r28
    2424:	00 d0       	rcall	.+0      	; 0x2426 <prvUnlockQueue+0x6>
    2426:	00 d0       	rcall	.+0      	; 0x2428 <prvUnlockQueue+0x8>
    2428:	cd b7       	in	r28, 0x3d	; 61
    242a:	de b7       	in	r29, 0x3e	; 62
    242c:	9c 83       	std	Y+4, r25	; 0x04
    242e:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    2430:	0f b6       	in	r0, 0x3f	; 63
    2432:	f8 94       	cli
    2434:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    2436:	eb 81       	ldd	r30, Y+3	; 0x03
    2438:	fc 81       	ldd	r31, Y+4	; 0x04
    243a:	86 8d       	ldd	r24, Z+30	; 0x1e
    243c:	8a 83       	std	Y+2, r24	; 0x02
    243e:	11 c0       	rjmp	.+34     	; 0x2462 <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2440:	eb 81       	ldd	r30, Y+3	; 0x03
    2442:	fc 81       	ldd	r31, Y+4	; 0x04
    2444:	81 89       	ldd	r24, Z+17	; 0x11
    2446:	88 23       	and	r24, r24
    2448:	79 f0       	breq	.+30     	; 0x2468 <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    244a:	8b 81       	ldd	r24, Y+3	; 0x03
    244c:	9c 81       	ldd	r25, Y+4	; 0x04
    244e:	41 96       	adiw	r24, 0x11	; 17
    2450:	0e 94 71 18 	call	0x30e2	; 0x30e2 <xTaskRemoveFromEventList>
    2454:	88 23       	and	r24, r24
    2456:	11 f0       	breq	.+4      	; 0x245c <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    2458:	0e 94 d3 19 	call	0x33a6	; 0x33a6 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    245c:	8a 81       	ldd	r24, Y+2	; 0x02
    245e:	81 50       	subi	r24, 0x01	; 1
    2460:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    2462:	8a 81       	ldd	r24, Y+2	; 0x02
    2464:	18 16       	cp	r1, r24
    2466:	64 f3       	brlt	.-40     	; 0x2440 <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    2468:	eb 81       	ldd	r30, Y+3	; 0x03
    246a:	fc 81       	ldd	r31, Y+4	; 0x04
    246c:	8f ef       	ldi	r24, 0xFF	; 255
    246e:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    2470:	0f 90       	pop	r0
    2472:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2474:	0f b6       	in	r0, 0x3f	; 63
    2476:	f8 94       	cli
    2478:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    247a:	eb 81       	ldd	r30, Y+3	; 0x03
    247c:	fc 81       	ldd	r31, Y+4	; 0x04
    247e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2480:	89 83       	std	Y+1, r24	; 0x01
    2482:	11 c0       	rjmp	.+34     	; 0x24a6 <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2484:	eb 81       	ldd	r30, Y+3	; 0x03
    2486:	fc 81       	ldd	r31, Y+4	; 0x04
    2488:	80 85       	ldd	r24, Z+8	; 0x08
    248a:	88 23       	and	r24, r24
    248c:	79 f0       	breq	.+30     	; 0x24ac <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    248e:	8b 81       	ldd	r24, Y+3	; 0x03
    2490:	9c 81       	ldd	r25, Y+4	; 0x04
    2492:	08 96       	adiw	r24, 0x08	; 8
    2494:	0e 94 71 18 	call	0x30e2	; 0x30e2 <xTaskRemoveFromEventList>
    2498:	88 23       	and	r24, r24
    249a:	11 f0       	breq	.+4      	; 0x24a0 <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    249c:	0e 94 d3 19 	call	0x33a6	; 0x33a6 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    24a0:	89 81       	ldd	r24, Y+1	; 0x01
    24a2:	81 50       	subi	r24, 0x01	; 1
    24a4:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    24a6:	89 81       	ldd	r24, Y+1	; 0x01
    24a8:	18 16       	cp	r1, r24
    24aa:	64 f3       	brlt	.-40     	; 0x2484 <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    24ac:	eb 81       	ldd	r30, Y+3	; 0x03
    24ae:	fc 81       	ldd	r31, Y+4	; 0x04
    24b0:	8f ef       	ldi	r24, 0xFF	; 255
    24b2:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    24b4:	0f 90       	pop	r0
    24b6:	0f be       	out	0x3f, r0	; 63
}
    24b8:	0f 90       	pop	r0
    24ba:	0f 90       	pop	r0
    24bc:	0f 90       	pop	r0
    24be:	0f 90       	pop	r0
    24c0:	cf 91       	pop	r28
    24c2:	df 91       	pop	r29
    24c4:	08 95       	ret

000024c6 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    24c6:	df 93       	push	r29
    24c8:	cf 93       	push	r28
    24ca:	00 d0       	rcall	.+0      	; 0x24cc <prvIsQueueEmpty+0x6>
    24cc:	0f 92       	push	r0
    24ce:	cd b7       	in	r28, 0x3d	; 61
    24d0:	de b7       	in	r29, 0x3e	; 62
    24d2:	9b 83       	std	Y+3, r25	; 0x03
    24d4:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    24d6:	0f b6       	in	r0, 0x3f	; 63
    24d8:	f8 94       	cli
    24da:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    24dc:	ea 81       	ldd	r30, Y+2	; 0x02
    24de:	fb 81       	ldd	r31, Y+3	; 0x03
    24e0:	82 8d       	ldd	r24, Z+26	; 0x1a
    24e2:	88 23       	and	r24, r24
    24e4:	19 f4       	brne	.+6      	; 0x24ec <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    24e6:	81 e0       	ldi	r24, 0x01	; 1
    24e8:	89 83       	std	Y+1, r24	; 0x01
    24ea:	01 c0       	rjmp	.+2      	; 0x24ee <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    24ec:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    24ee:	0f 90       	pop	r0
    24f0:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    24f2:	89 81       	ldd	r24, Y+1	; 0x01
}
    24f4:	0f 90       	pop	r0
    24f6:	0f 90       	pop	r0
    24f8:	0f 90       	pop	r0
    24fa:	cf 91       	pop	r28
    24fc:	df 91       	pop	r29
    24fe:	08 95       	ret

00002500 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    2500:	df 93       	push	r29
    2502:	cf 93       	push	r28
    2504:	00 d0       	rcall	.+0      	; 0x2506 <xQueueIsQueueEmptyFromISR+0x6>
    2506:	00 d0       	rcall	.+0      	; 0x2508 <xQueueIsQueueEmptyFromISR+0x8>
    2508:	0f 92       	push	r0
    250a:	cd b7       	in	r28, 0x3d	; 61
    250c:	de b7       	in	r29, 0x3e	; 62
    250e:	9d 83       	std	Y+5, r25	; 0x05
    2510:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    2512:	8c 81       	ldd	r24, Y+4	; 0x04
    2514:	9d 81       	ldd	r25, Y+5	; 0x05
    2516:	9a 83       	std	Y+2, r25	; 0x02
    2518:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    251a:	e9 81       	ldd	r30, Y+1	; 0x01
    251c:	fa 81       	ldd	r31, Y+2	; 0x02
    251e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2520:	88 23       	and	r24, r24
    2522:	19 f4       	brne	.+6      	; 0x252a <xQueueIsQueueEmptyFromISR+0x2a>
	{
		xReturn = pdTRUE;
    2524:	81 e0       	ldi	r24, 0x01	; 1
    2526:	8b 83       	std	Y+3, r24	; 0x03
    2528:	01 c0       	rjmp	.+2      	; 0x252c <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    252a:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    252c:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    252e:	0f 90       	pop	r0
    2530:	0f 90       	pop	r0
    2532:	0f 90       	pop	r0
    2534:	0f 90       	pop	r0
    2536:	0f 90       	pop	r0
    2538:	cf 91       	pop	r28
    253a:	df 91       	pop	r29
    253c:	08 95       	ret

0000253e <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    253e:	df 93       	push	r29
    2540:	cf 93       	push	r28
    2542:	00 d0       	rcall	.+0      	; 0x2544 <prvIsQueueFull+0x6>
    2544:	0f 92       	push	r0
    2546:	cd b7       	in	r28, 0x3d	; 61
    2548:	de b7       	in	r29, 0x3e	; 62
    254a:	9b 83       	std	Y+3, r25	; 0x03
    254c:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    254e:	0f b6       	in	r0, 0x3f	; 63
    2550:	f8 94       	cli
    2552:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2554:	ea 81       	ldd	r30, Y+2	; 0x02
    2556:	fb 81       	ldd	r31, Y+3	; 0x03
    2558:	92 8d       	ldd	r25, Z+26	; 0x1a
    255a:	ea 81       	ldd	r30, Y+2	; 0x02
    255c:	fb 81       	ldd	r31, Y+3	; 0x03
    255e:	83 8d       	ldd	r24, Z+27	; 0x1b
    2560:	98 17       	cp	r25, r24
    2562:	19 f4       	brne	.+6      	; 0x256a <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    2564:	81 e0       	ldi	r24, 0x01	; 1
    2566:	89 83       	std	Y+1, r24	; 0x01
    2568:	01 c0       	rjmp	.+2      	; 0x256c <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    256a:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    256c:	0f 90       	pop	r0
    256e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2570:	89 81       	ldd	r24, Y+1	; 0x01
}
    2572:	0f 90       	pop	r0
    2574:	0f 90       	pop	r0
    2576:	0f 90       	pop	r0
    2578:	cf 91       	pop	r28
    257a:	df 91       	pop	r29
    257c:	08 95       	ret

0000257e <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    257e:	df 93       	push	r29
    2580:	cf 93       	push	r28
    2582:	00 d0       	rcall	.+0      	; 0x2584 <xQueueIsQueueFullFromISR+0x6>
    2584:	00 d0       	rcall	.+0      	; 0x2586 <xQueueIsQueueFullFromISR+0x8>
    2586:	0f 92       	push	r0
    2588:	cd b7       	in	r28, 0x3d	; 61
    258a:	de b7       	in	r29, 0x3e	; 62
    258c:	9d 83       	std	Y+5, r25	; 0x05
    258e:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    2590:	8c 81       	ldd	r24, Y+4	; 0x04
    2592:	9d 81       	ldd	r25, Y+5	; 0x05
    2594:	9a 83       	std	Y+2, r25	; 0x02
    2596:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2598:	e9 81       	ldd	r30, Y+1	; 0x01
    259a:	fa 81       	ldd	r31, Y+2	; 0x02
    259c:	92 8d       	ldd	r25, Z+26	; 0x1a
    259e:	e9 81       	ldd	r30, Y+1	; 0x01
    25a0:	fa 81       	ldd	r31, Y+2	; 0x02
    25a2:	83 8d       	ldd	r24, Z+27	; 0x1b
    25a4:	98 17       	cp	r25, r24
    25a6:	19 f4       	brne	.+6      	; 0x25ae <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
    25a8:	81 e0       	ldi	r24, 0x01	; 1
    25aa:	8b 83       	std	Y+3, r24	; 0x03
    25ac:	01 c0       	rjmp	.+2      	; 0x25b0 <xQueueIsQueueFullFromISR+0x32>
	}
	else
	{
		xReturn = pdFALSE;
    25ae:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    25b0:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    25b2:	0f 90       	pop	r0
    25b4:	0f 90       	pop	r0
    25b6:	0f 90       	pop	r0
    25b8:	0f 90       	pop	r0
    25ba:	0f 90       	pop	r0
    25bc:	cf 91       	pop	r28
    25be:	df 91       	pop	r29
    25c0:	08 95       	ret

000025c2 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    25c2:	8f 92       	push	r8
    25c4:	9f 92       	push	r9
    25c6:	af 92       	push	r10
    25c8:	bf 92       	push	r11
    25ca:	cf 92       	push	r12
    25cc:	df 92       	push	r13
    25ce:	ef 92       	push	r14
    25d0:	ff 92       	push	r15
    25d2:	0f 93       	push	r16
    25d4:	1f 93       	push	r17
    25d6:	df 93       	push	r29
    25d8:	cf 93       	push	r28
    25da:	cd b7       	in	r28, 0x3d	; 61
    25dc:	de b7       	in	r29, 0x3e	; 62
    25de:	60 97       	sbiw	r28, 0x10	; 16
    25e0:	0f b6       	in	r0, 0x3f	; 63
    25e2:	f8 94       	cli
    25e4:	de bf       	out	0x3e, r29	; 62
    25e6:	0f be       	out	0x3f, r0	; 63
    25e8:	cd bf       	out	0x3d, r28	; 61
    25ea:	9f 83       	std	Y+7, r25	; 0x07
    25ec:	8e 83       	std	Y+6, r24	; 0x06
    25ee:	79 87       	std	Y+9, r23	; 0x09
    25f0:	68 87       	std	Y+8, r22	; 0x08
    25f2:	5b 87       	std	Y+11, r21	; 0x0b
    25f4:	4a 87       	std	Y+10, r20	; 0x0a
    25f6:	3d 87       	std	Y+13, r19	; 0x0d
    25f8:	2c 87       	std	Y+12, r18	; 0x0c
    25fa:	0e 87       	std	Y+14, r16	; 0x0e
    25fc:	f8 8a       	std	Y+16, r15	; 0x10
    25fe:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    2600:	8a 85       	ldd	r24, Y+10	; 0x0a
    2602:	9b 85       	ldd	r25, Y+11	; 0x0b
    2604:	0e 94 af 06 	call	0xd5e	; 0xd5e <pvPortMalloc>
    2608:	9a 83       	std	Y+2, r25	; 0x02
    260a:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    260c:	89 81       	ldd	r24, Y+1	; 0x01
    260e:	9a 81       	ldd	r25, Y+2	; 0x02
    2610:	00 97       	sbiw	r24, 0x00	; 0
    2612:	b1 f0       	breq	.+44     	; 0x2640 <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    2614:	86 e2       	ldi	r24, 0x26	; 38
    2616:	90 e0       	ldi	r25, 0x00	; 0
    2618:	0e 94 af 06 	call	0xd5e	; 0xd5e <pvPortMalloc>
    261c:	9d 83       	std	Y+5, r25	; 0x05
    261e:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    2620:	8c 81       	ldd	r24, Y+4	; 0x04
    2622:	9d 81       	ldd	r25, Y+5	; 0x05
    2624:	00 97       	sbiw	r24, 0x00	; 0
    2626:	39 f0       	breq	.+14     	; 0x2636 <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    2628:	ec 81       	ldd	r30, Y+4	; 0x04
    262a:	fd 81       	ldd	r31, Y+5	; 0x05
    262c:	89 81       	ldd	r24, Y+1	; 0x01
    262e:	9a 81       	ldd	r25, Y+2	; 0x02
    2630:	90 8f       	std	Z+24, r25	; 0x18
    2632:	87 8b       	std	Z+23, r24	; 0x17
    2634:	07 c0       	rjmp	.+14     	; 0x2644 <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    2636:	89 81       	ldd	r24, Y+1	; 0x01
    2638:	9a 81       	ldd	r25, Y+2	; 0x02
    263a:	0e 94 05 07 	call	0xe0a	; 0xe0a <vPortFree>
    263e:	02 c0       	rjmp	.+4      	; 0x2644 <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    2640:	1d 82       	std	Y+5, r1	; 0x05
    2642:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    2644:	8c 81       	ldd	r24, Y+4	; 0x04
    2646:	9d 81       	ldd	r25, Y+5	; 0x05
    2648:	00 97       	sbiw	r24, 0x00	; 0
    264a:	e9 f0       	breq	.+58     	; 0x2686 <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    264c:	8a 85       	ldd	r24, Y+10	; 0x0a
    264e:	9b 85       	ldd	r25, Y+11	; 0x0b
    2650:	9c 01       	movw	r18, r24
    2652:	40 e0       	ldi	r20, 0x00	; 0
    2654:	50 e0       	ldi	r21, 0x00	; 0
    2656:	8e 81       	ldd	r24, Y+6	; 0x06
    2658:	9f 81       	ldd	r25, Y+7	; 0x07
    265a:	68 85       	ldd	r22, Y+8	; 0x08
    265c:	79 85       	ldd	r23, Y+9	; 0x09
    265e:	ec 85       	ldd	r30, Y+12	; 0x0c
    2660:	fd 85       	ldd	r31, Y+13	; 0x0d
    2662:	af 85       	ldd	r26, Y+15	; 0x0f
    2664:	b8 89       	ldd	r27, Y+16	; 0x10
    2666:	ac 80       	ldd	r10, Y+4	; 0x04
    2668:	bd 80       	ldd	r11, Y+5	; 0x05
    266a:	8f 01       	movw	r16, r30
    266c:	ee 84       	ldd	r14, Y+14	; 0x0e
    266e:	6d 01       	movw	r12, r26
    2670:	88 24       	eor	r8, r8
    2672:	99 24       	eor	r9, r9
    2674:	0e 94 59 13 	call	0x26b2	; 0x26b2 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    2678:	8c 81       	ldd	r24, Y+4	; 0x04
    267a:	9d 81       	ldd	r25, Y+5	; 0x05
    267c:	0e 94 15 14 	call	0x282a	; 0x282a <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    2680:	81 e0       	ldi	r24, 0x01	; 1
    2682:	8b 83       	std	Y+3, r24	; 0x03
    2684:	02 c0       	rjmp	.+4      	; 0x268a <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2686:	8f ef       	ldi	r24, 0xFF	; 255
    2688:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    268a:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    268c:	60 96       	adiw	r28, 0x10	; 16
    268e:	0f b6       	in	r0, 0x3f	; 63
    2690:	f8 94       	cli
    2692:	de bf       	out	0x3e, r29	; 62
    2694:	0f be       	out	0x3f, r0	; 63
    2696:	cd bf       	out	0x3d, r28	; 61
    2698:	cf 91       	pop	r28
    269a:	df 91       	pop	r29
    269c:	1f 91       	pop	r17
    269e:	0f 91       	pop	r16
    26a0:	ff 90       	pop	r15
    26a2:	ef 90       	pop	r14
    26a4:	df 90       	pop	r13
    26a6:	cf 90       	pop	r12
    26a8:	bf 90       	pop	r11
    26aa:	af 90       	pop	r10
    26ac:	9f 90       	pop	r9
    26ae:	8f 90       	pop	r8
    26b0:	08 95       	ret

000026b2 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    26b2:	8f 92       	push	r8
    26b4:	9f 92       	push	r9
    26b6:	af 92       	push	r10
    26b8:	bf 92       	push	r11
    26ba:	cf 92       	push	r12
    26bc:	df 92       	push	r13
    26be:	ef 92       	push	r14
    26c0:	0f 93       	push	r16
    26c2:	1f 93       	push	r17
    26c4:	df 93       	push	r29
    26c6:	cf 93       	push	r28
    26c8:	cd b7       	in	r28, 0x3d	; 61
    26ca:	de b7       	in	r29, 0x3e	; 62
    26cc:	64 97       	sbiw	r28, 0x14	; 20
    26ce:	0f b6       	in	r0, 0x3f	; 63
    26d0:	f8 94       	cli
    26d2:	de bf       	out	0x3e, r29	; 62
    26d4:	0f be       	out	0x3f, r0	; 63
    26d6:	cd bf       	out	0x3d, r28	; 61
    26d8:	9d 83       	std	Y+5, r25	; 0x05
    26da:	8c 83       	std	Y+4, r24	; 0x04
    26dc:	7f 83       	std	Y+7, r23	; 0x07
    26de:	6e 83       	std	Y+6, r22	; 0x06
    26e0:	28 87       	std	Y+8, r18	; 0x08
    26e2:	39 87       	std	Y+9, r19	; 0x09
    26e4:	4a 87       	std	Y+10, r20	; 0x0a
    26e6:	5b 87       	std	Y+11, r21	; 0x0b
    26e8:	1d 87       	std	Y+13, r17	; 0x0d
    26ea:	0c 87       	std	Y+12, r16	; 0x0c
    26ec:	ee 86       	std	Y+14, r14	; 0x0e
    26ee:	d8 8a       	std	Y+16, r13	; 0x10
    26f0:	cf 86       	std	Y+15, r12	; 0x0f
    26f2:	ba 8a       	std	Y+18, r11	; 0x12
    26f4:	a9 8a       	std	Y+17, r10	; 0x11
    26f6:	9c 8a       	std	Y+20, r9	; 0x14
    26f8:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    26fa:	e9 89       	ldd	r30, Y+17	; 0x11
    26fc:	fa 89       	ldd	r31, Y+18	; 0x12
    26fe:	27 89       	ldd	r18, Z+23	; 0x17
    2700:	30 8d       	ldd	r19, Z+24	; 0x18
    2702:	88 85       	ldd	r24, Y+8	; 0x08
    2704:	99 85       	ldd	r25, Y+9	; 0x09
    2706:	01 97       	sbiw	r24, 0x01	; 1
    2708:	82 0f       	add	r24, r18
    270a:	93 1f       	adc	r25, r19
    270c:	9b 83       	std	Y+3, r25	; 0x03
    270e:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    2710:	8e 81       	ldd	r24, Y+6	; 0x06
    2712:	9f 81       	ldd	r25, Y+7	; 0x07
    2714:	00 97       	sbiw	r24, 0x00	; 0
    2716:	51 f1       	breq	.+84     	; 0x276c <prvInitialiseNewTask+0xba>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    2718:	19 82       	std	Y+1, r1	; 0x01
    271a:	21 c0       	rjmp	.+66     	; 0x275e <prvInitialiseNewTask+0xac>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    271c:	89 81       	ldd	r24, Y+1	; 0x01
    271e:	48 2f       	mov	r20, r24
    2720:	50 e0       	ldi	r21, 0x00	; 0
    2722:	89 81       	ldd	r24, Y+1	; 0x01
    2724:	28 2f       	mov	r18, r24
    2726:	30 e0       	ldi	r19, 0x00	; 0
    2728:	8e 81       	ldd	r24, Y+6	; 0x06
    272a:	9f 81       	ldd	r25, Y+7	; 0x07
    272c:	fc 01       	movw	r30, r24
    272e:	e2 0f       	add	r30, r18
    2730:	f3 1f       	adc	r31, r19
    2732:	20 81       	ld	r18, Z
    2734:	89 89       	ldd	r24, Y+17	; 0x11
    2736:	9a 89       	ldd	r25, Y+18	; 0x12
    2738:	84 0f       	add	r24, r20
    273a:	95 1f       	adc	r25, r21
    273c:	fc 01       	movw	r30, r24
    273e:	79 96       	adiw	r30, 0x19	; 25
    2740:	20 83       	st	Z, r18

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    2742:	89 81       	ldd	r24, Y+1	; 0x01
    2744:	28 2f       	mov	r18, r24
    2746:	30 e0       	ldi	r19, 0x00	; 0
    2748:	8e 81       	ldd	r24, Y+6	; 0x06
    274a:	9f 81       	ldd	r25, Y+7	; 0x07
    274c:	fc 01       	movw	r30, r24
    274e:	e2 0f       	add	r30, r18
    2750:	f3 1f       	adc	r31, r19
    2752:	80 81       	ld	r24, Z
    2754:	88 23       	and	r24, r24
    2756:	31 f0       	breq	.+12     	; 0x2764 <prvInitialiseNewTask+0xb2>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    2758:	89 81       	ldd	r24, Y+1	; 0x01
    275a:	8f 5f       	subi	r24, 0xFF	; 255
    275c:	89 83       	std	Y+1, r24	; 0x01
    275e:	89 81       	ldd	r24, Y+1	; 0x01
    2760:	88 30       	cpi	r24, 0x08	; 8
    2762:	e0 f2       	brcs	.-72     	; 0x271c <prvInitialiseNewTask+0x6a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    2764:	e9 89       	ldd	r30, Y+17	; 0x11
    2766:	fa 89       	ldd	r31, Y+18	; 0x12
    2768:	10 a2       	std	Z+32, r1	; 0x20
    276a:	03 c0       	rjmp	.+6      	; 0x2772 <prvInitialiseNewTask+0xc0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    276c:	e9 89       	ldd	r30, Y+17	; 0x11
    276e:	fa 89       	ldd	r31, Y+18	; 0x12
    2770:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    2772:	8e 85       	ldd	r24, Y+14	; 0x0e
    2774:	84 30       	cpi	r24, 0x04	; 4
    2776:	10 f0       	brcs	.+4      	; 0x277c <prvInitialiseNewTask+0xca>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    2778:	83 e0       	ldi	r24, 0x03	; 3
    277a:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    277c:	e9 89       	ldd	r30, Y+17	; 0x11
    277e:	fa 89       	ldd	r31, Y+18	; 0x12
    2780:	8e 85       	ldd	r24, Y+14	; 0x0e
    2782:	86 8b       	std	Z+22, r24	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    2784:	89 89       	ldd	r24, Y+17	; 0x11
    2786:	9a 89       	ldd	r25, Y+18	; 0x12
    2788:	02 96       	adiw	r24, 0x02	; 2
    278a:	0e 94 55 07 	call	0xeaa	; 0xeaa <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    278e:	89 89       	ldd	r24, Y+17	; 0x11
    2790:	9a 89       	ldd	r25, Y+18	; 0x12
    2792:	0c 96       	adiw	r24, 0x0c	; 12
    2794:	0e 94 55 07 	call	0xeaa	; 0xeaa <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    2798:	e9 89       	ldd	r30, Y+17	; 0x11
    279a:	fa 89       	ldd	r31, Y+18	; 0x12
    279c:	89 89       	ldd	r24, Y+17	; 0x11
    279e:	9a 89       	ldd	r25, Y+18	; 0x12
    27a0:	91 87       	std	Z+9, r25	; 0x09
    27a2:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    27a4:	8e 85       	ldd	r24, Y+14	; 0x0e
    27a6:	28 2f       	mov	r18, r24
    27a8:	30 e0       	ldi	r19, 0x00	; 0
    27aa:	84 e0       	ldi	r24, 0x04	; 4
    27ac:	90 e0       	ldi	r25, 0x00	; 0
    27ae:	82 1b       	sub	r24, r18
    27b0:	93 0b       	sbc	r25, r19
    27b2:	e9 89       	ldd	r30, Y+17	; 0x11
    27b4:	fa 89       	ldd	r31, Y+18	; 0x12
    27b6:	95 87       	std	Z+13, r25	; 0x0d
    27b8:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    27ba:	e9 89       	ldd	r30, Y+17	; 0x11
    27bc:	fa 89       	ldd	r31, Y+18	; 0x12
    27be:	89 89       	ldd	r24, Y+17	; 0x11
    27c0:	9a 89       	ldd	r25, Y+18	; 0x12
    27c2:	93 8b       	std	Z+19, r25	; 0x13
    27c4:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    27c6:	e9 89       	ldd	r30, Y+17	; 0x11
    27c8:	fa 89       	ldd	r31, Y+18	; 0x12
    27ca:	11 a2       	std	Z+33, r1	; 0x21
    27cc:	12 a2       	std	Z+34, r1	; 0x22
    27ce:	13 a2       	std	Z+35, r1	; 0x23
    27d0:	14 a2       	std	Z+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    27d2:	e9 89       	ldd	r30, Y+17	; 0x11
    27d4:	fa 89       	ldd	r31, Y+18	; 0x12
    27d6:	15 a2       	std	Z+37, r1	; 0x25
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    27d8:	8a 81       	ldd	r24, Y+2	; 0x02
    27da:	9b 81       	ldd	r25, Y+3	; 0x03
    27dc:	2c 81       	ldd	r18, Y+4	; 0x04
    27de:	3d 81       	ldd	r19, Y+5	; 0x05
    27e0:	4c 85       	ldd	r20, Y+12	; 0x0c
    27e2:	5d 85       	ldd	r21, Y+13	; 0x0d
    27e4:	b9 01       	movw	r22, r18
    27e6:	0e 94 eb 08 	call	0x11d6	; 0x11d6 <pxPortInitialiseStack>
    27ea:	e9 89       	ldd	r30, Y+17	; 0x11
    27ec:	fa 89       	ldd	r31, Y+18	; 0x12
    27ee:	91 83       	std	Z+1, r25	; 0x01
    27f0:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    27f2:	8f 85       	ldd	r24, Y+15	; 0x0f
    27f4:	98 89       	ldd	r25, Y+16	; 0x10
    27f6:	00 97       	sbiw	r24, 0x00	; 0
    27f8:	31 f0       	breq	.+12     	; 0x2806 <prvInitialiseNewTask+0x154>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    27fa:	ef 85       	ldd	r30, Y+15	; 0x0f
    27fc:	f8 89       	ldd	r31, Y+16	; 0x10
    27fe:	89 89       	ldd	r24, Y+17	; 0x11
    2800:	9a 89       	ldd	r25, Y+18	; 0x12
    2802:	91 83       	std	Z+1, r25	; 0x01
    2804:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    2806:	64 96       	adiw	r28, 0x14	; 20
    2808:	0f b6       	in	r0, 0x3f	; 63
    280a:	f8 94       	cli
    280c:	de bf       	out	0x3e, r29	; 62
    280e:	0f be       	out	0x3f, r0	; 63
    2810:	cd bf       	out	0x3d, r28	; 61
    2812:	cf 91       	pop	r28
    2814:	df 91       	pop	r29
    2816:	1f 91       	pop	r17
    2818:	0f 91       	pop	r16
    281a:	ef 90       	pop	r14
    281c:	df 90       	pop	r13
    281e:	cf 90       	pop	r12
    2820:	bf 90       	pop	r11
    2822:	af 90       	pop	r10
    2824:	9f 90       	pop	r9
    2826:	8f 90       	pop	r8
    2828:	08 95       	ret

0000282a <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    282a:	df 93       	push	r29
    282c:	cf 93       	push	r28
    282e:	00 d0       	rcall	.+0      	; 0x2830 <prvAddNewTaskToReadyList+0x6>
    2830:	cd b7       	in	r28, 0x3d	; 61
    2832:	de b7       	in	r29, 0x3e	; 62
    2834:	9a 83       	std	Y+2, r25	; 0x02
    2836:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    2838:	0f b6       	in	r0, 0x3f	; 63
    283a:	f8 94       	cli
    283c:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    283e:	80 91 d4 02 	lds	r24, 0x02D4
    2842:	8f 5f       	subi	r24, 0xFF	; 255
    2844:	80 93 d4 02 	sts	0x02D4, r24
		if( pxCurrentTCB == NULL )
    2848:	80 91 d1 02 	lds	r24, 0x02D1
    284c:	90 91 d2 02 	lds	r25, 0x02D2
    2850:	00 97       	sbiw	r24, 0x00	; 0
    2852:	69 f4       	brne	.+26     	; 0x286e <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    2854:	89 81       	ldd	r24, Y+1	; 0x01
    2856:	9a 81       	ldd	r25, Y+2	; 0x02
    2858:	90 93 d2 02 	sts	0x02D2, r25
    285c:	80 93 d1 02 	sts	0x02D1, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    2860:	80 91 d4 02 	lds	r24, 0x02D4
    2864:	81 30       	cpi	r24, 0x01	; 1
    2866:	b9 f4       	brne	.+46     	; 0x2896 <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    2868:	0e 94 e7 19 	call	0x33ce	; 0x33ce <prvInitialiseTaskLists>
    286c:	14 c0       	rjmp	.+40     	; 0x2896 <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    286e:	80 91 d8 02 	lds	r24, 0x02D8
    2872:	88 23       	and	r24, r24
    2874:	81 f4       	brne	.+32     	; 0x2896 <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    2876:	e0 91 d1 02 	lds	r30, 0x02D1
    287a:	f0 91 d2 02 	lds	r31, 0x02D2
    287e:	96 89       	ldd	r25, Z+22	; 0x16
    2880:	e9 81       	ldd	r30, Y+1	; 0x01
    2882:	fa 81       	ldd	r31, Y+2	; 0x02
    2884:	86 89       	ldd	r24, Z+22	; 0x16
    2886:	89 17       	cp	r24, r25
    2888:	30 f0       	brcs	.+12     	; 0x2896 <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    288a:	89 81       	ldd	r24, Y+1	; 0x01
    288c:	9a 81       	ldd	r25, Y+2	; 0x02
    288e:	90 93 d2 02 	sts	0x02D2, r25
    2892:	80 93 d1 02 	sts	0x02D1, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    2896:	80 91 dc 02 	lds	r24, 0x02DC
    289a:	8f 5f       	subi	r24, 0xFF	; 255
    289c:	80 93 dc 02 	sts	0x02DC, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    28a0:	e9 81       	ldd	r30, Y+1	; 0x01
    28a2:	fa 81       	ldd	r31, Y+2	; 0x02
    28a4:	96 89       	ldd	r25, Z+22	; 0x16
    28a6:	80 91 d7 02 	lds	r24, 0x02D7
    28aa:	89 17       	cp	r24, r25
    28ac:	28 f4       	brcc	.+10     	; 0x28b8 <prvAddNewTaskToReadyList+0x8e>
    28ae:	e9 81       	ldd	r30, Y+1	; 0x01
    28b0:	fa 81       	ldd	r31, Y+2	; 0x02
    28b2:	86 89       	ldd	r24, Z+22	; 0x16
    28b4:	80 93 d7 02 	sts	0x02D7, r24
    28b8:	e9 81       	ldd	r30, Y+1	; 0x01
    28ba:	fa 81       	ldd	r31, Y+2	; 0x02
    28bc:	86 89       	ldd	r24, Z+22	; 0x16
    28be:	28 2f       	mov	r18, r24
    28c0:	30 e0       	ldi	r19, 0x00	; 0
    28c2:	c9 01       	movw	r24, r18
    28c4:	88 0f       	add	r24, r24
    28c6:	99 1f       	adc	r25, r25
    28c8:	88 0f       	add	r24, r24
    28ca:	99 1f       	adc	r25, r25
    28cc:	88 0f       	add	r24, r24
    28ce:	99 1f       	adc	r25, r25
    28d0:	82 0f       	add	r24, r18
    28d2:	93 1f       	adc	r25, r19
    28d4:	ac 01       	movw	r20, r24
    28d6:	4e 51       	subi	r20, 0x1E	; 30
    28d8:	5d 4f       	sbci	r21, 0xFD	; 253
    28da:	89 81       	ldd	r24, Y+1	; 0x01
    28dc:	9a 81       	ldd	r25, Y+2	; 0x02
    28de:	9c 01       	movw	r18, r24
    28e0:	2e 5f       	subi	r18, 0xFE	; 254
    28e2:	3f 4f       	sbci	r19, 0xFF	; 255
    28e4:	ca 01       	movw	r24, r20
    28e6:	b9 01       	movw	r22, r18
    28e8:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    28ec:	0f 90       	pop	r0
    28ee:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    28f0:	80 91 d8 02 	lds	r24, 0x02D8
    28f4:	88 23       	and	r24, r24
    28f6:	61 f0       	breq	.+24     	; 0x2910 <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    28f8:	e0 91 d1 02 	lds	r30, 0x02D1
    28fc:	f0 91 d2 02 	lds	r31, 0x02D2
    2900:	96 89       	ldd	r25, Z+22	; 0x16
    2902:	e9 81       	ldd	r30, Y+1	; 0x01
    2904:	fa 81       	ldd	r31, Y+2	; 0x02
    2906:	86 89       	ldd	r24, Z+22	; 0x16
    2908:	98 17       	cp	r25, r24
    290a:	10 f4       	brcc	.+4      	; 0x2910 <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    290c:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    2910:	0f 90       	pop	r0
    2912:	0f 90       	pop	r0
    2914:	cf 91       	pop	r28
    2916:	df 91       	pop	r29
    2918:	08 95       	ret

0000291a <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    291a:	df 93       	push	r29
    291c:	cf 93       	push	r28
    291e:	00 d0       	rcall	.+0      	; 0x2920 <vTaskDelete+0x6>
    2920:	00 d0       	rcall	.+0      	; 0x2922 <vTaskDelete+0x8>
    2922:	00 d0       	rcall	.+0      	; 0x2924 <vTaskDelete+0xa>
    2924:	cd b7       	in	r28, 0x3d	; 61
    2926:	de b7       	in	r29, 0x3e	; 62
    2928:	9c 83       	std	Y+4, r25	; 0x04
    292a:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    292c:	0f b6       	in	r0, 0x3f	; 63
    292e:	f8 94       	cli
    2930:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    2932:	8b 81       	ldd	r24, Y+3	; 0x03
    2934:	9c 81       	ldd	r25, Y+4	; 0x04
    2936:	00 97       	sbiw	r24, 0x00	; 0
    2938:	39 f4       	brne	.+14     	; 0x2948 <vTaskDelete+0x2e>
    293a:	80 91 d1 02 	lds	r24, 0x02D1
    293e:	90 91 d2 02 	lds	r25, 0x02D2
    2942:	9e 83       	std	Y+6, r25	; 0x06
    2944:	8d 83       	std	Y+5, r24	; 0x05
    2946:	04 c0       	rjmp	.+8      	; 0x2950 <vTaskDelete+0x36>
    2948:	8b 81       	ldd	r24, Y+3	; 0x03
    294a:	9c 81       	ldd	r25, Y+4	; 0x04
    294c:	9e 83       	std	Y+6, r25	; 0x06
    294e:	8d 83       	std	Y+5, r24	; 0x05
    2950:	8d 81       	ldd	r24, Y+5	; 0x05
    2952:	9e 81       	ldd	r25, Y+6	; 0x06
    2954:	9a 83       	std	Y+2, r25	; 0x02
    2956:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2958:	89 81       	ldd	r24, Y+1	; 0x01
    295a:	9a 81       	ldd	r25, Y+2	; 0x02
    295c:	02 96       	adiw	r24, 0x02	; 2
    295e:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    2962:	e9 81       	ldd	r30, Y+1	; 0x01
    2964:	fa 81       	ldd	r31, Y+2	; 0x02
    2966:	84 89       	ldd	r24, Z+20	; 0x14
    2968:	95 89       	ldd	r25, Z+21	; 0x15
    296a:	00 97       	sbiw	r24, 0x00	; 0
    296c:	29 f0       	breq	.+10     	; 0x2978 <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    296e:	89 81       	ldd	r24, Y+1	; 0x01
    2970:	9a 81       	ldd	r25, Y+2	; 0x02
    2972:	0c 96       	adiw	r24, 0x0c	; 12
    2974:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    2978:	80 91 dc 02 	lds	r24, 0x02DC
    297c:	8f 5f       	subi	r24, 0xFF	; 255
    297e:	80 93 dc 02 	sts	0x02DC, r24

			if( pxTCB == pxCurrentTCB )
    2982:	20 91 d1 02 	lds	r18, 0x02D1
    2986:	30 91 d2 02 	lds	r19, 0x02D2
    298a:	89 81       	ldd	r24, Y+1	; 0x01
    298c:	9a 81       	ldd	r25, Y+2	; 0x02
    298e:	82 17       	cp	r24, r18
    2990:	93 07       	cpc	r25, r19
    2992:	81 f4       	brne	.+32     	; 0x29b4 <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    2994:	89 81       	ldd	r24, Y+1	; 0x01
    2996:	9a 81       	ldd	r25, Y+2	; 0x02
    2998:	9c 01       	movw	r18, r24
    299a:	2e 5f       	subi	r18, 0xFE	; 254
    299c:	3f 4f       	sbci	r19, 0xFF	; 255
    299e:	85 e2       	ldi	r24, 0x25	; 37
    29a0:	93 e0       	ldi	r25, 0x03	; 3
    29a2:	b9 01       	movw	r22, r18
    29a4:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    29a8:	80 91 d3 02 	lds	r24, 0x02D3
    29ac:	8f 5f       	subi	r24, 0xFF	; 255
    29ae:	80 93 d3 02 	sts	0x02D3, r24
    29b2:	0b c0       	rjmp	.+22     	; 0x29ca <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    29b4:	80 91 d4 02 	lds	r24, 0x02D4
    29b8:	81 50       	subi	r24, 0x01	; 1
    29ba:	80 93 d4 02 	sts	0x02D4, r24
				prvDeleteTCB( pxTCB );
    29be:	89 81       	ldd	r24, Y+1	; 0x01
    29c0:	9a 81       	ldd	r25, Y+2	; 0x02
    29c2:	0e 94 53 1a 	call	0x34a6	; 0x34a6 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    29c6:	0e 94 69 1a 	call	0x34d2	; 0x34d2 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    29ca:	0f 90       	pop	r0
    29cc:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    29ce:	80 91 d8 02 	lds	r24, 0x02D8
    29d2:	88 23       	and	r24, r24
    29d4:	59 f0       	breq	.+22     	; 0x29ec <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    29d6:	20 91 d1 02 	lds	r18, 0x02D1
    29da:	30 91 d2 02 	lds	r19, 0x02D2
    29de:	89 81       	ldd	r24, Y+1	; 0x01
    29e0:	9a 81       	ldd	r25, Y+2	; 0x02
    29e2:	82 17       	cp	r24, r18
    29e4:	93 07       	cpc	r25, r19
    29e6:	11 f4       	brne	.+4      	; 0x29ec <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    29e8:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    29ec:	26 96       	adiw	r28, 0x06	; 6
    29ee:	0f b6       	in	r0, 0x3f	; 63
    29f0:	f8 94       	cli
    29f2:	de bf       	out	0x3e, r29	; 62
    29f4:	0f be       	out	0x3f, r0	; 63
    29f6:	cd bf       	out	0x3d, r28	; 61
    29f8:	cf 91       	pop	r28
    29fa:	df 91       	pop	r29
    29fc:	08 95       	ret

000029fe <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    29fe:	df 93       	push	r29
    2a00:	cf 93       	push	r28
    2a02:	cd b7       	in	r28, 0x3d	; 61
    2a04:	de b7       	in	r29, 0x3e	; 62
    2a06:	2a 97       	sbiw	r28, 0x0a	; 10
    2a08:	0f b6       	in	r0, 0x3f	; 63
    2a0a:	f8 94       	cli
    2a0c:	de bf       	out	0x3e, r29	; 62
    2a0e:	0f be       	out	0x3f, r0	; 63
    2a10:	cd bf       	out	0x3d, r28	; 61
    2a12:	98 87       	std	Y+8, r25	; 0x08
    2a14:	8f 83       	std	Y+7, r24	; 0x07
    2a16:	7a 87       	std	Y+10, r23	; 0x0a
    2a18:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    2a1a:	1b 82       	std	Y+3, r1	; 0x03

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    2a1c:	0e 94 d1 15 	call	0x2ba2	; 0x2ba2 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    2a20:	80 91 d5 02 	lds	r24, 0x02D5
    2a24:	90 91 d6 02 	lds	r25, 0x02D6
    2a28:	9a 83       	std	Y+2, r25	; 0x02
    2a2a:	89 83       	std	Y+1, r24	; 0x01

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2a2c:	ef 81       	ldd	r30, Y+7	; 0x07
    2a2e:	f8 85       	ldd	r31, Y+8	; 0x08
    2a30:	20 81       	ld	r18, Z
    2a32:	31 81       	ldd	r19, Z+1	; 0x01
    2a34:	89 85       	ldd	r24, Y+9	; 0x09
    2a36:	9a 85       	ldd	r25, Y+10	; 0x0a
    2a38:	82 0f       	add	r24, r18
    2a3a:	93 1f       	adc	r25, r19
    2a3c:	9e 83       	std	Y+6, r25	; 0x06
    2a3e:	8d 83       	std	Y+5, r24	; 0x05

			if( xConstTickCount < *pxPreviousWakeTime )
    2a40:	ef 81       	ldd	r30, Y+7	; 0x07
    2a42:	f8 85       	ldd	r31, Y+8	; 0x08
    2a44:	20 81       	ld	r18, Z
    2a46:	31 81       	ldd	r19, Z+1	; 0x01
    2a48:	89 81       	ldd	r24, Y+1	; 0x01
    2a4a:	9a 81       	ldd	r25, Y+2	; 0x02
    2a4c:	82 17       	cp	r24, r18
    2a4e:	93 07       	cpc	r25, r19
    2a50:	98 f4       	brcc	.+38     	; 0x2a78 <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    2a52:	ef 81       	ldd	r30, Y+7	; 0x07
    2a54:	f8 85       	ldd	r31, Y+8	; 0x08
    2a56:	20 81       	ld	r18, Z
    2a58:	31 81       	ldd	r19, Z+1	; 0x01
    2a5a:	8d 81       	ldd	r24, Y+5	; 0x05
    2a5c:	9e 81       	ldd	r25, Y+6	; 0x06
    2a5e:	82 17       	cp	r24, r18
    2a60:	93 07       	cpc	r25, r19
    2a62:	e0 f4       	brcc	.+56     	; 0x2a9c <vTaskDelayUntil+0x9e>
    2a64:	2d 81       	ldd	r18, Y+5	; 0x05
    2a66:	3e 81       	ldd	r19, Y+6	; 0x06
    2a68:	89 81       	ldd	r24, Y+1	; 0x01
    2a6a:	9a 81       	ldd	r25, Y+2	; 0x02
    2a6c:	82 17       	cp	r24, r18
    2a6e:	93 07       	cpc	r25, r19
    2a70:	a8 f4       	brcc	.+42     	; 0x2a9c <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    2a72:	81 e0       	ldi	r24, 0x01	; 1
    2a74:	8b 83       	std	Y+3, r24	; 0x03
    2a76:	12 c0       	rjmp	.+36     	; 0x2a9c <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    2a78:	ef 81       	ldd	r30, Y+7	; 0x07
    2a7a:	f8 85       	ldd	r31, Y+8	; 0x08
    2a7c:	20 81       	ld	r18, Z
    2a7e:	31 81       	ldd	r19, Z+1	; 0x01
    2a80:	8d 81       	ldd	r24, Y+5	; 0x05
    2a82:	9e 81       	ldd	r25, Y+6	; 0x06
    2a84:	82 17       	cp	r24, r18
    2a86:	93 07       	cpc	r25, r19
    2a88:	38 f0       	brcs	.+14     	; 0x2a98 <vTaskDelayUntil+0x9a>
    2a8a:	2d 81       	ldd	r18, Y+5	; 0x05
    2a8c:	3e 81       	ldd	r19, Y+6	; 0x06
    2a8e:	89 81       	ldd	r24, Y+1	; 0x01
    2a90:	9a 81       	ldd	r25, Y+2	; 0x02
    2a92:	82 17       	cp	r24, r18
    2a94:	93 07       	cpc	r25, r19
    2a96:	10 f4       	brcc	.+4      	; 0x2a9c <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    2a98:	81 e0       	ldi	r24, 0x01	; 1
    2a9a:	8b 83       	std	Y+3, r24	; 0x03
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2a9c:	ef 81       	ldd	r30, Y+7	; 0x07
    2a9e:	f8 85       	ldd	r31, Y+8	; 0x08
    2aa0:	8d 81       	ldd	r24, Y+5	; 0x05
    2aa2:	9e 81       	ldd	r25, Y+6	; 0x06
    2aa4:	91 83       	std	Z+1, r25	; 0x01
    2aa6:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    2aa8:	8b 81       	ldd	r24, Y+3	; 0x03
    2aaa:	88 23       	and	r24, r24
    2aac:	49 f0       	breq	.+18     	; 0x2ac0 <vTaskDelayUntil+0xc2>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    2aae:	8d 81       	ldd	r24, Y+5	; 0x05
    2ab0:	9e 81       	ldd	r25, Y+6	; 0x06
    2ab2:	29 81       	ldd	r18, Y+1	; 0x01
    2ab4:	3a 81       	ldd	r19, Y+2	; 0x02
    2ab6:	82 1b       	sub	r24, r18
    2ab8:	93 0b       	sbc	r25, r19
    2aba:	60 e0       	ldi	r22, 0x00	; 0
    2abc:	0e 94 63 1e 	call	0x3cc6	; 0x3cc6 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2ac0:	0e 94 dd 15 	call	0x2bba	; 0x2bba <xTaskResumeAll>
    2ac4:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2ac6:	8c 81       	ldd	r24, Y+4	; 0x04
    2ac8:	88 23       	and	r24, r24
    2aca:	11 f4       	brne	.+4      	; 0x2ad0 <vTaskDelayUntil+0xd2>
		{
			portYIELD_WITHIN_API();
    2acc:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2ad0:	2a 96       	adiw	r28, 0x0a	; 10
    2ad2:	0f b6       	in	r0, 0x3f	; 63
    2ad4:	f8 94       	cli
    2ad6:	de bf       	out	0x3e, r29	; 62
    2ad8:	0f be       	out	0x3f, r0	; 63
    2ada:	cd bf       	out	0x3d, r28	; 61
    2adc:	cf 91       	pop	r28
    2ade:	df 91       	pop	r29
    2ae0:	08 95       	ret

00002ae2 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    2ae2:	df 93       	push	r29
    2ae4:	cf 93       	push	r28
    2ae6:	00 d0       	rcall	.+0      	; 0x2ae8 <vTaskDelay+0x6>
    2ae8:	0f 92       	push	r0
    2aea:	cd b7       	in	r28, 0x3d	; 61
    2aec:	de b7       	in	r29, 0x3e	; 62
    2aee:	9b 83       	std	Y+3, r25	; 0x03
    2af0:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    2af2:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    2af4:	8a 81       	ldd	r24, Y+2	; 0x02
    2af6:	9b 81       	ldd	r25, Y+3	; 0x03
    2af8:	00 97       	sbiw	r24, 0x00	; 0
    2afa:	51 f0       	breq	.+20     	; 0x2b10 <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    2afc:	0e 94 d1 15 	call	0x2ba2	; 0x2ba2 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    2b00:	8a 81       	ldd	r24, Y+2	; 0x02
    2b02:	9b 81       	ldd	r25, Y+3	; 0x03
    2b04:	60 e0       	ldi	r22, 0x00	; 0
    2b06:	0e 94 63 1e 	call	0x3cc6	; 0x3cc6 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2b0a:	0e 94 dd 15 	call	0x2bba	; 0x2bba <xTaskResumeAll>
    2b0e:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2b10:	89 81       	ldd	r24, Y+1	; 0x01
    2b12:	88 23       	and	r24, r24
    2b14:	11 f4       	brne	.+4      	; 0x2b1a <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    2b16:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2b1a:	0f 90       	pop	r0
    2b1c:	0f 90       	pop	r0
    2b1e:	0f 90       	pop	r0
    2b20:	cf 91       	pop	r28
    2b22:	df 91       	pop	r29
    2b24:	08 95       	ret

00002b26 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    2b26:	ef 92       	push	r14
    2b28:	ff 92       	push	r15
    2b2a:	0f 93       	push	r16
    2b2c:	df 93       	push	r29
    2b2e:	cf 93       	push	r28
    2b30:	0f 92       	push	r0
    2b32:	cd b7       	in	r28, 0x3d	; 61
    2b34:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    2b36:	8d ed       	ldi	r24, 0xDD	; 221
    2b38:	99 e1       	ldi	r25, 0x19	; 25
    2b3a:	2e e6       	ldi	r18, 0x6E	; 110
    2b3c:	30 e0       	ldi	r19, 0x00	; 0
    2b3e:	ef ed       	ldi	r30, 0xDF	; 223
    2b40:	f2 e0       	ldi	r31, 0x02	; 2
    2b42:	b9 01       	movw	r22, r18
    2b44:	45 e5       	ldi	r20, 0x55	; 85
    2b46:	50 e0       	ldi	r21, 0x00	; 0
    2b48:	20 e0       	ldi	r18, 0x00	; 0
    2b4a:	30 e0       	ldi	r19, 0x00	; 0
    2b4c:	00 e0       	ldi	r16, 0x00	; 0
    2b4e:	7f 01       	movw	r14, r30
    2b50:	0e 94 e1 12 	call	0x25c2	; 0x25c2 <xTaskCreate>
    2b54:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    2b56:	89 81       	ldd	r24, Y+1	; 0x01
    2b58:	81 30       	cpi	r24, 0x01	; 1
    2b5a:	81 f4       	brne	.+32     	; 0x2b7c <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    2b5c:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    2b5e:	8f ef       	ldi	r24, 0xFF	; 255
    2b60:	9f ef       	ldi	r25, 0xFF	; 255
    2b62:	90 93 de 02 	sts	0x02DE, r25
    2b66:	80 93 dd 02 	sts	0x02DD, r24
		xSchedulerRunning = pdTRUE;
    2b6a:	81 e0       	ldi	r24, 0x01	; 1
    2b6c:	80 93 d8 02 	sts	0x02D8, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    2b70:	10 92 d6 02 	sts	0x02D6, r1
    2b74:	10 92 d5 02 	sts	0x02D5, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    2b78:	0e 94 6e 0a 	call	0x14dc	; 0x14dc <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    2b7c:	0f 90       	pop	r0
    2b7e:	cf 91       	pop	r28
    2b80:	df 91       	pop	r29
    2b82:	0f 91       	pop	r16
    2b84:	ff 90       	pop	r15
    2b86:	ef 90       	pop	r14
    2b88:	08 95       	ret

00002b8a <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    2b8a:	df 93       	push	r29
    2b8c:	cf 93       	push	r28
    2b8e:	cd b7       	in	r28, 0x3d	; 61
    2b90:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    2b92:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    2b94:	10 92 d8 02 	sts	0x02D8, r1
	vPortEndScheduler();
    2b98:	0e 94 a3 0a 	call	0x1546	; 0x1546 <vPortEndScheduler>
}
    2b9c:	cf 91       	pop	r28
    2b9e:	df 91       	pop	r29
    2ba0:	08 95       	ret

00002ba2 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    2ba2:	df 93       	push	r29
    2ba4:	cf 93       	push	r28
    2ba6:	cd b7       	in	r28, 0x3d	; 61
    2ba8:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    2baa:	80 91 e1 02 	lds	r24, 0x02E1
    2bae:	8f 5f       	subi	r24, 0xFF	; 255
    2bb0:	80 93 e1 02 	sts	0x02E1, r24
	portMEMORY_BARRIER();
}
    2bb4:	cf 91       	pop	r28
    2bb6:	df 91       	pop	r29
    2bb8:	08 95       	ret

00002bba <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    2bba:	df 93       	push	r29
    2bbc:	cf 93       	push	r28
    2bbe:	00 d0       	rcall	.+0      	; 0x2bc0 <xTaskResumeAll+0x6>
    2bc0:	00 d0       	rcall	.+0      	; 0x2bc2 <xTaskResumeAll+0x8>
    2bc2:	cd b7       	in	r28, 0x3d	; 61
    2bc4:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    2bc6:	1c 82       	std	Y+4, r1	; 0x04
    2bc8:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xAlreadyYielded = pdFALSE;
    2bca:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2bcc:	0f b6       	in	r0, 0x3f	; 63
    2bce:	f8 94       	cli
    2bd0:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2bd2:	80 91 e1 02 	lds	r24, 0x02E1
    2bd6:	81 50       	subi	r24, 0x01	; 1
    2bd8:	80 93 e1 02 	sts	0x02E1, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2bdc:	80 91 e1 02 	lds	r24, 0x02E1
    2be0:	88 23       	and	r24, r24
    2be2:	09 f0       	breq	.+2      	; 0x2be6 <xTaskResumeAll+0x2c>
    2be4:	73 c0       	rjmp	.+230    	; 0x2ccc <xTaskResumeAll+0x112>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    2be6:	80 91 d4 02 	lds	r24, 0x02D4
    2bea:	88 23       	and	r24, r24
    2bec:	09 f4       	brne	.+2      	; 0x2bf0 <xTaskResumeAll+0x36>
    2bee:	6e c0       	rjmp	.+220    	; 0x2ccc <xTaskResumeAll+0x112>
    2bf0:	45 c0       	rjmp	.+138    	; 0x2c7c <xTaskResumeAll+0xc2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2bf2:	e0 91 21 03 	lds	r30, 0x0321
    2bf6:	f0 91 22 03 	lds	r31, 0x0322
    2bfa:	86 81       	ldd	r24, Z+6	; 0x06
    2bfc:	97 81       	ldd	r25, Z+7	; 0x07
    2bfe:	9c 83       	std	Y+4, r25	; 0x04
    2c00:	8b 83       	std	Y+3, r24	; 0x03
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2c02:	8b 81       	ldd	r24, Y+3	; 0x03
    2c04:	9c 81       	ldd	r25, Y+4	; 0x04
    2c06:	0c 96       	adiw	r24, 0x0c	; 12
    2c08:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2c0c:	8b 81       	ldd	r24, Y+3	; 0x03
    2c0e:	9c 81       	ldd	r25, Y+4	; 0x04
    2c10:	02 96       	adiw	r24, 0x02	; 2
    2c12:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2c16:	eb 81       	ldd	r30, Y+3	; 0x03
    2c18:	fc 81       	ldd	r31, Y+4	; 0x04
    2c1a:	96 89       	ldd	r25, Z+22	; 0x16
    2c1c:	80 91 d7 02 	lds	r24, 0x02D7
    2c20:	89 17       	cp	r24, r25
    2c22:	28 f4       	brcc	.+10     	; 0x2c2e <xTaskResumeAll+0x74>
    2c24:	eb 81       	ldd	r30, Y+3	; 0x03
    2c26:	fc 81       	ldd	r31, Y+4	; 0x04
    2c28:	86 89       	ldd	r24, Z+22	; 0x16
    2c2a:	80 93 d7 02 	sts	0x02D7, r24
    2c2e:	eb 81       	ldd	r30, Y+3	; 0x03
    2c30:	fc 81       	ldd	r31, Y+4	; 0x04
    2c32:	86 89       	ldd	r24, Z+22	; 0x16
    2c34:	28 2f       	mov	r18, r24
    2c36:	30 e0       	ldi	r19, 0x00	; 0
    2c38:	c9 01       	movw	r24, r18
    2c3a:	88 0f       	add	r24, r24
    2c3c:	99 1f       	adc	r25, r25
    2c3e:	88 0f       	add	r24, r24
    2c40:	99 1f       	adc	r25, r25
    2c42:	88 0f       	add	r24, r24
    2c44:	99 1f       	adc	r25, r25
    2c46:	82 0f       	add	r24, r18
    2c48:	93 1f       	adc	r25, r19
    2c4a:	ac 01       	movw	r20, r24
    2c4c:	4e 51       	subi	r20, 0x1E	; 30
    2c4e:	5d 4f       	sbci	r21, 0xFD	; 253
    2c50:	8b 81       	ldd	r24, Y+3	; 0x03
    2c52:	9c 81       	ldd	r25, Y+4	; 0x04
    2c54:	9c 01       	movw	r18, r24
    2c56:	2e 5f       	subi	r18, 0xFE	; 254
    2c58:	3f 4f       	sbci	r19, 0xFF	; 255
    2c5a:	ca 01       	movw	r24, r20
    2c5c:	b9 01       	movw	r22, r18
    2c5e:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2c62:	eb 81       	ldd	r30, Y+3	; 0x03
    2c64:	fc 81       	ldd	r31, Y+4	; 0x04
    2c66:	96 89       	ldd	r25, Z+22	; 0x16
    2c68:	e0 91 d1 02 	lds	r30, 0x02D1
    2c6c:	f0 91 d2 02 	lds	r31, 0x02D2
    2c70:	86 89       	ldd	r24, Z+22	; 0x16
    2c72:	98 17       	cp	r25, r24
    2c74:	18 f0       	brcs	.+6      	; 0x2c7c <xTaskResumeAll+0xc2>
					{
						xYieldPending = pdTRUE;
    2c76:	81 e0       	ldi	r24, 0x01	; 1
    2c78:	80 93 da 02 	sts	0x02DA, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    2c7c:	80 91 1c 03 	lds	r24, 0x031C
    2c80:	88 23       	and	r24, r24
    2c82:	09 f0       	breq	.+2      	; 0x2c86 <xTaskResumeAll+0xcc>
    2c84:	b6 cf       	rjmp	.-148    	; 0x2bf2 <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    2c86:	8b 81       	ldd	r24, Y+3	; 0x03
    2c88:	9c 81       	ldd	r25, Y+4	; 0x04
    2c8a:	00 97       	sbiw	r24, 0x00	; 0
    2c8c:	11 f0       	breq	.+4      	; 0x2c92 <xTaskResumeAll+0xd8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    2c8e:	0e 94 69 1a 	call	0x34d2	; 0x34d2 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    2c92:	80 91 d9 02 	lds	r24, 0x02D9
    2c96:	89 83       	std	Y+1, r24	; 0x01

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    2c98:	89 81       	ldd	r24, Y+1	; 0x01
    2c9a:	88 23       	and	r24, r24
    2c9c:	79 f0       	breq	.+30     	; 0x2cbc <xTaskResumeAll+0x102>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    2c9e:	0e 94 cd 16 	call	0x2d9a	; 0x2d9a <xTaskIncrementTick>
    2ca2:	88 23       	and	r24, r24
    2ca4:	19 f0       	breq	.+6      	; 0x2cac <xTaskResumeAll+0xf2>
							{
								xYieldPending = pdTRUE;
    2ca6:	81 e0       	ldi	r24, 0x01	; 1
    2ca8:	80 93 da 02 	sts	0x02DA, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    2cac:	89 81       	ldd	r24, Y+1	; 0x01
    2cae:	81 50       	subi	r24, 0x01	; 1
    2cb0:	89 83       	std	Y+1, r24	; 0x01
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    2cb2:	89 81       	ldd	r24, Y+1	; 0x01
    2cb4:	88 23       	and	r24, r24
    2cb6:	99 f7       	brne	.-26     	; 0x2c9e <xTaskResumeAll+0xe4>

						uxPendedTicks = 0;
    2cb8:	10 92 d9 02 	sts	0x02D9, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    2cbc:	80 91 da 02 	lds	r24, 0x02DA
    2cc0:	88 23       	and	r24, r24
    2cc2:	21 f0       	breq	.+8      	; 0x2ccc <xTaskResumeAll+0x112>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    2cc4:	81 e0       	ldi	r24, 0x01	; 1
    2cc6:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    2cc8:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    2ccc:	0f 90       	pop	r0
    2cce:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    2cd0:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2cd2:	0f 90       	pop	r0
    2cd4:	0f 90       	pop	r0
    2cd6:	0f 90       	pop	r0
    2cd8:	0f 90       	pop	r0
    2cda:	cf 91       	pop	r28
    2cdc:	df 91       	pop	r29
    2cde:	08 95       	ret

00002ce0 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    2ce0:	df 93       	push	r29
    2ce2:	cf 93       	push	r28
    2ce4:	00 d0       	rcall	.+0      	; 0x2ce6 <xTaskGetTickCount+0x6>
    2ce6:	cd b7       	in	r28, 0x3d	; 61
    2ce8:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    2cea:	0f b6       	in	r0, 0x3f	; 63
    2cec:	f8 94       	cli
    2cee:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    2cf0:	80 91 d5 02 	lds	r24, 0x02D5
    2cf4:	90 91 d6 02 	lds	r25, 0x02D6
    2cf8:	9a 83       	std	Y+2, r25	; 0x02
    2cfa:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    2cfc:	0f 90       	pop	r0
    2cfe:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    2d00:	89 81       	ldd	r24, Y+1	; 0x01
    2d02:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2d04:	0f 90       	pop	r0
    2d06:	0f 90       	pop	r0
    2d08:	cf 91       	pop	r28
    2d0a:	df 91       	pop	r29
    2d0c:	08 95       	ret

00002d0e <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    2d0e:	df 93       	push	r29
    2d10:	cf 93       	push	r28
    2d12:	00 d0       	rcall	.+0      	; 0x2d14 <xTaskGetTickCountFromISR+0x6>
    2d14:	0f 92       	push	r0
    2d16:	cd b7       	in	r28, 0x3d	; 61
    2d18:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    2d1a:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    2d1c:	80 91 d5 02 	lds	r24, 0x02D5
    2d20:	90 91 d6 02 	lds	r25, 0x02D6
    2d24:	9b 83       	std	Y+3, r25	; 0x03
    2d26:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2d28:	8a 81       	ldd	r24, Y+2	; 0x02
    2d2a:	9b 81       	ldd	r25, Y+3	; 0x03
}
    2d2c:	0f 90       	pop	r0
    2d2e:	0f 90       	pop	r0
    2d30:	0f 90       	pop	r0
    2d32:	cf 91       	pop	r28
    2d34:	df 91       	pop	r29
    2d36:	08 95       	ret

00002d38 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    2d38:	df 93       	push	r29
    2d3a:	cf 93       	push	r28
    2d3c:	cd b7       	in	r28, 0x3d	; 61
    2d3e:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    2d40:	80 91 d4 02 	lds	r24, 0x02D4
}
    2d44:	cf 91       	pop	r28
    2d46:	df 91       	pop	r29
    2d48:	08 95       	ret

00002d4a <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    2d4a:	df 93       	push	r29
    2d4c:	cf 93       	push	r28
    2d4e:	00 d0       	rcall	.+0      	; 0x2d50 <pcTaskGetName+0x6>
    2d50:	00 d0       	rcall	.+0      	; 0x2d52 <pcTaskGetName+0x8>
    2d52:	00 d0       	rcall	.+0      	; 0x2d54 <pcTaskGetName+0xa>
    2d54:	cd b7       	in	r28, 0x3d	; 61
    2d56:	de b7       	in	r29, 0x3e	; 62
    2d58:	9c 83       	std	Y+4, r25	; 0x04
    2d5a:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    2d5c:	8b 81       	ldd	r24, Y+3	; 0x03
    2d5e:	9c 81       	ldd	r25, Y+4	; 0x04
    2d60:	00 97       	sbiw	r24, 0x00	; 0
    2d62:	39 f4       	brne	.+14     	; 0x2d72 <pcTaskGetName+0x28>
    2d64:	80 91 d1 02 	lds	r24, 0x02D1
    2d68:	90 91 d2 02 	lds	r25, 0x02D2
    2d6c:	9e 83       	std	Y+6, r25	; 0x06
    2d6e:	8d 83       	std	Y+5, r24	; 0x05
    2d70:	04 c0       	rjmp	.+8      	; 0x2d7a <pcTaskGetName+0x30>
    2d72:	8b 81       	ldd	r24, Y+3	; 0x03
    2d74:	9c 81       	ldd	r25, Y+4	; 0x04
    2d76:	9e 83       	std	Y+6, r25	; 0x06
    2d78:	8d 83       	std	Y+5, r24	; 0x05
    2d7a:	8d 81       	ldd	r24, Y+5	; 0x05
    2d7c:	9e 81       	ldd	r25, Y+6	; 0x06
    2d7e:	9a 83       	std	Y+2, r25	; 0x02
    2d80:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    2d82:	89 81       	ldd	r24, Y+1	; 0x01
    2d84:	9a 81       	ldd	r25, Y+2	; 0x02
    2d86:	49 96       	adiw	r24, 0x19	; 25
}
    2d88:	26 96       	adiw	r28, 0x06	; 6
    2d8a:	0f b6       	in	r0, 0x3f	; 63
    2d8c:	f8 94       	cli
    2d8e:	de bf       	out	0x3e, r29	; 62
    2d90:	0f be       	out	0x3f, r0	; 63
    2d92:	cd bf       	out	0x3d, r28	; 61
    2d94:	cf 91       	pop	r28
    2d96:	df 91       	pop	r29
    2d98:	08 95       	ret

00002d9a <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    2d9a:	df 93       	push	r29
    2d9c:	cf 93       	push	r28
    2d9e:	cd b7       	in	r28, 0x3d	; 61
    2da0:	de b7       	in	r29, 0x3e	; 62
    2da2:	29 97       	sbiw	r28, 0x09	; 9
    2da4:	0f b6       	in	r0, 0x3f	; 63
    2da6:	f8 94       	cli
    2da8:	de bf       	out	0x3e, r29	; 62
    2daa:	0f be       	out	0x3f, r0	; 63
    2dac:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    2dae:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2db0:	80 91 e1 02 	lds	r24, 0x02E1
    2db4:	88 23       	and	r24, r24
    2db6:	09 f0       	breq	.+2      	; 0x2dba <xTaskIncrementTick+0x20>
    2db8:	c0 c0       	rjmp	.+384    	; 0x2f3a <xTaskIncrementTick+0x1a0>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    2dba:	80 91 d5 02 	lds	r24, 0x02D5
    2dbe:	90 91 d6 02 	lds	r25, 0x02D6
    2dc2:	01 96       	adiw	r24, 0x01	; 1
    2dc4:	9c 83       	std	Y+4, r25	; 0x04
    2dc6:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    2dc8:	8b 81       	ldd	r24, Y+3	; 0x03
    2dca:	9c 81       	ldd	r25, Y+4	; 0x04
    2dcc:	90 93 d6 02 	sts	0x02D6, r25
    2dd0:	80 93 d5 02 	sts	0x02D5, r24

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    2dd4:	8b 81       	ldd	r24, Y+3	; 0x03
    2dd6:	9c 81       	ldd	r25, Y+4	; 0x04
    2dd8:	00 97       	sbiw	r24, 0x00	; 0
    2dda:	d9 f4       	brne	.+54     	; 0x2e12 <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    2ddc:	80 91 18 03 	lds	r24, 0x0318
    2de0:	90 91 19 03 	lds	r25, 0x0319
    2de4:	9a 83       	std	Y+2, r25	; 0x02
    2de6:	89 83       	std	Y+1, r24	; 0x01
    2de8:	80 91 1a 03 	lds	r24, 0x031A
    2dec:	90 91 1b 03 	lds	r25, 0x031B
    2df0:	90 93 19 03 	sts	0x0319, r25
    2df4:	80 93 18 03 	sts	0x0318, r24
    2df8:	89 81       	ldd	r24, Y+1	; 0x01
    2dfa:	9a 81       	ldd	r25, Y+2	; 0x02
    2dfc:	90 93 1b 03 	sts	0x031B, r25
    2e00:	80 93 1a 03 	sts	0x031A, r24
    2e04:	80 91 db 02 	lds	r24, 0x02DB
    2e08:	8f 5f       	subi	r24, 0xFF	; 255
    2e0a:	80 93 db 02 	sts	0x02DB, r24
    2e0e:	0e 94 69 1a 	call	0x34d2	; 0x34d2 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    2e12:	20 91 dd 02 	lds	r18, 0x02DD
    2e16:	30 91 de 02 	lds	r19, 0x02DE
    2e1a:	8b 81       	ldd	r24, Y+3	; 0x03
    2e1c:	9c 81       	ldd	r25, Y+4	; 0x04
    2e1e:	82 17       	cp	r24, r18
    2e20:	93 07       	cpc	r25, r19
    2e22:	08 f4       	brcc	.+2      	; 0x2e26 <xTaskIncrementTick+0x8c>
    2e24:	71 c0       	rjmp	.+226    	; 0x2f08 <xTaskIncrementTick+0x16e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2e26:	e0 91 18 03 	lds	r30, 0x0318
    2e2a:	f0 91 19 03 	lds	r31, 0x0319
    2e2e:	80 81       	ld	r24, Z
    2e30:	88 23       	and	r24, r24
    2e32:	39 f4       	brne	.+14     	; 0x2e42 <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2e34:	8f ef       	ldi	r24, 0xFF	; 255
    2e36:	9f ef       	ldi	r25, 0xFF	; 255
    2e38:	90 93 de 02 	sts	0x02DE, r25
    2e3c:	80 93 dd 02 	sts	0x02DD, r24
    2e40:	63 c0       	rjmp	.+198    	; 0x2f08 <xTaskIncrementTick+0x16e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2e42:	e0 91 18 03 	lds	r30, 0x0318
    2e46:	f0 91 19 03 	lds	r31, 0x0319
    2e4a:	05 80       	ldd	r0, Z+5	; 0x05
    2e4c:	f6 81       	ldd	r31, Z+6	; 0x06
    2e4e:	e0 2d       	mov	r30, r0
    2e50:	86 81       	ldd	r24, Z+6	; 0x06
    2e52:	97 81       	ldd	r25, Z+7	; 0x07
    2e54:	99 87       	std	Y+9, r25	; 0x09
    2e56:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    2e58:	e8 85       	ldd	r30, Y+8	; 0x08
    2e5a:	f9 85       	ldd	r31, Y+9	; 0x09
    2e5c:	82 81       	ldd	r24, Z+2	; 0x02
    2e5e:	93 81       	ldd	r25, Z+3	; 0x03
    2e60:	9f 83       	std	Y+7, r25	; 0x07
    2e62:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    2e64:	2b 81       	ldd	r18, Y+3	; 0x03
    2e66:	3c 81       	ldd	r19, Y+4	; 0x04
    2e68:	8e 81       	ldd	r24, Y+6	; 0x06
    2e6a:	9f 81       	ldd	r25, Y+7	; 0x07
    2e6c:	28 17       	cp	r18, r24
    2e6e:	39 07       	cpc	r19, r25
    2e70:	38 f4       	brcc	.+14     	; 0x2e80 <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    2e72:	8e 81       	ldd	r24, Y+6	; 0x06
    2e74:	9f 81       	ldd	r25, Y+7	; 0x07
    2e76:	90 93 de 02 	sts	0x02DE, r25
    2e7a:	80 93 dd 02 	sts	0x02DD, r24
    2e7e:	44 c0       	rjmp	.+136    	; 0x2f08 <xTaskIncrementTick+0x16e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2e80:	88 85       	ldd	r24, Y+8	; 0x08
    2e82:	99 85       	ldd	r25, Y+9	; 0x09
    2e84:	02 96       	adiw	r24, 0x02	; 2
    2e86:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    2e8a:	e8 85       	ldd	r30, Y+8	; 0x08
    2e8c:	f9 85       	ldd	r31, Y+9	; 0x09
    2e8e:	84 89       	ldd	r24, Z+20	; 0x14
    2e90:	95 89       	ldd	r25, Z+21	; 0x15
    2e92:	00 97       	sbiw	r24, 0x00	; 0
    2e94:	29 f0       	breq	.+10     	; 0x2ea0 <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2e96:	88 85       	ldd	r24, Y+8	; 0x08
    2e98:	99 85       	ldd	r25, Y+9	; 0x09
    2e9a:	0c 96       	adiw	r24, 0x0c	; 12
    2e9c:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    2ea0:	e8 85       	ldd	r30, Y+8	; 0x08
    2ea2:	f9 85       	ldd	r31, Y+9	; 0x09
    2ea4:	96 89       	ldd	r25, Z+22	; 0x16
    2ea6:	80 91 d7 02 	lds	r24, 0x02D7
    2eaa:	89 17       	cp	r24, r25
    2eac:	28 f4       	brcc	.+10     	; 0x2eb8 <xTaskIncrementTick+0x11e>
    2eae:	e8 85       	ldd	r30, Y+8	; 0x08
    2eb0:	f9 85       	ldd	r31, Y+9	; 0x09
    2eb2:	86 89       	ldd	r24, Z+22	; 0x16
    2eb4:	80 93 d7 02 	sts	0x02D7, r24
    2eb8:	e8 85       	ldd	r30, Y+8	; 0x08
    2eba:	f9 85       	ldd	r31, Y+9	; 0x09
    2ebc:	86 89       	ldd	r24, Z+22	; 0x16
    2ebe:	28 2f       	mov	r18, r24
    2ec0:	30 e0       	ldi	r19, 0x00	; 0
    2ec2:	c9 01       	movw	r24, r18
    2ec4:	88 0f       	add	r24, r24
    2ec6:	99 1f       	adc	r25, r25
    2ec8:	88 0f       	add	r24, r24
    2eca:	99 1f       	adc	r25, r25
    2ecc:	88 0f       	add	r24, r24
    2ece:	99 1f       	adc	r25, r25
    2ed0:	82 0f       	add	r24, r18
    2ed2:	93 1f       	adc	r25, r19
    2ed4:	ac 01       	movw	r20, r24
    2ed6:	4e 51       	subi	r20, 0x1E	; 30
    2ed8:	5d 4f       	sbci	r21, 0xFD	; 253
    2eda:	88 85       	ldd	r24, Y+8	; 0x08
    2edc:	99 85       	ldd	r25, Y+9	; 0x09
    2ede:	9c 01       	movw	r18, r24
    2ee0:	2e 5f       	subi	r18, 0xFE	; 254
    2ee2:	3f 4f       	sbci	r19, 0xFF	; 255
    2ee4:	ca 01       	movw	r24, r20
    2ee6:	b9 01       	movw	r22, r18
    2ee8:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2eec:	e8 85       	ldd	r30, Y+8	; 0x08
    2eee:	f9 85       	ldd	r31, Y+9	; 0x09
    2ef0:	96 89       	ldd	r25, Z+22	; 0x16
    2ef2:	e0 91 d1 02 	lds	r30, 0x02D1
    2ef6:	f0 91 d2 02 	lds	r31, 0x02D2
    2efa:	86 89       	ldd	r24, Z+22	; 0x16
    2efc:	98 17       	cp	r25, r24
    2efe:	08 f4       	brcc	.+2      	; 0x2f02 <xTaskIncrementTick+0x168>
    2f00:	92 cf       	rjmp	.-220    	; 0x2e26 <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    2f02:	81 e0       	ldi	r24, 0x01	; 1
    2f04:	8d 83       	std	Y+5, r24	; 0x05
    2f06:	8f cf       	rjmp	.-226    	; 0x2e26 <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    2f08:	e0 91 d1 02 	lds	r30, 0x02D1
    2f0c:	f0 91 d2 02 	lds	r31, 0x02D2
    2f10:	86 89       	ldd	r24, Z+22	; 0x16
    2f12:	28 2f       	mov	r18, r24
    2f14:	30 e0       	ldi	r19, 0x00	; 0
    2f16:	c9 01       	movw	r24, r18
    2f18:	88 0f       	add	r24, r24
    2f1a:	99 1f       	adc	r25, r25
    2f1c:	88 0f       	add	r24, r24
    2f1e:	99 1f       	adc	r25, r25
    2f20:	88 0f       	add	r24, r24
    2f22:	99 1f       	adc	r25, r25
    2f24:	82 0f       	add	r24, r18
    2f26:	93 1f       	adc	r25, r19
    2f28:	fc 01       	movw	r30, r24
    2f2a:	ee 51       	subi	r30, 0x1E	; 30
    2f2c:	fd 4f       	sbci	r31, 0xFD	; 253
    2f2e:	80 81       	ld	r24, Z
    2f30:	82 30       	cpi	r24, 0x02	; 2
    2f32:	40 f0       	brcs	.+16     	; 0x2f44 <xTaskIncrementTick+0x1aa>
			{
				xSwitchRequired = pdTRUE;
    2f34:	81 e0       	ldi	r24, 0x01	; 1
    2f36:	8d 83       	std	Y+5, r24	; 0x05
    2f38:	05 c0       	rjmp	.+10     	; 0x2f44 <xTaskIncrementTick+0x1aa>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    2f3a:	80 91 d9 02 	lds	r24, 0x02D9
    2f3e:	8f 5f       	subi	r24, 0xFF	; 255
    2f40:	80 93 d9 02 	sts	0x02D9, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    2f44:	80 91 da 02 	lds	r24, 0x02DA
    2f48:	88 23       	and	r24, r24
    2f4a:	11 f0       	breq	.+4      	; 0x2f50 <xTaskIncrementTick+0x1b6>
		{
			xSwitchRequired = pdTRUE;
    2f4c:	81 e0       	ldi	r24, 0x01	; 1
    2f4e:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    2f50:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2f52:	29 96       	adiw	r28, 0x09	; 9
    2f54:	0f b6       	in	r0, 0x3f	; 63
    2f56:	f8 94       	cli
    2f58:	de bf       	out	0x3e, r29	; 62
    2f5a:	0f be       	out	0x3f, r0	; 63
    2f5c:	cd bf       	out	0x3d, r28	; 61
    2f5e:	cf 91       	pop	r28
    2f60:	df 91       	pop	r29
    2f62:	08 95       	ret

00002f64 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    2f64:	df 93       	push	r29
    2f66:	cf 93       	push	r28
    2f68:	00 d0       	rcall	.+0      	; 0x2f6a <vTaskSwitchContext+0x6>
    2f6a:	0f 92       	push	r0
    2f6c:	cd b7       	in	r28, 0x3d	; 61
    2f6e:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    2f70:	80 91 e1 02 	lds	r24, 0x02E1
    2f74:	88 23       	and	r24, r24
    2f76:	21 f0       	breq	.+8      	; 0x2f80 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    2f78:	81 e0       	ldi	r24, 0x01	; 1
    2f7a:	80 93 da 02 	sts	0x02DA, r24
    2f7e:	59 c0       	rjmp	.+178    	; 0x3032 <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    2f80:	10 92 da 02 	sts	0x02DA, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2f84:	80 91 d7 02 	lds	r24, 0x02D7
    2f88:	8b 83       	std	Y+3, r24	; 0x03
    2f8a:	03 c0       	rjmp	.+6      	; 0x2f92 <vTaskSwitchContext+0x2e>
    2f8c:	8b 81       	ldd	r24, Y+3	; 0x03
    2f8e:	81 50       	subi	r24, 0x01	; 1
    2f90:	8b 83       	std	Y+3, r24	; 0x03
    2f92:	8b 81       	ldd	r24, Y+3	; 0x03
    2f94:	28 2f       	mov	r18, r24
    2f96:	30 e0       	ldi	r19, 0x00	; 0
    2f98:	c9 01       	movw	r24, r18
    2f9a:	88 0f       	add	r24, r24
    2f9c:	99 1f       	adc	r25, r25
    2f9e:	88 0f       	add	r24, r24
    2fa0:	99 1f       	adc	r25, r25
    2fa2:	88 0f       	add	r24, r24
    2fa4:	99 1f       	adc	r25, r25
    2fa6:	82 0f       	add	r24, r18
    2fa8:	93 1f       	adc	r25, r19
    2faa:	fc 01       	movw	r30, r24
    2fac:	ee 51       	subi	r30, 0x1E	; 30
    2fae:	fd 4f       	sbci	r31, 0xFD	; 253
    2fb0:	80 81       	ld	r24, Z
    2fb2:	88 23       	and	r24, r24
    2fb4:	59 f3       	breq	.-42     	; 0x2f8c <vTaskSwitchContext+0x28>
    2fb6:	8b 81       	ldd	r24, Y+3	; 0x03
    2fb8:	28 2f       	mov	r18, r24
    2fba:	30 e0       	ldi	r19, 0x00	; 0
    2fbc:	c9 01       	movw	r24, r18
    2fbe:	88 0f       	add	r24, r24
    2fc0:	99 1f       	adc	r25, r25
    2fc2:	88 0f       	add	r24, r24
    2fc4:	99 1f       	adc	r25, r25
    2fc6:	88 0f       	add	r24, r24
    2fc8:	99 1f       	adc	r25, r25
    2fca:	82 0f       	add	r24, r18
    2fcc:	93 1f       	adc	r25, r19
    2fce:	8e 51       	subi	r24, 0x1E	; 30
    2fd0:	9d 4f       	sbci	r25, 0xFD	; 253
    2fd2:	9a 83       	std	Y+2, r25	; 0x02
    2fd4:	89 83       	std	Y+1, r24	; 0x01
    2fd6:	e9 81       	ldd	r30, Y+1	; 0x01
    2fd8:	fa 81       	ldd	r31, Y+2	; 0x02
    2fda:	01 80       	ldd	r0, Z+1	; 0x01
    2fdc:	f2 81       	ldd	r31, Z+2	; 0x02
    2fde:	e0 2d       	mov	r30, r0
    2fe0:	82 81       	ldd	r24, Z+2	; 0x02
    2fe2:	93 81       	ldd	r25, Z+3	; 0x03
    2fe4:	e9 81       	ldd	r30, Y+1	; 0x01
    2fe6:	fa 81       	ldd	r31, Y+2	; 0x02
    2fe8:	92 83       	std	Z+2, r25	; 0x02
    2fea:	81 83       	std	Z+1, r24	; 0x01
    2fec:	e9 81       	ldd	r30, Y+1	; 0x01
    2fee:	fa 81       	ldd	r31, Y+2	; 0x02
    2ff0:	21 81       	ldd	r18, Z+1	; 0x01
    2ff2:	32 81       	ldd	r19, Z+2	; 0x02
    2ff4:	89 81       	ldd	r24, Y+1	; 0x01
    2ff6:	9a 81       	ldd	r25, Y+2	; 0x02
    2ff8:	03 96       	adiw	r24, 0x03	; 3
    2ffa:	28 17       	cp	r18, r24
    2ffc:	39 07       	cpc	r19, r25
    2ffe:	59 f4       	brne	.+22     	; 0x3016 <vTaskSwitchContext+0xb2>
    3000:	e9 81       	ldd	r30, Y+1	; 0x01
    3002:	fa 81       	ldd	r31, Y+2	; 0x02
    3004:	01 80       	ldd	r0, Z+1	; 0x01
    3006:	f2 81       	ldd	r31, Z+2	; 0x02
    3008:	e0 2d       	mov	r30, r0
    300a:	82 81       	ldd	r24, Z+2	; 0x02
    300c:	93 81       	ldd	r25, Z+3	; 0x03
    300e:	e9 81       	ldd	r30, Y+1	; 0x01
    3010:	fa 81       	ldd	r31, Y+2	; 0x02
    3012:	92 83       	std	Z+2, r25	; 0x02
    3014:	81 83       	std	Z+1, r24	; 0x01
    3016:	e9 81       	ldd	r30, Y+1	; 0x01
    3018:	fa 81       	ldd	r31, Y+2	; 0x02
    301a:	01 80       	ldd	r0, Z+1	; 0x01
    301c:	f2 81       	ldd	r31, Z+2	; 0x02
    301e:	e0 2d       	mov	r30, r0
    3020:	86 81       	ldd	r24, Z+6	; 0x06
    3022:	97 81       	ldd	r25, Z+7	; 0x07
    3024:	90 93 d2 02 	sts	0x02D2, r25
    3028:	80 93 d1 02 	sts	0x02D1, r24
    302c:	8b 81       	ldd	r24, Y+3	; 0x03
    302e:	80 93 d7 02 	sts	0x02D7, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    3032:	0f 90       	pop	r0
    3034:	0f 90       	pop	r0
    3036:	0f 90       	pop	r0
    3038:	cf 91       	pop	r28
    303a:	df 91       	pop	r29
    303c:	08 95       	ret

0000303e <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    303e:	df 93       	push	r29
    3040:	cf 93       	push	r28
    3042:	00 d0       	rcall	.+0      	; 0x3044 <vTaskPlaceOnEventList+0x6>
    3044:	00 d0       	rcall	.+0      	; 0x3046 <vTaskPlaceOnEventList+0x8>
    3046:	cd b7       	in	r28, 0x3d	; 61
    3048:	de b7       	in	r29, 0x3e	; 62
    304a:	9a 83       	std	Y+2, r25	; 0x02
    304c:	89 83       	std	Y+1, r24	; 0x01
    304e:	7c 83       	std	Y+4, r23	; 0x04
    3050:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3052:	80 91 d1 02 	lds	r24, 0x02D1
    3056:	90 91 d2 02 	lds	r25, 0x02D2
    305a:	9c 01       	movw	r18, r24
    305c:	24 5f       	subi	r18, 0xF4	; 244
    305e:	3f 4f       	sbci	r19, 0xFF	; 255
    3060:	89 81       	ldd	r24, Y+1	; 0x01
    3062:	9a 81       	ldd	r25, Y+2	; 0x02
    3064:	b9 01       	movw	r22, r18
    3066:	0e 94 a9 07 	call	0xf52	; 0xf52 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    306a:	8b 81       	ldd	r24, Y+3	; 0x03
    306c:	9c 81       	ldd	r25, Y+4	; 0x04
    306e:	61 e0       	ldi	r22, 0x01	; 1
    3070:	0e 94 63 1e 	call	0x3cc6	; 0x3cc6 <prvAddCurrentTaskToDelayedList>
}
    3074:	0f 90       	pop	r0
    3076:	0f 90       	pop	r0
    3078:	0f 90       	pop	r0
    307a:	0f 90       	pop	r0
    307c:	cf 91       	pop	r28
    307e:	df 91       	pop	r29
    3080:	08 95       	ret

00003082 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    3082:	df 93       	push	r29
    3084:	cf 93       	push	r28
    3086:	00 d0       	rcall	.+0      	; 0x3088 <vTaskPlaceOnUnorderedEventList+0x6>
    3088:	00 d0       	rcall	.+0      	; 0x308a <vTaskPlaceOnUnorderedEventList+0x8>
    308a:	00 d0       	rcall	.+0      	; 0x308c <vTaskPlaceOnUnorderedEventList+0xa>
    308c:	cd b7       	in	r28, 0x3d	; 61
    308e:	de b7       	in	r29, 0x3e	; 62
    3090:	9a 83       	std	Y+2, r25	; 0x02
    3092:	89 83       	std	Y+1, r24	; 0x01
    3094:	7c 83       	std	Y+4, r23	; 0x04
    3096:	6b 83       	std	Y+3, r22	; 0x03
    3098:	5e 83       	std	Y+6, r21	; 0x06
    309a:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    309c:	e0 91 d1 02 	lds	r30, 0x02D1
    30a0:	f0 91 d2 02 	lds	r31, 0x02D2
    30a4:	8b 81       	ldd	r24, Y+3	; 0x03
    30a6:	9c 81       	ldd	r25, Y+4	; 0x04
    30a8:	90 68       	ori	r25, 0x80	; 128
    30aa:	95 87       	std	Z+13, r25	; 0x0d
    30ac:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    30ae:	80 91 d1 02 	lds	r24, 0x02D1
    30b2:	90 91 d2 02 	lds	r25, 0x02D2
    30b6:	9c 01       	movw	r18, r24
    30b8:	24 5f       	subi	r18, 0xF4	; 244
    30ba:	3f 4f       	sbci	r19, 0xFF	; 255
    30bc:	89 81       	ldd	r24, Y+1	; 0x01
    30be:	9a 81       	ldd	r25, Y+2	; 0x02
    30c0:	b9 01       	movw	r22, r18
    30c2:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    30c6:	8d 81       	ldd	r24, Y+5	; 0x05
    30c8:	9e 81       	ldd	r25, Y+6	; 0x06
    30ca:	61 e0       	ldi	r22, 0x01	; 1
    30cc:	0e 94 63 1e 	call	0x3cc6	; 0x3cc6 <prvAddCurrentTaskToDelayedList>
}
    30d0:	26 96       	adiw	r28, 0x06	; 6
    30d2:	0f b6       	in	r0, 0x3f	; 63
    30d4:	f8 94       	cli
    30d6:	de bf       	out	0x3e, r29	; 62
    30d8:	0f be       	out	0x3f, r0	; 63
    30da:	cd bf       	out	0x3d, r28	; 61
    30dc:	cf 91       	pop	r28
    30de:	df 91       	pop	r29
    30e0:	08 95       	ret

000030e2 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    30e2:	df 93       	push	r29
    30e4:	cf 93       	push	r28
    30e6:	00 d0       	rcall	.+0      	; 0x30e8 <xTaskRemoveFromEventList+0x6>
    30e8:	00 d0       	rcall	.+0      	; 0x30ea <xTaskRemoveFromEventList+0x8>
    30ea:	0f 92       	push	r0
    30ec:	cd b7       	in	r28, 0x3d	; 61
    30ee:	de b7       	in	r29, 0x3e	; 62
    30f0:	9d 83       	std	Y+5, r25	; 0x05
    30f2:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    30f4:	ec 81       	ldd	r30, Y+4	; 0x04
    30f6:	fd 81       	ldd	r31, Y+5	; 0x05
    30f8:	05 80       	ldd	r0, Z+5	; 0x05
    30fa:	f6 81       	ldd	r31, Z+6	; 0x06
    30fc:	e0 2d       	mov	r30, r0
    30fe:	86 81       	ldd	r24, Z+6	; 0x06
    3100:	97 81       	ldd	r25, Z+7	; 0x07
    3102:	9b 83       	std	Y+3, r25	; 0x03
    3104:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    3106:	8a 81       	ldd	r24, Y+2	; 0x02
    3108:	9b 81       	ldd	r25, Y+3	; 0x03
    310a:	0c 96       	adiw	r24, 0x0c	; 12
    310c:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3110:	80 91 e1 02 	lds	r24, 0x02E1
    3114:	88 23       	and	r24, r24
    3116:	61 f5       	brne	.+88     	; 0x3170 <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    3118:	8a 81       	ldd	r24, Y+2	; 0x02
    311a:	9b 81       	ldd	r25, Y+3	; 0x03
    311c:	02 96       	adiw	r24, 0x02	; 2
    311e:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    3122:	ea 81       	ldd	r30, Y+2	; 0x02
    3124:	fb 81       	ldd	r31, Y+3	; 0x03
    3126:	96 89       	ldd	r25, Z+22	; 0x16
    3128:	80 91 d7 02 	lds	r24, 0x02D7
    312c:	89 17       	cp	r24, r25
    312e:	28 f4       	brcc	.+10     	; 0x313a <xTaskRemoveFromEventList+0x58>
    3130:	ea 81       	ldd	r30, Y+2	; 0x02
    3132:	fb 81       	ldd	r31, Y+3	; 0x03
    3134:	86 89       	ldd	r24, Z+22	; 0x16
    3136:	80 93 d7 02 	sts	0x02D7, r24
    313a:	ea 81       	ldd	r30, Y+2	; 0x02
    313c:	fb 81       	ldd	r31, Y+3	; 0x03
    313e:	86 89       	ldd	r24, Z+22	; 0x16
    3140:	28 2f       	mov	r18, r24
    3142:	30 e0       	ldi	r19, 0x00	; 0
    3144:	c9 01       	movw	r24, r18
    3146:	88 0f       	add	r24, r24
    3148:	99 1f       	adc	r25, r25
    314a:	88 0f       	add	r24, r24
    314c:	99 1f       	adc	r25, r25
    314e:	88 0f       	add	r24, r24
    3150:	99 1f       	adc	r25, r25
    3152:	82 0f       	add	r24, r18
    3154:	93 1f       	adc	r25, r19
    3156:	ac 01       	movw	r20, r24
    3158:	4e 51       	subi	r20, 0x1E	; 30
    315a:	5d 4f       	sbci	r21, 0xFD	; 253
    315c:	8a 81       	ldd	r24, Y+2	; 0x02
    315e:	9b 81       	ldd	r25, Y+3	; 0x03
    3160:	9c 01       	movw	r18, r24
    3162:	2e 5f       	subi	r18, 0xFE	; 254
    3164:	3f 4f       	sbci	r19, 0xFF	; 255
    3166:	ca 01       	movw	r24, r20
    3168:	b9 01       	movw	r22, r18
    316a:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>
    316e:	0a c0       	rjmp	.+20     	; 0x3184 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    3170:	8a 81       	ldd	r24, Y+2	; 0x02
    3172:	9b 81       	ldd	r25, Y+3	; 0x03
    3174:	9c 01       	movw	r18, r24
    3176:	24 5f       	subi	r18, 0xF4	; 244
    3178:	3f 4f       	sbci	r19, 0xFF	; 255
    317a:	8c e1       	ldi	r24, 0x1C	; 28
    317c:	93 e0       	ldi	r25, 0x03	; 3
    317e:	b9 01       	movw	r22, r18
    3180:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3184:	ea 81       	ldd	r30, Y+2	; 0x02
    3186:	fb 81       	ldd	r31, Y+3	; 0x03
    3188:	96 89       	ldd	r25, Z+22	; 0x16
    318a:	e0 91 d1 02 	lds	r30, 0x02D1
    318e:	f0 91 d2 02 	lds	r31, 0x02D2
    3192:	86 89       	ldd	r24, Z+22	; 0x16
    3194:	89 17       	cp	r24, r25
    3196:	30 f4       	brcc	.+12     	; 0x31a4 <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    3198:	81 e0       	ldi	r24, 0x01	; 1
    319a:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    319c:	81 e0       	ldi	r24, 0x01	; 1
    319e:	80 93 da 02 	sts	0x02DA, r24
    31a2:	01 c0       	rjmp	.+2      	; 0x31a6 <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    31a4:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    31a6:	89 81       	ldd	r24, Y+1	; 0x01
}
    31a8:	0f 90       	pop	r0
    31aa:	0f 90       	pop	r0
    31ac:	0f 90       	pop	r0
    31ae:	0f 90       	pop	r0
    31b0:	0f 90       	pop	r0
    31b2:	cf 91       	pop	r28
    31b4:	df 91       	pop	r29
    31b6:	08 95       	ret

000031b8 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    31b8:	df 93       	push	r29
    31ba:	cf 93       	push	r28
    31bc:	00 d0       	rcall	.+0      	; 0x31be <vTaskRemoveFromUnorderedEventList+0x6>
    31be:	00 d0       	rcall	.+0      	; 0x31c0 <vTaskRemoveFromUnorderedEventList+0x8>
    31c0:	00 d0       	rcall	.+0      	; 0x31c2 <vTaskRemoveFromUnorderedEventList+0xa>
    31c2:	cd b7       	in	r28, 0x3d	; 61
    31c4:	de b7       	in	r29, 0x3e	; 62
    31c6:	9c 83       	std	Y+4, r25	; 0x04
    31c8:	8b 83       	std	Y+3, r24	; 0x03
    31ca:	7e 83       	std	Y+6, r23	; 0x06
    31cc:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    31ce:	8d 81       	ldd	r24, Y+5	; 0x05
    31d0:	9e 81       	ldd	r25, Y+6	; 0x06
    31d2:	90 68       	ori	r25, 0x80	; 128
    31d4:	eb 81       	ldd	r30, Y+3	; 0x03
    31d6:	fc 81       	ldd	r31, Y+4	; 0x04
    31d8:	91 83       	std	Z+1, r25	; 0x01
    31da:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    31dc:	eb 81       	ldd	r30, Y+3	; 0x03
    31de:	fc 81       	ldd	r31, Y+4	; 0x04
    31e0:	86 81       	ldd	r24, Z+6	; 0x06
    31e2:	97 81       	ldd	r25, Z+7	; 0x07
    31e4:	9a 83       	std	Y+2, r25	; 0x02
    31e6:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    31e8:	8b 81       	ldd	r24, Y+3	; 0x03
    31ea:	9c 81       	ldd	r25, Y+4	; 0x04
    31ec:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    31f0:	89 81       	ldd	r24, Y+1	; 0x01
    31f2:	9a 81       	ldd	r25, Y+2	; 0x02
    31f4:	02 96       	adiw	r24, 0x02	; 2
    31f6:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    31fa:	e9 81       	ldd	r30, Y+1	; 0x01
    31fc:	fa 81       	ldd	r31, Y+2	; 0x02
    31fe:	96 89       	ldd	r25, Z+22	; 0x16
    3200:	80 91 d7 02 	lds	r24, 0x02D7
    3204:	89 17       	cp	r24, r25
    3206:	28 f4       	brcc	.+10     	; 0x3212 <vTaskRemoveFromUnorderedEventList+0x5a>
    3208:	e9 81       	ldd	r30, Y+1	; 0x01
    320a:	fa 81       	ldd	r31, Y+2	; 0x02
    320c:	86 89       	ldd	r24, Z+22	; 0x16
    320e:	80 93 d7 02 	sts	0x02D7, r24
    3212:	e9 81       	ldd	r30, Y+1	; 0x01
    3214:	fa 81       	ldd	r31, Y+2	; 0x02
    3216:	86 89       	ldd	r24, Z+22	; 0x16
    3218:	28 2f       	mov	r18, r24
    321a:	30 e0       	ldi	r19, 0x00	; 0
    321c:	c9 01       	movw	r24, r18
    321e:	88 0f       	add	r24, r24
    3220:	99 1f       	adc	r25, r25
    3222:	88 0f       	add	r24, r24
    3224:	99 1f       	adc	r25, r25
    3226:	88 0f       	add	r24, r24
    3228:	99 1f       	adc	r25, r25
    322a:	82 0f       	add	r24, r18
    322c:	93 1f       	adc	r25, r19
    322e:	ac 01       	movw	r20, r24
    3230:	4e 51       	subi	r20, 0x1E	; 30
    3232:	5d 4f       	sbci	r21, 0xFD	; 253
    3234:	89 81       	ldd	r24, Y+1	; 0x01
    3236:	9a 81       	ldd	r25, Y+2	; 0x02
    3238:	9c 01       	movw	r18, r24
    323a:	2e 5f       	subi	r18, 0xFE	; 254
    323c:	3f 4f       	sbci	r19, 0xFF	; 255
    323e:	ca 01       	movw	r24, r20
    3240:	b9 01       	movw	r22, r18
    3242:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3246:	e9 81       	ldd	r30, Y+1	; 0x01
    3248:	fa 81       	ldd	r31, Y+2	; 0x02
    324a:	96 89       	ldd	r25, Z+22	; 0x16
    324c:	e0 91 d1 02 	lds	r30, 0x02D1
    3250:	f0 91 d2 02 	lds	r31, 0x02D2
    3254:	86 89       	ldd	r24, Z+22	; 0x16
    3256:	89 17       	cp	r24, r25
    3258:	18 f4       	brcc	.+6      	; 0x3260 <vTaskRemoveFromUnorderedEventList+0xa8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    325a:	81 e0       	ldi	r24, 0x01	; 1
    325c:	80 93 da 02 	sts	0x02DA, r24
	}
}
    3260:	26 96       	adiw	r28, 0x06	; 6
    3262:	0f b6       	in	r0, 0x3f	; 63
    3264:	f8 94       	cli
    3266:	de bf       	out	0x3e, r29	; 62
    3268:	0f be       	out	0x3f, r0	; 63
    326a:	cd bf       	out	0x3d, r28	; 61
    326c:	cf 91       	pop	r28
    326e:	df 91       	pop	r29
    3270:	08 95       	ret

00003272 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    3272:	df 93       	push	r29
    3274:	cf 93       	push	r28
    3276:	00 d0       	rcall	.+0      	; 0x3278 <vTaskSetTimeOutState+0x6>
    3278:	cd b7       	in	r28, 0x3d	; 61
    327a:	de b7       	in	r29, 0x3e	; 62
    327c:	9a 83       	std	Y+2, r25	; 0x02
    327e:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    3280:	0f b6       	in	r0, 0x3f	; 63
    3282:	f8 94       	cli
    3284:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    3286:	80 91 db 02 	lds	r24, 0x02DB
    328a:	e9 81       	ldd	r30, Y+1	; 0x01
    328c:	fa 81       	ldd	r31, Y+2	; 0x02
    328e:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    3290:	80 91 d5 02 	lds	r24, 0x02D5
    3294:	90 91 d6 02 	lds	r25, 0x02D6
    3298:	e9 81       	ldd	r30, Y+1	; 0x01
    329a:	fa 81       	ldd	r31, Y+2	; 0x02
    329c:	92 83       	std	Z+2, r25	; 0x02
    329e:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    32a0:	0f 90       	pop	r0
    32a2:	0f be       	out	0x3f, r0	; 63
}
    32a4:	0f 90       	pop	r0
    32a6:	0f 90       	pop	r0
    32a8:	cf 91       	pop	r28
    32aa:	df 91       	pop	r29
    32ac:	08 95       	ret

000032ae <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    32ae:	df 93       	push	r29
    32b0:	cf 93       	push	r28
    32b2:	00 d0       	rcall	.+0      	; 0x32b4 <vTaskInternalSetTimeOutState+0x6>
    32b4:	cd b7       	in	r28, 0x3d	; 61
    32b6:	de b7       	in	r29, 0x3e	; 62
    32b8:	9a 83       	std	Y+2, r25	; 0x02
    32ba:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    32bc:	80 91 db 02 	lds	r24, 0x02DB
    32c0:	e9 81       	ldd	r30, Y+1	; 0x01
    32c2:	fa 81       	ldd	r31, Y+2	; 0x02
    32c4:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    32c6:	80 91 d5 02 	lds	r24, 0x02D5
    32ca:	90 91 d6 02 	lds	r25, 0x02D6
    32ce:	e9 81       	ldd	r30, Y+1	; 0x01
    32d0:	fa 81       	ldd	r31, Y+2	; 0x02
    32d2:	92 83       	std	Z+2, r25	; 0x02
    32d4:	81 83       	std	Z+1, r24	; 0x01
}
    32d6:	0f 90       	pop	r0
    32d8:	0f 90       	pop	r0
    32da:	cf 91       	pop	r28
    32dc:	df 91       	pop	r29
    32de:	08 95       	ret

000032e0 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    32e0:	df 93       	push	r29
    32e2:	cf 93       	push	r28
    32e4:	cd b7       	in	r28, 0x3d	; 61
    32e6:	de b7       	in	r29, 0x3e	; 62
    32e8:	29 97       	sbiw	r28, 0x09	; 9
    32ea:	0f b6       	in	r0, 0x3f	; 63
    32ec:	f8 94       	cli
    32ee:	de bf       	out	0x3e, r29	; 62
    32f0:	0f be       	out	0x3f, r0	; 63
    32f2:	cd bf       	out	0x3d, r28	; 61
    32f4:	9f 83       	std	Y+7, r25	; 0x07
    32f6:	8e 83       	std	Y+6, r24	; 0x06
    32f8:	79 87       	std	Y+9, r23	; 0x09
    32fa:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    32fc:	0f b6       	in	r0, 0x3f	; 63
    32fe:	f8 94       	cli
    3300:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    3302:	80 91 d5 02 	lds	r24, 0x02D5
    3306:	90 91 d6 02 	lds	r25, 0x02D6
    330a:	9c 83       	std	Y+4, r25	; 0x04
    330c:	8b 83       	std	Y+3, r24	; 0x03
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    330e:	ee 81       	ldd	r30, Y+6	; 0x06
    3310:	ff 81       	ldd	r31, Y+7	; 0x07
    3312:	21 81       	ldd	r18, Z+1	; 0x01
    3314:	32 81       	ldd	r19, Z+2	; 0x02
    3316:	8b 81       	ldd	r24, Y+3	; 0x03
    3318:	9c 81       	ldd	r25, Y+4	; 0x04
    331a:	82 1b       	sub	r24, r18
    331c:	93 0b       	sbc	r25, r19
    331e:	9a 83       	std	Y+2, r25	; 0x02
    3320:	89 83       	std	Y+1, r24	; 0x01
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    3322:	ee 81       	ldd	r30, Y+6	; 0x06
    3324:	ff 81       	ldd	r31, Y+7	; 0x07
    3326:	90 81       	ld	r25, Z
    3328:	80 91 db 02 	lds	r24, 0x02DB
    332c:	98 17       	cp	r25, r24
    332e:	61 f0       	breq	.+24     	; 0x3348 <xTaskCheckForTimeOut+0x68>
    3330:	ee 81       	ldd	r30, Y+6	; 0x06
    3332:	ff 81       	ldd	r31, Y+7	; 0x07
    3334:	21 81       	ldd	r18, Z+1	; 0x01
    3336:	32 81       	ldd	r19, Z+2	; 0x02
    3338:	8b 81       	ldd	r24, Y+3	; 0x03
    333a:	9c 81       	ldd	r25, Y+4	; 0x04
    333c:	82 17       	cp	r24, r18
    333e:	93 07       	cpc	r25, r19
    3340:	18 f0       	brcs	.+6      	; 0x3348 <xTaskCheckForTimeOut+0x68>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    3342:	81 e0       	ldi	r24, 0x01	; 1
    3344:	8d 83       	std	Y+5, r24	; 0x05
    3346:	23 c0       	rjmp	.+70     	; 0x338e <xTaskCheckForTimeOut+0xae>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    3348:	e8 85       	ldd	r30, Y+8	; 0x08
    334a:	f9 85       	ldd	r31, Y+9	; 0x09
    334c:	20 81       	ld	r18, Z
    334e:	31 81       	ldd	r19, Z+1	; 0x01
    3350:	89 81       	ldd	r24, Y+1	; 0x01
    3352:	9a 81       	ldd	r25, Y+2	; 0x02
    3354:	82 17       	cp	r24, r18
    3356:	93 07       	cpc	r25, r19
    3358:	a0 f4       	brcc	.+40     	; 0x3382 <xTaskCheckForTimeOut+0xa2>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    335a:	e8 85       	ldd	r30, Y+8	; 0x08
    335c:	f9 85       	ldd	r31, Y+9	; 0x09
    335e:	20 81       	ld	r18, Z
    3360:	31 81       	ldd	r19, Z+1	; 0x01
    3362:	89 81       	ldd	r24, Y+1	; 0x01
    3364:	9a 81       	ldd	r25, Y+2	; 0x02
    3366:	a9 01       	movw	r20, r18
    3368:	48 1b       	sub	r20, r24
    336a:	59 0b       	sbc	r21, r25
    336c:	ca 01       	movw	r24, r20
    336e:	e8 85       	ldd	r30, Y+8	; 0x08
    3370:	f9 85       	ldd	r31, Y+9	; 0x09
    3372:	91 83       	std	Z+1, r25	; 0x01
    3374:	80 83       	st	Z, r24
			vTaskInternalSetTimeOutState( pxTimeOut );
    3376:	8e 81       	ldd	r24, Y+6	; 0x06
    3378:	9f 81       	ldd	r25, Y+7	; 0x07
    337a:	0e 94 57 19 	call	0x32ae	; 0x32ae <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    337e:	1d 82       	std	Y+5, r1	; 0x05
    3380:	06 c0       	rjmp	.+12     	; 0x338e <xTaskCheckForTimeOut+0xae>
		}
		else
		{
			*pxTicksToWait = 0;
    3382:	e8 85       	ldd	r30, Y+8	; 0x08
    3384:	f9 85       	ldd	r31, Y+9	; 0x09
    3386:	11 82       	std	Z+1, r1	; 0x01
    3388:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    338a:	81 e0       	ldi	r24, 0x01	; 1
    338c:	8d 83       	std	Y+5, r24	; 0x05
		}
	}
	taskEXIT_CRITICAL();
    338e:	0f 90       	pop	r0
    3390:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3392:	8d 81       	ldd	r24, Y+5	; 0x05
}
    3394:	29 96       	adiw	r28, 0x09	; 9
    3396:	0f b6       	in	r0, 0x3f	; 63
    3398:	f8 94       	cli
    339a:	de bf       	out	0x3e, r29	; 62
    339c:	0f be       	out	0x3f, r0	; 63
    339e:	cd bf       	out	0x3d, r28	; 61
    33a0:	cf 91       	pop	r28
    33a2:	df 91       	pop	r29
    33a4:	08 95       	ret

000033a6 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    33a6:	df 93       	push	r29
    33a8:	cf 93       	push	r28
    33aa:	cd b7       	in	r28, 0x3d	; 61
    33ac:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    33ae:	81 e0       	ldi	r24, 0x01	; 1
    33b0:	80 93 da 02 	sts	0x02DA, r24
}
    33b4:	cf 91       	pop	r28
    33b6:	df 91       	pop	r29
    33b8:	08 95       	ret

000033ba <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    33ba:	df 93       	push	r29
    33bc:	cf 93       	push	r28
    33be:	00 d0       	rcall	.+0      	; 0x33c0 <prvIdleTask+0x6>
    33c0:	cd b7       	in	r28, 0x3d	; 61
    33c2:	de b7       	in	r29, 0x3e	; 62
    33c4:	9a 83       	std	Y+2, r25	; 0x02
    33c6:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    33c8:	0e 94 24 1a 	call	0x3448	; 0x3448 <prvCheckTasksWaitingTermination>
    33cc:	fd cf       	rjmp	.-6      	; 0x33c8 <prvIdleTask+0xe>

000033ce <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    33ce:	df 93       	push	r29
    33d0:	cf 93       	push	r28
    33d2:	0f 92       	push	r0
    33d4:	cd b7       	in	r28, 0x3d	; 61
    33d6:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    33d8:	19 82       	std	Y+1, r1	; 0x01
    33da:	13 c0       	rjmp	.+38     	; 0x3402 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    33dc:	89 81       	ldd	r24, Y+1	; 0x01
    33de:	28 2f       	mov	r18, r24
    33e0:	30 e0       	ldi	r19, 0x00	; 0
    33e2:	c9 01       	movw	r24, r18
    33e4:	88 0f       	add	r24, r24
    33e6:	99 1f       	adc	r25, r25
    33e8:	88 0f       	add	r24, r24
    33ea:	99 1f       	adc	r25, r25
    33ec:	88 0f       	add	r24, r24
    33ee:	99 1f       	adc	r25, r25
    33f0:	82 0f       	add	r24, r18
    33f2:	93 1f       	adc	r25, r19
    33f4:	8e 51       	subi	r24, 0x1E	; 30
    33f6:	9d 4f       	sbci	r25, 0xFD	; 253
    33f8:	0e 94 2b 07 	call	0xe56	; 0xe56 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    33fc:	89 81       	ldd	r24, Y+1	; 0x01
    33fe:	8f 5f       	subi	r24, 0xFF	; 255
    3400:	89 83       	std	Y+1, r24	; 0x01
    3402:	89 81       	ldd	r24, Y+1	; 0x01
    3404:	84 30       	cpi	r24, 0x04	; 4
    3406:	50 f3       	brcs	.-44     	; 0x33dc <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    3408:	86 e0       	ldi	r24, 0x06	; 6
    340a:	93 e0       	ldi	r25, 0x03	; 3
    340c:	0e 94 2b 07 	call	0xe56	; 0xe56 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    3410:	8f e0       	ldi	r24, 0x0F	; 15
    3412:	93 e0       	ldi	r25, 0x03	; 3
    3414:	0e 94 2b 07 	call	0xe56	; 0xe56 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    3418:	8c e1       	ldi	r24, 0x1C	; 28
    341a:	93 e0       	ldi	r25, 0x03	; 3
    341c:	0e 94 2b 07 	call	0xe56	; 0xe56 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    3420:	85 e2       	ldi	r24, 0x25	; 37
    3422:	93 e0       	ldi	r25, 0x03	; 3
    3424:	0e 94 2b 07 	call	0xe56	; 0xe56 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    3428:	86 e0       	ldi	r24, 0x06	; 6
    342a:	93 e0       	ldi	r25, 0x03	; 3
    342c:	90 93 19 03 	sts	0x0319, r25
    3430:	80 93 18 03 	sts	0x0318, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    3434:	8f e0       	ldi	r24, 0x0F	; 15
    3436:	93 e0       	ldi	r25, 0x03	; 3
    3438:	90 93 1b 03 	sts	0x031B, r25
    343c:	80 93 1a 03 	sts	0x031A, r24
}
    3440:	0f 90       	pop	r0
    3442:	cf 91       	pop	r28
    3444:	df 91       	pop	r29
    3446:	08 95       	ret

00003448 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    3448:	df 93       	push	r29
    344a:	cf 93       	push	r28
    344c:	00 d0       	rcall	.+0      	; 0x344e <prvCheckTasksWaitingTermination+0x6>
    344e:	cd b7       	in	r28, 0x3d	; 61
    3450:	de b7       	in	r29, 0x3e	; 62
    3452:	20 c0       	rjmp	.+64     	; 0x3494 <prvCheckTasksWaitingTermination+0x4c>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
    3454:	0f b6       	in	r0, 0x3f	; 63
    3456:	f8 94       	cli
    3458:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    345a:	e0 91 2a 03 	lds	r30, 0x032A
    345e:	f0 91 2b 03 	lds	r31, 0x032B
    3462:	86 81       	ldd	r24, Z+6	; 0x06
    3464:	97 81       	ldd	r25, Z+7	; 0x07
    3466:	9a 83       	std	Y+2, r25	; 0x02
    3468:	89 83       	std	Y+1, r24	; 0x01
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    346a:	89 81       	ldd	r24, Y+1	; 0x01
    346c:	9a 81       	ldd	r25, Y+2	; 0x02
    346e:	02 96       	adiw	r24, 0x02	; 2
    3470:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>
				--uxCurrentNumberOfTasks;
    3474:	80 91 d4 02 	lds	r24, 0x02D4
    3478:	81 50       	subi	r24, 0x01	; 1
    347a:	80 93 d4 02 	sts	0x02D4, r24
				--uxDeletedTasksWaitingCleanUp;
    347e:	80 91 d3 02 	lds	r24, 0x02D3
    3482:	81 50       	subi	r24, 0x01	; 1
    3484:	80 93 d3 02 	sts	0x02D3, r24
			}
			taskEXIT_CRITICAL();
    3488:	0f 90       	pop	r0
    348a:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    348c:	89 81       	ldd	r24, Y+1	; 0x01
    348e:	9a 81       	ldd	r25, Y+2	; 0x02
    3490:	0e 94 53 1a 	call	0x34a6	; 0x34a6 <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    3494:	80 91 d3 02 	lds	r24, 0x02D3
    3498:	88 23       	and	r24, r24
    349a:	e1 f6       	brne	.-72     	; 0x3454 <prvCheckTasksWaitingTermination+0xc>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    349c:	0f 90       	pop	r0
    349e:	0f 90       	pop	r0
    34a0:	cf 91       	pop	r28
    34a2:	df 91       	pop	r29
    34a4:	08 95       	ret

000034a6 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    34a6:	df 93       	push	r29
    34a8:	cf 93       	push	r28
    34aa:	00 d0       	rcall	.+0      	; 0x34ac <prvDeleteTCB+0x6>
    34ac:	cd b7       	in	r28, 0x3d	; 61
    34ae:	de b7       	in	r29, 0x3e	; 62
    34b0:	9a 83       	std	Y+2, r25	; 0x02
    34b2:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    34b4:	e9 81       	ldd	r30, Y+1	; 0x01
    34b6:	fa 81       	ldd	r31, Y+2	; 0x02
    34b8:	87 89       	ldd	r24, Z+23	; 0x17
    34ba:	90 8d       	ldd	r25, Z+24	; 0x18
    34bc:	0e 94 05 07 	call	0xe0a	; 0xe0a <vPortFree>
			vPortFree( pxTCB );
    34c0:	89 81       	ldd	r24, Y+1	; 0x01
    34c2:	9a 81       	ldd	r25, Y+2	; 0x02
    34c4:	0e 94 05 07 	call	0xe0a	; 0xe0a <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    34c8:	0f 90       	pop	r0
    34ca:	0f 90       	pop	r0
    34cc:	cf 91       	pop	r28
    34ce:	df 91       	pop	r29
    34d0:	08 95       	ret

000034d2 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    34d2:	df 93       	push	r29
    34d4:	cf 93       	push	r28
    34d6:	00 d0       	rcall	.+0      	; 0x34d8 <prvResetNextTaskUnblockTime+0x6>
    34d8:	cd b7       	in	r28, 0x3d	; 61
    34da:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    34dc:	e0 91 18 03 	lds	r30, 0x0318
    34e0:	f0 91 19 03 	lds	r31, 0x0319
    34e4:	80 81       	ld	r24, Z
    34e6:	88 23       	and	r24, r24
    34e8:	39 f4       	brne	.+14     	; 0x34f8 <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    34ea:	8f ef       	ldi	r24, 0xFF	; 255
    34ec:	9f ef       	ldi	r25, 0xFF	; 255
    34ee:	90 93 de 02 	sts	0x02DE, r25
    34f2:	80 93 dd 02 	sts	0x02DD, r24
    34f6:	13 c0       	rjmp	.+38     	; 0x351e <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    34f8:	e0 91 18 03 	lds	r30, 0x0318
    34fc:	f0 91 19 03 	lds	r31, 0x0319
    3500:	05 80       	ldd	r0, Z+5	; 0x05
    3502:	f6 81       	ldd	r31, Z+6	; 0x06
    3504:	e0 2d       	mov	r30, r0
    3506:	86 81       	ldd	r24, Z+6	; 0x06
    3508:	97 81       	ldd	r25, Z+7	; 0x07
    350a:	9a 83       	std	Y+2, r25	; 0x02
    350c:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    350e:	e9 81       	ldd	r30, Y+1	; 0x01
    3510:	fa 81       	ldd	r31, Y+2	; 0x02
    3512:	82 81       	ldd	r24, Z+2	; 0x02
    3514:	93 81       	ldd	r25, Z+3	; 0x03
    3516:	90 93 de 02 	sts	0x02DE, r25
    351a:	80 93 dd 02 	sts	0x02DD, r24
	}
}
    351e:	0f 90       	pop	r0
    3520:	0f 90       	pop	r0
    3522:	cf 91       	pop	r28
    3524:	df 91       	pop	r29
    3526:	08 95       	ret

00003528 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    3528:	df 93       	push	r29
    352a:	cf 93       	push	r28
    352c:	00 d0       	rcall	.+0      	; 0x352e <uxTaskResetEventItemValue+0x6>
    352e:	cd b7       	in	r28, 0x3d	; 61
    3530:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    3532:	e0 91 d1 02 	lds	r30, 0x02D1
    3536:	f0 91 d2 02 	lds	r31, 0x02D2
    353a:	84 85       	ldd	r24, Z+12	; 0x0c
    353c:	95 85       	ldd	r25, Z+13	; 0x0d
    353e:	9a 83       	std	Y+2, r25	; 0x02
    3540:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3542:	a0 91 d1 02 	lds	r26, 0x02D1
    3546:	b0 91 d2 02 	lds	r27, 0x02D2
    354a:	e0 91 d1 02 	lds	r30, 0x02D1
    354e:	f0 91 d2 02 	lds	r31, 0x02D2
    3552:	86 89       	ldd	r24, Z+22	; 0x16
    3554:	28 2f       	mov	r18, r24
    3556:	30 e0       	ldi	r19, 0x00	; 0
    3558:	84 e0       	ldi	r24, 0x04	; 4
    355a:	90 e0       	ldi	r25, 0x00	; 0
    355c:	82 1b       	sub	r24, r18
    355e:	93 0b       	sbc	r25, r19
    3560:	1d 96       	adiw	r26, 0x0d	; 13
    3562:	9c 93       	st	X, r25
    3564:	8e 93       	st	-X, r24
    3566:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    3568:	89 81       	ldd	r24, Y+1	; 0x01
    356a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    356c:	0f 90       	pop	r0
    356e:	0f 90       	pop	r0
    3570:	cf 91       	pop	r28
    3572:	df 91       	pop	r29
    3574:	08 95       	ret

00003576 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    3576:	df 93       	push	r29
    3578:	cf 93       	push	r28
    357a:	cd b7       	in	r28, 0x3d	; 61
    357c:	de b7       	in	r29, 0x3e	; 62
    357e:	27 97       	sbiw	r28, 0x07	; 7
    3580:	0f b6       	in	r0, 0x3f	; 63
    3582:	f8 94       	cli
    3584:	de bf       	out	0x3e, r29	; 62
    3586:	0f be       	out	0x3f, r0	; 63
    3588:	cd bf       	out	0x3d, r28	; 61
    358a:	8d 83       	std	Y+5, r24	; 0x05
    358c:	7f 83       	std	Y+7, r23	; 0x07
    358e:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    3590:	0f b6       	in	r0, 0x3f	; 63
    3592:	f8 94       	cli
    3594:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    3596:	e0 91 d1 02 	lds	r30, 0x02D1
    359a:	f0 91 d2 02 	lds	r31, 0x02D2
    359e:	81 a1       	ldd	r24, Z+33	; 0x21
    35a0:	92 a1       	ldd	r25, Z+34	; 0x22
    35a2:	a3 a1       	ldd	r26, Z+35	; 0x23
    35a4:	b4 a1       	ldd	r27, Z+36	; 0x24
    35a6:	00 97       	sbiw	r24, 0x00	; 0
    35a8:	a1 05       	cpc	r26, r1
    35aa:	b1 05       	cpc	r27, r1
    35ac:	89 f4       	brne	.+34     	; 0x35d0 <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    35ae:	e0 91 d1 02 	lds	r30, 0x02D1
    35b2:	f0 91 d2 02 	lds	r31, 0x02D2
    35b6:	81 e0       	ldi	r24, 0x01	; 1
    35b8:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    35ba:	8e 81       	ldd	r24, Y+6	; 0x06
    35bc:	9f 81       	ldd	r25, Y+7	; 0x07
    35be:	00 97       	sbiw	r24, 0x00	; 0
    35c0:	39 f0       	breq	.+14     	; 0x35d0 <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    35c2:	8e 81       	ldd	r24, Y+6	; 0x06
    35c4:	9f 81       	ldd	r25, Y+7	; 0x07
    35c6:	61 e0       	ldi	r22, 0x01	; 1
    35c8:	0e 94 63 1e 	call	0x3cc6	; 0x3cc6 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    35cc:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    35d0:	0f 90       	pop	r0
    35d2:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    35d4:	0f b6       	in	r0, 0x3f	; 63
    35d6:	f8 94       	cli
    35d8:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    35da:	e0 91 d1 02 	lds	r30, 0x02D1
    35de:	f0 91 d2 02 	lds	r31, 0x02D2
    35e2:	81 a1       	ldd	r24, Z+33	; 0x21
    35e4:	92 a1       	ldd	r25, Z+34	; 0x22
    35e6:	a3 a1       	ldd	r26, Z+35	; 0x23
    35e8:	b4 a1       	ldd	r27, Z+36	; 0x24
    35ea:	89 83       	std	Y+1, r24	; 0x01
    35ec:	9a 83       	std	Y+2, r25	; 0x02
    35ee:	ab 83       	std	Y+3, r26	; 0x03
    35f0:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    35f2:	89 81       	ldd	r24, Y+1	; 0x01
    35f4:	9a 81       	ldd	r25, Y+2	; 0x02
    35f6:	ab 81       	ldd	r26, Y+3	; 0x03
    35f8:	bc 81       	ldd	r27, Y+4	; 0x04
    35fa:	00 97       	sbiw	r24, 0x00	; 0
    35fc:	a1 05       	cpc	r26, r1
    35fe:	b1 05       	cpc	r27, r1
    3600:	d9 f0       	breq	.+54     	; 0x3638 <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    3602:	8d 81       	ldd	r24, Y+5	; 0x05
    3604:	88 23       	and	r24, r24
    3606:	49 f0       	breq	.+18     	; 0x361a <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    3608:	e0 91 d1 02 	lds	r30, 0x02D1
    360c:	f0 91 d2 02 	lds	r31, 0x02D2
    3610:	11 a2       	std	Z+33, r1	; 0x21
    3612:	12 a2       	std	Z+34, r1	; 0x22
    3614:	13 a2       	std	Z+35, r1	; 0x23
    3616:	14 a2       	std	Z+36, r1	; 0x24
    3618:	0f c0       	rjmp	.+30     	; 0x3638 <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    361a:	e0 91 d1 02 	lds	r30, 0x02D1
    361e:	f0 91 d2 02 	lds	r31, 0x02D2
    3622:	89 81       	ldd	r24, Y+1	; 0x01
    3624:	9a 81       	ldd	r25, Y+2	; 0x02
    3626:	ab 81       	ldd	r26, Y+3	; 0x03
    3628:	bc 81       	ldd	r27, Y+4	; 0x04
    362a:	01 97       	sbiw	r24, 0x01	; 1
    362c:	a1 09       	sbc	r26, r1
    362e:	b1 09       	sbc	r27, r1
    3630:	81 a3       	std	Z+33, r24	; 0x21
    3632:	92 a3       	std	Z+34, r25	; 0x22
    3634:	a3 a3       	std	Z+35, r26	; 0x23
    3636:	b4 a3       	std	Z+36, r27	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3638:	e0 91 d1 02 	lds	r30, 0x02D1
    363c:	f0 91 d2 02 	lds	r31, 0x02D2
    3640:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    3642:	0f 90       	pop	r0
    3644:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    3646:	89 81       	ldd	r24, Y+1	; 0x01
    3648:	9a 81       	ldd	r25, Y+2	; 0x02
    364a:	ab 81       	ldd	r26, Y+3	; 0x03
    364c:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    364e:	bc 01       	movw	r22, r24
    3650:	cd 01       	movw	r24, r26
    3652:	27 96       	adiw	r28, 0x07	; 7
    3654:	0f b6       	in	r0, 0x3f	; 63
    3656:	f8 94       	cli
    3658:	de bf       	out	0x3e, r29	; 62
    365a:	0f be       	out	0x3f, r0	; 63
    365c:	cd bf       	out	0x3d, r28	; 61
    365e:	cf 91       	pop	r28
    3660:	df 91       	pop	r29
    3662:	08 95       	ret

00003664 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    3664:	ef 92       	push	r14
    3666:	ff 92       	push	r15
    3668:	0f 93       	push	r16
    366a:	1f 93       	push	r17
    366c:	df 93       	push	r29
    366e:	cf 93       	push	r28
    3670:	cd b7       	in	r28, 0x3d	; 61
    3672:	de b7       	in	r29, 0x3e	; 62
    3674:	2d 97       	sbiw	r28, 0x0d	; 13
    3676:	0f b6       	in	r0, 0x3f	; 63
    3678:	f8 94       	cli
    367a:	de bf       	out	0x3e, r29	; 62
    367c:	0f be       	out	0x3f, r0	; 63
    367e:	cd bf       	out	0x3d, r28	; 61
    3680:	6a 83       	std	Y+2, r22	; 0x02
    3682:	7b 83       	std	Y+3, r23	; 0x03
    3684:	8c 83       	std	Y+4, r24	; 0x04
    3686:	9d 83       	std	Y+5, r25	; 0x05
    3688:	2e 83       	std	Y+6, r18	; 0x06
    368a:	3f 83       	std	Y+7, r19	; 0x07
    368c:	48 87       	std	Y+8, r20	; 0x08
    368e:	59 87       	std	Y+9, r21	; 0x09
    3690:	1b 87       	std	Y+11, r17	; 0x0b
    3692:	0a 87       	std	Y+10, r16	; 0x0a
    3694:	fd 86       	std	Y+13, r15	; 0x0d
    3696:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    3698:	0f b6       	in	r0, 0x3f	; 63
    369a:	f8 94       	cli
    369c:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    369e:	e0 91 d1 02 	lds	r30, 0x02D1
    36a2:	f0 91 d2 02 	lds	r31, 0x02D2
    36a6:	85 a1       	ldd	r24, Z+37	; 0x25
    36a8:	82 30       	cpi	r24, 0x02	; 2
    36aa:	49 f1       	breq	.+82     	; 0x36fe <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    36ac:	e0 91 d1 02 	lds	r30, 0x02D1
    36b0:	f0 91 d2 02 	lds	r31, 0x02D2
    36b4:	21 a1       	ldd	r18, Z+33	; 0x21
    36b6:	32 a1       	ldd	r19, Z+34	; 0x22
    36b8:	43 a1       	ldd	r20, Z+35	; 0x23
    36ba:	54 a1       	ldd	r21, Z+36	; 0x24
    36bc:	8a 81       	ldd	r24, Y+2	; 0x02
    36be:	9b 81       	ldd	r25, Y+3	; 0x03
    36c0:	ac 81       	ldd	r26, Y+4	; 0x04
    36c2:	bd 81       	ldd	r27, Y+5	; 0x05
    36c4:	80 95       	com	r24
    36c6:	90 95       	com	r25
    36c8:	a0 95       	com	r26
    36ca:	b0 95       	com	r27
    36cc:	82 23       	and	r24, r18
    36ce:	93 23       	and	r25, r19
    36d0:	a4 23       	and	r26, r20
    36d2:	b5 23       	and	r27, r21
    36d4:	81 a3       	std	Z+33, r24	; 0x21
    36d6:	92 a3       	std	Z+34, r25	; 0x22
    36d8:	a3 a3       	std	Z+35, r26	; 0x23
    36da:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    36dc:	e0 91 d1 02 	lds	r30, 0x02D1
    36e0:	f0 91 d2 02 	lds	r31, 0x02D2
    36e4:	81 e0       	ldi	r24, 0x01	; 1
    36e6:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    36e8:	8c 85       	ldd	r24, Y+12	; 0x0c
    36ea:	9d 85       	ldd	r25, Y+13	; 0x0d
    36ec:	00 97       	sbiw	r24, 0x00	; 0
    36ee:	39 f0       	breq	.+14     	; 0x36fe <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    36f0:	8c 85       	ldd	r24, Y+12	; 0x0c
    36f2:	9d 85       	ldd	r25, Y+13	; 0x0d
    36f4:	61 e0       	ldi	r22, 0x01	; 1
    36f6:	0e 94 63 1e 	call	0x3cc6	; 0x3cc6 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    36fa:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    36fe:	0f 90       	pop	r0
    3700:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    3702:	0f b6       	in	r0, 0x3f	; 63
    3704:	f8 94       	cli
    3706:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    3708:	8a 85       	ldd	r24, Y+10	; 0x0a
    370a:	9b 85       	ldd	r25, Y+11	; 0x0b
    370c:	00 97       	sbiw	r24, 0x00	; 0
    370e:	71 f0       	breq	.+28     	; 0x372c <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    3710:	e0 91 d1 02 	lds	r30, 0x02D1
    3714:	f0 91 d2 02 	lds	r31, 0x02D2
    3718:	81 a1       	ldd	r24, Z+33	; 0x21
    371a:	92 a1       	ldd	r25, Z+34	; 0x22
    371c:	a3 a1       	ldd	r26, Z+35	; 0x23
    371e:	b4 a1       	ldd	r27, Z+36	; 0x24
    3720:	ea 85       	ldd	r30, Y+10	; 0x0a
    3722:	fb 85       	ldd	r31, Y+11	; 0x0b
    3724:	80 83       	st	Z, r24
    3726:	91 83       	std	Z+1, r25	; 0x01
    3728:	a2 83       	std	Z+2, r26	; 0x02
    372a:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    372c:	e0 91 d1 02 	lds	r30, 0x02D1
    3730:	f0 91 d2 02 	lds	r31, 0x02D2
    3734:	85 a1       	ldd	r24, Z+37	; 0x25
    3736:	82 30       	cpi	r24, 0x02	; 2
    3738:	11 f0       	breq	.+4      	; 0x373e <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    373a:	19 82       	std	Y+1, r1	; 0x01
    373c:	1a c0       	rjmp	.+52     	; 0x3772 <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    373e:	e0 91 d1 02 	lds	r30, 0x02D1
    3742:	f0 91 d2 02 	lds	r31, 0x02D2
    3746:	21 a1       	ldd	r18, Z+33	; 0x21
    3748:	32 a1       	ldd	r19, Z+34	; 0x22
    374a:	43 a1       	ldd	r20, Z+35	; 0x23
    374c:	54 a1       	ldd	r21, Z+36	; 0x24
    374e:	8e 81       	ldd	r24, Y+6	; 0x06
    3750:	9f 81       	ldd	r25, Y+7	; 0x07
    3752:	a8 85       	ldd	r26, Y+8	; 0x08
    3754:	b9 85       	ldd	r27, Y+9	; 0x09
    3756:	80 95       	com	r24
    3758:	90 95       	com	r25
    375a:	a0 95       	com	r26
    375c:	b0 95       	com	r27
    375e:	82 23       	and	r24, r18
    3760:	93 23       	and	r25, r19
    3762:	a4 23       	and	r26, r20
    3764:	b5 23       	and	r27, r21
    3766:	81 a3       	std	Z+33, r24	; 0x21
    3768:	92 a3       	std	Z+34, r25	; 0x22
    376a:	a3 a3       	std	Z+35, r26	; 0x23
    376c:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
    376e:	81 e0       	ldi	r24, 0x01	; 1
    3770:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3772:	e0 91 d1 02 	lds	r30, 0x02D1
    3776:	f0 91 d2 02 	lds	r31, 0x02D2
    377a:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    377c:	0f 90       	pop	r0
    377e:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    3780:	89 81       	ldd	r24, Y+1	; 0x01
	}
    3782:	2d 96       	adiw	r28, 0x0d	; 13
    3784:	0f b6       	in	r0, 0x3f	; 63
    3786:	f8 94       	cli
    3788:	de bf       	out	0x3e, r29	; 62
    378a:	0f be       	out	0x3f, r0	; 63
    378c:	cd bf       	out	0x3d, r28	; 61
    378e:	cf 91       	pop	r28
    3790:	df 91       	pop	r29
    3792:	1f 91       	pop	r17
    3794:	0f 91       	pop	r16
    3796:	ff 90       	pop	r15
    3798:	ef 90       	pop	r14
    379a:	08 95       	ret

0000379c <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    379c:	0f 93       	push	r16
    379e:	1f 93       	push	r17
    37a0:	df 93       	push	r29
    37a2:	cf 93       	push	r28
    37a4:	cd b7       	in	r28, 0x3d	; 61
    37a6:	de b7       	in	r29, 0x3e	; 62
    37a8:	2f 97       	sbiw	r28, 0x0f	; 15
    37aa:	0f b6       	in	r0, 0x3f	; 63
    37ac:	f8 94       	cli
    37ae:	de bf       	out	0x3e, r29	; 62
    37b0:	0f be       	out	0x3f, r0	; 63
    37b2:	cd bf       	out	0x3d, r28	; 61
    37b4:	9e 83       	std	Y+6, r25	; 0x06
    37b6:	8d 83       	std	Y+5, r24	; 0x05
    37b8:	4f 83       	std	Y+7, r20	; 0x07
    37ba:	58 87       	std	Y+8, r21	; 0x08
    37bc:	69 87       	std	Y+9, r22	; 0x09
    37be:	7a 87       	std	Y+10, r23	; 0x0a
    37c0:	2b 87       	std	Y+11, r18	; 0x0b
    37c2:	1d 87       	std	Y+13, r17	; 0x0d
    37c4:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    37c6:	81 e0       	ldi	r24, 0x01	; 1
    37c8:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    37ca:	8d 81       	ldd	r24, Y+5	; 0x05
    37cc:	9e 81       	ldd	r25, Y+6	; 0x06
    37ce:	9c 83       	std	Y+4, r25	; 0x04
    37d0:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    37d2:	0f b6       	in	r0, 0x3f	; 63
    37d4:	f8 94       	cli
    37d6:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    37d8:	8c 85       	ldd	r24, Y+12	; 0x0c
    37da:	9d 85       	ldd	r25, Y+13	; 0x0d
    37dc:	00 97       	sbiw	r24, 0x00	; 0
    37de:	61 f0       	breq	.+24     	; 0x37f8 <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    37e0:	eb 81       	ldd	r30, Y+3	; 0x03
    37e2:	fc 81       	ldd	r31, Y+4	; 0x04
    37e4:	81 a1       	ldd	r24, Z+33	; 0x21
    37e6:	92 a1       	ldd	r25, Z+34	; 0x22
    37e8:	a3 a1       	ldd	r26, Z+35	; 0x23
    37ea:	b4 a1       	ldd	r27, Z+36	; 0x24
    37ec:	ec 85       	ldd	r30, Y+12	; 0x0c
    37ee:	fd 85       	ldd	r31, Y+13	; 0x0d
    37f0:	80 83       	st	Z, r24
    37f2:	91 83       	std	Z+1, r25	; 0x01
    37f4:	a2 83       	std	Z+2, r26	; 0x02
    37f6:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    37f8:	eb 81       	ldd	r30, Y+3	; 0x03
    37fa:	fc 81       	ldd	r31, Y+4	; 0x04
    37fc:	85 a1       	ldd	r24, Z+37	; 0x25
    37fe:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    3800:	eb 81       	ldd	r30, Y+3	; 0x03
    3802:	fc 81       	ldd	r31, Y+4	; 0x04
    3804:	82 e0       	ldi	r24, 0x02	; 2
    3806:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    3808:	8b 85       	ldd	r24, Y+11	; 0x0b
    380a:	28 2f       	mov	r18, r24
    380c:	30 e0       	ldi	r19, 0x00	; 0
    380e:	3f 87       	std	Y+15, r19	; 0x0f
    3810:	2e 87       	std	Y+14, r18	; 0x0e
    3812:	8e 85       	ldd	r24, Y+14	; 0x0e
    3814:	9f 85       	ldd	r25, Y+15	; 0x0f
    3816:	82 30       	cpi	r24, 0x02	; 2
    3818:	91 05       	cpc	r25, r1
    381a:	59 f1       	breq	.+86     	; 0x3872 <xTaskGenericNotify+0xd6>
    381c:	2e 85       	ldd	r18, Y+14	; 0x0e
    381e:	3f 85       	ldd	r19, Y+15	; 0x0f
    3820:	23 30       	cpi	r18, 0x03	; 3
    3822:	31 05       	cpc	r19, r1
    3824:	34 f4       	brge	.+12     	; 0x3832 <xTaskGenericNotify+0x96>
    3826:	8e 85       	ldd	r24, Y+14	; 0x0e
    3828:	9f 85       	ldd	r25, Y+15	; 0x0f
    382a:	81 30       	cpi	r24, 0x01	; 1
    382c:	91 05       	cpc	r25, r1
    382e:	61 f0       	breq	.+24     	; 0x3848 <xTaskGenericNotify+0xac>
    3830:	4a c0       	rjmp	.+148    	; 0x38c6 <xTaskGenericNotify+0x12a>
    3832:	2e 85       	ldd	r18, Y+14	; 0x0e
    3834:	3f 85       	ldd	r19, Y+15	; 0x0f
    3836:	23 30       	cpi	r18, 0x03	; 3
    3838:	31 05       	cpc	r19, r1
    383a:	59 f1       	breq	.+86     	; 0x3892 <xTaskGenericNotify+0xf6>
    383c:	8e 85       	ldd	r24, Y+14	; 0x0e
    383e:	9f 85       	ldd	r25, Y+15	; 0x0f
    3840:	84 30       	cpi	r24, 0x04	; 4
    3842:	91 05       	cpc	r25, r1
    3844:	89 f1       	breq	.+98     	; 0x38a8 <xTaskGenericNotify+0x10c>
    3846:	3f c0       	rjmp	.+126    	; 0x38c6 <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    3848:	eb 81       	ldd	r30, Y+3	; 0x03
    384a:	fc 81       	ldd	r31, Y+4	; 0x04
    384c:	21 a1       	ldd	r18, Z+33	; 0x21
    384e:	32 a1       	ldd	r19, Z+34	; 0x22
    3850:	43 a1       	ldd	r20, Z+35	; 0x23
    3852:	54 a1       	ldd	r21, Z+36	; 0x24
    3854:	8f 81       	ldd	r24, Y+7	; 0x07
    3856:	98 85       	ldd	r25, Y+8	; 0x08
    3858:	a9 85       	ldd	r26, Y+9	; 0x09
    385a:	ba 85       	ldd	r27, Y+10	; 0x0a
    385c:	82 2b       	or	r24, r18
    385e:	93 2b       	or	r25, r19
    3860:	a4 2b       	or	r26, r20
    3862:	b5 2b       	or	r27, r21
    3864:	eb 81       	ldd	r30, Y+3	; 0x03
    3866:	fc 81       	ldd	r31, Y+4	; 0x04
    3868:	81 a3       	std	Z+33, r24	; 0x21
    386a:	92 a3       	std	Z+34, r25	; 0x22
    386c:	a3 a3       	std	Z+35, r26	; 0x23
    386e:	b4 a3       	std	Z+36, r27	; 0x24
    3870:	2a c0       	rjmp	.+84     	; 0x38c6 <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    3872:	eb 81       	ldd	r30, Y+3	; 0x03
    3874:	fc 81       	ldd	r31, Y+4	; 0x04
    3876:	81 a1       	ldd	r24, Z+33	; 0x21
    3878:	92 a1       	ldd	r25, Z+34	; 0x22
    387a:	a3 a1       	ldd	r26, Z+35	; 0x23
    387c:	b4 a1       	ldd	r27, Z+36	; 0x24
    387e:	01 96       	adiw	r24, 0x01	; 1
    3880:	a1 1d       	adc	r26, r1
    3882:	b1 1d       	adc	r27, r1
    3884:	eb 81       	ldd	r30, Y+3	; 0x03
    3886:	fc 81       	ldd	r31, Y+4	; 0x04
    3888:	81 a3       	std	Z+33, r24	; 0x21
    388a:	92 a3       	std	Z+34, r25	; 0x22
    388c:	a3 a3       	std	Z+35, r26	; 0x23
    388e:	b4 a3       	std	Z+36, r27	; 0x24
    3890:	1a c0       	rjmp	.+52     	; 0x38c6 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    3892:	eb 81       	ldd	r30, Y+3	; 0x03
    3894:	fc 81       	ldd	r31, Y+4	; 0x04
    3896:	8f 81       	ldd	r24, Y+7	; 0x07
    3898:	98 85       	ldd	r25, Y+8	; 0x08
    389a:	a9 85       	ldd	r26, Y+9	; 0x09
    389c:	ba 85       	ldd	r27, Y+10	; 0x0a
    389e:	81 a3       	std	Z+33, r24	; 0x21
    38a0:	92 a3       	std	Z+34, r25	; 0x22
    38a2:	a3 a3       	std	Z+35, r26	; 0x23
    38a4:	b4 a3       	std	Z+36, r27	; 0x24
    38a6:	0f c0       	rjmp	.+30     	; 0x38c6 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    38a8:	89 81       	ldd	r24, Y+1	; 0x01
    38aa:	82 30       	cpi	r24, 0x02	; 2
    38ac:	59 f0       	breq	.+22     	; 0x38c4 <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    38ae:	eb 81       	ldd	r30, Y+3	; 0x03
    38b0:	fc 81       	ldd	r31, Y+4	; 0x04
    38b2:	8f 81       	ldd	r24, Y+7	; 0x07
    38b4:	98 85       	ldd	r25, Y+8	; 0x08
    38b6:	a9 85       	ldd	r26, Y+9	; 0x09
    38b8:	ba 85       	ldd	r27, Y+10	; 0x0a
    38ba:	81 a3       	std	Z+33, r24	; 0x21
    38bc:	92 a3       	std	Z+34, r25	; 0x22
    38be:	a3 a3       	std	Z+35, r26	; 0x23
    38c0:	b4 a3       	std	Z+36, r27	; 0x24
    38c2:	01 c0       	rjmp	.+2      	; 0x38c6 <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    38c4:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    38c6:	89 81       	ldd	r24, Y+1	; 0x01
    38c8:	81 30       	cpi	r24, 0x01	; 1
    38ca:	b9 f5       	brne	.+110    	; 0x393a <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    38cc:	8b 81       	ldd	r24, Y+3	; 0x03
    38ce:	9c 81       	ldd	r25, Y+4	; 0x04
    38d0:	02 96       	adiw	r24, 0x02	; 2
    38d2:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    38d6:	eb 81       	ldd	r30, Y+3	; 0x03
    38d8:	fc 81       	ldd	r31, Y+4	; 0x04
    38da:	96 89       	ldd	r25, Z+22	; 0x16
    38dc:	80 91 d7 02 	lds	r24, 0x02D7
    38e0:	89 17       	cp	r24, r25
    38e2:	28 f4       	brcc	.+10     	; 0x38ee <xTaskGenericNotify+0x152>
    38e4:	eb 81       	ldd	r30, Y+3	; 0x03
    38e6:	fc 81       	ldd	r31, Y+4	; 0x04
    38e8:	86 89       	ldd	r24, Z+22	; 0x16
    38ea:	80 93 d7 02 	sts	0x02D7, r24
    38ee:	eb 81       	ldd	r30, Y+3	; 0x03
    38f0:	fc 81       	ldd	r31, Y+4	; 0x04
    38f2:	86 89       	ldd	r24, Z+22	; 0x16
    38f4:	28 2f       	mov	r18, r24
    38f6:	30 e0       	ldi	r19, 0x00	; 0
    38f8:	c9 01       	movw	r24, r18
    38fa:	88 0f       	add	r24, r24
    38fc:	99 1f       	adc	r25, r25
    38fe:	88 0f       	add	r24, r24
    3900:	99 1f       	adc	r25, r25
    3902:	88 0f       	add	r24, r24
    3904:	99 1f       	adc	r25, r25
    3906:	82 0f       	add	r24, r18
    3908:	93 1f       	adc	r25, r19
    390a:	ac 01       	movw	r20, r24
    390c:	4e 51       	subi	r20, 0x1E	; 30
    390e:	5d 4f       	sbci	r21, 0xFD	; 253
    3910:	8b 81       	ldd	r24, Y+3	; 0x03
    3912:	9c 81       	ldd	r25, Y+4	; 0x04
    3914:	9c 01       	movw	r18, r24
    3916:	2e 5f       	subi	r18, 0xFE	; 254
    3918:	3f 4f       	sbci	r19, 0xFF	; 255
    391a:	ca 01       	movw	r24, r20
    391c:	b9 01       	movw	r22, r18
    391e:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    3922:	eb 81       	ldd	r30, Y+3	; 0x03
    3924:	fc 81       	ldd	r31, Y+4	; 0x04
    3926:	96 89       	ldd	r25, Z+22	; 0x16
    3928:	e0 91 d1 02 	lds	r30, 0x02D1
    392c:	f0 91 d2 02 	lds	r31, 0x02D2
    3930:	86 89       	ldd	r24, Z+22	; 0x16
    3932:	89 17       	cp	r24, r25
    3934:	10 f4       	brcc	.+4      	; 0x393a <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    3936:	0e 94 aa 0a 	call	0x1554	; 0x1554 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    393a:	0f 90       	pop	r0
    393c:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    393e:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    3940:	2f 96       	adiw	r28, 0x0f	; 15
    3942:	0f b6       	in	r0, 0x3f	; 63
    3944:	f8 94       	cli
    3946:	de bf       	out	0x3e, r29	; 62
    3948:	0f be       	out	0x3f, r0	; 63
    394a:	cd bf       	out	0x3d, r28	; 61
    394c:	cf 91       	pop	r28
    394e:	df 91       	pop	r29
    3950:	1f 91       	pop	r17
    3952:	0f 91       	pop	r16
    3954:	08 95       	ret

00003956 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    3956:	ef 92       	push	r14
    3958:	ff 92       	push	r15
    395a:	0f 93       	push	r16
    395c:	1f 93       	push	r17
    395e:	df 93       	push	r29
    3960:	cf 93       	push	r28
    3962:	cd b7       	in	r28, 0x3d	; 61
    3964:	de b7       	in	r29, 0x3e	; 62
    3966:	62 97       	sbiw	r28, 0x12	; 18
    3968:	0f b6       	in	r0, 0x3f	; 63
    396a:	f8 94       	cli
    396c:	de bf       	out	0x3e, r29	; 62
    396e:	0f be       	out	0x3f, r0	; 63
    3970:	cd bf       	out	0x3d, r28	; 61
    3972:	9f 83       	std	Y+7, r25	; 0x07
    3974:	8e 83       	std	Y+6, r24	; 0x06
    3976:	48 87       	std	Y+8, r20	; 0x08
    3978:	59 87       	std	Y+9, r21	; 0x09
    397a:	6a 87       	std	Y+10, r22	; 0x0a
    397c:	7b 87       	std	Y+11, r23	; 0x0b
    397e:	2c 87       	std	Y+12, r18	; 0x0c
    3980:	1e 87       	std	Y+14, r17	; 0x0e
    3982:	0d 87       	std	Y+13, r16	; 0x0d
    3984:	f8 8a       	std	Y+16, r15	; 0x10
    3986:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    3988:	81 e0       	ldi	r24, 0x01	; 1
    398a:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    398c:	8e 81       	ldd	r24, Y+6	; 0x06
    398e:	9f 81       	ldd	r25, Y+7	; 0x07
    3990:	9d 83       	std	Y+5, r25	; 0x05
    3992:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3994:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    3996:	8d 85       	ldd	r24, Y+13	; 0x0d
    3998:	9e 85       	ldd	r25, Y+14	; 0x0e
    399a:	00 97       	sbiw	r24, 0x00	; 0
    399c:	61 f0       	breq	.+24     	; 0x39b6 <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    399e:	ec 81       	ldd	r30, Y+4	; 0x04
    39a0:	fd 81       	ldd	r31, Y+5	; 0x05
    39a2:	81 a1       	ldd	r24, Z+33	; 0x21
    39a4:	92 a1       	ldd	r25, Z+34	; 0x22
    39a6:	a3 a1       	ldd	r26, Z+35	; 0x23
    39a8:	b4 a1       	ldd	r27, Z+36	; 0x24
    39aa:	ed 85       	ldd	r30, Y+13	; 0x0d
    39ac:	fe 85       	ldd	r31, Y+14	; 0x0e
    39ae:	80 83       	st	Z, r24
    39b0:	91 83       	std	Z+1, r25	; 0x01
    39b2:	a2 83       	std	Z+2, r26	; 0x02
    39b4:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    39b6:	ec 81       	ldd	r30, Y+4	; 0x04
    39b8:	fd 81       	ldd	r31, Y+5	; 0x05
    39ba:	85 a1       	ldd	r24, Z+37	; 0x25
    39bc:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    39be:	ec 81       	ldd	r30, Y+4	; 0x04
    39c0:	fd 81       	ldd	r31, Y+5	; 0x05
    39c2:	82 e0       	ldi	r24, 0x02	; 2
    39c4:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    39c6:	8c 85       	ldd	r24, Y+12	; 0x0c
    39c8:	28 2f       	mov	r18, r24
    39ca:	30 e0       	ldi	r19, 0x00	; 0
    39cc:	3a 8b       	std	Y+18, r19	; 0x12
    39ce:	29 8b       	std	Y+17, r18	; 0x11
    39d0:	89 89       	ldd	r24, Y+17	; 0x11
    39d2:	9a 89       	ldd	r25, Y+18	; 0x12
    39d4:	82 30       	cpi	r24, 0x02	; 2
    39d6:	91 05       	cpc	r25, r1
    39d8:	59 f1       	breq	.+86     	; 0x3a30 <xTaskGenericNotifyFromISR+0xda>
    39da:	29 89       	ldd	r18, Y+17	; 0x11
    39dc:	3a 89       	ldd	r19, Y+18	; 0x12
    39de:	23 30       	cpi	r18, 0x03	; 3
    39e0:	31 05       	cpc	r19, r1
    39e2:	34 f4       	brge	.+12     	; 0x39f0 <xTaskGenericNotifyFromISR+0x9a>
    39e4:	89 89       	ldd	r24, Y+17	; 0x11
    39e6:	9a 89       	ldd	r25, Y+18	; 0x12
    39e8:	81 30       	cpi	r24, 0x01	; 1
    39ea:	91 05       	cpc	r25, r1
    39ec:	61 f0       	breq	.+24     	; 0x3a06 <xTaskGenericNotifyFromISR+0xb0>
    39ee:	4a c0       	rjmp	.+148    	; 0x3a84 <xTaskGenericNotifyFromISR+0x12e>
    39f0:	29 89       	ldd	r18, Y+17	; 0x11
    39f2:	3a 89       	ldd	r19, Y+18	; 0x12
    39f4:	23 30       	cpi	r18, 0x03	; 3
    39f6:	31 05       	cpc	r19, r1
    39f8:	59 f1       	breq	.+86     	; 0x3a50 <xTaskGenericNotifyFromISR+0xfa>
    39fa:	89 89       	ldd	r24, Y+17	; 0x11
    39fc:	9a 89       	ldd	r25, Y+18	; 0x12
    39fe:	84 30       	cpi	r24, 0x04	; 4
    3a00:	91 05       	cpc	r25, r1
    3a02:	89 f1       	breq	.+98     	; 0x3a66 <xTaskGenericNotifyFromISR+0x110>
    3a04:	3f c0       	rjmp	.+126    	; 0x3a84 <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    3a06:	ec 81       	ldd	r30, Y+4	; 0x04
    3a08:	fd 81       	ldd	r31, Y+5	; 0x05
    3a0a:	21 a1       	ldd	r18, Z+33	; 0x21
    3a0c:	32 a1       	ldd	r19, Z+34	; 0x22
    3a0e:	43 a1       	ldd	r20, Z+35	; 0x23
    3a10:	54 a1       	ldd	r21, Z+36	; 0x24
    3a12:	88 85       	ldd	r24, Y+8	; 0x08
    3a14:	99 85       	ldd	r25, Y+9	; 0x09
    3a16:	aa 85       	ldd	r26, Y+10	; 0x0a
    3a18:	bb 85       	ldd	r27, Y+11	; 0x0b
    3a1a:	82 2b       	or	r24, r18
    3a1c:	93 2b       	or	r25, r19
    3a1e:	a4 2b       	or	r26, r20
    3a20:	b5 2b       	or	r27, r21
    3a22:	ec 81       	ldd	r30, Y+4	; 0x04
    3a24:	fd 81       	ldd	r31, Y+5	; 0x05
    3a26:	81 a3       	std	Z+33, r24	; 0x21
    3a28:	92 a3       	std	Z+34, r25	; 0x22
    3a2a:	a3 a3       	std	Z+35, r26	; 0x23
    3a2c:	b4 a3       	std	Z+36, r27	; 0x24
    3a2e:	2a c0       	rjmp	.+84     	; 0x3a84 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    3a30:	ec 81       	ldd	r30, Y+4	; 0x04
    3a32:	fd 81       	ldd	r31, Y+5	; 0x05
    3a34:	81 a1       	ldd	r24, Z+33	; 0x21
    3a36:	92 a1       	ldd	r25, Z+34	; 0x22
    3a38:	a3 a1       	ldd	r26, Z+35	; 0x23
    3a3a:	b4 a1       	ldd	r27, Z+36	; 0x24
    3a3c:	01 96       	adiw	r24, 0x01	; 1
    3a3e:	a1 1d       	adc	r26, r1
    3a40:	b1 1d       	adc	r27, r1
    3a42:	ec 81       	ldd	r30, Y+4	; 0x04
    3a44:	fd 81       	ldd	r31, Y+5	; 0x05
    3a46:	81 a3       	std	Z+33, r24	; 0x21
    3a48:	92 a3       	std	Z+34, r25	; 0x22
    3a4a:	a3 a3       	std	Z+35, r26	; 0x23
    3a4c:	b4 a3       	std	Z+36, r27	; 0x24
    3a4e:	1a c0       	rjmp	.+52     	; 0x3a84 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    3a50:	ec 81       	ldd	r30, Y+4	; 0x04
    3a52:	fd 81       	ldd	r31, Y+5	; 0x05
    3a54:	88 85       	ldd	r24, Y+8	; 0x08
    3a56:	99 85       	ldd	r25, Y+9	; 0x09
    3a58:	aa 85       	ldd	r26, Y+10	; 0x0a
    3a5a:	bb 85       	ldd	r27, Y+11	; 0x0b
    3a5c:	81 a3       	std	Z+33, r24	; 0x21
    3a5e:	92 a3       	std	Z+34, r25	; 0x22
    3a60:	a3 a3       	std	Z+35, r26	; 0x23
    3a62:	b4 a3       	std	Z+36, r27	; 0x24
    3a64:	0f c0       	rjmp	.+30     	; 0x3a84 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    3a66:	8b 81       	ldd	r24, Y+3	; 0x03
    3a68:	82 30       	cpi	r24, 0x02	; 2
    3a6a:	59 f0       	breq	.+22     	; 0x3a82 <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    3a6c:	ec 81       	ldd	r30, Y+4	; 0x04
    3a6e:	fd 81       	ldd	r31, Y+5	; 0x05
    3a70:	88 85       	ldd	r24, Y+8	; 0x08
    3a72:	99 85       	ldd	r25, Y+9	; 0x09
    3a74:	aa 85       	ldd	r26, Y+10	; 0x0a
    3a76:	bb 85       	ldd	r27, Y+11	; 0x0b
    3a78:	81 a3       	std	Z+33, r24	; 0x21
    3a7a:	92 a3       	std	Z+34, r25	; 0x22
    3a7c:	a3 a3       	std	Z+35, r26	; 0x23
    3a7e:	b4 a3       	std	Z+36, r27	; 0x24
    3a80:	01 c0       	rjmp	.+2      	; 0x3a84 <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    3a82:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    3a84:	8b 81       	ldd	r24, Y+3	; 0x03
    3a86:	81 30       	cpi	r24, 0x01	; 1
    3a88:	09 f0       	breq	.+2      	; 0x3a8c <xTaskGenericNotifyFromISR+0x136>
    3a8a:	4f c0       	rjmp	.+158    	; 0x3b2a <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3a8c:	80 91 e1 02 	lds	r24, 0x02E1
    3a90:	88 23       	and	r24, r24
    3a92:	61 f5       	brne	.+88     	; 0x3aec <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3a94:	8c 81       	ldd	r24, Y+4	; 0x04
    3a96:	9d 81       	ldd	r25, Y+5	; 0x05
    3a98:	02 96       	adiw	r24, 0x02	; 2
    3a9a:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3a9e:	ec 81       	ldd	r30, Y+4	; 0x04
    3aa0:	fd 81       	ldd	r31, Y+5	; 0x05
    3aa2:	96 89       	ldd	r25, Z+22	; 0x16
    3aa4:	80 91 d7 02 	lds	r24, 0x02D7
    3aa8:	89 17       	cp	r24, r25
    3aaa:	28 f4       	brcc	.+10     	; 0x3ab6 <xTaskGenericNotifyFromISR+0x160>
    3aac:	ec 81       	ldd	r30, Y+4	; 0x04
    3aae:	fd 81       	ldd	r31, Y+5	; 0x05
    3ab0:	86 89       	ldd	r24, Z+22	; 0x16
    3ab2:	80 93 d7 02 	sts	0x02D7, r24
    3ab6:	ec 81       	ldd	r30, Y+4	; 0x04
    3ab8:	fd 81       	ldd	r31, Y+5	; 0x05
    3aba:	86 89       	ldd	r24, Z+22	; 0x16
    3abc:	28 2f       	mov	r18, r24
    3abe:	30 e0       	ldi	r19, 0x00	; 0
    3ac0:	c9 01       	movw	r24, r18
    3ac2:	88 0f       	add	r24, r24
    3ac4:	99 1f       	adc	r25, r25
    3ac6:	88 0f       	add	r24, r24
    3ac8:	99 1f       	adc	r25, r25
    3aca:	88 0f       	add	r24, r24
    3acc:	99 1f       	adc	r25, r25
    3ace:	82 0f       	add	r24, r18
    3ad0:	93 1f       	adc	r25, r19
    3ad2:	ac 01       	movw	r20, r24
    3ad4:	4e 51       	subi	r20, 0x1E	; 30
    3ad6:	5d 4f       	sbci	r21, 0xFD	; 253
    3ad8:	8c 81       	ldd	r24, Y+4	; 0x04
    3ada:	9d 81       	ldd	r25, Y+5	; 0x05
    3adc:	9c 01       	movw	r18, r24
    3ade:	2e 5f       	subi	r18, 0xFE	; 254
    3ae0:	3f 4f       	sbci	r19, 0xFF	; 255
    3ae2:	ca 01       	movw	r24, r20
    3ae4:	b9 01       	movw	r22, r18
    3ae6:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>
    3aea:	0a c0       	rjmp	.+20     	; 0x3b00 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    3aec:	8c 81       	ldd	r24, Y+4	; 0x04
    3aee:	9d 81       	ldd	r25, Y+5	; 0x05
    3af0:	9c 01       	movw	r18, r24
    3af2:	24 5f       	subi	r18, 0xF4	; 244
    3af4:	3f 4f       	sbci	r19, 0xFF	; 255
    3af6:	8c e1       	ldi	r24, 0x1C	; 28
    3af8:	93 e0       	ldi	r25, 0x03	; 3
    3afa:	b9 01       	movw	r22, r18
    3afc:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    3b00:	ec 81       	ldd	r30, Y+4	; 0x04
    3b02:	fd 81       	ldd	r31, Y+5	; 0x05
    3b04:	96 89       	ldd	r25, Z+22	; 0x16
    3b06:	e0 91 d1 02 	lds	r30, 0x02D1
    3b0a:	f0 91 d2 02 	lds	r31, 0x02D2
    3b0e:	86 89       	ldd	r24, Z+22	; 0x16
    3b10:	89 17       	cp	r24, r25
    3b12:	58 f4       	brcc	.+22     	; 0x3b2a <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    3b14:	8f 85       	ldd	r24, Y+15	; 0x0f
    3b16:	98 89       	ldd	r25, Y+16	; 0x10
    3b18:	00 97       	sbiw	r24, 0x00	; 0
    3b1a:	21 f0       	breq	.+8      	; 0x3b24 <xTaskGenericNotifyFromISR+0x1ce>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    3b1c:	ef 85       	ldd	r30, Y+15	; 0x0f
    3b1e:	f8 89       	ldd	r31, Y+16	; 0x10
    3b20:	81 e0       	ldi	r24, 0x01	; 1
    3b22:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    3b24:	81 e0       	ldi	r24, 0x01	; 1
    3b26:	80 93 da 02 	sts	0x02DA, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    3b2a:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    3b2c:	62 96       	adiw	r28, 0x12	; 18
    3b2e:	0f b6       	in	r0, 0x3f	; 63
    3b30:	f8 94       	cli
    3b32:	de bf       	out	0x3e, r29	; 62
    3b34:	0f be       	out	0x3f, r0	; 63
    3b36:	cd bf       	out	0x3d, r28	; 61
    3b38:	cf 91       	pop	r28
    3b3a:	df 91       	pop	r29
    3b3c:	1f 91       	pop	r17
    3b3e:	0f 91       	pop	r16
    3b40:	ff 90       	pop	r15
    3b42:	ef 90       	pop	r14
    3b44:	08 95       	ret

00003b46 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    3b46:	df 93       	push	r29
    3b48:	cf 93       	push	r28
    3b4a:	cd b7       	in	r28, 0x3d	; 61
    3b4c:	de b7       	in	r29, 0x3e	; 62
    3b4e:	28 97       	sbiw	r28, 0x08	; 8
    3b50:	0f b6       	in	r0, 0x3f	; 63
    3b52:	f8 94       	cli
    3b54:	de bf       	out	0x3e, r29	; 62
    3b56:	0f be       	out	0x3f, r0	; 63
    3b58:	cd bf       	out	0x3d, r28	; 61
    3b5a:	9e 83       	std	Y+6, r25	; 0x06
    3b5c:	8d 83       	std	Y+5, r24	; 0x05
    3b5e:	78 87       	std	Y+8, r23	; 0x08
    3b60:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    3b62:	8d 81       	ldd	r24, Y+5	; 0x05
    3b64:	9e 81       	ldd	r25, Y+6	; 0x06
    3b66:	9c 83       	std	Y+4, r25	; 0x04
    3b68:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3b6a:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    3b6c:	eb 81       	ldd	r30, Y+3	; 0x03
    3b6e:	fc 81       	ldd	r31, Y+4	; 0x04
    3b70:	85 a1       	ldd	r24, Z+37	; 0x25
    3b72:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    3b74:	eb 81       	ldd	r30, Y+3	; 0x03
    3b76:	fc 81       	ldd	r31, Y+4	; 0x04
    3b78:	82 e0       	ldi	r24, 0x02	; 2
    3b7a:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    3b7c:	eb 81       	ldd	r30, Y+3	; 0x03
    3b7e:	fc 81       	ldd	r31, Y+4	; 0x04
    3b80:	81 a1       	ldd	r24, Z+33	; 0x21
    3b82:	92 a1       	ldd	r25, Z+34	; 0x22
    3b84:	a3 a1       	ldd	r26, Z+35	; 0x23
    3b86:	b4 a1       	ldd	r27, Z+36	; 0x24
    3b88:	01 96       	adiw	r24, 0x01	; 1
    3b8a:	a1 1d       	adc	r26, r1
    3b8c:	b1 1d       	adc	r27, r1
    3b8e:	eb 81       	ldd	r30, Y+3	; 0x03
    3b90:	fc 81       	ldd	r31, Y+4	; 0x04
    3b92:	81 a3       	std	Z+33, r24	; 0x21
    3b94:	92 a3       	std	Z+34, r25	; 0x22
    3b96:	a3 a3       	std	Z+35, r26	; 0x23
    3b98:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    3b9a:	8a 81       	ldd	r24, Y+2	; 0x02
    3b9c:	81 30       	cpi	r24, 0x01	; 1
    3b9e:	09 f0       	breq	.+2      	; 0x3ba2 <vTaskNotifyGiveFromISR+0x5c>
    3ba0:	4f c0       	rjmp	.+158    	; 0x3c40 <vTaskNotifyGiveFromISR+0xfa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3ba2:	80 91 e1 02 	lds	r24, 0x02E1
    3ba6:	88 23       	and	r24, r24
    3ba8:	61 f5       	brne	.+88     	; 0x3c02 <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3baa:	8b 81       	ldd	r24, Y+3	; 0x03
    3bac:	9c 81       	ldd	r25, Y+4	; 0x04
    3bae:	02 96       	adiw	r24, 0x02	; 2
    3bb0:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3bb4:	eb 81       	ldd	r30, Y+3	; 0x03
    3bb6:	fc 81       	ldd	r31, Y+4	; 0x04
    3bb8:	96 89       	ldd	r25, Z+22	; 0x16
    3bba:	80 91 d7 02 	lds	r24, 0x02D7
    3bbe:	89 17       	cp	r24, r25
    3bc0:	28 f4       	brcc	.+10     	; 0x3bcc <vTaskNotifyGiveFromISR+0x86>
    3bc2:	eb 81       	ldd	r30, Y+3	; 0x03
    3bc4:	fc 81       	ldd	r31, Y+4	; 0x04
    3bc6:	86 89       	ldd	r24, Z+22	; 0x16
    3bc8:	80 93 d7 02 	sts	0x02D7, r24
    3bcc:	eb 81       	ldd	r30, Y+3	; 0x03
    3bce:	fc 81       	ldd	r31, Y+4	; 0x04
    3bd0:	86 89       	ldd	r24, Z+22	; 0x16
    3bd2:	28 2f       	mov	r18, r24
    3bd4:	30 e0       	ldi	r19, 0x00	; 0
    3bd6:	c9 01       	movw	r24, r18
    3bd8:	88 0f       	add	r24, r24
    3bda:	99 1f       	adc	r25, r25
    3bdc:	88 0f       	add	r24, r24
    3bde:	99 1f       	adc	r25, r25
    3be0:	88 0f       	add	r24, r24
    3be2:	99 1f       	adc	r25, r25
    3be4:	82 0f       	add	r24, r18
    3be6:	93 1f       	adc	r25, r19
    3be8:	ac 01       	movw	r20, r24
    3bea:	4e 51       	subi	r20, 0x1E	; 30
    3bec:	5d 4f       	sbci	r21, 0xFD	; 253
    3bee:	8b 81       	ldd	r24, Y+3	; 0x03
    3bf0:	9c 81       	ldd	r25, Y+4	; 0x04
    3bf2:	9c 01       	movw	r18, r24
    3bf4:	2e 5f       	subi	r18, 0xFE	; 254
    3bf6:	3f 4f       	sbci	r19, 0xFF	; 255
    3bf8:	ca 01       	movw	r24, r20
    3bfa:	b9 01       	movw	r22, r18
    3bfc:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>
    3c00:	0a c0       	rjmp	.+20     	; 0x3c16 <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    3c02:	8b 81       	ldd	r24, Y+3	; 0x03
    3c04:	9c 81       	ldd	r25, Y+4	; 0x04
    3c06:	9c 01       	movw	r18, r24
    3c08:	24 5f       	subi	r18, 0xF4	; 244
    3c0a:	3f 4f       	sbci	r19, 0xFF	; 255
    3c0c:	8c e1       	ldi	r24, 0x1C	; 28
    3c0e:	93 e0       	ldi	r25, 0x03	; 3
    3c10:	b9 01       	movw	r22, r18
    3c12:	0e 94 65 07 	call	0xeca	; 0xeca <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    3c16:	eb 81       	ldd	r30, Y+3	; 0x03
    3c18:	fc 81       	ldd	r31, Y+4	; 0x04
    3c1a:	96 89       	ldd	r25, Z+22	; 0x16
    3c1c:	e0 91 d1 02 	lds	r30, 0x02D1
    3c20:	f0 91 d2 02 	lds	r31, 0x02D2
    3c24:	86 89       	ldd	r24, Z+22	; 0x16
    3c26:	89 17       	cp	r24, r25
    3c28:	58 f4       	brcc	.+22     	; 0x3c40 <vTaskNotifyGiveFromISR+0xfa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    3c2a:	8f 81       	ldd	r24, Y+7	; 0x07
    3c2c:	98 85       	ldd	r25, Y+8	; 0x08
    3c2e:	00 97       	sbiw	r24, 0x00	; 0
    3c30:	21 f0       	breq	.+8      	; 0x3c3a <vTaskNotifyGiveFromISR+0xf4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    3c32:	ef 81       	ldd	r30, Y+7	; 0x07
    3c34:	f8 85       	ldd	r31, Y+8	; 0x08
    3c36:	81 e0       	ldi	r24, 0x01	; 1
    3c38:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    3c3a:	81 e0       	ldi	r24, 0x01	; 1
    3c3c:	80 93 da 02 	sts	0x02DA, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    3c40:	28 96       	adiw	r28, 0x08	; 8
    3c42:	0f b6       	in	r0, 0x3f	; 63
    3c44:	f8 94       	cli
    3c46:	de bf       	out	0x3e, r29	; 62
    3c48:	0f be       	out	0x3f, r0	; 63
    3c4a:	cd bf       	out	0x3d, r28	; 61
    3c4c:	cf 91       	pop	r28
    3c4e:	df 91       	pop	r29
    3c50:	08 95       	ret

00003c52 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    3c52:	df 93       	push	r29
    3c54:	cf 93       	push	r28
    3c56:	cd b7       	in	r28, 0x3d	; 61
    3c58:	de b7       	in	r29, 0x3e	; 62
    3c5a:	27 97       	sbiw	r28, 0x07	; 7
    3c5c:	0f b6       	in	r0, 0x3f	; 63
    3c5e:	f8 94       	cli
    3c60:	de bf       	out	0x3e, r29	; 62
    3c62:	0f be       	out	0x3f, r0	; 63
    3c64:	cd bf       	out	0x3d, r28	; 61
    3c66:	9d 83       	std	Y+5, r25	; 0x05
    3c68:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    3c6a:	8c 81       	ldd	r24, Y+4	; 0x04
    3c6c:	9d 81       	ldd	r25, Y+5	; 0x05
    3c6e:	00 97       	sbiw	r24, 0x00	; 0
    3c70:	39 f4       	brne	.+14     	; 0x3c80 <xTaskNotifyStateClear+0x2e>
    3c72:	80 91 d1 02 	lds	r24, 0x02D1
    3c76:	90 91 d2 02 	lds	r25, 0x02D2
    3c7a:	9f 83       	std	Y+7, r25	; 0x07
    3c7c:	8e 83       	std	Y+6, r24	; 0x06
    3c7e:	04 c0       	rjmp	.+8      	; 0x3c88 <xTaskNotifyStateClear+0x36>
    3c80:	8c 81       	ldd	r24, Y+4	; 0x04
    3c82:	9d 81       	ldd	r25, Y+5	; 0x05
    3c84:	9f 83       	std	Y+7, r25	; 0x07
    3c86:	8e 83       	std	Y+6, r24	; 0x06
    3c88:	8e 81       	ldd	r24, Y+6	; 0x06
    3c8a:	9f 81       	ldd	r25, Y+7	; 0x07
    3c8c:	9b 83       	std	Y+3, r25	; 0x03
    3c8e:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    3c90:	0f b6       	in	r0, 0x3f	; 63
    3c92:	f8 94       	cli
    3c94:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    3c96:	ea 81       	ldd	r30, Y+2	; 0x02
    3c98:	fb 81       	ldd	r31, Y+3	; 0x03
    3c9a:	85 a1       	ldd	r24, Z+37	; 0x25
    3c9c:	82 30       	cpi	r24, 0x02	; 2
    3c9e:	31 f4       	brne	.+12     	; 0x3cac <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3ca0:	ea 81       	ldd	r30, Y+2	; 0x02
    3ca2:	fb 81       	ldd	r31, Y+3	; 0x03
    3ca4:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    3ca6:	81 e0       	ldi	r24, 0x01	; 1
    3ca8:	89 83       	std	Y+1, r24	; 0x01
    3caa:	01 c0       	rjmp	.+2      	; 0x3cae <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    3cac:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    3cae:	0f 90       	pop	r0
    3cb0:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    3cb2:	89 81       	ldd	r24, Y+1	; 0x01
	}
    3cb4:	27 96       	adiw	r28, 0x07	; 7
    3cb6:	0f b6       	in	r0, 0x3f	; 63
    3cb8:	f8 94       	cli
    3cba:	de bf       	out	0x3e, r29	; 62
    3cbc:	0f be       	out	0x3f, r0	; 63
    3cbe:	cd bf       	out	0x3d, r28	; 61
    3cc0:	cf 91       	pop	r28
    3cc2:	df 91       	pop	r29
    3cc4:	08 95       	ret

00003cc6 <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    3cc6:	df 93       	push	r29
    3cc8:	cf 93       	push	r28
    3cca:	cd b7       	in	r28, 0x3d	; 61
    3ccc:	de b7       	in	r29, 0x3e	; 62
    3cce:	27 97       	sbiw	r28, 0x07	; 7
    3cd0:	0f b6       	in	r0, 0x3f	; 63
    3cd2:	f8 94       	cli
    3cd4:	de bf       	out	0x3e, r29	; 62
    3cd6:	0f be       	out	0x3f, r0	; 63
    3cd8:	cd bf       	out	0x3d, r28	; 61
    3cda:	9e 83       	std	Y+6, r25	; 0x06
    3cdc:	8d 83       	std	Y+5, r24	; 0x05
    3cde:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    3ce0:	80 91 d5 02 	lds	r24, 0x02D5
    3ce4:	90 91 d6 02 	lds	r25, 0x02D6
    3ce8:	9a 83       	std	Y+2, r25	; 0x02
    3cea:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3cec:	80 91 d1 02 	lds	r24, 0x02D1
    3cf0:	90 91 d2 02 	lds	r25, 0x02D2
    3cf4:	02 96       	adiw	r24, 0x02	; 2
    3cf6:	0e 94 15 08 	call	0x102a	; 0x102a <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
		/* Calculate the time at which the task should be woken if the event
		does not occur.  This may overflow but this doesn't matter, the kernel
		will manage it correctly. */
		xTimeToWake = xConstTickCount + xTicksToWait;
    3cfa:	29 81       	ldd	r18, Y+1	; 0x01
    3cfc:	3a 81       	ldd	r19, Y+2	; 0x02
    3cfe:	8d 81       	ldd	r24, Y+5	; 0x05
    3d00:	9e 81       	ldd	r25, Y+6	; 0x06
    3d02:	82 0f       	add	r24, r18
    3d04:	93 1f       	adc	r25, r19
    3d06:	9c 83       	std	Y+4, r25	; 0x04
    3d08:	8b 83       	std	Y+3, r24	; 0x03

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    3d0a:	e0 91 d1 02 	lds	r30, 0x02D1
    3d0e:	f0 91 d2 02 	lds	r31, 0x02D2
    3d12:	8b 81       	ldd	r24, Y+3	; 0x03
    3d14:	9c 81       	ldd	r25, Y+4	; 0x04
    3d16:	93 83       	std	Z+3, r25	; 0x03
    3d18:	82 83       	std	Z+2, r24	; 0x02

		if( xTimeToWake < xConstTickCount )
    3d1a:	2b 81       	ldd	r18, Y+3	; 0x03
    3d1c:	3c 81       	ldd	r19, Y+4	; 0x04
    3d1e:	89 81       	ldd	r24, Y+1	; 0x01
    3d20:	9a 81       	ldd	r25, Y+2	; 0x02
    3d22:	28 17       	cp	r18, r24
    3d24:	39 07       	cpc	r19, r25
    3d26:	70 f4       	brcc	.+28     	; 0x3d44 <prvAddCurrentTaskToDelayedList+0x7e>
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    3d28:	80 91 1a 03 	lds	r24, 0x031A
    3d2c:	90 91 1b 03 	lds	r25, 0x031B
    3d30:	20 91 d1 02 	lds	r18, 0x02D1
    3d34:	30 91 d2 02 	lds	r19, 0x02D2
    3d38:	2e 5f       	subi	r18, 0xFE	; 254
    3d3a:	3f 4f       	sbci	r19, 0xFF	; 255
    3d3c:	b9 01       	movw	r22, r18
    3d3e:	0e 94 a9 07 	call	0xf52	; 0xf52 <vListInsert>
    3d42:	1e c0       	rjmp	.+60     	; 0x3d80 <prvAddCurrentTaskToDelayedList+0xba>
		}
		else
		{
			/* The wake time has not overflowed, so the current block list is used. */
			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    3d44:	40 91 18 03 	lds	r20, 0x0318
    3d48:	50 91 19 03 	lds	r21, 0x0319
    3d4c:	80 91 d1 02 	lds	r24, 0x02D1
    3d50:	90 91 d2 02 	lds	r25, 0x02D2
    3d54:	9c 01       	movw	r18, r24
    3d56:	2e 5f       	subi	r18, 0xFE	; 254
    3d58:	3f 4f       	sbci	r19, 0xFF	; 255
    3d5a:	ca 01       	movw	r24, r20
    3d5c:	b9 01       	movw	r22, r18
    3d5e:	0e 94 a9 07 	call	0xf52	; 0xf52 <vListInsert>

			/* If the task entering the blocked state was placed at the head of the
			list of blocked tasks then xNextTaskUnblockTime needs to be updated
			too. */
			if( xTimeToWake < xNextTaskUnblockTime )
    3d62:	20 91 dd 02 	lds	r18, 0x02DD
    3d66:	30 91 de 02 	lds	r19, 0x02DE
    3d6a:	8b 81       	ldd	r24, Y+3	; 0x03
    3d6c:	9c 81       	ldd	r25, Y+4	; 0x04
    3d6e:	82 17       	cp	r24, r18
    3d70:	93 07       	cpc	r25, r19
    3d72:	30 f4       	brcc	.+12     	; 0x3d80 <prvAddCurrentTaskToDelayedList+0xba>
			{
				xNextTaskUnblockTime = xTimeToWake;
    3d74:	8b 81       	ldd	r24, Y+3	; 0x03
    3d76:	9c 81       	ldd	r25, Y+4	; 0x04
    3d78:	90 93 de 02 	sts	0x02DE, r25
    3d7c:	80 93 dd 02 	sts	0x02DD, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    3d80:	27 96       	adiw	r28, 0x07	; 7
    3d82:	0f b6       	in	r0, 0x3f	; 63
    3d84:	f8 94       	cli
    3d86:	de bf       	out	0x3e, r29	; 62
    3d88:	0f be       	out	0x3f, r0	; 63
    3d8a:	cd bf       	out	0x3d, r28	; 61
    3d8c:	cf 91       	pop	r28
    3d8e:	df 91       	pop	r29
    3d90:	08 95       	ret

00003d92 <memcpy>:
    3d92:	fb 01       	movw	r30, r22
    3d94:	dc 01       	movw	r26, r24
    3d96:	02 c0       	rjmp	.+4      	; 0x3d9c <memcpy+0xa>
    3d98:	01 90       	ld	r0, Z+
    3d9a:	0d 92       	st	X+, r0
    3d9c:	41 50       	subi	r20, 0x01	; 1
    3d9e:	50 40       	sbci	r21, 0x00	; 0
    3da0:	d8 f7       	brcc	.-10     	; 0x3d98 <memcpy+0x6>
    3da2:	08 95       	ret

00003da4 <_exit>:
    3da4:	f8 94       	cli

00003da6 <__stop_program>:
    3da6:	ff cf       	rjmp	.-2      	; 0x3da6 <__stop_program>
